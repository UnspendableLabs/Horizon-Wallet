// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'session_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SessionState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(Onboarding onboarding) onboarding,
    required TResult Function(SessionStateSuccess succcess) success,
    required TResult Function() loggedOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(Onboarding onboarding)? onboarding,
    TResult? Function(SessionStateSuccess succcess)? success,
    TResult? Function()? loggedOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(Onboarding onboarding)? onboarding,
    TResult Function(SessionStateSuccess succcess)? success,
    TResult Function()? loggedOut,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Error value) error,
    required TResult Function(_Onboarding value) onboarding,
    required TResult Function(_Success value) success,
    required TResult Function(_LoggedOut value) loggedOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Error value)? error,
    TResult? Function(_Onboarding value)? onboarding,
    TResult? Function(_Success value)? success,
    TResult? Function(_LoggedOut value)? loggedOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Error value)? error,
    TResult Function(_Onboarding value)? onboarding,
    TResult Function(_Success value)? success,
    TResult Function(_LoggedOut value)? loggedOut,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SessionStateCopyWith<$Res> {
  factory $SessionStateCopyWith(
          SessionState value, $Res Function(SessionState) then) =
      _$SessionStateCopyWithImpl<$Res, SessionState>;
}

/// @nodoc
class _$SessionStateCopyWithImpl<$Res, $Val extends SessionState>
    implements $SessionStateCopyWith<$Res> {
  _$SessionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$SessionStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'SessionState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(Onboarding onboarding) onboarding,
    required TResult Function(SessionStateSuccess succcess) success,
    required TResult Function() loggedOut,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(Onboarding onboarding)? onboarding,
    TResult? Function(SessionStateSuccess succcess)? success,
    TResult? Function()? loggedOut,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(Onboarding onboarding)? onboarding,
    TResult Function(SessionStateSuccess succcess)? success,
    TResult Function()? loggedOut,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Error value) error,
    required TResult Function(_Onboarding value) onboarding,
    required TResult Function(_Success value) success,
    required TResult Function(_LoggedOut value) loggedOut,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Error value)? error,
    TResult? Function(_Onboarding value)? onboarding,
    TResult? Function(_Success value)? success,
    TResult? Function(_LoggedOut value)? loggedOut,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Error value)? error,
    TResult Function(_Onboarding value)? onboarding,
    TResult Function(_Success value)? success,
    TResult Function(_LoggedOut value)? loggedOut,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements SessionState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =
      __$$LoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$SessionStateCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingImpl implements _Loading {
  const _$LoadingImpl();

  @override
  String toString() {
    return 'SessionState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(Onboarding onboarding) onboarding,
    required TResult Function(SessionStateSuccess succcess) success,
    required TResult Function() loggedOut,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(Onboarding onboarding)? onboarding,
    TResult? Function(SessionStateSuccess succcess)? success,
    TResult? Function()? loggedOut,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(Onboarding onboarding)? onboarding,
    TResult Function(SessionStateSuccess succcess)? success,
    TResult Function()? loggedOut,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Error value) error,
    required TResult Function(_Onboarding value) onboarding,
    required TResult Function(_Success value) success,
    required TResult Function(_LoggedOut value) loggedOut,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Error value)? error,
    TResult? Function(_Onboarding value)? onboarding,
    TResult? Function(_Success value)? success,
    TResult? Function(_LoggedOut value)? loggedOut,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Error value)? error,
    TResult Function(_Onboarding value)? onboarding,
    TResult Function(_Success value)? success,
    TResult Function(_LoggedOut value)? loggedOut,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements SessionState {
  const factory _Loading() = _$LoadingImpl;
}

/// @nodoc
abstract class _$$ErrorImplCopyWith<$Res> {
  factory _$$ErrorImplCopyWith(
          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =
      __$$ErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$ErrorImplCopyWithImpl<$Res>
    extends _$SessionStateCopyWithImpl<$Res, _$ErrorImpl>
    implements _$$ErrorImplCopyWith<$Res> {
  __$$ErrorImplCopyWithImpl(
      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$ErrorImpl(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ErrorImpl implements _Error {
  const _$ErrorImpl(this.error);

  @override
  final String error;

  @override
  String toString() {
    return 'SessionState.error(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(Onboarding onboarding) onboarding,
    required TResult Function(SessionStateSuccess succcess) success,
    required TResult Function() loggedOut,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(Onboarding onboarding)? onboarding,
    TResult? Function(SessionStateSuccess succcess)? success,
    TResult? Function()? loggedOut,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(Onboarding onboarding)? onboarding,
    TResult Function(SessionStateSuccess succcess)? success,
    TResult Function()? loggedOut,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Error value) error,
    required TResult Function(_Onboarding value) onboarding,
    required TResult Function(_Success value) success,
    required TResult Function(_LoggedOut value) loggedOut,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Error value)? error,
    TResult? Function(_Onboarding value)? onboarding,
    TResult? Function(_Success value)? success,
    TResult? Function(_LoggedOut value)? loggedOut,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Error value)? error,
    TResult Function(_Onboarding value)? onboarding,
    TResult Function(_Success value)? success,
    TResult Function(_LoggedOut value)? loggedOut,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _Error implements SessionState {
  const factory _Error(final String error) = _$ErrorImpl;

  String get error;
  @JsonKey(ignore: true)
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$OnboardingImplCopyWith<$Res> {
  factory _$$OnboardingImplCopyWith(
          _$OnboardingImpl value, $Res Function(_$OnboardingImpl) then) =
      __$$OnboardingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Onboarding onboarding});

  $OnboardingCopyWith<$Res> get onboarding;
}

/// @nodoc
class __$$OnboardingImplCopyWithImpl<$Res>
    extends _$SessionStateCopyWithImpl<$Res, _$OnboardingImpl>
    implements _$$OnboardingImplCopyWith<$Res> {
  __$$OnboardingImplCopyWithImpl(
      _$OnboardingImpl _value, $Res Function(_$OnboardingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? onboarding = null,
  }) {
    return _then(_$OnboardingImpl(
      null == onboarding
          ? _value.onboarding
          : onboarding // ignore: cast_nullable_to_non_nullable
              as Onboarding,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $OnboardingCopyWith<$Res> get onboarding {
    return $OnboardingCopyWith<$Res>(_value.onboarding, (value) {
      return _then(_value.copyWith(onboarding: value));
    });
  }
}

/// @nodoc

class _$OnboardingImpl implements _Onboarding {
  const _$OnboardingImpl(this.onboarding);

  @override
  final Onboarding onboarding;

  @override
  String toString() {
    return 'SessionState.onboarding(onboarding: $onboarding)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OnboardingImpl &&
            (identical(other.onboarding, onboarding) ||
                other.onboarding == onboarding));
  }

  @override
  int get hashCode => Object.hash(runtimeType, onboarding);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OnboardingImplCopyWith<_$OnboardingImpl> get copyWith =>
      __$$OnboardingImplCopyWithImpl<_$OnboardingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(Onboarding onboarding) onboarding,
    required TResult Function(SessionStateSuccess succcess) success,
    required TResult Function() loggedOut,
  }) {
    return onboarding(this.onboarding);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(Onboarding onboarding)? onboarding,
    TResult? Function(SessionStateSuccess succcess)? success,
    TResult? Function()? loggedOut,
  }) {
    return onboarding?.call(this.onboarding);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(Onboarding onboarding)? onboarding,
    TResult Function(SessionStateSuccess succcess)? success,
    TResult Function()? loggedOut,
    required TResult orElse(),
  }) {
    if (onboarding != null) {
      return onboarding(this.onboarding);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Error value) error,
    required TResult Function(_Onboarding value) onboarding,
    required TResult Function(_Success value) success,
    required TResult Function(_LoggedOut value) loggedOut,
  }) {
    return onboarding(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Error value)? error,
    TResult? Function(_Onboarding value)? onboarding,
    TResult? Function(_Success value)? success,
    TResult? Function(_LoggedOut value)? loggedOut,
  }) {
    return onboarding?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Error value)? error,
    TResult Function(_Onboarding value)? onboarding,
    TResult Function(_Success value)? success,
    TResult Function(_LoggedOut value)? loggedOut,
    required TResult orElse(),
  }) {
    if (onboarding != null) {
      return onboarding(this);
    }
    return orElse();
  }
}

abstract class _Onboarding implements SessionState {
  const factory _Onboarding(final Onboarding onboarding) = _$OnboardingImpl;

  Onboarding get onboarding;
  @JsonKey(ignore: true)
  _$$OnboardingImplCopyWith<_$OnboardingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SuccessImplCopyWith<$Res> {
  factory _$$SuccessImplCopyWith(
          _$SuccessImpl value, $Res Function(_$SuccessImpl) then) =
      __$$SuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SessionStateSuccess succcess});

  $SessionStateSuccessCopyWith<$Res> get succcess;
}

/// @nodoc
class __$$SuccessImplCopyWithImpl<$Res>
    extends _$SessionStateCopyWithImpl<$Res, _$SuccessImpl>
    implements _$$SuccessImplCopyWith<$Res> {
  __$$SuccessImplCopyWithImpl(
      _$SuccessImpl _value, $Res Function(_$SuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? succcess = null,
  }) {
    return _then(_$SuccessImpl(
      null == succcess
          ? _value.succcess
          : succcess // ignore: cast_nullable_to_non_nullable
              as SessionStateSuccess,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $SessionStateSuccessCopyWith<$Res> get succcess {
    return $SessionStateSuccessCopyWith<$Res>(_value.succcess, (value) {
      return _then(_value.copyWith(succcess: value));
    });
  }
}

/// @nodoc

class _$SuccessImpl implements _Success {
  const _$SuccessImpl(this.succcess);

  @override
  final SessionStateSuccess succcess;

  @override
  String toString() {
    return 'SessionState.success(succcess: $succcess)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuccessImpl &&
            (identical(other.succcess, succcess) ||
                other.succcess == succcess));
  }

  @override
  int get hashCode => Object.hash(runtimeType, succcess);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>
      __$$SuccessImplCopyWithImpl<_$SuccessImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(Onboarding onboarding) onboarding,
    required TResult Function(SessionStateSuccess succcess) success,
    required TResult Function() loggedOut,
  }) {
    return success(succcess);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(Onboarding onboarding)? onboarding,
    TResult? Function(SessionStateSuccess succcess)? success,
    TResult? Function()? loggedOut,
  }) {
    return success?.call(succcess);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(Onboarding onboarding)? onboarding,
    TResult Function(SessionStateSuccess succcess)? success,
    TResult Function()? loggedOut,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(succcess);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Error value) error,
    required TResult Function(_Onboarding value) onboarding,
    required TResult Function(_Success value) success,
    required TResult Function(_LoggedOut value) loggedOut,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Error value)? error,
    TResult? Function(_Onboarding value)? onboarding,
    TResult? Function(_Success value)? success,
    TResult? Function(_LoggedOut value)? loggedOut,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Error value)? error,
    TResult Function(_Onboarding value)? onboarding,
    TResult Function(_Success value)? success,
    TResult Function(_LoggedOut value)? loggedOut,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _Success implements SessionState {
  const factory _Success(final SessionStateSuccess succcess) = _$SuccessImpl;

  SessionStateSuccess get succcess;
  @JsonKey(ignore: true)
  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoggedOutImplCopyWith<$Res> {
  factory _$$LoggedOutImplCopyWith(
          _$LoggedOutImpl value, $Res Function(_$LoggedOutImpl) then) =
      __$$LoggedOutImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoggedOutImplCopyWithImpl<$Res>
    extends _$SessionStateCopyWithImpl<$Res, _$LoggedOutImpl>
    implements _$$LoggedOutImplCopyWith<$Res> {
  __$$LoggedOutImplCopyWithImpl(
      _$LoggedOutImpl _value, $Res Function(_$LoggedOutImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoggedOutImpl implements _LoggedOut {
  const _$LoggedOutImpl();

  @override
  String toString() {
    return 'SessionState.loggedOut()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoggedOutImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(Onboarding onboarding) onboarding,
    required TResult Function(SessionStateSuccess succcess) success,
    required TResult Function() loggedOut,
  }) {
    return loggedOut();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(Onboarding onboarding)? onboarding,
    TResult? Function(SessionStateSuccess succcess)? success,
    TResult? Function()? loggedOut,
  }) {
    return loggedOut?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(Onboarding onboarding)? onboarding,
    TResult Function(SessionStateSuccess succcess)? success,
    TResult Function()? loggedOut,
    required TResult orElse(),
  }) {
    if (loggedOut != null) {
      return loggedOut();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Error value) error,
    required TResult Function(_Onboarding value) onboarding,
    required TResult Function(_Success value) success,
    required TResult Function(_LoggedOut value) loggedOut,
  }) {
    return loggedOut(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Error value)? error,
    TResult? Function(_Onboarding value)? onboarding,
    TResult? Function(_Success value)? success,
    TResult? Function(_LoggedOut value)? loggedOut,
  }) {
    return loggedOut?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Error value)? error,
    TResult Function(_Onboarding value)? onboarding,
    TResult Function(_Success value)? success,
    TResult Function(_LoggedOut value)? loggedOut,
    required TResult orElse(),
  }) {
    if (loggedOut != null) {
      return loggedOut(this);
    }
    return orElse();
  }
}

abstract class _LoggedOut implements SessionState {
  const factory _LoggedOut() = _$LoggedOutImpl;
}

/// @nodoc
mixin _$SessionStateSuccess {
  HttpConfig get httpConfig => throw _privateConstructorUsedError;
  AccountV2? get currentAccount => throw _privateConstructorUsedError;
  bool get redirect =>
      throw _privateConstructorUsedError; // required Wallet wallet,
  String get decryptionKey => throw _privateConstructorUsedError;
  List<AccountV2> get accounts => throw _privateConstructorUsedError;
  List<AddressV2> get addresses => throw _privateConstructorUsedError;
  List<ImportedAddress>? get importedAddresses =>
      throw _privateConstructorUsedError;
  WalletConfig get walletConfig => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SessionStateSuccessCopyWith<SessionStateSuccess> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SessionStateSuccessCopyWith<$Res> {
  factory $SessionStateSuccessCopyWith(
          SessionStateSuccess value, $Res Function(SessionStateSuccess) then) =
      _$SessionStateSuccessCopyWithImpl<$Res, SessionStateSuccess>;
  @useResult
  $Res call(
      {HttpConfig httpConfig,
      AccountV2? currentAccount,
      bool redirect,
      String decryptionKey,
      List<AccountV2> accounts,
      List<AddressV2> addresses,
      List<ImportedAddress>? importedAddresses,
      WalletConfig walletConfig});
}

/// @nodoc
class _$SessionStateSuccessCopyWithImpl<$Res, $Val extends SessionStateSuccess>
    implements $SessionStateSuccessCopyWith<$Res> {
  _$SessionStateSuccessCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? httpConfig = null,
    Object? currentAccount = freezed,
    Object? redirect = null,
    Object? decryptionKey = null,
    Object? accounts = null,
    Object? addresses = null,
    Object? importedAddresses = freezed,
    Object? walletConfig = null,
  }) {
    return _then(_value.copyWith(
      httpConfig: null == httpConfig
          ? _value.httpConfig
          : httpConfig // ignore: cast_nullable_to_non_nullable
              as HttpConfig,
      currentAccount: freezed == currentAccount
          ? _value.currentAccount
          : currentAccount // ignore: cast_nullable_to_non_nullable
              as AccountV2?,
      redirect: null == redirect
          ? _value.redirect
          : redirect // ignore: cast_nullable_to_non_nullable
              as bool,
      decryptionKey: null == decryptionKey
          ? _value.decryptionKey
          : decryptionKey // ignore: cast_nullable_to_non_nullable
              as String,
      accounts: null == accounts
          ? _value.accounts
          : accounts // ignore: cast_nullable_to_non_nullable
              as List<AccountV2>,
      addresses: null == addresses
          ? _value.addresses
          : addresses // ignore: cast_nullable_to_non_nullable
              as List<AddressV2>,
      importedAddresses: freezed == importedAddresses
          ? _value.importedAddresses
          : importedAddresses // ignore: cast_nullable_to_non_nullable
              as List<ImportedAddress>?,
      walletConfig: null == walletConfig
          ? _value.walletConfig
          : walletConfig // ignore: cast_nullable_to_non_nullable
              as WalletConfig,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SessionStateSuccessImplCopyWith<$Res>
    implements $SessionStateSuccessCopyWith<$Res> {
  factory _$$SessionStateSuccessImplCopyWith(_$SessionStateSuccessImpl value,
          $Res Function(_$SessionStateSuccessImpl) then) =
      __$$SessionStateSuccessImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {HttpConfig httpConfig,
      AccountV2? currentAccount,
      bool redirect,
      String decryptionKey,
      List<AccountV2> accounts,
      List<AddressV2> addresses,
      List<ImportedAddress>? importedAddresses,
      WalletConfig walletConfig});
}

/// @nodoc
class __$$SessionStateSuccessImplCopyWithImpl<$Res>
    extends _$SessionStateSuccessCopyWithImpl<$Res, _$SessionStateSuccessImpl>
    implements _$$SessionStateSuccessImplCopyWith<$Res> {
  __$$SessionStateSuccessImplCopyWithImpl(_$SessionStateSuccessImpl _value,
      $Res Function(_$SessionStateSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? httpConfig = null,
    Object? currentAccount = freezed,
    Object? redirect = null,
    Object? decryptionKey = null,
    Object? accounts = null,
    Object? addresses = null,
    Object? importedAddresses = freezed,
    Object? walletConfig = null,
  }) {
    return _then(_$SessionStateSuccessImpl(
      httpConfig: null == httpConfig
          ? _value.httpConfig
          : httpConfig // ignore: cast_nullable_to_non_nullable
              as HttpConfig,
      currentAccount: freezed == currentAccount
          ? _value.currentAccount
          : currentAccount // ignore: cast_nullable_to_non_nullable
              as AccountV2?,
      redirect: null == redirect
          ? _value.redirect
          : redirect // ignore: cast_nullable_to_non_nullable
              as bool,
      decryptionKey: null == decryptionKey
          ? _value.decryptionKey
          : decryptionKey // ignore: cast_nullable_to_non_nullable
              as String,
      accounts: null == accounts
          ? _value._accounts
          : accounts // ignore: cast_nullable_to_non_nullable
              as List<AccountV2>,
      addresses: null == addresses
          ? _value._addresses
          : addresses // ignore: cast_nullable_to_non_nullable
              as List<AddressV2>,
      importedAddresses: freezed == importedAddresses
          ? _value._importedAddresses
          : importedAddresses // ignore: cast_nullable_to_non_nullable
              as List<ImportedAddress>?,
      walletConfig: null == walletConfig
          ? _value.walletConfig
          : walletConfig // ignore: cast_nullable_to_non_nullable
              as WalletConfig,
    ));
  }
}

/// @nodoc

class _$SessionStateSuccessImpl implements _SessionStateSuccess {
  const _$SessionStateSuccessImpl(
      {required this.httpConfig,
      required this.currentAccount,
      required this.redirect,
      required this.decryptionKey,
      required final List<AccountV2> accounts,
      required final List<AddressV2> addresses,
      final List<ImportedAddress>? importedAddresses,
      required this.walletConfig})
      : _accounts = accounts,
        _addresses = addresses,
        _importedAddresses = importedAddresses;

  @override
  final HttpConfig httpConfig;
  @override
  final AccountV2? currentAccount;
  @override
  final bool redirect;
// required Wallet wallet,
  @override
  final String decryptionKey;
  final List<AccountV2> _accounts;
  @override
  List<AccountV2> get accounts {
    if (_accounts is EqualUnmodifiableListView) return _accounts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_accounts);
  }

  final List<AddressV2> _addresses;
  @override
  List<AddressV2> get addresses {
    if (_addresses is EqualUnmodifiableListView) return _addresses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_addresses);
  }

  final List<ImportedAddress>? _importedAddresses;
  @override
  List<ImportedAddress>? get importedAddresses {
    final value = _importedAddresses;
    if (value == null) return null;
    if (_importedAddresses is EqualUnmodifiableListView)
      return _importedAddresses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final WalletConfig walletConfig;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SessionStateSuccessImpl &&
            (identical(other.httpConfig, httpConfig) ||
                other.httpConfig == httpConfig) &&
            (identical(other.currentAccount, currentAccount) ||
                other.currentAccount == currentAccount) &&
            (identical(other.redirect, redirect) ||
                other.redirect == redirect) &&
            (identical(other.decryptionKey, decryptionKey) ||
                other.decryptionKey == decryptionKey) &&
            const DeepCollectionEquality().equals(other._accounts, _accounts) &&
            const DeepCollectionEquality()
                .equals(other._addresses, _addresses) &&
            const DeepCollectionEquality()
                .equals(other._importedAddresses, _importedAddresses) &&
            (identical(other.walletConfig, walletConfig) ||
                other.walletConfig == walletConfig));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      httpConfig,
      currentAccount,
      redirect,
      decryptionKey,
      const DeepCollectionEquality().hash(_accounts),
      const DeepCollectionEquality().hash(_addresses),
      const DeepCollectionEquality().hash(_importedAddresses),
      walletConfig);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SessionStateSuccessImplCopyWith<_$SessionStateSuccessImpl> get copyWith =>
      __$$SessionStateSuccessImplCopyWithImpl<_$SessionStateSuccessImpl>(
          this, _$identity);
}

abstract class _SessionStateSuccess implements SessionStateSuccess {
  const factory _SessionStateSuccess(
      {required final HttpConfig httpConfig,
      required final AccountV2? currentAccount,
      required final bool redirect,
      required final String decryptionKey,
      required final List<AccountV2> accounts,
      required final List<AddressV2> addresses,
      final List<ImportedAddress>? importedAddresses,
      required final WalletConfig walletConfig}) = _$SessionStateSuccessImpl;

  @override
  HttpConfig get httpConfig;
  @override
  AccountV2? get currentAccount;
  @override
  bool get redirect;
  @override // required Wallet wallet,
  String get decryptionKey;
  @override
  List<AccountV2> get accounts;
  @override
  List<AddressV2> get addresses;
  @override
  List<ImportedAddress>? get importedAddresses;
  @override
  WalletConfig get walletConfig;
  @override
  @JsonKey(ignore: true)
  _$$SessionStateSuccessImplCopyWith<_$SessionStateSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Onboarding {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() create,
    required TResult Function() import,
    required TResult Function() importPK,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? create,
    TResult? Function()? import,
    TResult? Function()? importPK,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? create,
    TResult Function()? import,
    TResult Function()? importPK,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_OnboardingInitial value) initial,
    required TResult Function(_Create value) create,
    required TResult Function(_Import value) import,
    required TResult Function(_ImportPK value) importPK,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_OnboardingInitial value)? initial,
    TResult? Function(_Create value)? create,
    TResult? Function(_Import value)? import,
    TResult? Function(_ImportPK value)? importPK,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_OnboardingInitial value)? initial,
    TResult Function(_Create value)? create,
    TResult Function(_Import value)? import,
    TResult Function(_ImportPK value)? importPK,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OnboardingCopyWith<$Res> {
  factory $OnboardingCopyWith(
          Onboarding value, $Res Function(Onboarding) then) =
      _$OnboardingCopyWithImpl<$Res, Onboarding>;
}

/// @nodoc
class _$OnboardingCopyWithImpl<$Res, $Val extends Onboarding>
    implements $OnboardingCopyWith<$Res> {
  _$OnboardingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$OnboardingInitialImplCopyWith<$Res> {
  factory _$$OnboardingInitialImplCopyWith(_$OnboardingInitialImpl value,
          $Res Function(_$OnboardingInitialImpl) then) =
      __$$OnboardingInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OnboardingInitialImplCopyWithImpl<$Res>
    extends _$OnboardingCopyWithImpl<$Res, _$OnboardingInitialImpl>
    implements _$$OnboardingInitialImplCopyWith<$Res> {
  __$$OnboardingInitialImplCopyWithImpl(_$OnboardingInitialImpl _value,
      $Res Function(_$OnboardingInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OnboardingInitialImpl implements _OnboardingInitial {
  const _$OnboardingInitialImpl();

  @override
  String toString() {
    return 'Onboarding.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OnboardingInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() create,
    required TResult Function() import,
    required TResult Function() importPK,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? create,
    TResult? Function()? import,
    TResult? Function()? importPK,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? create,
    TResult Function()? import,
    TResult Function()? importPK,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_OnboardingInitial value) initial,
    required TResult Function(_Create value) create,
    required TResult Function(_Import value) import,
    required TResult Function(_ImportPK value) importPK,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_OnboardingInitial value)? initial,
    TResult? Function(_Create value)? create,
    TResult? Function(_Import value)? import,
    TResult? Function(_ImportPK value)? importPK,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_OnboardingInitial value)? initial,
    TResult Function(_Create value)? create,
    TResult Function(_Import value)? import,
    TResult Function(_ImportPK value)? importPK,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _OnboardingInitial implements Onboarding {
  const factory _OnboardingInitial() = _$OnboardingInitialImpl;
}

/// @nodoc
abstract class _$$CreateImplCopyWith<$Res> {
  factory _$$CreateImplCopyWith(
          _$CreateImpl value, $Res Function(_$CreateImpl) then) =
      __$$CreateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CreateImplCopyWithImpl<$Res>
    extends _$OnboardingCopyWithImpl<$Res, _$CreateImpl>
    implements _$$CreateImplCopyWith<$Res> {
  __$$CreateImplCopyWithImpl(
      _$CreateImpl _value, $Res Function(_$CreateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CreateImpl implements _Create {
  const _$CreateImpl();

  @override
  String toString() {
    return 'Onboarding.create()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CreateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() create,
    required TResult Function() import,
    required TResult Function() importPK,
  }) {
    return create();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? create,
    TResult? Function()? import,
    TResult? Function()? importPK,
  }) {
    return create?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? create,
    TResult Function()? import,
    TResult Function()? importPK,
    required TResult orElse(),
  }) {
    if (create != null) {
      return create();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_OnboardingInitial value) initial,
    required TResult Function(_Create value) create,
    required TResult Function(_Import value) import,
    required TResult Function(_ImportPK value) importPK,
  }) {
    return create(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_OnboardingInitial value)? initial,
    TResult? Function(_Create value)? create,
    TResult? Function(_Import value)? import,
    TResult? Function(_ImportPK value)? importPK,
  }) {
    return create?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_OnboardingInitial value)? initial,
    TResult Function(_Create value)? create,
    TResult Function(_Import value)? import,
    TResult Function(_ImportPK value)? importPK,
    required TResult orElse(),
  }) {
    if (create != null) {
      return create(this);
    }
    return orElse();
  }
}

abstract class _Create implements Onboarding {
  const factory _Create() = _$CreateImpl;
}

/// @nodoc
abstract class _$$ImportImplCopyWith<$Res> {
  factory _$$ImportImplCopyWith(
          _$ImportImpl value, $Res Function(_$ImportImpl) then) =
      __$$ImportImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ImportImplCopyWithImpl<$Res>
    extends _$OnboardingCopyWithImpl<$Res, _$ImportImpl>
    implements _$$ImportImplCopyWith<$Res> {
  __$$ImportImplCopyWithImpl(
      _$ImportImpl _value, $Res Function(_$ImportImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ImportImpl implements _Import {
  const _$ImportImpl();

  @override
  String toString() {
    return 'Onboarding.import()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ImportImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() create,
    required TResult Function() import,
    required TResult Function() importPK,
  }) {
    return import();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? create,
    TResult? Function()? import,
    TResult? Function()? importPK,
  }) {
    return import?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? create,
    TResult Function()? import,
    TResult Function()? importPK,
    required TResult orElse(),
  }) {
    if (import != null) {
      return import();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_OnboardingInitial value) initial,
    required TResult Function(_Create value) create,
    required TResult Function(_Import value) import,
    required TResult Function(_ImportPK value) importPK,
  }) {
    return import(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_OnboardingInitial value)? initial,
    TResult? Function(_Create value)? create,
    TResult? Function(_Import value)? import,
    TResult? Function(_ImportPK value)? importPK,
  }) {
    return import?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_OnboardingInitial value)? initial,
    TResult Function(_Create value)? create,
    TResult Function(_Import value)? import,
    TResult Function(_ImportPK value)? importPK,
    required TResult orElse(),
  }) {
    if (import != null) {
      return import(this);
    }
    return orElse();
  }
}

abstract class _Import implements Onboarding {
  const factory _Import() = _$ImportImpl;
}

/// @nodoc
abstract class _$$ImportPKImplCopyWith<$Res> {
  factory _$$ImportPKImplCopyWith(
          _$ImportPKImpl value, $Res Function(_$ImportPKImpl) then) =
      __$$ImportPKImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ImportPKImplCopyWithImpl<$Res>
    extends _$OnboardingCopyWithImpl<$Res, _$ImportPKImpl>
    implements _$$ImportPKImplCopyWith<$Res> {
  __$$ImportPKImplCopyWithImpl(
      _$ImportPKImpl _value, $Res Function(_$ImportPKImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ImportPKImpl implements _ImportPK {
  const _$ImportPKImpl();

  @override
  String toString() {
    return 'Onboarding.importPK()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ImportPKImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() create,
    required TResult Function() import,
    required TResult Function() importPK,
  }) {
    return importPK();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? create,
    TResult? Function()? import,
    TResult? Function()? importPK,
  }) {
    return importPK?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? create,
    TResult Function()? import,
    TResult Function()? importPK,
    required TResult orElse(),
  }) {
    if (importPK != null) {
      return importPK();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_OnboardingInitial value) initial,
    required TResult Function(_Create value) create,
    required TResult Function(_Import value) import,
    required TResult Function(_ImportPK value) importPK,
  }) {
    return importPK(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_OnboardingInitial value)? initial,
    TResult? Function(_Create value)? create,
    TResult? Function(_Import value)? import,
    TResult? Function(_ImportPK value)? importPK,
  }) {
    return importPK?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_OnboardingInitial value)? initial,
    TResult Function(_Create value)? create,
    TResult Function(_Import value)? import,
    TResult Function(_ImportPK value)? importPK,
    required TResult orElse(),
  }) {
    if (importPK != null) {
      return importPK(this);
    }
    return orElse();
  }
}

abstract class _ImportPK implements Onboarding {
  const factory _ImportPK() = _$ImportPKImpl;
}
