// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'compose_dispenser_on_new_address_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ComposeDispenserOnNewAddressStateBase {
  dynamic get feeState => throw _privateConstructorUsedError;
  String get password => throw _privateConstructorUsedError;
  Account? get newAccount => throw _privateConstructorUsedError;
  Address? get newAddress => throw _privateConstructorUsedError;
  dynamic get composeDispenserOnNewAddressState =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ComposeDispenserOnNewAddressStateBaseCopyWith<
          ComposeDispenserOnNewAddressStateBase>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ComposeDispenserOnNewAddressStateBaseCopyWith<$Res> {
  factory $ComposeDispenserOnNewAddressStateBaseCopyWith(
          ComposeDispenserOnNewAddressStateBase value,
          $Res Function(ComposeDispenserOnNewAddressStateBase) then) =
      _$ComposeDispenserOnNewAddressStateBaseCopyWithImpl<$Res,
          ComposeDispenserOnNewAddressStateBase>;
  @useResult
  $Res call(
      {dynamic feeState,
      String password,
      Account? newAccount,
      Address? newAddress,
      dynamic composeDispenserOnNewAddressState});
}

/// @nodoc
class _$ComposeDispenserOnNewAddressStateBaseCopyWithImpl<$Res,
        $Val extends ComposeDispenserOnNewAddressStateBase>
    implements $ComposeDispenserOnNewAddressStateBaseCopyWith<$Res> {
  _$ComposeDispenserOnNewAddressStateBaseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? feeState = freezed,
    Object? password = null,
    Object? newAccount = freezed,
    Object? newAddress = freezed,
    Object? composeDispenserOnNewAddressState = freezed,
  }) {
    return _then(_value.copyWith(
      feeState: freezed == feeState
          ? _value.feeState
          : feeState // ignore: cast_nullable_to_non_nullable
              as dynamic,
      password: null == password
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as String,
      newAccount: freezed == newAccount
          ? _value.newAccount
          : newAccount // ignore: cast_nullable_to_non_nullable
              as Account?,
      newAddress: freezed == newAddress
          ? _value.newAddress
          : newAddress // ignore: cast_nullable_to_non_nullable
              as Address?,
      composeDispenserOnNewAddressState: freezed ==
              composeDispenserOnNewAddressState
          ? _value.composeDispenserOnNewAddressState
          : composeDispenserOnNewAddressState // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ComposeDispenserOnNewAddressStateBaseImplCopyWith<$Res>
    implements $ComposeDispenserOnNewAddressStateBaseCopyWith<$Res> {
  factory _$$ComposeDispenserOnNewAddressStateBaseImplCopyWith(
          _$ComposeDispenserOnNewAddressStateBaseImpl value,
          $Res Function(_$ComposeDispenserOnNewAddressStateBaseImpl) then) =
      __$$ComposeDispenserOnNewAddressStateBaseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {dynamic feeState,
      String password,
      Account? newAccount,
      Address? newAddress,
      dynamic composeDispenserOnNewAddressState});
}

/// @nodoc
class __$$ComposeDispenserOnNewAddressStateBaseImplCopyWithImpl<$Res>
    extends _$ComposeDispenserOnNewAddressStateBaseCopyWithImpl<$Res,
        _$ComposeDispenserOnNewAddressStateBaseImpl>
    implements _$$ComposeDispenserOnNewAddressStateBaseImplCopyWith<$Res> {
  __$$ComposeDispenserOnNewAddressStateBaseImplCopyWithImpl(
      _$ComposeDispenserOnNewAddressStateBaseImpl _value,
      $Res Function(_$ComposeDispenserOnNewAddressStateBaseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? feeState = freezed,
    Object? password = null,
    Object? newAccount = freezed,
    Object? newAddress = freezed,
    Object? composeDispenserOnNewAddressState = freezed,
  }) {
    return _then(_$ComposeDispenserOnNewAddressStateBaseImpl(
      feeState: freezed == feeState ? _value.feeState! : feeState,
      password: null == password
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as String,
      newAccount: freezed == newAccount
          ? _value.newAccount
          : newAccount // ignore: cast_nullable_to_non_nullable
              as Account?,
      newAddress: freezed == newAddress
          ? _value.newAddress
          : newAddress // ignore: cast_nullable_to_non_nullable
              as Address?,
      composeDispenserOnNewAddressState:
          freezed == composeDispenserOnNewAddressState
              ? _value.composeDispenserOnNewAddressState!
              : composeDispenserOnNewAddressState,
    ));
  }
}

/// @nodoc

class _$ComposeDispenserOnNewAddressStateBaseImpl
    implements _ComposeDispenserOnNewAddressStateBase {
  const _$ComposeDispenserOnNewAddressStateBaseImpl(
      {this.feeState = const FeeState.initial(),
      this.password = '',
      this.newAccount = null,
      this.newAddress = null,
      this.composeDispenserOnNewAddressState =
          const ComposeDispenserOnNewAddressState.initial()});

  @override
  @JsonKey()
  final dynamic feeState;
  @override
  @JsonKey()
  final String password;
  @override
  @JsonKey()
  final Account? newAccount;
  @override
  @JsonKey()
  final Address? newAddress;
  @override
  @JsonKey()
  final dynamic composeDispenserOnNewAddressState;

  @override
  String toString() {
    return 'ComposeDispenserOnNewAddressStateBase(feeState: $feeState, password: $password, newAccount: $newAccount, newAddress: $newAddress, composeDispenserOnNewAddressState: $composeDispenserOnNewAddressState)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposeDispenserOnNewAddressStateBaseImpl &&
            const DeepCollectionEquality().equals(other.feeState, feeState) &&
            (identical(other.password, password) ||
                other.password == password) &&
            (identical(other.newAccount, newAccount) ||
                other.newAccount == newAccount) &&
            (identical(other.newAddress, newAddress) ||
                other.newAddress == newAddress) &&
            const DeepCollectionEquality().equals(
                other.composeDispenserOnNewAddressState,
                composeDispenserOnNewAddressState));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(feeState),
      password,
      newAccount,
      newAddress,
      const DeepCollectionEquality().hash(composeDispenserOnNewAddressState));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposeDispenserOnNewAddressStateBaseImplCopyWith<
          _$ComposeDispenserOnNewAddressStateBaseImpl>
      get copyWith => __$$ComposeDispenserOnNewAddressStateBaseImplCopyWithImpl<
          _$ComposeDispenserOnNewAddressStateBaseImpl>(this, _$identity);
}

abstract class _ComposeDispenserOnNewAddressStateBase
    implements ComposeDispenserOnNewAddressStateBase {
  const factory _ComposeDispenserOnNewAddressStateBase(
          {final dynamic feeState,
          final String password,
          final Account? newAccount,
          final Address? newAddress,
          final dynamic composeDispenserOnNewAddressState}) =
      _$ComposeDispenserOnNewAddressStateBaseImpl;

  @override
  dynamic get feeState;
  @override
  String get password;
  @override
  Account? get newAccount;
  @override
  Address? get newAddress;
  @override
  dynamic get composeDispenserOnNewAddressState;
  @override
  @JsonKey(ignore: true)
  _$$ComposeDispenserOnNewAddressStateBaseImplCopyWith<
          _$ComposeDispenserOnNewAddressStateBaseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ComposeDispenserOnNewAddressState<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)
        confirm,
    required TResult Function(String error) error,
    required TResult Function(String? error, bool? loading) collectPassword,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)?
        confirm,
    TResult? Function(String error)? error,
    TResult? Function(String? error, bool? loading)? collectPassword,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)?
        confirm,
    TResult Function(String error)? error,
    TResult Function(String? error, bool? loading)? collectPassword,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _ComposeDispenserOnNewAddressStateInitial<T> value)
        initial,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateLoading<T> value)
        loading,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateConfirm<T> value)
        confirm,
    required TResult Function(_ComposeDispenserOnNewAddressStateError<T> value)
        error,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)
        collectPassword,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ComposeDispenserOnNewAddressStateInitial<T> value)?
        initial,
    TResult? Function(_ComposeDispenserOnNewAddressStateLoading<T> value)?
        loading,
    TResult? Function(_ComposeDispenserOnNewAddressStateConfirm<T> value)?
        confirm,
    TResult? Function(_ComposeDispenserOnNewAddressStateError<T> value)? error,
    TResult? Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)?
        collectPassword,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ComposeDispenserOnNewAddressStateInitial<T> value)?
        initial,
    TResult Function(_ComposeDispenserOnNewAddressStateLoading<T> value)?
        loading,
    TResult Function(_ComposeDispenserOnNewAddressStateConfirm<T> value)?
        confirm,
    TResult Function(_ComposeDispenserOnNewAddressStateError<T> value)? error,
    TResult Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)?
        collectPassword,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ComposeDispenserOnNewAddressStateCopyWith<T, $Res> {
  factory $ComposeDispenserOnNewAddressStateCopyWith(
          ComposeDispenserOnNewAddressState<T> value,
          $Res Function(ComposeDispenserOnNewAddressState<T>) then) =
      _$ComposeDispenserOnNewAddressStateCopyWithImpl<T, $Res,
          ComposeDispenserOnNewAddressState<T>>;
}

/// @nodoc
class _$ComposeDispenserOnNewAddressStateCopyWithImpl<T, $Res,
        $Val extends ComposeDispenserOnNewAddressState<T>>
    implements $ComposeDispenserOnNewAddressStateCopyWith<T, $Res> {
  _$ComposeDispenserOnNewAddressStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ComposeDispenserOnNewAddressStateInitialImplCopyWith<T,
    $Res> {
  factory _$$ComposeDispenserOnNewAddressStateInitialImplCopyWith(
          _$ComposeDispenserOnNewAddressStateInitialImpl<T> value,
          $Res Function(_$ComposeDispenserOnNewAddressStateInitialImpl<T>)
              then) =
      __$$ComposeDispenserOnNewAddressStateInitialImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$ComposeDispenserOnNewAddressStateInitialImplCopyWithImpl<T, $Res>
    extends _$ComposeDispenserOnNewAddressStateCopyWithImpl<T, $Res,
        _$ComposeDispenserOnNewAddressStateInitialImpl<T>>
    implements
        _$$ComposeDispenserOnNewAddressStateInitialImplCopyWith<T, $Res> {
  __$$ComposeDispenserOnNewAddressStateInitialImplCopyWithImpl(
      _$ComposeDispenserOnNewAddressStateInitialImpl<T> _value,
      $Res Function(_$ComposeDispenserOnNewAddressStateInitialImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ComposeDispenserOnNewAddressStateInitialImpl<T>
    implements _ComposeDispenserOnNewAddressStateInitial<T> {
  const _$ComposeDispenserOnNewAddressStateInitialImpl();

  @override
  String toString() {
    return 'ComposeDispenserOnNewAddressState<$T>.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposeDispenserOnNewAddressStateInitialImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)
        confirm,
    required TResult Function(String error) error,
    required TResult Function(String? error, bool? loading) collectPassword,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)?
        confirm,
    TResult? Function(String error)? error,
    TResult? Function(String? error, bool? loading)? collectPassword,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)?
        confirm,
    TResult Function(String error)? error,
    TResult Function(String? error, bool? loading)? collectPassword,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _ComposeDispenserOnNewAddressStateInitial<T> value)
        initial,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateLoading<T> value)
        loading,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateConfirm<T> value)
        confirm,
    required TResult Function(_ComposeDispenserOnNewAddressStateError<T> value)
        error,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)
        collectPassword,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ComposeDispenserOnNewAddressStateInitial<T> value)?
        initial,
    TResult? Function(_ComposeDispenserOnNewAddressStateLoading<T> value)?
        loading,
    TResult? Function(_ComposeDispenserOnNewAddressStateConfirm<T> value)?
        confirm,
    TResult? Function(_ComposeDispenserOnNewAddressStateError<T> value)? error,
    TResult? Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)?
        collectPassword,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ComposeDispenserOnNewAddressStateInitial<T> value)?
        initial,
    TResult Function(_ComposeDispenserOnNewAddressStateLoading<T> value)?
        loading,
    TResult Function(_ComposeDispenserOnNewAddressStateConfirm<T> value)?
        confirm,
    TResult Function(_ComposeDispenserOnNewAddressStateError<T> value)? error,
    TResult Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)?
        collectPassword,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _ComposeDispenserOnNewAddressStateInitial<T>
    implements ComposeDispenserOnNewAddressState<T> {
  const factory _ComposeDispenserOnNewAddressStateInitial() =
      _$ComposeDispenserOnNewAddressStateInitialImpl<T>;
}

/// @nodoc
abstract class _$$ComposeDispenserOnNewAddressStateLoadingImplCopyWith<T,
    $Res> {
  factory _$$ComposeDispenserOnNewAddressStateLoadingImplCopyWith(
          _$ComposeDispenserOnNewAddressStateLoadingImpl<T> value,
          $Res Function(_$ComposeDispenserOnNewAddressStateLoadingImpl<T>)
              then) =
      __$$ComposeDispenserOnNewAddressStateLoadingImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$ComposeDispenserOnNewAddressStateLoadingImplCopyWithImpl<T, $Res>
    extends _$ComposeDispenserOnNewAddressStateCopyWithImpl<T, $Res,
        _$ComposeDispenserOnNewAddressStateLoadingImpl<T>>
    implements
        _$$ComposeDispenserOnNewAddressStateLoadingImplCopyWith<T, $Res> {
  __$$ComposeDispenserOnNewAddressStateLoadingImplCopyWithImpl(
      _$ComposeDispenserOnNewAddressStateLoadingImpl<T> _value,
      $Res Function(_$ComposeDispenserOnNewAddressStateLoadingImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ComposeDispenserOnNewAddressStateLoadingImpl<T>
    implements _ComposeDispenserOnNewAddressStateLoading<T> {
  const _$ComposeDispenserOnNewAddressStateLoadingImpl();

  @override
  String toString() {
    return 'ComposeDispenserOnNewAddressState<$T>.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposeDispenserOnNewAddressStateLoadingImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)
        confirm,
    required TResult Function(String error) error,
    required TResult Function(String? error, bool? loading) collectPassword,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)?
        confirm,
    TResult? Function(String error)? error,
    TResult? Function(String? error, bool? loading)? collectPassword,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)?
        confirm,
    TResult Function(String error)? error,
    TResult Function(String? error, bool? loading)? collectPassword,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _ComposeDispenserOnNewAddressStateInitial<T> value)
        initial,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateLoading<T> value)
        loading,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateConfirm<T> value)
        confirm,
    required TResult Function(_ComposeDispenserOnNewAddressStateError<T> value)
        error,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)
        collectPassword,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ComposeDispenserOnNewAddressStateInitial<T> value)?
        initial,
    TResult? Function(_ComposeDispenserOnNewAddressStateLoading<T> value)?
        loading,
    TResult? Function(_ComposeDispenserOnNewAddressStateConfirm<T> value)?
        confirm,
    TResult? Function(_ComposeDispenserOnNewAddressStateError<T> value)? error,
    TResult? Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)?
        collectPassword,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ComposeDispenserOnNewAddressStateInitial<T> value)?
        initial,
    TResult Function(_ComposeDispenserOnNewAddressStateLoading<T> value)?
        loading,
    TResult Function(_ComposeDispenserOnNewAddressStateConfirm<T> value)?
        confirm,
    TResult Function(_ComposeDispenserOnNewAddressStateError<T> value)? error,
    TResult Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)?
        collectPassword,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _ComposeDispenserOnNewAddressStateLoading<T>
    implements ComposeDispenserOnNewAddressState<T> {
  const factory _ComposeDispenserOnNewAddressStateLoading() =
      _$ComposeDispenserOnNewAddressStateLoadingImpl<T>;
}

/// @nodoc
abstract class _$$ComposeDispenserOnNewAddressStateConfirmImplCopyWith<T,
    $Res> {
  factory _$$ComposeDispenserOnNewAddressStateConfirmImplCopyWith(
          _$ComposeDispenserOnNewAddressStateConfirmImpl<T> value,
          $Res Function(_$ComposeDispenserOnNewAddressStateConfirmImpl<T>)
              then) =
      __$$ComposeDispenserOnNewAddressStateConfirmImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call(
      {String newAccountName,
      String newAddress,
      T composeSendTransaction1,
      T composeSendTransaction2,
      T composeDispenserTransaction,
      int fee,
      int feeRate,
      int totalVirtualSize,
      int totalAdjustedVirtualSize});
}

/// @nodoc
class __$$ComposeDispenserOnNewAddressStateConfirmImplCopyWithImpl<T, $Res>
    extends _$ComposeDispenserOnNewAddressStateCopyWithImpl<T, $Res,
        _$ComposeDispenserOnNewAddressStateConfirmImpl<T>>
    implements
        _$$ComposeDispenserOnNewAddressStateConfirmImplCopyWith<T, $Res> {
  __$$ComposeDispenserOnNewAddressStateConfirmImplCopyWithImpl(
      _$ComposeDispenserOnNewAddressStateConfirmImpl<T> _value,
      $Res Function(_$ComposeDispenserOnNewAddressStateConfirmImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? newAccountName = null,
    Object? newAddress = null,
    Object? composeSendTransaction1 = freezed,
    Object? composeSendTransaction2 = freezed,
    Object? composeDispenserTransaction = freezed,
    Object? fee = null,
    Object? feeRate = null,
    Object? totalVirtualSize = null,
    Object? totalAdjustedVirtualSize = null,
  }) {
    return _then(_$ComposeDispenserOnNewAddressStateConfirmImpl<T>(
      newAccountName: null == newAccountName
          ? _value.newAccountName
          : newAccountName // ignore: cast_nullable_to_non_nullable
              as String,
      newAddress: null == newAddress
          ? _value.newAddress
          : newAddress // ignore: cast_nullable_to_non_nullable
              as String,
      composeSendTransaction1: freezed == composeSendTransaction1
          ? _value.composeSendTransaction1
          : composeSendTransaction1 // ignore: cast_nullable_to_non_nullable
              as T,
      composeSendTransaction2: freezed == composeSendTransaction2
          ? _value.composeSendTransaction2
          : composeSendTransaction2 // ignore: cast_nullable_to_non_nullable
              as T,
      composeDispenserTransaction: freezed == composeDispenserTransaction
          ? _value.composeDispenserTransaction
          : composeDispenserTransaction // ignore: cast_nullable_to_non_nullable
              as T,
      fee: null == fee
          ? _value.fee
          : fee // ignore: cast_nullable_to_non_nullable
              as int,
      feeRate: null == feeRate
          ? _value.feeRate
          : feeRate // ignore: cast_nullable_to_non_nullable
              as int,
      totalVirtualSize: null == totalVirtualSize
          ? _value.totalVirtualSize
          : totalVirtualSize // ignore: cast_nullable_to_non_nullable
              as int,
      totalAdjustedVirtualSize: null == totalAdjustedVirtualSize
          ? _value.totalAdjustedVirtualSize
          : totalAdjustedVirtualSize // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ComposeDispenserOnNewAddressStateConfirmImpl<T>
    implements _ComposeDispenserOnNewAddressStateConfirm<T> {
  const _$ComposeDispenserOnNewAddressStateConfirmImpl(
      {required this.newAccountName,
      required this.newAddress,
      required this.composeSendTransaction1,
      required this.composeSendTransaction2,
      required this.composeDispenserTransaction,
      required this.fee,
      required this.feeRate,
      required this.totalVirtualSize,
      required this.totalAdjustedVirtualSize});

  @override
  final String newAccountName;
  @override
  final String newAddress;
  @override
  final T composeSendTransaction1;
  @override
  final T composeSendTransaction2;
  @override
  final T composeDispenserTransaction;
  @override
  final int fee;
  @override
  final int feeRate;
  @override
  final int totalVirtualSize;
  @override
  final int totalAdjustedVirtualSize;

  @override
  String toString() {
    return 'ComposeDispenserOnNewAddressState<$T>.confirm(newAccountName: $newAccountName, newAddress: $newAddress, composeSendTransaction1: $composeSendTransaction1, composeSendTransaction2: $composeSendTransaction2, composeDispenserTransaction: $composeDispenserTransaction, fee: $fee, feeRate: $feeRate, totalVirtualSize: $totalVirtualSize, totalAdjustedVirtualSize: $totalAdjustedVirtualSize)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposeDispenserOnNewAddressStateConfirmImpl<T> &&
            (identical(other.newAccountName, newAccountName) ||
                other.newAccountName == newAccountName) &&
            (identical(other.newAddress, newAddress) ||
                other.newAddress == newAddress) &&
            const DeepCollectionEquality().equals(
                other.composeSendTransaction1, composeSendTransaction1) &&
            const DeepCollectionEquality().equals(
                other.composeSendTransaction2, composeSendTransaction2) &&
            const DeepCollectionEquality().equals(
                other.composeDispenserTransaction,
                composeDispenserTransaction) &&
            (identical(other.fee, fee) || other.fee == fee) &&
            (identical(other.feeRate, feeRate) || other.feeRate == feeRate) &&
            (identical(other.totalVirtualSize, totalVirtualSize) ||
                other.totalVirtualSize == totalVirtualSize) &&
            (identical(
                    other.totalAdjustedVirtualSize, totalAdjustedVirtualSize) ||
                other.totalAdjustedVirtualSize == totalAdjustedVirtualSize));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      newAccountName,
      newAddress,
      const DeepCollectionEquality().hash(composeSendTransaction1),
      const DeepCollectionEquality().hash(composeSendTransaction2),
      const DeepCollectionEquality().hash(composeDispenserTransaction),
      fee,
      feeRate,
      totalVirtualSize,
      totalAdjustedVirtualSize);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposeDispenserOnNewAddressStateConfirmImplCopyWith<T,
          _$ComposeDispenserOnNewAddressStateConfirmImpl<T>>
      get copyWith =>
          __$$ComposeDispenserOnNewAddressStateConfirmImplCopyWithImpl<T,
                  _$ComposeDispenserOnNewAddressStateConfirmImpl<T>>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)
        confirm,
    required TResult Function(String error) error,
    required TResult Function(String? error, bool? loading) collectPassword,
  }) {
    return confirm(
        newAccountName,
        newAddress,
        composeSendTransaction1,
        composeSendTransaction2,
        composeDispenserTransaction,
        fee,
        feeRate,
        totalVirtualSize,
        totalAdjustedVirtualSize);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)?
        confirm,
    TResult? Function(String error)? error,
    TResult? Function(String? error, bool? loading)? collectPassword,
  }) {
    return confirm?.call(
        newAccountName,
        newAddress,
        composeSendTransaction1,
        composeSendTransaction2,
        composeDispenserTransaction,
        fee,
        feeRate,
        totalVirtualSize,
        totalAdjustedVirtualSize);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)?
        confirm,
    TResult Function(String error)? error,
    TResult Function(String? error, bool? loading)? collectPassword,
    required TResult orElse(),
  }) {
    if (confirm != null) {
      return confirm(
          newAccountName,
          newAddress,
          composeSendTransaction1,
          composeSendTransaction2,
          composeDispenserTransaction,
          fee,
          feeRate,
          totalVirtualSize,
          totalAdjustedVirtualSize);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _ComposeDispenserOnNewAddressStateInitial<T> value)
        initial,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateLoading<T> value)
        loading,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateConfirm<T> value)
        confirm,
    required TResult Function(_ComposeDispenserOnNewAddressStateError<T> value)
        error,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)
        collectPassword,
  }) {
    return confirm(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ComposeDispenserOnNewAddressStateInitial<T> value)?
        initial,
    TResult? Function(_ComposeDispenserOnNewAddressStateLoading<T> value)?
        loading,
    TResult? Function(_ComposeDispenserOnNewAddressStateConfirm<T> value)?
        confirm,
    TResult? Function(_ComposeDispenserOnNewAddressStateError<T> value)? error,
    TResult? Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)?
        collectPassword,
  }) {
    return confirm?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ComposeDispenserOnNewAddressStateInitial<T> value)?
        initial,
    TResult Function(_ComposeDispenserOnNewAddressStateLoading<T> value)?
        loading,
    TResult Function(_ComposeDispenserOnNewAddressStateConfirm<T> value)?
        confirm,
    TResult Function(_ComposeDispenserOnNewAddressStateError<T> value)? error,
    TResult Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)?
        collectPassword,
    required TResult orElse(),
  }) {
    if (confirm != null) {
      return confirm(this);
    }
    return orElse();
  }
}

abstract class _ComposeDispenserOnNewAddressStateConfirm<T>
    implements ComposeDispenserOnNewAddressState<T> {
  const factory _ComposeDispenserOnNewAddressStateConfirm(
          {required final String newAccountName,
          required final String newAddress,
          required final T composeSendTransaction1,
          required final T composeSendTransaction2,
          required final T composeDispenserTransaction,
          required final int fee,
          required final int feeRate,
          required final int totalVirtualSize,
          required final int totalAdjustedVirtualSize}) =
      _$ComposeDispenserOnNewAddressStateConfirmImpl<T>;

  String get newAccountName;
  String get newAddress;
  T get composeSendTransaction1;
  T get composeSendTransaction2;
  T get composeDispenserTransaction;
  int get fee;
  int get feeRate;
  int get totalVirtualSize;
  int get totalAdjustedVirtualSize;
  @JsonKey(ignore: true)
  _$$ComposeDispenserOnNewAddressStateConfirmImplCopyWith<T,
          _$ComposeDispenserOnNewAddressStateConfirmImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ComposeDispenserOnNewAddressStateErrorImplCopyWith<T, $Res> {
  factory _$$ComposeDispenserOnNewAddressStateErrorImplCopyWith(
          _$ComposeDispenserOnNewAddressStateErrorImpl<T> value,
          $Res Function(_$ComposeDispenserOnNewAddressStateErrorImpl<T>) then) =
      __$$ComposeDispenserOnNewAddressStateErrorImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$ComposeDispenserOnNewAddressStateErrorImplCopyWithImpl<T, $Res>
    extends _$ComposeDispenserOnNewAddressStateCopyWithImpl<T, $Res,
        _$ComposeDispenserOnNewAddressStateErrorImpl<T>>
    implements _$$ComposeDispenserOnNewAddressStateErrorImplCopyWith<T, $Res> {
  __$$ComposeDispenserOnNewAddressStateErrorImplCopyWithImpl(
      _$ComposeDispenserOnNewAddressStateErrorImpl<T> _value,
      $Res Function(_$ComposeDispenserOnNewAddressStateErrorImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$ComposeDispenserOnNewAddressStateErrorImpl<T>(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ComposeDispenserOnNewAddressStateErrorImpl<T>
    implements _ComposeDispenserOnNewAddressStateError<T> {
  const _$ComposeDispenserOnNewAddressStateErrorImpl(this.error);

  @override
  final String error;

  @override
  String toString() {
    return 'ComposeDispenserOnNewAddressState<$T>.error(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposeDispenserOnNewAddressStateErrorImpl<T> &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposeDispenserOnNewAddressStateErrorImplCopyWith<T,
          _$ComposeDispenserOnNewAddressStateErrorImpl<T>>
      get copyWith =>
          __$$ComposeDispenserOnNewAddressStateErrorImplCopyWithImpl<T,
                  _$ComposeDispenserOnNewAddressStateErrorImpl<T>>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)
        confirm,
    required TResult Function(String error) error,
    required TResult Function(String? error, bool? loading) collectPassword,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)?
        confirm,
    TResult? Function(String error)? error,
    TResult? Function(String? error, bool? loading)? collectPassword,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)?
        confirm,
    TResult Function(String error)? error,
    TResult Function(String? error, bool? loading)? collectPassword,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _ComposeDispenserOnNewAddressStateInitial<T> value)
        initial,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateLoading<T> value)
        loading,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateConfirm<T> value)
        confirm,
    required TResult Function(_ComposeDispenserOnNewAddressStateError<T> value)
        error,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)
        collectPassword,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ComposeDispenserOnNewAddressStateInitial<T> value)?
        initial,
    TResult? Function(_ComposeDispenserOnNewAddressStateLoading<T> value)?
        loading,
    TResult? Function(_ComposeDispenserOnNewAddressStateConfirm<T> value)?
        confirm,
    TResult? Function(_ComposeDispenserOnNewAddressStateError<T> value)? error,
    TResult? Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)?
        collectPassword,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ComposeDispenserOnNewAddressStateInitial<T> value)?
        initial,
    TResult Function(_ComposeDispenserOnNewAddressStateLoading<T> value)?
        loading,
    TResult Function(_ComposeDispenserOnNewAddressStateConfirm<T> value)?
        confirm,
    TResult Function(_ComposeDispenserOnNewAddressStateError<T> value)? error,
    TResult Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)?
        collectPassword,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _ComposeDispenserOnNewAddressStateError<T>
    implements ComposeDispenserOnNewAddressState<T> {
  const factory _ComposeDispenserOnNewAddressStateError(final String error) =
      _$ComposeDispenserOnNewAddressStateErrorImpl<T>;

  String get error;
  @JsonKey(ignore: true)
  _$$ComposeDispenserOnNewAddressStateErrorImplCopyWith<T,
          _$ComposeDispenserOnNewAddressStateErrorImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ComposeDispenserOnNewAddressStateCollectPasswordImplCopyWith<
    T, $Res> {
  factory _$$ComposeDispenserOnNewAddressStateCollectPasswordImplCopyWith(
          _$ComposeDispenserOnNewAddressStateCollectPasswordImpl<T> value,
          $Res Function(
                  _$ComposeDispenserOnNewAddressStateCollectPasswordImpl<T>)
              then) =
      __$$ComposeDispenserOnNewAddressStateCollectPasswordImplCopyWithImpl<T,
          $Res>;
  @useResult
  $Res call({String? error, bool? loading});
}

/// @nodoc
class __$$ComposeDispenserOnNewAddressStateCollectPasswordImplCopyWithImpl<T,
        $Res>
    extends _$ComposeDispenserOnNewAddressStateCopyWithImpl<T, $Res,
        _$ComposeDispenserOnNewAddressStateCollectPasswordImpl<T>>
    implements
        _$$ComposeDispenserOnNewAddressStateCollectPasswordImplCopyWith<T,
            $Res> {
  __$$ComposeDispenserOnNewAddressStateCollectPasswordImplCopyWithImpl(
      _$ComposeDispenserOnNewAddressStateCollectPasswordImpl<T> _value,
      $Res Function(_$ComposeDispenserOnNewAddressStateCollectPasswordImpl<T>)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? loading = freezed,
  }) {
    return _then(_$ComposeDispenserOnNewAddressStateCollectPasswordImpl<T>(
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
      loading: freezed == loading
          ? _value.loading
          : loading // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

class _$ComposeDispenserOnNewAddressStateCollectPasswordImpl<T>
    implements _ComposeDispenserOnNewAddressStateCollectPassword<T> {
  const _$ComposeDispenserOnNewAddressStateCollectPasswordImpl(
      {this.error, this.loading});

  @override
  final String? error;
  @override
  final bool? loading;

  @override
  String toString() {
    return 'ComposeDispenserOnNewAddressState<$T>.collectPassword(error: $error, loading: $loading)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$ComposeDispenserOnNewAddressStateCollectPasswordImpl<T> &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.loading, loading) || other.loading == loading));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error, loading);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposeDispenserOnNewAddressStateCollectPasswordImplCopyWith<T,
          _$ComposeDispenserOnNewAddressStateCollectPasswordImpl<T>>
      get copyWith =>
          __$$ComposeDispenserOnNewAddressStateCollectPasswordImplCopyWithImpl<
                  T, _$ComposeDispenserOnNewAddressStateCollectPasswordImpl<T>>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)
        confirm,
    required TResult Function(String error) error,
    required TResult Function(String? error, bool? loading) collectPassword,
  }) {
    return collectPassword(this.error, this.loading);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)?
        confirm,
    TResult? Function(String error)? error,
    TResult? Function(String? error, bool? loading)? collectPassword,
  }) {
    return collectPassword?.call(this.error, this.loading);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            String newAccountName,
            String newAddress,
            T composeSendTransaction1,
            T composeSendTransaction2,
            T composeDispenserTransaction,
            int fee,
            int feeRate,
            int totalVirtualSize,
            int totalAdjustedVirtualSize)?
        confirm,
    TResult Function(String error)? error,
    TResult Function(String? error, bool? loading)? collectPassword,
    required TResult orElse(),
  }) {
    if (collectPassword != null) {
      return collectPassword(this.error, this.loading);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _ComposeDispenserOnNewAddressStateInitial<T> value)
        initial,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateLoading<T> value)
        loading,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateConfirm<T> value)
        confirm,
    required TResult Function(_ComposeDispenserOnNewAddressStateError<T> value)
        error,
    required TResult Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)
        collectPassword,
  }) {
    return collectPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ComposeDispenserOnNewAddressStateInitial<T> value)?
        initial,
    TResult? Function(_ComposeDispenserOnNewAddressStateLoading<T> value)?
        loading,
    TResult? Function(_ComposeDispenserOnNewAddressStateConfirm<T> value)?
        confirm,
    TResult? Function(_ComposeDispenserOnNewAddressStateError<T> value)? error,
    TResult? Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)?
        collectPassword,
  }) {
    return collectPassword?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ComposeDispenserOnNewAddressStateInitial<T> value)?
        initial,
    TResult Function(_ComposeDispenserOnNewAddressStateLoading<T> value)?
        loading,
    TResult Function(_ComposeDispenserOnNewAddressStateConfirm<T> value)?
        confirm,
    TResult Function(_ComposeDispenserOnNewAddressStateError<T> value)? error,
    TResult Function(
            _ComposeDispenserOnNewAddressStateCollectPassword<T> value)?
        collectPassword,
    required TResult orElse(),
  }) {
    if (collectPassword != null) {
      return collectPassword(this);
    }
    return orElse();
  }
}

abstract class _ComposeDispenserOnNewAddressStateCollectPassword<T>
    implements ComposeDispenserOnNewAddressState<T> {
  const factory _ComposeDispenserOnNewAddressStateCollectPassword(
          {final String? error, final bool? loading}) =
      _$ComposeDispenserOnNewAddressStateCollectPasswordImpl<T>;

  String? get error;
  bool? get loading;
  @JsonKey(ignore: true)
  _$$ComposeDispenserOnNewAddressStateCollectPasswordImplCopyWith<T,
          _$ComposeDispenserOnNewAddressStateCollectPasswordImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FeeState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(FeeEstimates feeEstimates) success,
    required TResult Function(String error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(FeeEstimates feeEstimates)? success,
    TResult? Function(String error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(FeeEstimates feeEstimates)? success,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FeeInitial value) initial,
    required TResult Function(_FeeLoading value) loading,
    required TResult Function(_FeeSuccess value) success,
    required TResult Function(_FeeError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FeeInitial value)? initial,
    TResult? Function(_FeeLoading value)? loading,
    TResult? Function(_FeeSuccess value)? success,
    TResult? Function(_FeeError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FeeInitial value)? initial,
    TResult Function(_FeeLoading value)? loading,
    TResult Function(_FeeSuccess value)? success,
    TResult Function(_FeeError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FeeStateCopyWith<$Res> {
  factory $FeeStateCopyWith(FeeState value, $Res Function(FeeState) then) =
      _$FeeStateCopyWithImpl<$Res, FeeState>;
}

/// @nodoc
class _$FeeStateCopyWithImpl<$Res, $Val extends FeeState>
    implements $FeeStateCopyWith<$Res> {
  _$FeeStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FeeInitialImplCopyWith<$Res> {
  factory _$$FeeInitialImplCopyWith(
          _$FeeInitialImpl value, $Res Function(_$FeeInitialImpl) then) =
      __$$FeeInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FeeInitialImplCopyWithImpl<$Res>
    extends _$FeeStateCopyWithImpl<$Res, _$FeeInitialImpl>
    implements _$$FeeInitialImplCopyWith<$Res> {
  __$$FeeInitialImplCopyWithImpl(
      _$FeeInitialImpl _value, $Res Function(_$FeeInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FeeInitialImpl implements _FeeInitial {
  const _$FeeInitialImpl();

  @override
  String toString() {
    return 'FeeState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FeeInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(FeeEstimates feeEstimates) success,
    required TResult Function(String error) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(FeeEstimates feeEstimates)? success,
    TResult? Function(String error)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(FeeEstimates feeEstimates)? success,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FeeInitial value) initial,
    required TResult Function(_FeeLoading value) loading,
    required TResult Function(_FeeSuccess value) success,
    required TResult Function(_FeeError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FeeInitial value)? initial,
    TResult? Function(_FeeLoading value)? loading,
    TResult? Function(_FeeSuccess value)? success,
    TResult? Function(_FeeError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FeeInitial value)? initial,
    TResult Function(_FeeLoading value)? loading,
    TResult Function(_FeeSuccess value)? success,
    TResult Function(_FeeError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _FeeInitial implements FeeState {
  const factory _FeeInitial() = _$FeeInitialImpl;
}

/// @nodoc
abstract class _$$FeeLoadingImplCopyWith<$Res> {
  factory _$$FeeLoadingImplCopyWith(
          _$FeeLoadingImpl value, $Res Function(_$FeeLoadingImpl) then) =
      __$$FeeLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FeeLoadingImplCopyWithImpl<$Res>
    extends _$FeeStateCopyWithImpl<$Res, _$FeeLoadingImpl>
    implements _$$FeeLoadingImplCopyWith<$Res> {
  __$$FeeLoadingImplCopyWithImpl(
      _$FeeLoadingImpl _value, $Res Function(_$FeeLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FeeLoadingImpl implements _FeeLoading {
  const _$FeeLoadingImpl();

  @override
  String toString() {
    return 'FeeState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FeeLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(FeeEstimates feeEstimates) success,
    required TResult Function(String error) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(FeeEstimates feeEstimates)? success,
    TResult? Function(String error)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(FeeEstimates feeEstimates)? success,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FeeInitial value) initial,
    required TResult Function(_FeeLoading value) loading,
    required TResult Function(_FeeSuccess value) success,
    required TResult Function(_FeeError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FeeInitial value)? initial,
    TResult? Function(_FeeLoading value)? loading,
    TResult? Function(_FeeSuccess value)? success,
    TResult? Function(_FeeError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FeeInitial value)? initial,
    TResult Function(_FeeLoading value)? loading,
    TResult Function(_FeeSuccess value)? success,
    TResult Function(_FeeError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _FeeLoading implements FeeState {
  const factory _FeeLoading() = _$FeeLoadingImpl;
}

/// @nodoc
abstract class _$$FeeSuccessImplCopyWith<$Res> {
  factory _$$FeeSuccessImplCopyWith(
          _$FeeSuccessImpl value, $Res Function(_$FeeSuccessImpl) then) =
      __$$FeeSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({FeeEstimates feeEstimates});
}

/// @nodoc
class __$$FeeSuccessImplCopyWithImpl<$Res>
    extends _$FeeStateCopyWithImpl<$Res, _$FeeSuccessImpl>
    implements _$$FeeSuccessImplCopyWith<$Res> {
  __$$FeeSuccessImplCopyWithImpl(
      _$FeeSuccessImpl _value, $Res Function(_$FeeSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? feeEstimates = null,
  }) {
    return _then(_$FeeSuccessImpl(
      null == feeEstimates
          ? _value.feeEstimates
          : feeEstimates // ignore: cast_nullable_to_non_nullable
              as FeeEstimates,
    ));
  }
}

/// @nodoc

class _$FeeSuccessImpl implements _FeeSuccess {
  const _$FeeSuccessImpl(this.feeEstimates);

  @override
  final FeeEstimates feeEstimates;

  @override
  String toString() {
    return 'FeeState.success(feeEstimates: $feeEstimates)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FeeSuccessImpl &&
            (identical(other.feeEstimates, feeEstimates) ||
                other.feeEstimates == feeEstimates));
  }

  @override
  int get hashCode => Object.hash(runtimeType, feeEstimates);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FeeSuccessImplCopyWith<_$FeeSuccessImpl> get copyWith =>
      __$$FeeSuccessImplCopyWithImpl<_$FeeSuccessImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(FeeEstimates feeEstimates) success,
    required TResult Function(String error) error,
  }) {
    return success(feeEstimates);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(FeeEstimates feeEstimates)? success,
    TResult? Function(String error)? error,
  }) {
    return success?.call(feeEstimates);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(FeeEstimates feeEstimates)? success,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(feeEstimates);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FeeInitial value) initial,
    required TResult Function(_FeeLoading value) loading,
    required TResult Function(_FeeSuccess value) success,
    required TResult Function(_FeeError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FeeInitial value)? initial,
    TResult? Function(_FeeLoading value)? loading,
    TResult? Function(_FeeSuccess value)? success,
    TResult? Function(_FeeError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FeeInitial value)? initial,
    TResult Function(_FeeLoading value)? loading,
    TResult Function(_FeeSuccess value)? success,
    TResult Function(_FeeError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _FeeSuccess implements FeeState {
  const factory _FeeSuccess(final FeeEstimates feeEstimates) = _$FeeSuccessImpl;

  FeeEstimates get feeEstimates;
  @JsonKey(ignore: true)
  _$$FeeSuccessImplCopyWith<_$FeeSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FeeErrorImplCopyWith<$Res> {
  factory _$$FeeErrorImplCopyWith(
          _$FeeErrorImpl value, $Res Function(_$FeeErrorImpl) then) =
      __$$FeeErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$FeeErrorImplCopyWithImpl<$Res>
    extends _$FeeStateCopyWithImpl<$Res, _$FeeErrorImpl>
    implements _$$FeeErrorImplCopyWith<$Res> {
  __$$FeeErrorImplCopyWithImpl(
      _$FeeErrorImpl _value, $Res Function(_$FeeErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$FeeErrorImpl(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$FeeErrorImpl implements _FeeError {
  const _$FeeErrorImpl(this.error);

  @override
  final String error;

  @override
  String toString() {
    return 'FeeState.error(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FeeErrorImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FeeErrorImplCopyWith<_$FeeErrorImpl> get copyWith =>
      __$$FeeErrorImplCopyWithImpl<_$FeeErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(FeeEstimates feeEstimates) success,
    required TResult Function(String error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(FeeEstimates feeEstimates)? success,
    TResult? Function(String error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(FeeEstimates feeEstimates)? success,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FeeInitial value) initial,
    required TResult Function(_FeeLoading value) loading,
    required TResult Function(_FeeSuccess value) success,
    required TResult Function(_FeeError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FeeInitial value)? initial,
    TResult? Function(_FeeLoading value)? loading,
    TResult? Function(_FeeSuccess value)? success,
    TResult? Function(_FeeError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FeeInitial value)? initial,
    TResult Function(_FeeLoading value)? loading,
    TResult Function(_FeeSuccess value)? success,
    TResult Function(_FeeError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _FeeError implements FeeState {
  const factory _FeeError(final String error) = _$FeeErrorImpl;

  String get error;
  @JsonKey(ignore: true)
  _$$FeeErrorImplCopyWith<_$FeeErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
