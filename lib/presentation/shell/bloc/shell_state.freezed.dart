// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'shell_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ShellState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(Onboarding onboarding) onboarding,
    required TResult Function(ShellStateSuccess succcess) success,
    required TResult Function() loggedOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(Onboarding onboarding)? onboarding,
    TResult? Function(ShellStateSuccess succcess)? success,
    TResult? Function()? loggedOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(Onboarding onboarding)? onboarding,
    TResult Function(ShellStateSuccess succcess)? success,
    TResult Function()? loggedOut,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Error value) error,
    required TResult Function(_Onboarding value) onboarding,
    required TResult Function(_Success value) success,
    required TResult Function(_LoggedOut value) loggedOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Error value)? error,
    TResult? Function(_Onboarding value)? onboarding,
    TResult? Function(_Success value)? success,
    TResult? Function(_LoggedOut value)? loggedOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Error value)? error,
    TResult Function(_Onboarding value)? onboarding,
    TResult Function(_Success value)? success,
    TResult Function(_LoggedOut value)? loggedOut,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShellStateCopyWith<$Res> {
  factory $ShellStateCopyWith(
          ShellState value, $Res Function(ShellState) then) =
      _$ShellStateCopyWithImpl<$Res, ShellState>;
}

/// @nodoc
class _$ShellStateCopyWithImpl<$Res, $Val extends ShellState>
    implements $ShellStateCopyWith<$Res> {
  _$ShellStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$ShellStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'ShellState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(Onboarding onboarding) onboarding,
    required TResult Function(ShellStateSuccess succcess) success,
    required TResult Function() loggedOut,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(Onboarding onboarding)? onboarding,
    TResult? Function(ShellStateSuccess succcess)? success,
    TResult? Function()? loggedOut,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(Onboarding onboarding)? onboarding,
    TResult Function(ShellStateSuccess succcess)? success,
    TResult Function()? loggedOut,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Error value) error,
    required TResult Function(_Onboarding value) onboarding,
    required TResult Function(_Success value) success,
    required TResult Function(_LoggedOut value) loggedOut,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Error value)? error,
    TResult? Function(_Onboarding value)? onboarding,
    TResult? Function(_Success value)? success,
    TResult? Function(_LoggedOut value)? loggedOut,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Error value)? error,
    TResult Function(_Onboarding value)? onboarding,
    TResult Function(_Success value)? success,
    TResult Function(_LoggedOut value)? loggedOut,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements ShellState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =
      __$$LoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$ShellStateCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingImpl implements _Loading {
  const _$LoadingImpl();

  @override
  String toString() {
    return 'ShellState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(Onboarding onboarding) onboarding,
    required TResult Function(ShellStateSuccess succcess) success,
    required TResult Function() loggedOut,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(Onboarding onboarding)? onboarding,
    TResult? Function(ShellStateSuccess succcess)? success,
    TResult? Function()? loggedOut,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(Onboarding onboarding)? onboarding,
    TResult Function(ShellStateSuccess succcess)? success,
    TResult Function()? loggedOut,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Error value) error,
    required TResult Function(_Onboarding value) onboarding,
    required TResult Function(_Success value) success,
    required TResult Function(_LoggedOut value) loggedOut,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Error value)? error,
    TResult? Function(_Onboarding value)? onboarding,
    TResult? Function(_Success value)? success,
    TResult? Function(_LoggedOut value)? loggedOut,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Error value)? error,
    TResult Function(_Onboarding value)? onboarding,
    TResult Function(_Success value)? success,
    TResult Function(_LoggedOut value)? loggedOut,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements ShellState {
  const factory _Loading() = _$LoadingImpl;
}

/// @nodoc
abstract class _$$ErrorImplCopyWith<$Res> {
  factory _$$ErrorImplCopyWith(
          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =
      __$$ErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$ErrorImplCopyWithImpl<$Res>
    extends _$ShellStateCopyWithImpl<$Res, _$ErrorImpl>
    implements _$$ErrorImplCopyWith<$Res> {
  __$$ErrorImplCopyWithImpl(
      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$ErrorImpl(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ErrorImpl implements _Error {
  const _$ErrorImpl(this.error);

  @override
  final String error;

  @override
  String toString() {
    return 'ShellState.error(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(Onboarding onboarding) onboarding,
    required TResult Function(ShellStateSuccess succcess) success,
    required TResult Function() loggedOut,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(Onboarding onboarding)? onboarding,
    TResult? Function(ShellStateSuccess succcess)? success,
    TResult? Function()? loggedOut,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(Onboarding onboarding)? onboarding,
    TResult Function(ShellStateSuccess succcess)? success,
    TResult Function()? loggedOut,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Error value) error,
    required TResult Function(_Onboarding value) onboarding,
    required TResult Function(_Success value) success,
    required TResult Function(_LoggedOut value) loggedOut,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Error value)? error,
    TResult? Function(_Onboarding value)? onboarding,
    TResult? Function(_Success value)? success,
    TResult? Function(_LoggedOut value)? loggedOut,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Error value)? error,
    TResult Function(_Onboarding value)? onboarding,
    TResult Function(_Success value)? success,
    TResult Function(_LoggedOut value)? loggedOut,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _Error implements ShellState {
  const factory _Error(final String error) = _$ErrorImpl;

  String get error;
  @JsonKey(ignore: true)
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$OnboardingImplCopyWith<$Res> {
  factory _$$OnboardingImplCopyWith(
          _$OnboardingImpl value, $Res Function(_$OnboardingImpl) then) =
      __$$OnboardingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Onboarding onboarding});

  $OnboardingCopyWith<$Res> get onboarding;
}

/// @nodoc
class __$$OnboardingImplCopyWithImpl<$Res>
    extends _$ShellStateCopyWithImpl<$Res, _$OnboardingImpl>
    implements _$$OnboardingImplCopyWith<$Res> {
  __$$OnboardingImplCopyWithImpl(
      _$OnboardingImpl _value, $Res Function(_$OnboardingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? onboarding = null,
  }) {
    return _then(_$OnboardingImpl(
      null == onboarding
          ? _value.onboarding
          : onboarding // ignore: cast_nullable_to_non_nullable
              as Onboarding,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $OnboardingCopyWith<$Res> get onboarding {
    return $OnboardingCopyWith<$Res>(_value.onboarding, (value) {
      return _then(_value.copyWith(onboarding: value));
    });
  }
}

/// @nodoc

class _$OnboardingImpl implements _Onboarding {
  const _$OnboardingImpl(this.onboarding);

  @override
  final Onboarding onboarding;

  @override
  String toString() {
    return 'ShellState.onboarding(onboarding: $onboarding)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OnboardingImpl &&
            (identical(other.onboarding, onboarding) ||
                other.onboarding == onboarding));
  }

  @override
  int get hashCode => Object.hash(runtimeType, onboarding);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OnboardingImplCopyWith<_$OnboardingImpl> get copyWith =>
      __$$OnboardingImplCopyWithImpl<_$OnboardingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(Onboarding onboarding) onboarding,
    required TResult Function(ShellStateSuccess succcess) success,
    required TResult Function() loggedOut,
  }) {
    return onboarding(this.onboarding);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(Onboarding onboarding)? onboarding,
    TResult? Function(ShellStateSuccess succcess)? success,
    TResult? Function()? loggedOut,
  }) {
    return onboarding?.call(this.onboarding);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(Onboarding onboarding)? onboarding,
    TResult Function(ShellStateSuccess succcess)? success,
    TResult Function()? loggedOut,
    required TResult orElse(),
  }) {
    if (onboarding != null) {
      return onboarding(this.onboarding);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Error value) error,
    required TResult Function(_Onboarding value) onboarding,
    required TResult Function(_Success value) success,
    required TResult Function(_LoggedOut value) loggedOut,
  }) {
    return onboarding(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Error value)? error,
    TResult? Function(_Onboarding value)? onboarding,
    TResult? Function(_Success value)? success,
    TResult? Function(_LoggedOut value)? loggedOut,
  }) {
    return onboarding?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Error value)? error,
    TResult Function(_Onboarding value)? onboarding,
    TResult Function(_Success value)? success,
    TResult Function(_LoggedOut value)? loggedOut,
    required TResult orElse(),
  }) {
    if (onboarding != null) {
      return onboarding(this);
    }
    return orElse();
  }
}

abstract class _Onboarding implements ShellState {
  const factory _Onboarding(final Onboarding onboarding) = _$OnboardingImpl;

  Onboarding get onboarding;
  @JsonKey(ignore: true)
  _$$OnboardingImplCopyWith<_$OnboardingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SuccessImplCopyWith<$Res> {
  factory _$$SuccessImplCopyWith(
          _$SuccessImpl value, $Res Function(_$SuccessImpl) then) =
      __$$SuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ShellStateSuccess succcess});

  $ShellStateSuccessCopyWith<$Res> get succcess;
}

/// @nodoc
class __$$SuccessImplCopyWithImpl<$Res>
    extends _$ShellStateCopyWithImpl<$Res, _$SuccessImpl>
    implements _$$SuccessImplCopyWith<$Res> {
  __$$SuccessImplCopyWithImpl(
      _$SuccessImpl _value, $Res Function(_$SuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? succcess = null,
  }) {
    return _then(_$SuccessImpl(
      null == succcess
          ? _value.succcess
          : succcess // ignore: cast_nullable_to_non_nullable
              as ShellStateSuccess,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ShellStateSuccessCopyWith<$Res> get succcess {
    return $ShellStateSuccessCopyWith<$Res>(_value.succcess, (value) {
      return _then(_value.copyWith(succcess: value));
    });
  }
}

/// @nodoc

class _$SuccessImpl implements _Success {
  const _$SuccessImpl(this.succcess);

  @override
  final ShellStateSuccess succcess;

  @override
  String toString() {
    return 'ShellState.success(succcess: $succcess)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuccessImpl &&
            (identical(other.succcess, succcess) ||
                other.succcess == succcess));
  }

  @override
  int get hashCode => Object.hash(runtimeType, succcess);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>
      __$$SuccessImplCopyWithImpl<_$SuccessImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(Onboarding onboarding) onboarding,
    required TResult Function(ShellStateSuccess succcess) success,
    required TResult Function() loggedOut,
  }) {
    return success(succcess);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(Onboarding onboarding)? onboarding,
    TResult? Function(ShellStateSuccess succcess)? success,
    TResult? Function()? loggedOut,
  }) {
    return success?.call(succcess);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(Onboarding onboarding)? onboarding,
    TResult Function(ShellStateSuccess succcess)? success,
    TResult Function()? loggedOut,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(succcess);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Error value) error,
    required TResult Function(_Onboarding value) onboarding,
    required TResult Function(_Success value) success,
    required TResult Function(_LoggedOut value) loggedOut,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Error value)? error,
    TResult? Function(_Onboarding value)? onboarding,
    TResult? Function(_Success value)? success,
    TResult? Function(_LoggedOut value)? loggedOut,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Error value)? error,
    TResult Function(_Onboarding value)? onboarding,
    TResult Function(_Success value)? success,
    TResult Function(_LoggedOut value)? loggedOut,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _Success implements ShellState {
  const factory _Success(final ShellStateSuccess succcess) = _$SuccessImpl;

  ShellStateSuccess get succcess;
  @JsonKey(ignore: true)
  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoggedOutImplCopyWith<$Res> {
  factory _$$LoggedOutImplCopyWith(
          _$LoggedOutImpl value, $Res Function(_$LoggedOutImpl) then) =
      __$$LoggedOutImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoggedOutImplCopyWithImpl<$Res>
    extends _$ShellStateCopyWithImpl<$Res, _$LoggedOutImpl>
    implements _$$LoggedOutImplCopyWith<$Res> {
  __$$LoggedOutImplCopyWithImpl(
      _$LoggedOutImpl _value, $Res Function(_$LoggedOutImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoggedOutImpl implements _LoggedOut {
  const _$LoggedOutImpl();

  @override
  String toString() {
    return 'ShellState.loggedOut()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoggedOutImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(Onboarding onboarding) onboarding,
    required TResult Function(ShellStateSuccess succcess) success,
    required TResult Function() loggedOut,
  }) {
    return loggedOut();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(Onboarding onboarding)? onboarding,
    TResult? Function(ShellStateSuccess succcess)? success,
    TResult? Function()? loggedOut,
  }) {
    return loggedOut?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(Onboarding onboarding)? onboarding,
    TResult Function(ShellStateSuccess succcess)? success,
    TResult Function()? loggedOut,
    required TResult orElse(),
  }) {
    if (loggedOut != null) {
      return loggedOut();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Error value) error,
    required TResult Function(_Onboarding value) onboarding,
    required TResult Function(_Success value) success,
    required TResult Function(_LoggedOut value) loggedOut,
  }) {
    return loggedOut(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Error value)? error,
    TResult? Function(_Onboarding value)? onboarding,
    TResult? Function(_Success value)? success,
    TResult? Function(_LoggedOut value)? loggedOut,
  }) {
    return loggedOut?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Error value)? error,
    TResult Function(_Onboarding value)? onboarding,
    TResult Function(_Success value)? success,
    TResult Function(_LoggedOut value)? loggedOut,
    required TResult orElse(),
  }) {
    if (loggedOut != null) {
      return loggedOut(this);
    }
    return orElse();
  }
}

abstract class _LoggedOut implements ShellState {
  const factory _LoggedOut() = _$LoggedOutImpl;
}

/// @nodoc
mixin _$ShellStateSuccess {
  bool get redirect => throw _privateConstructorUsedError;
  Wallet get wallet => throw _privateConstructorUsedError;
  List<Account> get accounts => throw _privateConstructorUsedError;
  String? get currentAccountUuid => throw _privateConstructorUsedError;
  List<Address> get addresses => throw _privateConstructorUsedError;
  Address? get currentAddress => throw _privateConstructorUsedError;
  List<ImportedAddress>? get importedAddresses =>
      throw _privateConstructorUsedError;
  ImportedAddress? get currentImportedAddress =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ShellStateSuccessCopyWith<ShellStateSuccess> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShellStateSuccessCopyWith<$Res> {
  factory $ShellStateSuccessCopyWith(
          ShellStateSuccess value, $Res Function(ShellStateSuccess) then) =
      _$ShellStateSuccessCopyWithImpl<$Res, ShellStateSuccess>;
  @useResult
  $Res call(
      {bool redirect,
      Wallet wallet,
      List<Account> accounts,
      String? currentAccountUuid,
      List<Address> addresses,
      Address? currentAddress,
      List<ImportedAddress>? importedAddresses,
      ImportedAddress? currentImportedAddress});
}

/// @nodoc
class _$ShellStateSuccessCopyWithImpl<$Res, $Val extends ShellStateSuccess>
    implements $ShellStateSuccessCopyWith<$Res> {
  _$ShellStateSuccessCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? redirect = null,
    Object? wallet = null,
    Object? accounts = null,
    Object? currentAccountUuid = freezed,
    Object? addresses = null,
    Object? currentAddress = freezed,
    Object? importedAddresses = freezed,
    Object? currentImportedAddress = freezed,
  }) {
    return _then(_value.copyWith(
      redirect: null == redirect
          ? _value.redirect
          : redirect // ignore: cast_nullable_to_non_nullable
              as bool,
      wallet: null == wallet
          ? _value.wallet
          : wallet // ignore: cast_nullable_to_non_nullable
              as Wallet,
      accounts: null == accounts
          ? _value.accounts
          : accounts // ignore: cast_nullable_to_non_nullable
              as List<Account>,
      currentAccountUuid: freezed == currentAccountUuid
          ? _value.currentAccountUuid
          : currentAccountUuid // ignore: cast_nullable_to_non_nullable
              as String?,
      addresses: null == addresses
          ? _value.addresses
          : addresses // ignore: cast_nullable_to_non_nullable
              as List<Address>,
      currentAddress: freezed == currentAddress
          ? _value.currentAddress
          : currentAddress // ignore: cast_nullable_to_non_nullable
              as Address?,
      importedAddresses: freezed == importedAddresses
          ? _value.importedAddresses
          : importedAddresses // ignore: cast_nullable_to_non_nullable
              as List<ImportedAddress>?,
      currentImportedAddress: freezed == currentImportedAddress
          ? _value.currentImportedAddress
          : currentImportedAddress // ignore: cast_nullable_to_non_nullable
              as ImportedAddress?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ShellStateSuccessImplCopyWith<$Res>
    implements $ShellStateSuccessCopyWith<$Res> {
  factory _$$ShellStateSuccessImplCopyWith(_$ShellStateSuccessImpl value,
          $Res Function(_$ShellStateSuccessImpl) then) =
      __$$ShellStateSuccessImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool redirect,
      Wallet wallet,
      List<Account> accounts,
      String? currentAccountUuid,
      List<Address> addresses,
      Address? currentAddress,
      List<ImportedAddress>? importedAddresses,
      ImportedAddress? currentImportedAddress});
}

/// @nodoc
class __$$ShellStateSuccessImplCopyWithImpl<$Res>
    extends _$ShellStateSuccessCopyWithImpl<$Res, _$ShellStateSuccessImpl>
    implements _$$ShellStateSuccessImplCopyWith<$Res> {
  __$$ShellStateSuccessImplCopyWithImpl(_$ShellStateSuccessImpl _value,
      $Res Function(_$ShellStateSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? redirect = null,
    Object? wallet = null,
    Object? accounts = null,
    Object? currentAccountUuid = freezed,
    Object? addresses = null,
    Object? currentAddress = freezed,
    Object? importedAddresses = freezed,
    Object? currentImportedAddress = freezed,
  }) {
    return _then(_$ShellStateSuccessImpl(
      redirect: null == redirect
          ? _value.redirect
          : redirect // ignore: cast_nullable_to_non_nullable
              as bool,
      wallet: null == wallet
          ? _value.wallet
          : wallet // ignore: cast_nullable_to_non_nullable
              as Wallet,
      accounts: null == accounts
          ? _value._accounts
          : accounts // ignore: cast_nullable_to_non_nullable
              as List<Account>,
      currentAccountUuid: freezed == currentAccountUuid
          ? _value.currentAccountUuid
          : currentAccountUuid // ignore: cast_nullable_to_non_nullable
              as String?,
      addresses: null == addresses
          ? _value._addresses
          : addresses // ignore: cast_nullable_to_non_nullable
              as List<Address>,
      currentAddress: freezed == currentAddress
          ? _value.currentAddress
          : currentAddress // ignore: cast_nullable_to_non_nullable
              as Address?,
      importedAddresses: freezed == importedAddresses
          ? _value._importedAddresses
          : importedAddresses // ignore: cast_nullable_to_non_nullable
              as List<ImportedAddress>?,
      currentImportedAddress: freezed == currentImportedAddress
          ? _value.currentImportedAddress
          : currentImportedAddress // ignore: cast_nullable_to_non_nullable
              as ImportedAddress?,
    ));
  }
}

/// @nodoc

class _$ShellStateSuccessImpl implements _ShellStateSuccess {
  const _$ShellStateSuccessImpl(
      {required this.redirect,
      required this.wallet,
      required final List<Account> accounts,
      required this.currentAccountUuid,
      required final List<Address> addresses,
      required this.currentAddress,
      final List<ImportedAddress>? importedAddresses,
      this.currentImportedAddress})
      : _accounts = accounts,
        _addresses = addresses,
        _importedAddresses = importedAddresses;

  @override
  final bool redirect;
  @override
  final Wallet wallet;
  final List<Account> _accounts;
  @override
  List<Account> get accounts {
    if (_accounts is EqualUnmodifiableListView) return _accounts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_accounts);
  }

  @override
  final String? currentAccountUuid;
  final List<Address> _addresses;
  @override
  List<Address> get addresses {
    if (_addresses is EqualUnmodifiableListView) return _addresses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_addresses);
  }

  @override
  final Address? currentAddress;
  final List<ImportedAddress>? _importedAddresses;
  @override
  List<ImportedAddress>? get importedAddresses {
    final value = _importedAddresses;
    if (value == null) return null;
    if (_importedAddresses is EqualUnmodifiableListView)
      return _importedAddresses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final ImportedAddress? currentImportedAddress;

  @override
  String toString() {
    return 'ShellStateSuccess._(redirect: $redirect, wallet: $wallet, accounts: $accounts, currentAccountUuid: $currentAccountUuid, addresses: $addresses, currentAddress: $currentAddress, importedAddresses: $importedAddresses, currentImportedAddress: $currentImportedAddress)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ShellStateSuccessImpl &&
            (identical(other.redirect, redirect) ||
                other.redirect == redirect) &&
            (identical(other.wallet, wallet) || other.wallet == wallet) &&
            const DeepCollectionEquality().equals(other._accounts, _accounts) &&
            (identical(other.currentAccountUuid, currentAccountUuid) ||
                other.currentAccountUuid == currentAccountUuid) &&
            const DeepCollectionEquality()
                .equals(other._addresses, _addresses) &&
            (identical(other.currentAddress, currentAddress) ||
                other.currentAddress == currentAddress) &&
            const DeepCollectionEquality()
                .equals(other._importedAddresses, _importedAddresses) &&
            (identical(other.currentImportedAddress, currentImportedAddress) ||
                other.currentImportedAddress == currentImportedAddress));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      redirect,
      wallet,
      const DeepCollectionEquality().hash(_accounts),
      currentAccountUuid,
      const DeepCollectionEquality().hash(_addresses),
      currentAddress,
      const DeepCollectionEquality().hash(_importedAddresses),
      currentImportedAddress);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ShellStateSuccessImplCopyWith<_$ShellStateSuccessImpl> get copyWith =>
      __$$ShellStateSuccessImplCopyWithImpl<_$ShellStateSuccessImpl>(
          this, _$identity);
}

abstract class _ShellStateSuccess implements ShellStateSuccess {
  const factory _ShellStateSuccess(
      {required final bool redirect,
      required final Wallet wallet,
      required final List<Account> accounts,
      required final String? currentAccountUuid,
      required final List<Address> addresses,
      required final Address? currentAddress,
      final List<ImportedAddress>? importedAddresses,
      final ImportedAddress? currentImportedAddress}) = _$ShellStateSuccessImpl;

  @override
  bool get redirect;
  @override
  Wallet get wallet;
  @override
  List<Account> get accounts;
  @override
  String? get currentAccountUuid;
  @override
  List<Address> get addresses;
  @override
  Address? get currentAddress;
  @override
  List<ImportedAddress>? get importedAddresses;
  @override
  ImportedAddress? get currentImportedAddress;
  @override
  @JsonKey(ignore: true)
  _$$ShellStateSuccessImplCopyWith<_$ShellStateSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Onboarding {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() create,
    required TResult Function() import,
    required TResult Function() importPK,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? create,
    TResult? Function()? import,
    TResult? Function()? importPK,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? create,
    TResult Function()? import,
    TResult Function()? importPK,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_OnboardingInitial value) initial,
    required TResult Function(_Create value) create,
    required TResult Function(_Import value) import,
    required TResult Function(_ImportPK value) importPK,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_OnboardingInitial value)? initial,
    TResult? Function(_Create value)? create,
    TResult? Function(_Import value)? import,
    TResult? Function(_ImportPK value)? importPK,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_OnboardingInitial value)? initial,
    TResult Function(_Create value)? create,
    TResult Function(_Import value)? import,
    TResult Function(_ImportPK value)? importPK,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OnboardingCopyWith<$Res> {
  factory $OnboardingCopyWith(
          Onboarding value, $Res Function(Onboarding) then) =
      _$OnboardingCopyWithImpl<$Res, Onboarding>;
}

/// @nodoc
class _$OnboardingCopyWithImpl<$Res, $Val extends Onboarding>
    implements $OnboardingCopyWith<$Res> {
  _$OnboardingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$OnboardingInitialImplCopyWith<$Res> {
  factory _$$OnboardingInitialImplCopyWith(_$OnboardingInitialImpl value,
          $Res Function(_$OnboardingInitialImpl) then) =
      __$$OnboardingInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OnboardingInitialImplCopyWithImpl<$Res>
    extends _$OnboardingCopyWithImpl<$Res, _$OnboardingInitialImpl>
    implements _$$OnboardingInitialImplCopyWith<$Res> {
  __$$OnboardingInitialImplCopyWithImpl(_$OnboardingInitialImpl _value,
      $Res Function(_$OnboardingInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OnboardingInitialImpl implements _OnboardingInitial {
  const _$OnboardingInitialImpl();

  @override
  String toString() {
    return 'Onboarding.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OnboardingInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() create,
    required TResult Function() import,
    required TResult Function() importPK,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? create,
    TResult? Function()? import,
    TResult? Function()? importPK,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? create,
    TResult Function()? import,
    TResult Function()? importPK,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_OnboardingInitial value) initial,
    required TResult Function(_Create value) create,
    required TResult Function(_Import value) import,
    required TResult Function(_ImportPK value) importPK,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_OnboardingInitial value)? initial,
    TResult? Function(_Create value)? create,
    TResult? Function(_Import value)? import,
    TResult? Function(_ImportPK value)? importPK,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_OnboardingInitial value)? initial,
    TResult Function(_Create value)? create,
    TResult Function(_Import value)? import,
    TResult Function(_ImportPK value)? importPK,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _OnboardingInitial implements Onboarding {
  const factory _OnboardingInitial() = _$OnboardingInitialImpl;
}

/// @nodoc
abstract class _$$CreateImplCopyWith<$Res> {
  factory _$$CreateImplCopyWith(
          _$CreateImpl value, $Res Function(_$CreateImpl) then) =
      __$$CreateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CreateImplCopyWithImpl<$Res>
    extends _$OnboardingCopyWithImpl<$Res, _$CreateImpl>
    implements _$$CreateImplCopyWith<$Res> {
  __$$CreateImplCopyWithImpl(
      _$CreateImpl _value, $Res Function(_$CreateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CreateImpl implements _Create {
  const _$CreateImpl();

  @override
  String toString() {
    return 'Onboarding.create()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CreateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() create,
    required TResult Function() import,
    required TResult Function() importPK,
  }) {
    return create();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? create,
    TResult? Function()? import,
    TResult? Function()? importPK,
  }) {
    return create?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? create,
    TResult Function()? import,
    TResult Function()? importPK,
    required TResult orElse(),
  }) {
    if (create != null) {
      return create();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_OnboardingInitial value) initial,
    required TResult Function(_Create value) create,
    required TResult Function(_Import value) import,
    required TResult Function(_ImportPK value) importPK,
  }) {
    return create(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_OnboardingInitial value)? initial,
    TResult? Function(_Create value)? create,
    TResult? Function(_Import value)? import,
    TResult? Function(_ImportPK value)? importPK,
  }) {
    return create?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_OnboardingInitial value)? initial,
    TResult Function(_Create value)? create,
    TResult Function(_Import value)? import,
    TResult Function(_ImportPK value)? importPK,
    required TResult orElse(),
  }) {
    if (create != null) {
      return create(this);
    }
    return orElse();
  }
}

abstract class _Create implements Onboarding {
  const factory _Create() = _$CreateImpl;
}

/// @nodoc
abstract class _$$ImportImplCopyWith<$Res> {
  factory _$$ImportImplCopyWith(
          _$ImportImpl value, $Res Function(_$ImportImpl) then) =
      __$$ImportImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ImportImplCopyWithImpl<$Res>
    extends _$OnboardingCopyWithImpl<$Res, _$ImportImpl>
    implements _$$ImportImplCopyWith<$Res> {
  __$$ImportImplCopyWithImpl(
      _$ImportImpl _value, $Res Function(_$ImportImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ImportImpl implements _Import {
  const _$ImportImpl();

  @override
  String toString() {
    return 'Onboarding.import()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ImportImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() create,
    required TResult Function() import,
    required TResult Function() importPK,
  }) {
    return import();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? create,
    TResult? Function()? import,
    TResult? Function()? importPK,
  }) {
    return import?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? create,
    TResult Function()? import,
    TResult Function()? importPK,
    required TResult orElse(),
  }) {
    if (import != null) {
      return import();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_OnboardingInitial value) initial,
    required TResult Function(_Create value) create,
    required TResult Function(_Import value) import,
    required TResult Function(_ImportPK value) importPK,
  }) {
    return import(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_OnboardingInitial value)? initial,
    TResult? Function(_Create value)? create,
    TResult? Function(_Import value)? import,
    TResult? Function(_ImportPK value)? importPK,
  }) {
    return import?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_OnboardingInitial value)? initial,
    TResult Function(_Create value)? create,
    TResult Function(_Import value)? import,
    TResult Function(_ImportPK value)? importPK,
    required TResult orElse(),
  }) {
    if (import != null) {
      return import(this);
    }
    return orElse();
  }
}

abstract class _Import implements Onboarding {
  const factory _Import() = _$ImportImpl;
}

/// @nodoc
abstract class _$$ImportPKImplCopyWith<$Res> {
  factory _$$ImportPKImplCopyWith(
          _$ImportPKImpl value, $Res Function(_$ImportPKImpl) then) =
      __$$ImportPKImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ImportPKImplCopyWithImpl<$Res>
    extends _$OnboardingCopyWithImpl<$Res, _$ImportPKImpl>
    implements _$$ImportPKImplCopyWith<$Res> {
  __$$ImportPKImplCopyWithImpl(
      _$ImportPKImpl _value, $Res Function(_$ImportPKImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ImportPKImpl implements _ImportPK {
  const _$ImportPKImpl();

  @override
  String toString() {
    return 'Onboarding.importPK()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ImportPKImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() create,
    required TResult Function() import,
    required TResult Function() importPK,
  }) {
    return importPK();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? create,
    TResult? Function()? import,
    TResult? Function()? importPK,
  }) {
    return importPK?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? create,
    TResult Function()? import,
    TResult Function()? importPK,
    required TResult orElse(),
  }) {
    if (importPK != null) {
      return importPK();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_OnboardingInitial value) initial,
    required TResult Function(_Create value) create,
    required TResult Function(_Import value) import,
    required TResult Function(_ImportPK value) importPK,
  }) {
    return importPK(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_OnboardingInitial value)? initial,
    TResult? Function(_Create value)? create,
    TResult? Function(_Import value)? import,
    TResult? Function(_ImportPK value)? importPK,
  }) {
    return importPK?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_OnboardingInitial value)? initial,
    TResult Function(_Create value)? create,
    TResult Function(_Import value)? import,
    TResult Function(_ImportPK value)? importPK,
    required TResult orElse(),
  }) {
    if (importPK != null) {
      return importPK(this);
    }
    return orElse();
  }
}

abstract class _ImportPK implements Onboarding {
  const factory _ImportPK() = _$ImportPKImpl;
}
