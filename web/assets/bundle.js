var hwd = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js
  var init_dirname = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js"() {
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/process.js
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function hrtime(previousTimestamp) {
    var baseNow = Math.floor((Date.now() - _performance.now()) * 1e-3);
    var clocktime = _performance.now() * 1e-3;
    var seconds = Math.floor(clocktime) + baseNow;
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += nanoPerSec;
      }
    }
    return [seconds, nanoseconds];
  }
  var env, _performance, nowOffset, nanoPerSec;
  var init_process = __esm({
    "node_modules/@jspm/core/nodelibs/browser/process.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      env = {
        PATH: "/usr/bin",
        LANG: typeof navigator !== "undefined" ? navigator.language + ".UTF-8" : void 0,
        PWD: "/",
        HOME: "/home",
        TMP: "/tmp"
      };
      _performance = {
        now: typeof performance !== "undefined" ? performance.now.bind(performance) : void 0,
        timing: typeof performance !== "undefined" ? performance.timing : void 0
      };
      if (_performance.now === void 0) {
        nowOffset = Date.now();
        if (_performance.timing && _performance.timing.navigationStart) {
          nowOffset = _performance.timing.navigationStart;
        }
        _performance.now = () => Date.now() - nowOffset;
      }
      nanoPerSec = 1e9;
      hrtime.bigint = function(time) {
        var diff = hrtime(time);
        if (typeof BigInt === "undefined") {
          return diff[0] * nanoPerSec + diff[1];
        }
        return BigInt(diff[0] * nanoPerSec) + BigInt(diff[1]);
      };
    }
  });

  // node_modules/esbuild-plugin-polyfill-node/polyfills/process.js
  var init_process2 = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/process.js"() {
      init_process();
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-DtuTasat.js
  function dew$2() {
    if (_dewExec$2) return exports$2;
    _dewExec$2 = true;
    exports$2.byteLength = byteLength;
    exports$2.toByteArray = toByteArray;
    exports$2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
    return exports$2;
  }
  function dew$1() {
    if (_dewExec$1) return exports$1;
    _dewExec$1 = true;
    exports$1.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports$1.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
    return exports$1;
  }
  function dew() {
    if (_dewExec) return exports;
    _dewExec = true;
    const base64 = dew$2();
    const ieee754 = dew$1();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = {
          foo: function() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer2(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare3(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat2(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect2() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare3(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt82(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt82(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    const errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E("ERR_INVALID_ARG_TYPE", function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE("offset", `>= ${0} and <= ${length}`, value);
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    return exports;
  }
  var exports$2, _dewExec$2, exports$1, _dewExec$1, exports, _dewExec;
  var init_chunk_DtuTasat = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-DtuTasat.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      exports$2 = {};
      _dewExec$2 = false;
      exports$1 = {};
      _dewExec$1 = false;
      exports = {};
      _dewExec = false;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/buffer.js
  var buffer_exports = {};
  __export(buffer_exports, {
    Buffer: () => Buffer2,
    INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
    default: () => exports2,
    kMaxLength: () => kMaxLength
  });
  var exports2, Buffer2, INSPECT_MAX_BYTES, kMaxLength;
  var init_buffer = __esm({
    "node_modules/@jspm/core/nodelibs/browser/buffer.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_DtuTasat();
      exports2 = dew();
      exports2["Buffer"];
      exports2["SlowBuffer"];
      exports2["INSPECT_MAX_BYTES"];
      exports2["kMaxLength"];
      Buffer2 = exports2.Buffer;
      INSPECT_MAX_BYTES = exports2.INSPECT_MAX_BYTES;
      kMaxLength = exports2.kMaxLength;
    }
  });

  // node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js
  var init_buffer2 = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js"() {
      init_buffer();
    }
  });

  // node_modules/bitcoinjs-lib/src/networks.js
  var require_networks = __commonJS({
    "node_modules/bitcoinjs-lib/src/networks.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.testnet = exports9.regtest = exports9.bitcoin = void 0;
      exports9.bitcoin = {
        /**
         * The message prefix used for signing Bitcoin messages.
         */
        messagePrefix: "Bitcoin Signed Message:\n",
        /**
         * The Bech32 prefix used for Bitcoin addresses.
         */
        bech32: "bc",
        /**
         * The BIP32 key prefixes for Bitcoin.
         */
        bip32: {
          /**
           * The public key prefix for BIP32 extended public keys.
           */
          public: 76067358,
          /**
           * The private key prefix for BIP32 extended private keys.
           */
          private: 76066276
        },
        /**
         * The prefix for Bitcoin public key hashes.
         */
        pubKeyHash: 0,
        /**
         * The prefix for Bitcoin script hashes.
         */
        scriptHash: 5,
        /**
         * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
         */
        wif: 128
      };
      exports9.regtest = {
        messagePrefix: "Bitcoin Signed Message:\n",
        bech32: "bcrt",
        bip32: {
          public: 70617039,
          private: 70615956
        },
        pubKeyHash: 111,
        scriptHash: 196,
        wif: 239
      };
      exports9.testnet = {
        messagePrefix: "Bitcoin Signed Message:\n",
        bech32: "tb",
        bip32: {
          public: 70617039,
          private: 70615956
        },
        pubKeyHash: 111,
        scriptHash: 196,
        wif: 239
      };
    }
  });

  // node_modules/bitcoinjs-lib/src/bip66.js
  var require_bip66 = __commonJS({
    "node_modules/bitcoinjs-lib/src/bip66.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.encode = exports9.decode = exports9.check = void 0;
      function check(buffer) {
        if (buffer.length < 8) return false;
        if (buffer.length > 72) return false;
        if (buffer[0] !== 48) return false;
        if (buffer[1] !== buffer.length - 2) return false;
        if (buffer[2] !== 2) return false;
        const lenR = buffer[3];
        if (lenR === 0) return false;
        if (5 + lenR >= buffer.length) return false;
        if (buffer[4 + lenR] !== 2) return false;
        const lenS = buffer[5 + lenR];
        if (lenS === 0) return false;
        if (6 + lenR + lenS !== buffer.length) return false;
        if (buffer[4] & 128) return false;
        if (lenR > 1 && buffer[4] === 0 && !(buffer[5] & 128)) return false;
        if (buffer[lenR + 6] & 128) return false;
        if (lenS > 1 && buffer[lenR + 6] === 0 && !(buffer[lenR + 7] & 128))
          return false;
        return true;
      }
      exports9.check = check;
      function decode(buffer) {
        if (buffer.length < 8) throw new Error("DER sequence length is too short");
        if (buffer.length > 72) throw new Error("DER sequence length is too long");
        if (buffer[0] !== 48) throw new Error("Expected DER sequence");
        if (buffer[1] !== buffer.length - 2)
          throw new Error("DER sequence length is invalid");
        if (buffer[2] !== 2) throw new Error("Expected DER integer");
        const lenR = buffer[3];
        if (lenR === 0) throw new Error("R length is zero");
        if (5 + lenR >= buffer.length) throw new Error("R length is too long");
        if (buffer[4 + lenR] !== 2) throw new Error("Expected DER integer (2)");
        const lenS = buffer[5 + lenR];
        if (lenS === 0) throw new Error("S length is zero");
        if (6 + lenR + lenS !== buffer.length) throw new Error("S length is invalid");
        if (buffer[4] & 128) throw new Error("R value is negative");
        if (lenR > 1 && buffer[4] === 0 && !(buffer[5] & 128))
          throw new Error("R value excessively padded");
        if (buffer[lenR + 6] & 128) throw new Error("S value is negative");
        if (lenS > 1 && buffer[lenR + 6] === 0 && !(buffer[lenR + 7] & 128))
          throw new Error("S value excessively padded");
        return {
          r: buffer.slice(4, 4 + lenR),
          s: buffer.slice(6 + lenR)
        };
      }
      exports9.decode = decode;
      function encode(r, s) {
        const lenR = r.length;
        const lenS = s.length;
        if (lenR === 0) throw new Error("R length is zero");
        if (lenS === 0) throw new Error("S length is zero");
        if (lenR > 33) throw new Error("R length is too long");
        if (lenS > 33) throw new Error("S length is too long");
        if (r[0] & 128) throw new Error("R value is negative");
        if (s[0] & 128) throw new Error("S value is negative");
        if (lenR > 1 && r[0] === 0 && !(r[1] & 128))
          throw new Error("R value excessively padded");
        if (lenS > 1 && s[0] === 0 && !(s[1] & 128))
          throw new Error("S value excessively padded");
        const signature = Buffer2.allocUnsafe(6 + lenR + lenS);
        signature[0] = 48;
        signature[1] = signature.length - 2;
        signature[2] = 2;
        signature[3] = r.length;
        r.copy(signature, 4);
        signature[4 + lenR] = 2;
        signature[5 + lenR] = s.length;
        s.copy(signature, 6 + lenR);
        return signature;
      }
      exports9.encode = encode;
    }
  });

  // node_modules/bitcoinjs-lib/src/ops.js
  var require_ops = __commonJS({
    "node_modules/bitcoinjs-lib/src/ops.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.REVERSE_OPS = exports9.OPS = void 0;
      var OPS = {
        OP_FALSE: 0,
        OP_0: 0,
        OP_PUSHDATA1: 76,
        OP_PUSHDATA2: 77,
        OP_PUSHDATA4: 78,
        OP_1NEGATE: 79,
        OP_RESERVED: 80,
        OP_TRUE: 81,
        OP_1: 81,
        OP_2: 82,
        OP_3: 83,
        OP_4: 84,
        OP_5: 85,
        OP_6: 86,
        OP_7: 87,
        OP_8: 88,
        OP_9: 89,
        OP_10: 90,
        OP_11: 91,
        OP_12: 92,
        OP_13: 93,
        OP_14: 94,
        OP_15: 95,
        OP_16: 96,
        OP_NOP: 97,
        OP_VER: 98,
        OP_IF: 99,
        OP_NOTIF: 100,
        OP_VERIF: 101,
        OP_VERNOTIF: 102,
        OP_ELSE: 103,
        OP_ENDIF: 104,
        OP_VERIFY: 105,
        OP_RETURN: 106,
        OP_TOALTSTACK: 107,
        OP_FROMALTSTACK: 108,
        OP_2DROP: 109,
        OP_2DUP: 110,
        OP_3DUP: 111,
        OP_2OVER: 112,
        OP_2ROT: 113,
        OP_2SWAP: 114,
        OP_IFDUP: 115,
        OP_DEPTH: 116,
        OP_DROP: 117,
        OP_DUP: 118,
        OP_NIP: 119,
        OP_OVER: 120,
        OP_PICK: 121,
        OP_ROLL: 122,
        OP_ROT: 123,
        OP_SWAP: 124,
        OP_TUCK: 125,
        OP_CAT: 126,
        OP_SUBSTR: 127,
        OP_LEFT: 128,
        OP_RIGHT: 129,
        OP_SIZE: 130,
        OP_INVERT: 131,
        OP_AND: 132,
        OP_OR: 133,
        OP_XOR: 134,
        OP_EQUAL: 135,
        OP_EQUALVERIFY: 136,
        OP_RESERVED1: 137,
        OP_RESERVED2: 138,
        OP_1ADD: 139,
        OP_1SUB: 140,
        OP_2MUL: 141,
        OP_2DIV: 142,
        OP_NEGATE: 143,
        OP_ABS: 144,
        OP_NOT: 145,
        OP_0NOTEQUAL: 146,
        OP_ADD: 147,
        OP_SUB: 148,
        OP_MUL: 149,
        OP_DIV: 150,
        OP_MOD: 151,
        OP_LSHIFT: 152,
        OP_RSHIFT: 153,
        OP_BOOLAND: 154,
        OP_BOOLOR: 155,
        OP_NUMEQUAL: 156,
        OP_NUMEQUALVERIFY: 157,
        OP_NUMNOTEQUAL: 158,
        OP_LESSTHAN: 159,
        OP_GREATERTHAN: 160,
        OP_LESSTHANOREQUAL: 161,
        OP_GREATERTHANOREQUAL: 162,
        OP_MIN: 163,
        OP_MAX: 164,
        OP_WITHIN: 165,
        OP_RIPEMD160: 166,
        OP_SHA1: 167,
        OP_SHA256: 168,
        OP_HASH160: 169,
        OP_HASH256: 170,
        OP_CODESEPARATOR: 171,
        OP_CHECKSIG: 172,
        OP_CHECKSIGVERIFY: 173,
        OP_CHECKMULTISIG: 174,
        OP_CHECKMULTISIGVERIFY: 175,
        OP_NOP1: 176,
        OP_NOP2: 177,
        OP_CHECKLOCKTIMEVERIFY: 177,
        OP_NOP3: 178,
        OP_CHECKSEQUENCEVERIFY: 178,
        OP_NOP4: 179,
        OP_NOP5: 180,
        OP_NOP6: 181,
        OP_NOP7: 182,
        OP_NOP8: 183,
        OP_NOP9: 184,
        OP_NOP10: 185,
        OP_CHECKSIGADD: 186,
        OP_PUBKEYHASH: 253,
        OP_PUBKEY: 254,
        OP_INVALIDOPCODE: 255
      };
      exports9.OPS = OPS;
      var REVERSE_OPS = {};
      exports9.REVERSE_OPS = REVERSE_OPS;
      for (const op of Object.keys(OPS)) {
        const code = OPS[op];
        REVERSE_OPS[code] = op;
      }
    }
  });

  // node_modules/bitcoinjs-lib/src/push_data.js
  var require_push_data = __commonJS({
    "node_modules/bitcoinjs-lib/src/push_data.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.decode = exports9.encode = exports9.encodingLength = void 0;
      var ops_1 = require_ops();
      function encodingLength(i) {
        return i < ops_1.OPS.OP_PUSHDATA1 ? 1 : i <= 255 ? 2 : i <= 65535 ? 3 : 5;
      }
      exports9.encodingLength = encodingLength;
      function encode(buffer, num, offset) {
        const size = encodingLength(num);
        if (size === 1) {
          buffer.writeUInt8(num, offset);
        } else if (size === 2) {
          buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA1, offset);
          buffer.writeUInt8(num, offset + 1);
        } else if (size === 3) {
          buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA2, offset);
          buffer.writeUInt16LE(num, offset + 1);
        } else {
          buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA4, offset);
          buffer.writeUInt32LE(num, offset + 1);
        }
        return size;
      }
      exports9.encode = encode;
      function decode(buffer, offset) {
        const opcode = buffer.readUInt8(offset);
        let num;
        let size;
        if (opcode < ops_1.OPS.OP_PUSHDATA1) {
          num = opcode;
          size = 1;
        } else if (opcode === ops_1.OPS.OP_PUSHDATA1) {
          if (offset + 2 > buffer.length) return null;
          num = buffer.readUInt8(offset + 1);
          size = 2;
        } else if (opcode === ops_1.OPS.OP_PUSHDATA2) {
          if (offset + 3 > buffer.length) return null;
          num = buffer.readUInt16LE(offset + 1);
          size = 3;
        } else {
          if (offset + 5 > buffer.length) return null;
          if (opcode !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
          num = buffer.readUInt32LE(offset + 1);
          size = 5;
        }
        return {
          opcode,
          number: num,
          size
        };
      }
      exports9.decode = decode;
    }
  });

  // node_modules/bitcoinjs-lib/src/script_number.js
  var require_script_number = __commonJS({
    "node_modules/bitcoinjs-lib/src/script_number.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.encode = exports9.decode = void 0;
      function decode(buffer, maxLength, minimal) {
        maxLength = maxLength || 4;
        minimal = minimal === void 0 ? true : minimal;
        const length = buffer.length;
        if (length === 0) return 0;
        if (length > maxLength) throw new TypeError("Script number overflow");
        if (minimal) {
          if ((buffer[length - 1] & 127) === 0) {
            if (length <= 1 || (buffer[length - 2] & 128) === 0)
              throw new Error("Non-minimally encoded script number");
          }
        }
        if (length === 5) {
          const a = buffer.readUInt32LE(0);
          const b = buffer.readUInt8(4);
          if (b & 128) return -((b & ~128) * 4294967296 + a);
          return b * 4294967296 + a;
        }
        let result = 0;
        for (let i = 0; i < length; ++i) {
          result |= buffer[i] << 8 * i;
        }
        if (buffer[length - 1] & 128)
          return -(result & ~(128 << 8 * (length - 1)));
        return result;
      }
      exports9.decode = decode;
      function scriptNumSize(i) {
        return i > 2147483647 ? 5 : i > 8388607 ? 4 : i > 32767 ? 3 : i > 127 ? 2 : i > 0 ? 1 : 0;
      }
      function encode(_number) {
        let value = Math.abs(_number);
        const size = scriptNumSize(value);
        const buffer = Buffer2.allocUnsafe(size);
        const negative = _number < 0;
        for (let i = 0; i < size; ++i) {
          buffer.writeUInt8(value & 255, i);
          value >>= 8;
        }
        if (buffer[size - 1] & 128) {
          buffer.writeUInt8(negative ? 128 : 0, size - 1);
        } else if (negative) {
          buffer[size - 1] |= 128;
        }
        return buffer;
      }
      exports9.encode = encode;
    }
  });

  // node_modules/typeforce/native.js
  var require_native = __commonJS({
    "node_modules/typeforce/native.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var types2 = {
        Array: function(value) {
          return value !== null && value !== void 0 && value.constructor === Array;
        },
        Boolean: function(value) {
          return typeof value === "boolean";
        },
        Function: function(value) {
          return typeof value === "function";
        },
        Nil: function(value) {
          return value === void 0 || value === null;
        },
        Number: function(value) {
          return typeof value === "number";
        },
        Object: function(value) {
          return typeof value === "object";
        },
        String: function(value) {
          return typeof value === "string";
        },
        "": function() {
          return true;
        }
      };
      types2.Null = types2.Nil;
      for (typeName in types2) {
        types2[typeName].toJSON = function(t) {
          return t;
        }.bind(null, typeName);
      }
      var typeName;
      module.exports = types2;
    }
  });

  // node_modules/typeforce/errors.js
  var require_errors = __commonJS({
    "node_modules/typeforce/errors.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var native = require_native();
      function getTypeName(fn) {
        return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1];
      }
      function getValueTypeName(value) {
        return native.Nil(value) ? "" : getTypeName(value.constructor);
      }
      function getValue(value) {
        if (native.Function(value)) return "";
        if (native.String(value)) return JSON.stringify(value);
        if (value && native.Object(value)) return "";
        return value;
      }
      function captureStackTrace(e, t) {
        if (Error.captureStackTrace) {
          Error.captureStackTrace(e, t);
        }
      }
      function tfJSON(type) {
        if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type);
        if (native.Array(type)) return "Array";
        if (type && native.Object(type)) return "Object";
        return type !== void 0 ? type : "";
      }
      function tfErrorString(type, value, valueTypeName) {
        var valueJson = getValue(value);
        return "Expected " + tfJSON(type) + ", got" + (valueTypeName !== "" ? " " + valueTypeName : "") + (valueJson !== "" ? " " + valueJson : "");
      }
      function TfTypeError(type, value, valueTypeName) {
        valueTypeName = valueTypeName || getValueTypeName(value);
        this.message = tfErrorString(type, value, valueTypeName);
        captureStackTrace(this, TfTypeError);
        this.__type = type;
        this.__value = value;
        this.__valueTypeName = valueTypeName;
      }
      TfTypeError.prototype = Object.create(Error.prototype);
      TfTypeError.prototype.constructor = TfTypeError;
      function tfPropertyErrorString(type, label, name2, value, valueTypeName) {
        var description = '" of type ';
        if (label === "key") description = '" with key type ';
        return tfErrorString('property "' + tfJSON(name2) + description + tfJSON(type), value, valueTypeName);
      }
      function TfPropertyTypeError(type, property, label, value, valueTypeName) {
        if (type) {
          valueTypeName = valueTypeName || getValueTypeName(value);
          this.message = tfPropertyErrorString(type, label, property, value, valueTypeName);
        } else {
          this.message = 'Unexpected property "' + property + '"';
        }
        captureStackTrace(this, TfTypeError);
        this.__label = label;
        this.__property = property;
        this.__type = type;
        this.__value = value;
        this.__valueTypeName = valueTypeName;
      }
      TfPropertyTypeError.prototype = Object.create(Error.prototype);
      TfPropertyTypeError.prototype.constructor = TfTypeError;
      function tfCustomError(expected, actual) {
        return new TfTypeError(expected, {}, actual);
      }
      function tfSubError(e, property, label) {
        if (e instanceof TfPropertyTypeError) {
          property = property + "." + e.__property;
          e = new TfPropertyTypeError(
            e.__type,
            property,
            e.__label,
            e.__value,
            e.__valueTypeName
          );
        } else if (e instanceof TfTypeError) {
          e = new TfPropertyTypeError(
            e.__type,
            property,
            label,
            e.__value,
            e.__valueTypeName
          );
        }
        captureStackTrace(e);
        return e;
      }
      module.exports = {
        TfTypeError,
        TfPropertyTypeError,
        tfCustomError,
        tfSubError,
        tfJSON,
        getValueTypeName
      };
    }
  });

  // node_modules/typeforce/extra.js
  var require_extra = __commonJS({
    "node_modules/typeforce/extra.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var NATIVE = require_native();
      var ERRORS = require_errors();
      function _Buffer(value) {
        return Buffer2.isBuffer(value);
      }
      function Hex(value) {
        return typeof value === "string" && /^([0-9a-f]{2})+$/i.test(value);
      }
      function _LengthN(type, length) {
        var name2 = type.toJSON();
        function Length(value) {
          if (!type(value)) return false;
          if (value.length === length) return true;
          throw ERRORS.tfCustomError(name2 + "(Length: " + length + ")", name2 + "(Length: " + value.length + ")");
        }
        Length.toJSON = function() {
          return name2;
        };
        return Length;
      }
      var _ArrayN = _LengthN.bind(null, NATIVE.Array);
      var _BufferN = _LengthN.bind(null, _Buffer);
      var _HexN = _LengthN.bind(null, Hex);
      var _StringN = _LengthN.bind(null, NATIVE.String);
      function Range(a, b, f) {
        f = f || NATIVE.Number;
        function _range(value, strict) {
          return f(value, strict) && value > a && value < b;
        }
        _range.toJSON = function() {
          return `${f.toJSON()} between [${a}, ${b}]`;
        };
        return _range;
      }
      var INT53_MAX = Math.pow(2, 53) - 1;
      function Finite(value) {
        return typeof value === "number" && isFinite(value);
      }
      function Int8(value) {
        return value << 24 >> 24 === value;
      }
      function Int16(value) {
        return value << 16 >> 16 === value;
      }
      function Int32(value) {
        return (value | 0) === value;
      }
      function Int53(value) {
        return typeof value === "number" && value >= -INT53_MAX && value <= INT53_MAX && Math.floor(value) === value;
      }
      function UInt8(value) {
        return (value & 255) === value;
      }
      function UInt16(value) {
        return (value & 65535) === value;
      }
      function UInt32(value) {
        return value >>> 0 === value;
      }
      function UInt53(value) {
        return typeof value === "number" && value >= 0 && value <= INT53_MAX && Math.floor(value) === value;
      }
      var types2 = {
        ArrayN: _ArrayN,
        Buffer: _Buffer,
        BufferN: _BufferN,
        Finite,
        Hex,
        HexN: _HexN,
        Int8,
        Int16,
        Int32,
        Int53,
        Range,
        StringN: _StringN,
        UInt8,
        UInt16,
        UInt32,
        UInt53
      };
      for (typeName in types2) {
        types2[typeName].toJSON = function(t) {
          return t;
        }.bind(null, typeName);
      }
      var typeName;
      module.exports = types2;
    }
  });

  // node_modules/typeforce/index.js
  var require_typeforce = __commonJS({
    "node_modules/typeforce/index.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var ERRORS = require_errors();
      var NATIVE = require_native();
      var tfJSON = ERRORS.tfJSON;
      var TfTypeError = ERRORS.TfTypeError;
      var TfPropertyTypeError = ERRORS.TfPropertyTypeError;
      var tfSubError = ERRORS.tfSubError;
      var getValueTypeName = ERRORS.getValueTypeName;
      var TYPES = {
        arrayOf: function arrayOf(type, options) {
          type = compile(type);
          options = options || {};
          function _arrayOf(array, strict) {
            if (!NATIVE.Array(array)) return false;
            if (NATIVE.Nil(array)) return false;
            if (options.minLength !== void 0 && array.length < options.minLength) return false;
            if (options.maxLength !== void 0 && array.length > options.maxLength) return false;
            if (options.length !== void 0 && array.length !== options.length) return false;
            return array.every(function(value, i) {
              try {
                return typeforce(type, value, strict);
              } catch (e) {
                throw tfSubError(e, i);
              }
            });
          }
          _arrayOf.toJSON = function() {
            var str = "[" + tfJSON(type) + "]";
            if (options.length !== void 0) {
              str += "{" + options.length + "}";
            } else if (options.minLength !== void 0 || options.maxLength !== void 0) {
              str += "{" + (options.minLength === void 0 ? 0 : options.minLength) + "," + (options.maxLength === void 0 ? Infinity : options.maxLength) + "}";
            }
            return str;
          };
          return _arrayOf;
        },
        maybe: function maybe(type) {
          type = compile(type);
          function _maybe(value, strict) {
            return NATIVE.Nil(value) || type(value, strict, maybe);
          }
          _maybe.toJSON = function() {
            return "?" + tfJSON(type);
          };
          return _maybe;
        },
        map: function map(propertyType, propertyKeyType) {
          propertyType = compile(propertyType);
          if (propertyKeyType) propertyKeyType = compile(propertyKeyType);
          function _map(value, strict) {
            if (!NATIVE.Object(value)) return false;
            if (NATIVE.Nil(value)) return false;
            for (var propertyName in value) {
              try {
                if (propertyKeyType) {
                  typeforce(propertyKeyType, propertyName, strict);
                }
              } catch (e) {
                throw tfSubError(e, propertyName, "key");
              }
              try {
                var propertyValue = value[propertyName];
                typeforce(propertyType, propertyValue, strict);
              } catch (e) {
                throw tfSubError(e, propertyName);
              }
            }
            return true;
          }
          if (propertyKeyType) {
            _map.toJSON = function() {
              return "{" + tfJSON(propertyKeyType) + ": " + tfJSON(propertyType) + "}";
            };
          } else {
            _map.toJSON = function() {
              return "{" + tfJSON(propertyType) + "}";
            };
          }
          return _map;
        },
        object: function object(uncompiled) {
          var type = {};
          for (var typePropertyName in uncompiled) {
            type[typePropertyName] = compile(uncompiled[typePropertyName]);
          }
          function _object(value, strict) {
            if (!NATIVE.Object(value)) return false;
            if (NATIVE.Nil(value)) return false;
            var propertyName;
            try {
              for (propertyName in type) {
                var propertyType = type[propertyName];
                var propertyValue = value[propertyName];
                typeforce(propertyType, propertyValue, strict);
              }
            } catch (e) {
              throw tfSubError(e, propertyName);
            }
            if (strict) {
              for (propertyName in value) {
                if (type[propertyName]) continue;
                throw new TfPropertyTypeError(void 0, propertyName);
              }
            }
            return true;
          }
          _object.toJSON = function() {
            return tfJSON(type);
          };
          return _object;
        },
        anyOf: function anyOf() {
          var types2 = [].slice.call(arguments).map(compile);
          function _anyOf(value, strict) {
            return types2.some(function(type) {
              try {
                return typeforce(type, value, strict);
              } catch (e) {
                return false;
              }
            });
          }
          _anyOf.toJSON = function() {
            return types2.map(tfJSON).join("|");
          };
          return _anyOf;
        },
        allOf: function allOf() {
          var types2 = [].slice.call(arguments).map(compile);
          function _allOf(value, strict) {
            return types2.every(function(type) {
              try {
                return typeforce(type, value, strict);
              } catch (e) {
                return false;
              }
            });
          }
          _allOf.toJSON = function() {
            return types2.map(tfJSON).join(" & ");
          };
          return _allOf;
        },
        quacksLike: function quacksLike(type) {
          function _quacksLike(value) {
            return type === getValueTypeName(value);
          }
          _quacksLike.toJSON = function() {
            return type;
          };
          return _quacksLike;
        },
        tuple: function tuple() {
          var types2 = [].slice.call(arguments).map(compile);
          function _tuple(values, strict) {
            if (NATIVE.Nil(values)) return false;
            if (NATIVE.Nil(values.length)) return false;
            if (strict && values.length !== types2.length) return false;
            return types2.every(function(type, i) {
              try {
                return typeforce(type, values[i], strict);
              } catch (e) {
                throw tfSubError(e, i);
              }
            });
          }
          _tuple.toJSON = function() {
            return "(" + types2.map(tfJSON).join(", ") + ")";
          };
          return _tuple;
        },
        value: function value(expected) {
          function _value(actual) {
            return actual === expected;
          }
          _value.toJSON = function() {
            return expected;
          };
          return _value;
        }
      };
      TYPES.oneOf = TYPES.anyOf;
      function compile(type) {
        if (NATIVE.String(type)) {
          if (type[0] === "?") return TYPES.maybe(type.slice(1));
          return NATIVE[type] || TYPES.quacksLike(type);
        } else if (type && NATIVE.Object(type)) {
          if (NATIVE.Array(type)) {
            if (type.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
            return TYPES.arrayOf(type[0]);
          }
          return TYPES.object(type);
        } else if (NATIVE.Function(type)) {
          return type;
        }
        return TYPES.value(type);
      }
      function typeforce(type, value, strict, surrogate) {
        if (NATIVE.Function(type)) {
          if (type(value, strict)) return true;
          throw new TfTypeError(surrogate || type, value);
        }
        return typeforce(compile(type), value, strict);
      }
      for (typeName in NATIVE) {
        typeforce[typeName] = NATIVE[typeName];
      }
      var typeName;
      for (typeName in TYPES) {
        typeforce[typeName] = TYPES[typeName];
      }
      var EXTRA = require_extra();
      for (typeName in EXTRA) {
        typeforce[typeName] = EXTRA[typeName];
      }
      typeforce.compile = compile;
      typeforce.TfTypeError = TfTypeError;
      typeforce.TfPropertyTypeError = TfPropertyTypeError;
      module.exports = typeforce;
    }
  });

  // node_modules/bitcoinjs-lib/src/types.js
  var require_types = __commonJS({
    "node_modules/bitcoinjs-lib/src/types.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.oneOf = exports9.Null = exports9.BufferN = exports9.Function = exports9.UInt32 = exports9.UInt8 = exports9.tuple = exports9.maybe = exports9.Hex = exports9.Buffer = exports9.String = exports9.Boolean = exports9.Array = exports9.Number = exports9.Hash256bit = exports9.Hash160bit = exports9.Buffer256bit = exports9.isTaptree = exports9.isTapleaf = exports9.TAPLEAF_VERSION_MASK = exports9.Satoshi = exports9.isPoint = exports9.stacksEqual = exports9.typeforce = void 0;
      var buffer_1 = (init_buffer(), __toCommonJS(buffer_exports));
      exports9.typeforce = require_typeforce();
      var ZERO32 = buffer_1.Buffer.alloc(32, 0);
      var EC_P = buffer_1.Buffer.from(
        "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
        "hex"
      );
      function stacksEqual(a, b) {
        if (a.length !== b.length) return false;
        return a.every((x, i) => {
          return x.equals(b[i]);
        });
      }
      exports9.stacksEqual = stacksEqual;
      function isPoint4(p) {
  console.log('isPoint4 called with:', p);

  // Check if p is a Buffer
  if (!buffer_1.Buffer.isBuffer(p)) {

    
    debugger;
    console.log('FAILED: p is not a Buffer. p type:', typeof p);
    return false;
  }

  // Check minimum length
  if (p.length < 33) {
    console.log(`FAILED: p.length < 33 (actual length: ${p.length})`);
    return false;
  }

  const t = p[0];
  console.log('First byte (t):', t);

  const x = p.slice(1, 33);
  console.log('x:', x);

  // x must not be zero
  if (x.compare(ZERO32) === 0) {
    console.log('FAILED: x is ZERO32');
    return false;
  }

  // x must be < EC_P
  if (x.compare(EC_P) >= 0) {
    console.log('FAILED: x >= EC_P');
    return false;
  }

  // Compressed key check (0x02 or 0x03, 33 bytes total)
  if ((t === 2 || t === 3) && p.length === 33) {
    console.log('SUCCESS: Compressed pubkey format');
    return true;
  }

  // For uncompressed or hybrid key, check y
  const y = p.slice(33);
  console.log('y:', y);

  // y must not be zero
  if (y.compare(ZERO32) === 0) {
    console.log('FAILED: y is ZERO32');
    return false;
  }

  // y must be < EC_P
  if (y.compare(EC_P) >= 0) {
    console.log('FAILED: y >= EC_P');
    return false;
  }

  // Uncompressed key check (0x04, 65 bytes total)
  if (t === 4 && p.length === 65) {
    console.log('SUCCESS: Uncompressed pubkey format');
    return true;
  }

  // If none of the above checks pass
  console.log('FAILED: Not a recognized point format');
  return false;
}

      exports9.isPoint = isPoint4;
      var SATOSHI_MAX = 21 * 1e14;
      function Satoshi(value) {
        return exports9.typeforce.UInt53(value) && value <= SATOSHI_MAX;
      }
      exports9.Satoshi = Satoshi;
      exports9.TAPLEAF_VERSION_MASK = 254;
      function isTapleaf(o) {
        if (!o || !("output" in o)) return false;
        if (!buffer_1.Buffer.isBuffer(o.output)) return false;
        if (o.version !== void 0)
          return (o.version & exports9.TAPLEAF_VERSION_MASK) === o.version;
        return true;
      }
      exports9.isTapleaf = isTapleaf;
      function isTaptree(scriptTree) {
        if (!(0, exports9.Array)(scriptTree)) return isTapleaf(scriptTree);
        if (scriptTree.length !== 2) return false;
        return scriptTree.every((t) => isTaptree(t));
      }
      exports9.isTaptree = isTaptree;
      exports9.Buffer256bit = exports9.typeforce.BufferN(32);
      exports9.Hash160bit = exports9.typeforce.BufferN(20);
      exports9.Hash256bit = exports9.typeforce.BufferN(32);
      exports9.Number = exports9.typeforce.Number;
      exports9.Array = exports9.typeforce.Array;
      exports9.Boolean = exports9.typeforce.Boolean;
      exports9.String = exports9.typeforce.String;
      exports9.Buffer = exports9.typeforce.Buffer;
      exports9.Hex = exports9.typeforce.Hex;
      exports9.maybe = exports9.typeforce.maybe;
      exports9.tuple = exports9.typeforce.tuple;
      exports9.UInt8 = exports9.typeforce.UInt8;
      exports9.UInt32 = exports9.typeforce.UInt32;
      exports9.Function = exports9.typeforce.Function;
      exports9.BufferN = exports9.typeforce.BufferN;
      exports9.Null = exports9.typeforce.Null;
      exports9.oneOf = exports9.typeforce.oneOf;
    }
  });

  // node_modules/bitcoinjs-lib/src/script_signature.js
  var require_script_signature = __commonJS({
    "node_modules/bitcoinjs-lib/src/script_signature.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.encode = exports9.decode = void 0;
      var bip66 = require_bip66();
      var script_1 = require_script();
      var types2 = require_types();
      var { typeforce } = types2;
      var ZERO = Buffer2.alloc(1, 0);
      function toDER(x) {
        let i = 0;
        while (x[i] === 0) ++i;
        if (i === x.length) return ZERO;
        x = x.slice(i);
        if (x[0] & 128) return Buffer2.concat([ZERO, x], 1 + x.length);
        return x;
      }
      function fromDER(x) {
        if (x[0] === 0) x = x.slice(1);
        const buffer = Buffer2.alloc(32, 0);
        const bstart = Math.max(0, 32 - x.length);
        x.copy(buffer, bstart);
        return buffer;
      }
      function decode(buffer) {
        const hashType = buffer.readUInt8(buffer.length - 1);
        if (!(0, script_1.isDefinedHashType)(hashType)) {
          throw new Error("Invalid hashType " + hashType);
        }
        const decoded = bip66.decode(buffer.slice(0, -1));
        const r = fromDER(decoded.r);
        const s = fromDER(decoded.s);
        const signature = Buffer2.concat([r, s], 64);
        return { signature, hashType };
      }
      exports9.decode = decode;
      function encode(signature, hashType) {
        typeforce(
          {
            signature: types2.BufferN(64),
            hashType: types2.UInt8
          },
          { signature, hashType }
        );
        if (!(0, script_1.isDefinedHashType)(hashType)) {
          throw new Error("Invalid hashType " + hashType);
        }
        const hashTypeBuffer = Buffer2.allocUnsafe(1);
        hashTypeBuffer.writeUInt8(hashType, 0);
        const r = toDER(signature.slice(0, 32));
        const s = toDER(signature.slice(32, 64));
        return Buffer2.concat([bip66.encode(r, s), hashTypeBuffer]);
      }
      exports9.encode = encode;
    }
  });

  // node_modules/bitcoinjs-lib/src/script.js
  var require_script = __commonJS({
    "node_modules/bitcoinjs-lib/src/script.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.signature = exports9.number = exports9.isCanonicalScriptSignature = exports9.isDefinedHashType = exports9.isCanonicalPubKey = exports9.toStack = exports9.fromASM = exports9.toASM = exports9.decompile = exports9.compile = exports9.countNonPushOnlyOPs = exports9.isPushOnly = exports9.OPS = void 0;
      var bip66 = require_bip66();
      var ops_1 = require_ops();
      Object.defineProperty(exports9, "OPS", {
        enumerable: true,
        get: function() {
          return ops_1.OPS;
        }
      });
      var pushdata = require_push_data();
      var scriptNumber = require_script_number();
      var scriptSignature = require_script_signature();
      var types2 = require_types();
      var { typeforce } = types2;
      var OP_INT_BASE = ops_1.OPS.OP_RESERVED;
      function isOPInt(value) {
        return types2.Number(value) && (value === ops_1.OPS.OP_0 || value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16 || value === ops_1.OPS.OP_1NEGATE);
      }
      function isPushOnlyChunk(value) {
        return types2.Buffer(value) || isOPInt(value);
      }
      function isPushOnly(value) {
        return types2.Array(value) && value.every(isPushOnlyChunk);
      }
      exports9.isPushOnly = isPushOnly;
      function countNonPushOnlyOPs(value) {
        return value.length - value.filter(isPushOnlyChunk).length;
      }
      exports9.countNonPushOnlyOPs = countNonPushOnlyOPs;
      function asMinimalOP(buffer) {
        if (buffer.length === 0) return ops_1.OPS.OP_0;
        if (buffer.length !== 1) return;
        if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];
        if (buffer[0] === 129) return ops_1.OPS.OP_1NEGATE;
      }
      function chunksIsBuffer(buf) {
        return Buffer2.isBuffer(buf);
      }
      function chunksIsArray(buf) {
        return types2.Array(buf);
      }
      function singleChunkIsBuffer(buf) {
        return Buffer2.isBuffer(buf);
      }
      function compile(chunks) {
        if (chunksIsBuffer(chunks)) return chunks;
        typeforce(types2.Array, chunks);
        const bufferSize = chunks.reduce((accum, chunk) => {
          if (singleChunkIsBuffer(chunk)) {
            if (chunk.length === 1 && asMinimalOP(chunk) !== void 0) {
              return accum + 1;
            }
            return accum + pushdata.encodingLength(chunk.length) + chunk.length;
          }
          return accum + 1;
        }, 0);
        const buffer = Buffer2.allocUnsafe(bufferSize);
        let offset = 0;
        chunks.forEach((chunk) => {
          if (singleChunkIsBuffer(chunk)) {
            const opcode = asMinimalOP(chunk);
            if (opcode !== void 0) {
              buffer.writeUInt8(opcode, offset);
              offset += 1;
              return;
            }
            offset += pushdata.encode(buffer, chunk.length, offset);
            chunk.copy(buffer, offset);
            offset += chunk.length;
          } else {
            buffer.writeUInt8(chunk, offset);
            offset += 1;
          }
        });
        if (offset !== buffer.length) throw new Error("Could not decode chunks");
        return buffer;
      }
      exports9.compile = compile;
      function decompile(buffer) {
        if (chunksIsArray(buffer)) return buffer;
        typeforce(types2.Buffer, buffer);
        const chunks = [];
        let i = 0;
        while (i < buffer.length) {
          const opcode = buffer[i];
          if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {
            const d = pushdata.decode(buffer, i);
            if (d === null) return null;
            i += d.size;
            if (i + d.number > buffer.length) return null;
            const data = buffer.slice(i, i + d.number);
            i += d.number;
            const op = asMinimalOP(data);
            if (op !== void 0) {
              chunks.push(op);
            } else {
              chunks.push(data);
            }
          } else {
            chunks.push(opcode);
            i += 1;
          }
        }
        return chunks;
      }
      exports9.decompile = decompile;
      function toASM(chunks) {
        if (chunksIsBuffer(chunks)) {
          chunks = decompile(chunks);
        }
        if (!chunks) {
          throw new Error("Could not convert invalid chunks to ASM");
        }
        return chunks.map((chunk) => {
          if (singleChunkIsBuffer(chunk)) {
            const op = asMinimalOP(chunk);
            if (op === void 0) return chunk.toString("hex");
            chunk = op;
          }
          return ops_1.REVERSE_OPS[chunk];
        }).join(" ");
      }
      exports9.toASM = toASM;
      function fromASM(asm) {
        typeforce(types2.String, asm);
        return compile(
          asm.split(" ").map((chunkStr) => {
            if (ops_1.OPS[chunkStr] !== void 0) return ops_1.OPS[chunkStr];
            typeforce(types2.Hex, chunkStr);
            return Buffer2.from(chunkStr, "hex");
          })
        );
      }
      exports9.fromASM = fromASM;
      function toStack(chunks) {
        chunks = decompile(chunks);
        typeforce(isPushOnly, chunks);
        return chunks.map((op) => {
          if (singleChunkIsBuffer(op)) return op;
          if (op === ops_1.OPS.OP_0) return Buffer2.allocUnsafe(0);
          return scriptNumber.encode(op - OP_INT_BASE);
        });
      }
      exports9.toStack = toStack;
      function isCanonicalPubKey(buffer) {
        return types2.isPoint(buffer);
      }
      exports9.isCanonicalPubKey = isCanonicalPubKey;
      function isDefinedHashType(hashType) {
        const hashTypeMod = hashType & ~128;
        return hashTypeMod > 0 && hashTypeMod < 4;
      }
      exports9.isDefinedHashType = isDefinedHashType;
      function isCanonicalScriptSignature(buffer) {
        if (!Buffer2.isBuffer(buffer)) return false;
        if (!isDefinedHashType(buffer[buffer.length - 1])) return false;
        return bip66.check(buffer.slice(0, -1));
      }
      exports9.isCanonicalScriptSignature = isCanonicalScriptSignature;
      exports9.number = scriptNumber;
      exports9.signature = scriptSignature;
    }
  });

  // node_modules/bitcoinjs-lib/src/payments/lazy.js
  var require_lazy = __commonJS({
    "node_modules/bitcoinjs-lib/src/payments/lazy.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.value = exports9.prop = void 0;
      function prop(object, name2, f) {
        Object.defineProperty(object, name2, {
          configurable: true,
          enumerable: true,
          get() {
            const _value = f.call(this);
            this[name2] = _value;
            return _value;
          },
          set(_value) {
            Object.defineProperty(this, name2, {
              configurable: true,
              enumerable: true,
              value: _value,
              writable: true
            });
          }
        });
      }
      exports9.prop = prop;
      function value(f) {
        let _value;
        return () => {
          if (_value !== void 0) return _value;
          _value = f();
          return _value;
        };
      }
      exports9.value = value;
    }
  });

  // node_modules/bitcoinjs-lib/src/payments/embed.js
  var require_embed = __commonJS({
    "node_modules/bitcoinjs-lib/src/payments/embed.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.p2data = void 0;
      var networks_1 = require_networks();
      var bscript = require_script();
      var types_1 = require_types();
      var lazy = require_lazy();
      var OPS = bscript.OPS;
      function p2data(a, opts) {
        if (!a.data && !a.output) throw new TypeError("Not enough data");
        opts = Object.assign({ validate: true }, opts || {});
        (0, types_1.typeforce)(
          {
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            data: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          },
          a
        );
        const network = a.network || networks_1.bitcoin;
        const o = { name: "embed", network };
        lazy.prop(o, "output", () => {
          if (!a.data) return;
          return bscript.compile([OPS.OP_RETURN].concat(a.data));
        });
        lazy.prop(o, "data", () => {
          if (!a.output) return;
          return bscript.decompile(a.output).slice(1);
        });
        if (opts.validate) {
          if (a.output) {
            const chunks = bscript.decompile(a.output);
            if (chunks[0] !== OPS.OP_RETURN) throw new TypeError("Output is invalid");
            if (!chunks.slice(1).every(types_1.typeforce.Buffer))
              throw new TypeError("Output is invalid");
            if (a.data && !(0, types_1.stacksEqual)(a.data, o.data))
              throw new TypeError("Data mismatch");
          }
        }
        return Object.assign(o, a);
      }
      exports9.p2data = p2data;
    }
  });

  // node_modules/bitcoinjs-lib/src/payments/p2ms.js
  var require_p2ms = __commonJS({
    "node_modules/bitcoinjs-lib/src/payments/p2ms.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.p2ms = void 0;
      var networks_1 = require_networks();
      var bscript = require_script();
      var types_1 = require_types();
      var lazy = require_lazy();
      var OPS = bscript.OPS;
      var OP_INT_BASE = OPS.OP_RESERVED;
      function p2ms(a, opts) {
        if (!a.input && !a.output && !(a.pubkeys && a.m !== void 0) && !a.signatures)
          throw new TypeError("Not enough data");
        opts = Object.assign({ validate: true }, opts || {});
        function isAcceptableSignature(x) {
          return bscript.isCanonicalScriptSignature(x) || (opts.allowIncomplete && x === OPS.OP_0) !== void 0;
        }
        (0, types_1.typeforce)(
          {
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            m: types_1.typeforce.maybe(types_1.typeforce.Number),
            n: types_1.typeforce.maybe(types_1.typeforce.Number),
            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            pubkeys: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.isPoint)
            ),
            signatures: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(isAcceptableSignature)
            ),
            input: types_1.typeforce.maybe(types_1.typeforce.Buffer)
          },
          a
        );
        const network = a.network || networks_1.bitcoin;
        const o = { network };
        let chunks = [];
        let decoded = false;
        function decode(output) {
          if (decoded) return;
          decoded = true;
          chunks = bscript.decompile(output);
          o.m = chunks[0] - OP_INT_BASE;
          o.n = chunks[chunks.length - 2] - OP_INT_BASE;
          o.pubkeys = chunks.slice(1, -2);
        }
        lazy.prop(o, "output", () => {
          if (!a.m) return;
          if (!o.n) return;
          if (!a.pubkeys) return;
          return bscript.compile(
            [].concat(
              OP_INT_BASE + a.m,
              a.pubkeys,
              OP_INT_BASE + o.n,
              OPS.OP_CHECKMULTISIG
            )
          );
        });
        lazy.prop(o, "m", () => {
          if (!o.output) return;
          decode(o.output);
          return o.m;
        });
        lazy.prop(o, "n", () => {
          if (!o.pubkeys) return;
          return o.pubkeys.length;
        });
        lazy.prop(o, "pubkeys", () => {
          if (!a.output) return;
          decode(a.output);
          return o.pubkeys;
        });
        lazy.prop(o, "signatures", () => {
          if (!a.input) return;
          return bscript.decompile(a.input).slice(1);
        });
        lazy.prop(o, "input", () => {
          if (!a.signatures) return;
          return bscript.compile([OPS.OP_0].concat(a.signatures));
        });
        lazy.prop(o, "witness", () => {
          if (!o.input) return;
          return [];
        });
        lazy.prop(o, "name", () => {
          if (!o.m || !o.n) return;
          return `p2ms(${o.m} of ${o.n})`;
        });
        if (opts.validate) {
          if (a.output) {
            decode(a.output);
            if (!types_1.typeforce.Number(chunks[0]))
              throw new TypeError("Output is invalid");
            if (!types_1.typeforce.Number(chunks[chunks.length - 2]))
              throw new TypeError("Output is invalid");
            if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)
              throw new TypeError("Output is invalid");
            if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)
              throw new TypeError("Output is invalid");
            if (!o.pubkeys.every((x) => (0, types_1.isPoint)(x)))
              throw new TypeError("Output is invalid");
            if (a.m !== void 0 && a.m !== o.m) throw new TypeError("m mismatch");
            if (a.n !== void 0 && a.n !== o.n) throw new TypeError("n mismatch");
            if (a.pubkeys && !(0, types_1.stacksEqual)(a.pubkeys, o.pubkeys))
              throw new TypeError("Pubkeys mismatch");
          }
          if (a.pubkeys) {
            if (a.n !== void 0 && a.n !== a.pubkeys.length)
              throw new TypeError("Pubkey count mismatch");
            o.n = a.pubkeys.length;
            if (o.n < o.m) throw new TypeError("Pubkey count cannot be less than m");
          }
          if (a.signatures) {
            if (a.signatures.length < o.m)
              throw new TypeError("Not enough signatures provided");
            if (a.signatures.length > o.m)
              throw new TypeError("Too many signatures provided");
          }
          if (a.input) {
            if (a.input[0] !== OPS.OP_0) throw new TypeError("Input is invalid");
            if (o.signatures.length === 0 || !o.signatures.every(isAcceptableSignature))
              throw new TypeError("Input has invalid signature(s)");
            if (a.signatures && !(0, types_1.stacksEqual)(a.signatures, o.signatures))
              throw new TypeError("Signature mismatch");
            if (a.m !== void 0 && a.m !== a.signatures.length)
              throw new TypeError("Signature count mismatch");
          }
        }
        return Object.assign(o, a);
      }
      exports9.p2ms = p2ms;
    }
  });

  // node_modules/bitcoinjs-lib/src/payments/p2pk.js
  var require_p2pk = __commonJS({
    "node_modules/bitcoinjs-lib/src/payments/p2pk.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.p2pk = void 0;
      var networks_1 = require_networks();
      var bscript = require_script();
      var types_1 = require_types();
      var lazy = require_lazy();
      var OPS = bscript.OPS;
      function p2pk(a, opts) {
        if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)
          throw new TypeError("Not enough data");
        opts = Object.assign({ validate: true }, opts || {});
        (0, types_1.typeforce)(
          {
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            pubkey: types_1.typeforce.maybe(types_1.isPoint),
            signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
            input: types_1.typeforce.maybe(types_1.typeforce.Buffer)
          },
          a
        );
        const _chunks = lazy.value(() => {
          return bscript.decompile(a.input);
        });
        const network = a.network || networks_1.bitcoin;
        const o = { name: "p2pk", network };
        lazy.prop(o, "output", () => {
          if (!a.pubkey) return;
          return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);
        });
        lazy.prop(o, "pubkey", () => {
          if (!a.output) return;
          return a.output.slice(1, -1);
        });
        lazy.prop(o, "signature", () => {
          if (!a.input) return;
          return _chunks()[0];
        });
        lazy.prop(o, "input", () => {
          if (!a.signature) return;
          return bscript.compile([a.signature]);
        });
        lazy.prop(o, "witness", () => {
          if (!o.input) return;
          return [];
        });
        if (opts.validate) {
          if (a.output) {
            if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)
              throw new TypeError("Output is invalid");
            if (!(0, types_1.isPoint)(o.pubkey))
              throw new TypeError("Output pubkey is invalid");
            if (a.pubkey && !a.pubkey.equals(o.pubkey))
              throw new TypeError("Pubkey mismatch");
          }
          if (a.signature) {
            if (a.input && !a.input.equals(o.input))
              throw new TypeError("Signature mismatch");
          }
          if (a.input) {
            if (_chunks().length !== 1) throw new TypeError("Input is invalid");
            if (!bscript.isCanonicalScriptSignature(o.signature))
              throw new TypeError("Input has invalid signature");
          }
        }
        return Object.assign(o, a);
      }
      exports9.p2pk = p2pk;
    }
  });

  // node_modules/@noble/hashes/_assert.js
  var require_assert = __commonJS({
    "node_modules/@noble/hashes/_assert.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.isBytes = isBytes;
      exports9.number = number;
      exports9.bool = bool;
      exports9.bytes = bytes;
      exports9.hash = hash;
      exports9.exists = exists;
      exports9.output = output;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`positive integer expected, not ${n}`);
      }
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`boolean expected, not ${b}`);
      }
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      function bytes(b, ...lengths) {
        if (!isBytes(b))
          throw new Error("Uint8Array expected");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
      }
      function hash(h) {
        if (typeof h !== "function" || typeof h.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(h.outputLen);
        number(h.blockLen);
      }
      function exists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      function output(out, instance) {
        bytes(out);
        const min = instance.outputLen;
        if (out.length < min) {
          throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
      }
      var assert2 = { number, bool, bytes, hash, exists, output };
      exports9.default = assert2;
    }
  });

  // node_modules/@noble/hashes/crypto.js
  var require_crypto = __commonJS({
    "node_modules/@noble/hashes/crypto.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.crypto = void 0;
      exports9.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@noble/hashes/utils.js
  var require_utils = __commonJS({
    "node_modules/@noble/hashes/utils.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.Hash = exports9.nextTick = exports9.byteSwapIfBE = exports9.byteSwap = exports9.isLE = exports9.rotl = exports9.rotr = exports9.createView = exports9.u32 = exports9.u8 = void 0;
      exports9.isBytes = isBytes;
      exports9.byteSwap32 = byteSwap32;
      exports9.bytesToHex = bytesToHex;
      exports9.hexToBytes = hexToBytes;
      exports9.asyncLoop = asyncLoop;
      exports9.utf8ToBytes = utf8ToBytes;
      exports9.toBytes = toBytes;
      exports9.concatBytes = concatBytes;
      exports9.checkOpts = checkOpts;
      exports9.wrapConstructor = wrapConstructor;
      exports9.wrapConstructorWithOpts = wrapConstructorWithOpts;
      exports9.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      exports9.randomBytes = randomBytes;
      var crypto_1 = require_crypto();
      var _assert_js_1 = require_assert();
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports9.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports9.u32 = u32;
      var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports9.createView = createView;
      var rotr = (word, shift) => word << 32 - shift | word >>> shift;
      exports9.rotr = rotr;
      var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
      exports9.rotl = rotl;
      exports9.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
      exports9.byteSwap = byteSwap;
      exports9.byteSwapIfBE = exports9.isLE ? (n) => n : (n) => (0, exports9.byteSwap)(n);
      function byteSwap32(arr) {
        for (let i = 0; i < arr.length; i++) {
          arr[i] = (0, exports9.byteSwap)(arr[i]);
        }
      }
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        (0, _assert_js_1.bytes)(bytes);
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
      function asciiToBase16(char) {
        if (char >= asciis._0 && char <= asciis._9)
          return char - asciis._0;
        if (char >= asciis._A && char <= asciis._F)
          return char - (asciis._A - 10);
        if (char >= asciis._a && char <= asciis._f)
          return char - (asciis._a - 10);
        return;
      }
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
          const n1 = asciiToBase16(hex.charCodeAt(hi));
          const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
          }
          array[ai] = n1 * 16 + n2;
        }
        return array;
      }
      var nextTick2 = async () => {
      };
      exports9.nextTick = nextTick2;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports9.nextTick)();
          ts += diff;
        }
      }
      function utf8ToBytes(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      function toBytes(data) {
        if (typeof data === "string")
          data = utf8ToBytes(data);
        (0, _assert_js_1.bytes)(data);
        return data;
      }
      function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          (0, _assert_js_1.bytes)(a);
          sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad);
          pad += a.length;
        }
        return res;
      }
      var Hash = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports9.Hash = Hash;
      var toStr = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
          return crypto_1.crypto.randomBytes(bytesLength);
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
    }
  });

  // node_modules/@noble/hashes/_md.js
  var require_md = __commonJS({
    "node_modules/@noble/hashes/_md.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.HashMD = exports9.Maj = exports9.Chi = void 0;
      var _assert_js_1 = require_assert();
      var utils_js_1 = require_utils();
      function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      var Chi = (a, b, c) => a & b ^ ~a & c;
      exports9.Chi = Chi;
      var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
      exports9.Maj = Maj;
      var HashMD = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data) {
          (0, _assert_js_1.exists)(this);
          const { view, buffer, blockLen } = this;
          data = (0, utils_js_1.toBytes)(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.output)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished: finished2, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished2;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports9.HashMD = HashMD;
    }
  });

  // node_modules/@noble/hashes/ripemd160.js
  var require_ripemd160 = __commonJS({
    "node_modules/@noble/hashes/ripemd160.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.ripemd160 = exports9.RIPEMD160 = void 0;
      var _md_js_1 = require_md();
      var utils_js_1 = require_utils();
      var Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
      var Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((_, i) => i));
      var Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
      var idxL = [Id];
      var idxR = [Pi];
      for (let i = 0; i < 4; i++)
        for (let j of [idxL, idxR])
          j.push(j[i].map((k) => Rho[k]));
      var shifts = /* @__PURE__ */ [
        [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
        [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
        [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
        [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
        [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
      ].map((i) => new Uint8Array(i));
      var shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
      var shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
      var Kl = /* @__PURE__ */ new Uint32Array([
        0,
        1518500249,
        1859775393,
        2400959708,
        2840853838
      ]);
      var Kr = /* @__PURE__ */ new Uint32Array([
        1352829926,
        1548603684,
        1836072691,
        2053994217,
        0
      ]);
      function f(group, x, y, z) {
        if (group === 0)
          return x ^ y ^ z;
        else if (group === 1)
          return x & y | ~x & z;
        else if (group === 2)
          return (x | ~y) ^ z;
        else if (group === 3)
          return x & z | y & ~z;
        else
          return x ^ (y | ~z);
      }
      var R_BUF = /* @__PURE__ */ new Uint32Array(16);
      var RIPEMD160 = class extends _md_js_1.HashMD {
        constructor() {
          super(64, 20, 8, true);
          this.h0 = 1732584193 | 0;
          this.h1 = 4023233417 | 0;
          this.h2 = 2562383102 | 0;
          this.h3 = 271733878 | 0;
          this.h4 = 3285377520 | 0;
        }
        get() {
          const { h0, h1, h2, h3, h4 } = this;
          return [h0, h1, h2, h3, h4];
        }
        set(h0, h1, h2, h3, h4) {
          this.h0 = h0 | 0;
          this.h1 = h1 | 0;
          this.h2 = h2 | 0;
          this.h3 = h3 | 0;
          this.h4 = h4 | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            R_BUF[i] = view.getUint32(offset, true);
          let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
          for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl[group], hbr = Kr[group];
            const rl = idxL[group], rr = idxR[group];
            const sl = shiftsL[group], sr = shiftsR[group];
            for (let i = 0; i < 16; i++) {
              const tl = (0, utils_js_1.rotl)(al + f(group, bl, cl, dl) + R_BUF[rl[i]] + hbl, sl[i]) + el | 0;
              al = el, el = dl, dl = (0, utils_js_1.rotl)(cl, 10) | 0, cl = bl, bl = tl;
            }
            for (let i = 0; i < 16; i++) {
              const tr = (0, utils_js_1.rotl)(ar + f(rGroup, br, cr, dr) + R_BUF[rr[i]] + hbr, sr[i]) + er | 0;
              ar = er, er = dr, dr = (0, utils_js_1.rotl)(cr, 10) | 0, cr = br, br = tr;
            }
          }
          this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
        }
        roundClean() {
          R_BUF.fill(0);
        }
        destroy() {
          this.destroyed = true;
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0);
        }
      };
      exports9.RIPEMD160 = RIPEMD160;
      exports9.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
    }
  });

  // node_modules/@noble/hashes/sha1.js
  var require_sha1 = __commonJS({
    "node_modules/@noble/hashes/sha1.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.sha1 = exports9.SHA1 = void 0;
      var _md_js_1 = require_md();
      var utils_js_1 = require_utils();
      var SHA1_IV = /* @__PURE__ */ new Uint32Array([
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ]);
      var SHA1_W = /* @__PURE__ */ new Uint32Array(80);
      var SHA1 = class extends _md_js_1.HashMD {
        constructor() {
          super(64, 20, 8, false);
          this.A = SHA1_IV[0] | 0;
          this.B = SHA1_IV[1] | 0;
          this.C = SHA1_IV[2] | 0;
          this.D = SHA1_IV[3] | 0;
          this.E = SHA1_IV[4] | 0;
        }
        get() {
          const { A, B, C, D, E } = this;
          return [A, B, C, D, E];
        }
        set(A, B, C, D, E) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            SHA1_W[i] = view.getUint32(offset, false);
          for (let i = 16; i < 80; i++)
            SHA1_W[i] = (0, utils_js_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
          let { A, B, C, D, E } = this;
          for (let i = 0; i < 80; i++) {
            let F, K;
            if (i < 20) {
              F = (0, _md_js_1.Chi)(B, C, D);
              K = 1518500249;
            } else if (i < 40) {
              F = B ^ C ^ D;
              K = 1859775393;
            } else if (i < 60) {
              F = (0, _md_js_1.Maj)(B, C, D);
              K = 2400959708;
            } else {
              F = B ^ C ^ D;
              K = 3395469782;
            }
            const T = (0, utils_js_1.rotl)(A, 5) + F + E + K + SHA1_W[i] | 0;
            E = D;
            D = C;
            C = (0, utils_js_1.rotl)(B, 30);
            B = A;
            A = T;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          this.set(A, B, C, D, E);
        }
        roundClean() {
          SHA1_W.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      };
      exports9.SHA1 = SHA1;
      exports9.sha1 = (0, utils_js_1.wrapConstructor)(() => new SHA1());
    }
  });

  // node_modules/@noble/hashes/sha256.js
  var require_sha256 = __commonJS({
    "node_modules/@noble/hashes/sha256.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.sha224 = exports9.sha256 = exports9.SHA256 = void 0;
      var _md_js_1 = require_md();
      var utils_js_1 = require_utils();
      var SHA256_K = /* @__PURE__ */ new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      var SHA256_IV = /* @__PURE__ */ new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
      var SHA256 = class extends _md_js_1.HashMD {
        constructor() {
          super(64, 32, 8, false);
          this.A = SHA256_IV[0] | 0;
          this.B = SHA256_IV[1] | 0;
          this.C = SHA256_IV[2] | 0;
          this.D = SHA256_IV[3] | 0;
          this.E = SHA256_IV[4] | 0;
          this.F = SHA256_IV[5] | 0;
          this.G = SHA256_IV[6] | 0;
          this.H = SHA256_IV[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = sigma0 + (0, _md_js_1.Maj)(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          SHA256_W.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      };
      exports9.SHA256 = SHA256;
      var SHA224 = class extends SHA256 {
        constructor() {
          super();
          this.A = 3238371032 | 0;
          this.B = 914150663 | 0;
          this.C = 812702999 | 0;
          this.D = 4144912697 | 0;
          this.E = 4290775857 | 0;
          this.F = 1750603025 | 0;
          this.G = 1694076839 | 0;
          this.H = 3204075428 | 0;
          this.outputLen = 28;
        }
      };
      exports9.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
      exports9.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
    }
  });

  // node_modules/bitcoinjs-lib/src/crypto.js
  var require_crypto2 = __commonJS({
    "node_modules/bitcoinjs-lib/src/crypto.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.taggedHash = exports9.TAGGED_HASH_PREFIXES = exports9.TAGS = exports9.hash256 = exports9.hash160 = exports9.sha256 = exports9.sha1 = exports9.ripemd160 = void 0;
      var ripemd160_1 = require_ripemd160();
      var sha1_1 = require_sha1();
      var sha256_1 = require_sha256();
      function ripemd160(buffer) {
        return Buffer2.from((0, ripemd160_1.ripemd160)(Uint8Array.from(buffer)));
      }
      exports9.ripemd160 = ripemd160;
      function sha1(buffer) {
        return Buffer2.from((0, sha1_1.sha1)(Uint8Array.from(buffer)));
      }
      exports9.sha1 = sha1;
      function sha256(buffer) {
        return Buffer2.from((0, sha256_1.sha256)(Uint8Array.from(buffer)));
      }
      exports9.sha256 = sha256;
      function hash160(buffer) {
        return Buffer2.from(
          (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(Uint8Array.from(buffer)))
        );
      }
      exports9.hash160 = hash160;
      function hash256(buffer) {
        return Buffer2.from(
          (0, sha256_1.sha256)((0, sha256_1.sha256)(Uint8Array.from(buffer)))
        );
      }
      exports9.hash256 = hash256;
      exports9.TAGS = [
        "BIP0340/challenge",
        "BIP0340/aux",
        "BIP0340/nonce",
        "TapLeaf",
        "TapBranch",
        "TapSighash",
        "TapTweak",
        "KeyAgg list",
        "KeyAgg coefficient"
      ];
      exports9.TAGGED_HASH_PREFIXES = {
        "BIP0340/challenge": Buffer2.from([
          123,
          181,
          45,
          122,
          159,
          239,
          88,
          50,
          62,
          177,
          191,
          122,
          64,
          125,
          179,
          130,
          210,
          243,
          242,
          216,
          27,
          177,
          34,
          79,
          73,
          254,
          81,
          143,
          109,
          72,
          211,
          124,
          123,
          181,
          45,
          122,
          159,
          239,
          88,
          50,
          62,
          177,
          191,
          122,
          64,
          125,
          179,
          130,
          210,
          243,
          242,
          216,
          27,
          177,
          34,
          79,
          73,
          254,
          81,
          143,
          109,
          72,
          211,
          124
        ]),
        "BIP0340/aux": Buffer2.from([
          241,
          239,
          78,
          94,
          192,
          99,
          202,
          218,
          109,
          148,
          202,
          250,
          157,
          152,
          126,
          160,
          105,
          38,
          88,
          57,
          236,
          193,
          31,
          151,
          45,
          119,
          165,
          46,
          216,
          193,
          204,
          144,
          241,
          239,
          78,
          94,
          192,
          99,
          202,
          218,
          109,
          148,
          202,
          250,
          157,
          152,
          126,
          160,
          105,
          38,
          88,
          57,
          236,
          193,
          31,
          151,
          45,
          119,
          165,
          46,
          216,
          193,
          204,
          144
        ]),
        "BIP0340/nonce": Buffer2.from([
          7,
          73,
          119,
          52,
          167,
          155,
          203,
          53,
          91,
          155,
          140,
          125,
          3,
          79,
          18,
          28,
          244,
          52,
          215,
          62,
          247,
          45,
          218,
          25,
          135,
          0,
          97,
          251,
          82,
          191,
          235,
          47,
          7,
          73,
          119,
          52,
          167,
          155,
          203,
          53,
          91,
          155,
          140,
          125,
          3,
          79,
          18,
          28,
          244,
          52,
          215,
          62,
          247,
          45,
          218,
          25,
          135,
          0,
          97,
          251,
          82,
          191,
          235,
          47
        ]),
        TapLeaf: Buffer2.from([
          174,
          234,
          143,
          220,
          66,
          8,
          152,
          49,
          5,
          115,
          75,
          88,
          8,
          29,
          30,
          38,
          56,
          211,
          95,
          28,
          181,
          64,
          8,
          212,
          211,
          87,
          202,
          3,
          190,
          120,
          233,
          238,
          174,
          234,
          143,
          220,
          66,
          8,
          152,
          49,
          5,
          115,
          75,
          88,
          8,
          29,
          30,
          38,
          56,
          211,
          95,
          28,
          181,
          64,
          8,
          212,
          211,
          87,
          202,
          3,
          190,
          120,
          233,
          238
        ]),
        TapBranch: Buffer2.from([
          25,
          65,
          161,
          242,
          229,
          110,
          185,
          95,
          162,
          169,
          241,
          148,
          190,
          92,
          1,
          247,
          33,
          111,
          51,
          237,
          130,
          176,
          145,
          70,
          52,
          144,
          208,
          91,
          245,
          22,
          160,
          21,
          25,
          65,
          161,
          242,
          229,
          110,
          185,
          95,
          162,
          169,
          241,
          148,
          190,
          92,
          1,
          247,
          33,
          111,
          51,
          237,
          130,
          176,
          145,
          70,
          52,
          144,
          208,
          91,
          245,
          22,
          160,
          21
        ]),
        TapSighash: Buffer2.from([
          244,
          10,
          72,
          223,
          75,
          42,
          112,
          200,
          180,
          146,
          75,
          242,
          101,
          70,
          97,
          237,
          61,
          149,
          253,
          102,
          163,
          19,
          235,
          135,
          35,
          117,
          151,
          198,
          40,
          228,
          160,
          49,
          244,
          10,
          72,
          223,
          75,
          42,
          112,
          200,
          180,
          146,
          75,
          242,
          101,
          70,
          97,
          237,
          61,
          149,
          253,
          102,
          163,
          19,
          235,
          135,
          35,
          117,
          151,
          198,
          40,
          228,
          160,
          49
        ]),
        TapTweak: Buffer2.from([
          232,
          15,
          225,
          99,
          156,
          156,
          160,
          80,
          227,
          175,
          27,
          57,
          193,
          67,
          198,
          62,
          66,
          156,
          188,
          235,
          21,
          217,
          64,
          251,
          181,
          197,
          161,
          244,
          175,
          87,
          197,
          233,
          232,
          15,
          225,
          99,
          156,
          156,
          160,
          80,
          227,
          175,
          27,
          57,
          193,
          67,
          198,
          62,
          66,
          156,
          188,
          235,
          21,
          217,
          64,
          251,
          181,
          197,
          161,
          244,
          175,
          87,
          197,
          233
        ]),
        "KeyAgg list": Buffer2.from([
          72,
          28,
          151,
          28,
          60,
          11,
          70,
          215,
          240,
          178,
          117,
          174,
          89,
          141,
          78,
          44,
          126,
          215,
          49,
          156,
          89,
          74,
          92,
          110,
          199,
          158,
          160,
          212,
          153,
          2,
          148,
          240,
          72,
          28,
          151,
          28,
          60,
          11,
          70,
          215,
          240,
          178,
          117,
          174,
          89,
          141,
          78,
          44,
          126,
          215,
          49,
          156,
          89,
          74,
          92,
          110,
          199,
          158,
          160,
          212,
          153,
          2,
          148,
          240
        ]),
        "KeyAgg coefficient": Buffer2.from([
          191,
          201,
          4,
          3,
          77,
          28,
          136,
          232,
          200,
          14,
          34,
          229,
          61,
          36,
          86,
          109,
          100,
          130,
          78,
          214,
          66,
          114,
          129,
          192,
          145,
          0,
          249,
          77,
          205,
          82,
          201,
          129,
          191,
          201,
          4,
          3,
          77,
          28,
          136,
          232,
          200,
          14,
          34,
          229,
          61,
          36,
          86,
          109,
          100,
          130,
          78,
          214,
          66,
          114,
          129,
          192,
          145,
          0,
          249,
          77,
          205,
          82,
          201,
          129
        ])
      };
      function taggedHash(prefix, data) {
        return sha256(Buffer2.concat([exports9.TAGGED_HASH_PREFIXES[prefix], data]));
      }
      exports9.taggedHash = taggedHash;
    }
  });

  // node_modules/bitcoinjs-lib/node_modules/base-x/src/index.js
  var require_src = __commonJS({
    "node_modules/bitcoinjs-lib/node_modules/base-x/src/index.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      function base(ALPHABET) {
        if (ALPHABET.length >= 255) {
          throw new TypeError("Alphabet too long");
        }
        var BASE_MAP = new Uint8Array(256);
        for (var j = 0; j < BASE_MAP.length; j++) {
          BASE_MAP[j] = 255;
        }
        for (var i = 0; i < ALPHABET.length; i++) {
          var x = ALPHABET.charAt(i);
          var xc = x.charCodeAt(0);
          if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + " is ambiguous");
          }
          BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        var FACTOR = Math.log(BASE) / Math.log(256);
        var iFACTOR = Math.log(256) / Math.log(BASE);
        function encode(source) {
          if (source instanceof Uint8Array) {
          } else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
          } else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
          }
          if (!(source instanceof Uint8Array)) {
            throw new TypeError("Expected Uint8Array");
          }
          if (source.length === 0) {
            return "";
          }
          var zeroes = 0;
          var length = 0;
          var pbegin = 0;
          var pend = source.length;
          while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
          }
          var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
          var b58 = new Uint8Array(size);
          while (pbegin !== pend) {
            var carry = source[pbegin];
            var i2 = 0;
            for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
              carry += 256 * b58[it1] >>> 0;
              b58[it1] = carry % BASE >>> 0;
              carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            pbegin++;
          }
          var it2 = size - length;
          while (it2 !== size && b58[it2] === 0) {
            it2++;
          }
          var str = LEADER.repeat(zeroes);
          for (; it2 < size; ++it2) {
            str += ALPHABET.charAt(b58[it2]);
          }
          return str;
        }
        function decodeUnsafe(source) {
          if (typeof source !== "string") {
            throw new TypeError("Expected String");
          }
          if (source.length === 0) {
            return new Uint8Array();
          }
          var psz = 0;
          var zeroes = 0;
          var length = 0;
          while (source[psz] === LEADER) {
            zeroes++;
            psz++;
          }
          var size = (source.length - psz) * FACTOR + 1 >>> 0;
          var b256 = new Uint8Array(size);
          while (source[psz]) {
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (carry === 255) {
              return;
            }
            var i2 = 0;
            for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
              carry += BASE * b256[it3] >>> 0;
              b256[it3] = carry % 256 >>> 0;
              carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            psz++;
          }
          var it4 = size - length;
          while (it4 !== size && b256[it4] === 0) {
            it4++;
          }
          var vch = new Uint8Array(zeroes + (size - it4));
          var j2 = zeroes;
          while (it4 !== size) {
            vch[j2++] = b256[it4++];
          }
          return vch;
        }
        function decode(string) {
          var buffer = decodeUnsafe(string);
          if (buffer) {
            return buffer;
          }
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode,
          decodeUnsafe,
          decode
        };
      }
      module.exports = base;
    }
  });

  // node_modules/bitcoinjs-lib/node_modules/bs58/index.js
  var require_bs58 = __commonJS({
    "node_modules/bitcoinjs-lib/node_modules/bs58/index.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var basex = require_src();
      var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      module.exports = basex(ALPHABET);
    }
  });

  // node_modules/bitcoinjs-lib/node_modules/bs58check/base.js
  var require_base = __commonJS({
    "node_modules/bitcoinjs-lib/node_modules/bs58check/base.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var base58 = require_bs58();
      module.exports = function(checksumFn) {
        function encode(payload) {
          var payloadU8 = Uint8Array.from(payload);
          var checksum = checksumFn(payloadU8);
          var length = payloadU8.length + 4;
          var both = new Uint8Array(length);
          both.set(payloadU8, 0);
          both.set(checksum.subarray(0, 4), payloadU8.length);
          return base58.encode(both, length);
        }
        function decodeRaw(buffer) {
          var payload = buffer.slice(0, -4);
          var checksum = buffer.slice(-4);
          var newChecksum = checksumFn(payload);
          if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
          return payload;
        }
        function decodeUnsafe(string) {
          var buffer = base58.decodeUnsafe(string);
          if (!buffer) return;
          return decodeRaw(buffer);
        }
        function decode(string) {
          var buffer = base58.decode(string);
          var payload = decodeRaw(buffer, checksumFn);
          if (!payload) throw new Error("Invalid checksum");
          return payload;
        }
        return {
          encode,
          decode,
          decodeUnsafe
        };
      };
    }
  });

  // node_modules/bitcoinjs-lib/node_modules/bs58check/index.js
  var require_bs58check = __commonJS({
    "node_modules/bitcoinjs-lib/node_modules/bs58check/index.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var { sha256 } = require_sha256();
      var bs58checkBase = require_base();
      function sha256x2(buffer) {
        return sha256(sha256(buffer));
      }
      module.exports = bs58checkBase(sha256x2);
    }
  });

  // node_modules/bitcoinjs-lib/src/payments/p2pkh.js
  var require_p2pkh = __commonJS({
    "node_modules/bitcoinjs-lib/src/payments/p2pkh.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.p2pkh = void 0;
      var bcrypto = require_crypto2();
      var networks_1 = require_networks();
      var bscript = require_script();
      var types_1 = require_types();
      var lazy = require_lazy();
      var bs58check = require_bs58check();
      var OPS = bscript.OPS;
      function p2pkh(a, opts) {
        if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)
          throw new TypeError("Not enough data");
        opts = Object.assign({ validate: true }, opts || {});
        (0, types_1.typeforce)(
          {
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            address: types_1.typeforce.maybe(types_1.typeforce.String),
            hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
            output: types_1.typeforce.maybe(types_1.typeforce.BufferN(25)),
            pubkey: types_1.typeforce.maybe(types_1.isPoint),
            signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
            input: types_1.typeforce.maybe(types_1.typeforce.Buffer)
          },
          a
        );
        const _address = lazy.value(() => {
          const payload = Buffer2.from(bs58check.decode(a.address));
          const version2 = payload.readUInt8(0);
          const hash = payload.slice(1);
          return { version: version2, hash };
        });
        const _chunks = lazy.value(() => {
          return bscript.decompile(a.input);
        });
        const network = a.network || networks_1.bitcoin;
        const o = { name: "p2pkh", network };
        lazy.prop(o, "address", () => {
          if (!o.hash) return;
          const payload = Buffer2.allocUnsafe(21);
          payload.writeUInt8(network.pubKeyHash, 0);
          o.hash.copy(payload, 1);
          return bs58check.encode(payload);
        });
        lazy.prop(o, "hash", () => {
          if (a.output) return a.output.slice(3, 23);
          if (a.address) return _address().hash;
          if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
        });
        lazy.prop(o, "output", () => {
          if (!o.hash) return;
          return bscript.compile([
            OPS.OP_DUP,
            OPS.OP_HASH160,
            o.hash,
            OPS.OP_EQUALVERIFY,
            OPS.OP_CHECKSIG
          ]);
        });
        lazy.prop(o, "pubkey", () => {
          if (!a.input) return;
          return _chunks()[1];
        });
        lazy.prop(o, "signature", () => {
          if (!a.input) return;
          return _chunks()[0];
        });
        lazy.prop(o, "input", () => {
          if (!a.pubkey) return;
          if (!a.signature) return;
          return bscript.compile([a.signature, a.pubkey]);
        });
        lazy.prop(o, "witness", () => {
          if (!o.input) return;
          return [];
        });
        if (opts.validate) {
          let hash = Buffer2.from([]);
          if (a.address) {
            if (_address().version !== network.pubKeyHash)
              throw new TypeError("Invalid version or Network mismatch");
            if (_address().hash.length !== 20) throw new TypeError("Invalid address");
            hash = _address().hash;
          }
          if (a.hash) {
            if (hash.length > 0 && !hash.equals(a.hash))
              throw new TypeError("Hash mismatch");
            else hash = a.hash;
          }
          if (a.output) {
            if (a.output.length !== 25 || a.output[0] !== OPS.OP_DUP || a.output[1] !== OPS.OP_HASH160 || a.output[2] !== 20 || a.output[23] !== OPS.OP_EQUALVERIFY || a.output[24] !== OPS.OP_CHECKSIG)
              throw new TypeError("Output is invalid");
            const hash2 = a.output.slice(3, 23);
            if (hash.length > 0 && !hash.equals(hash2))
              throw new TypeError("Hash mismatch");
            else hash = hash2;
          }
          if (a.pubkey) {
            const pkh = bcrypto.hash160(a.pubkey);
            if (hash.length > 0 && !hash.equals(pkh))
              throw new TypeError("Hash mismatch");
            else hash = pkh;
          }
          if (a.input) {
            const chunks = _chunks();
            if (chunks.length !== 2) throw new TypeError("Input is invalid");
            if (!bscript.isCanonicalScriptSignature(chunks[0]))
              throw new TypeError("Input has invalid signature");
            if (!(0, types_1.isPoint)(chunks[1]))
              throw new TypeError("Input has invalid pubkey");
            if (a.signature && !a.signature.equals(chunks[0]))
              throw new TypeError("Signature mismatch");
            if (a.pubkey && !a.pubkey.equals(chunks[1]))
              throw new TypeError("Pubkey mismatch");
            const pkh = bcrypto.hash160(chunks[1]);
            if (hash.length > 0 && !hash.equals(pkh))
              throw new TypeError("Hash mismatch");
          }
        }
        return Object.assign(o, a);
      }
      exports9.p2pkh = p2pkh;
    }
  });

  // node_modules/bitcoinjs-lib/src/payments/p2sh.js
  var require_p2sh = __commonJS({
    "node_modules/bitcoinjs-lib/src/payments/p2sh.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.p2sh = void 0;
      var bcrypto = require_crypto2();
      var networks_1 = require_networks();
      var bscript = require_script();
      var types_1 = require_types();
      var lazy = require_lazy();
      var bs58check = require_bs58check();
      var OPS = bscript.OPS;
      function p2sh(a, opts) {
        if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)
          throw new TypeError("Not enough data");
        opts = Object.assign({ validate: true }, opts || {});
        (0, types_1.typeforce)(
          {
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            address: types_1.typeforce.maybe(types_1.typeforce.String),
            hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
            output: types_1.typeforce.maybe(types_1.typeforce.BufferN(23)),
            redeem: types_1.typeforce.maybe({
              network: types_1.typeforce.maybe(types_1.typeforce.Object),
              output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
              input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
              witness: types_1.typeforce.maybe(
                types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
              )
            }),
            input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          },
          a
        );
        let network = a.network;
        if (!network) {
          network = a.redeem && a.redeem.network || networks_1.bitcoin;
        }
        const o = { network };
        const _address = lazy.value(() => {
          const payload = Buffer2.from(bs58check.decode(a.address));
          const version2 = payload.readUInt8(0);
          const hash = payload.slice(1);
          return { version: version2, hash };
        });
        const _chunks = lazy.value(() => {
          return bscript.decompile(a.input);
        });
        const _redeem = lazy.value(() => {
          const chunks = _chunks();
          const lastChunk = chunks[chunks.length - 1];
          return {
            network,
            output: lastChunk === OPS.OP_FALSE ? Buffer2.from([]) : lastChunk,
            input: bscript.compile(chunks.slice(0, -1)),
            witness: a.witness || []
          };
        });
        lazy.prop(o, "address", () => {
          if (!o.hash) return;
          const payload = Buffer2.allocUnsafe(21);
          payload.writeUInt8(o.network.scriptHash, 0);
          o.hash.copy(payload, 1);
          return bs58check.encode(payload);
        });
        lazy.prop(o, "hash", () => {
          if (a.output) return a.output.slice(2, 22);
          if (a.address) return _address().hash;
          if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);
        });
        lazy.prop(o, "output", () => {
          if (!o.hash) return;
          return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);
        });
        lazy.prop(o, "redeem", () => {
          if (!a.input) return;
          return _redeem();
        });
        lazy.prop(o, "input", () => {
          if (!a.redeem || !a.redeem.input || !a.redeem.output) return;
          return bscript.compile(
            [].concat(bscript.decompile(a.redeem.input), a.redeem.output)
          );
        });
        lazy.prop(o, "witness", () => {
          if (o.redeem && o.redeem.witness) return o.redeem.witness;
          if (o.input) return [];
        });
        lazy.prop(o, "name", () => {
          const nameParts = ["p2sh"];
          if (o.redeem !== void 0 && o.redeem.name !== void 0)
            nameParts.push(o.redeem.name);
          return nameParts.join("-");
        });
        if (opts.validate) {
          let hash = Buffer2.from([]);
          if (a.address) {
            if (_address().version !== network.scriptHash)
              throw new TypeError("Invalid version or Network mismatch");
            if (_address().hash.length !== 20) throw new TypeError("Invalid address");
            hash = _address().hash;
          }
          if (a.hash) {
            if (hash.length > 0 && !hash.equals(a.hash))
              throw new TypeError("Hash mismatch");
            else hash = a.hash;
          }
          if (a.output) {
            if (a.output.length !== 23 || a.output[0] !== OPS.OP_HASH160 || a.output[1] !== 20 || a.output[22] !== OPS.OP_EQUAL)
              throw new TypeError("Output is invalid");
            const hash2 = a.output.slice(2, 22);
            if (hash.length > 0 && !hash.equals(hash2))
              throw new TypeError("Hash mismatch");
            else hash = hash2;
          }
          const checkRedeem = (redeem) => {
            if (redeem.output) {
              const decompile = bscript.decompile(redeem.output);
              if (!decompile || decompile.length < 1)
                throw new TypeError("Redeem.output too short");
              if (redeem.output.byteLength > 520)
                throw new TypeError(
                  "Redeem.output unspendable if larger than 520 bytes"
                );
              if (bscript.countNonPushOnlyOPs(decompile) > 201)
                throw new TypeError(
                  "Redeem.output unspendable with more than 201 non-push ops"
                );
              const hash2 = bcrypto.hash160(redeem.output);
              if (hash.length > 0 && !hash.equals(hash2))
                throw new TypeError("Hash mismatch");
              else hash = hash2;
            }
            if (redeem.input) {
              const hasInput = redeem.input.length > 0;
              const hasWitness = redeem.witness && redeem.witness.length > 0;
              if (!hasInput && !hasWitness) throw new TypeError("Empty input");
              if (hasInput && hasWitness)
                throw new TypeError("Input and witness provided");
              if (hasInput) {
                const richunks = bscript.decompile(redeem.input);
                if (!bscript.isPushOnly(richunks))
                  throw new TypeError("Non push-only scriptSig");
              }
            }
          };
          if (a.input) {
            const chunks = _chunks();
            if (!chunks || chunks.length < 1) throw new TypeError("Input too short");
            if (!Buffer2.isBuffer(_redeem().output))
              throw new TypeError("Input is invalid");
            checkRedeem(_redeem());
          }
          if (a.redeem) {
            if (a.redeem.network && a.redeem.network !== network)
              throw new TypeError("Network mismatch");
            if (a.input) {
              const redeem = _redeem();
              if (a.redeem.output && !a.redeem.output.equals(redeem.output))
                throw new TypeError("Redeem.output mismatch");
              if (a.redeem.input && !a.redeem.input.equals(redeem.input))
                throw new TypeError("Redeem.input mismatch");
            }
            checkRedeem(a.redeem);
          }
          if (a.witness) {
            if (a.redeem && a.redeem.witness && !(0, types_1.stacksEqual)(a.redeem.witness, a.witness))
              throw new TypeError("Witness and redeem.witness mismatch");
          }
        }
        return Object.assign(o, a);
      }
      exports9.p2sh = p2sh;
    }
  });

  // node_modules/bech32/dist/index.js
  var require_dist = __commonJS({
    "node_modules/bech32/dist/index.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.bech32m = exports9.bech32 = void 0;
      var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
      var ALPHABET_MAP = {};
      for (let z = 0; z < ALPHABET.length; z++) {
        const x = ALPHABET.charAt(z);
        ALPHABET_MAP[x] = z;
      }
      function polymodStep(pre) {
        const b = pre >> 25;
        return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
      }
      function prefixChk(prefix) {
        let chk = 1;
        for (let i = 0; i < prefix.length; ++i) {
          const c = prefix.charCodeAt(i);
          if (c < 33 || c > 126)
            return "Invalid prefix (" + prefix + ")";
          chk = polymodStep(chk) ^ c >> 5;
        }
        chk = polymodStep(chk);
        for (let i = 0; i < prefix.length; ++i) {
          const v = prefix.charCodeAt(i);
          chk = polymodStep(chk) ^ v & 31;
        }
        return chk;
      }
      function convert(data, inBits, outBits, pad) {
        let value = 0;
        let bits = 0;
        const maxV = (1 << outBits) - 1;
        const result = [];
        for (let i = 0; i < data.length; ++i) {
          value = value << inBits | data[i];
          bits += inBits;
          while (bits >= outBits) {
            bits -= outBits;
            result.push(value >> bits & maxV);
          }
        }
        if (pad) {
          if (bits > 0) {
            result.push(value << outBits - bits & maxV);
          }
        } else {
          if (bits >= inBits)
            return "Excess padding";
          if (value << outBits - bits & maxV)
            return "Non-zero padding";
        }
        return result;
      }
      function toWords(bytes) {
        return convert(bytes, 8, 5, true);
      }
      function fromWordsUnsafe(words) {
        const res = convert(words, 5, 8, false);
        if (Array.isArray(res))
          return res;
      }
      function fromWords(words) {
        const res = convert(words, 5, 8, false);
        if (Array.isArray(res))
          return res;
        throw new Error(res);
      }
      function getLibraryFromEncoding(encoding) {
        let ENCODING_CONST;
        if (encoding === "bech32") {
          ENCODING_CONST = 1;
        } else {
          ENCODING_CONST = 734539939;
        }
        function encode(prefix, words, LIMIT) {
          LIMIT = LIMIT || 90;
          if (prefix.length + 7 + words.length > LIMIT)
            throw new TypeError("Exceeds length limit");
          prefix = prefix.toLowerCase();
          let chk = prefixChk(prefix);
          if (typeof chk === "string")
            throw new Error(chk);
          let result = prefix + "1";
          for (let i = 0; i < words.length; ++i) {
            const x = words[i];
            if (x >> 5 !== 0)
              throw new Error("Non 5-bit word");
            chk = polymodStep(chk) ^ x;
            result += ALPHABET.charAt(x);
          }
          for (let i = 0; i < 6; ++i) {
            chk = polymodStep(chk);
          }
          chk ^= ENCODING_CONST;
          for (let i = 0; i < 6; ++i) {
            const v = chk >> (5 - i) * 5 & 31;
            result += ALPHABET.charAt(v);
          }
          return result;
        }
        function __decode(str, LIMIT) {
          LIMIT = LIMIT || 90;
          if (str.length < 8)
            return str + " too short";
          if (str.length > LIMIT)
            return "Exceeds length limit";
          const lowered = str.toLowerCase();
          const uppered = str.toUpperCase();
          if (str !== lowered && str !== uppered)
            return "Mixed-case string " + str;
          str = lowered;
          const split = str.lastIndexOf("1");
          if (split === -1)
            return "No separator character for " + str;
          if (split === 0)
            return "Missing prefix for " + str;
          const prefix = str.slice(0, split);
          const wordChars = str.slice(split + 1);
          if (wordChars.length < 6)
            return "Data too short";
          let chk = prefixChk(prefix);
          if (typeof chk === "string")
            return chk;
          const words = [];
          for (let i = 0; i < wordChars.length; ++i) {
            const c = wordChars.charAt(i);
            const v = ALPHABET_MAP[c];
            if (v === void 0)
              return "Unknown character " + c;
            chk = polymodStep(chk) ^ v;
            if (i + 6 >= wordChars.length)
              continue;
            words.push(v);
          }
          if (chk !== ENCODING_CONST)
            return "Invalid checksum for " + str;
          return { prefix, words };
        }
        function decodeUnsafe(str, LIMIT) {
          const res = __decode(str, LIMIT);
          if (typeof res === "object")
            return res;
        }
        function decode(str, LIMIT) {
          const res = __decode(str, LIMIT);
          if (typeof res === "object")
            return res;
          throw new Error(res);
        }
        return {
          decodeUnsafe,
          decode,
          encode,
          toWords,
          fromWordsUnsafe,
          fromWords
        };
      }
      exports9.bech32 = getLibraryFromEncoding("bech32");
      exports9.bech32m = getLibraryFromEncoding("bech32m");
    }
  });

  // node_modules/bitcoinjs-lib/src/payments/p2wpkh.js
  var require_p2wpkh = __commonJS({
    "node_modules/bitcoinjs-lib/src/payments/p2wpkh.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.p2wpkh = void 0;
      var bcrypto = require_crypto2();
      var networks_1 = require_networks();
      var bscript = require_script();
      var types_1 = require_types();
      var lazy = require_lazy();
      var bech32_1 = require_dist();
      var OPS = bscript.OPS;
      var EMPTY_BUFFER = Buffer2.alloc(0);
      function p2wpkh(a, opts) {
        if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)
          throw new TypeError("Not enough data");
        opts = Object.assign({ validate: true }, opts || {});
        (0, types_1.typeforce)(
          {
            address: types_1.typeforce.maybe(types_1.typeforce.String),
            hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
            input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            output: types_1.typeforce.maybe(types_1.typeforce.BufferN(22)),
            pubkey: types_1.typeforce.maybe(types_1.isPoint),
            signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          },
          a
        );
        const _address = lazy.value(() => {
          const result = bech32_1.bech32.decode(a.address);
          const version2 = result.words.shift();
          const data = bech32_1.bech32.fromWords(result.words);
          return {
            version: version2,
            prefix: result.prefix,
            data: Buffer2.from(data)
          };
        });
        const network = a.network || networks_1.bitcoin;
        const o = { name: "p2wpkh", network };
        lazy.prop(o, "address", () => {
          if (!o.hash) return;
          const words = bech32_1.bech32.toWords(o.hash);
          words.unshift(0);
          return bech32_1.bech32.encode(network.bech32, words);
        });
        lazy.prop(o, "hash", () => {
          if (a.output) return a.output.slice(2, 22);
          if (a.address) return _address().data;
          if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
        });
        lazy.prop(o, "output", () => {
          if (!o.hash) return;
          return bscript.compile([OPS.OP_0, o.hash]);
        });
        lazy.prop(o, "pubkey", () => {
          if (a.pubkey) return a.pubkey;
          if (!a.witness) return;
          return a.witness[1];
        });
        lazy.prop(o, "signature", () => {
          if (!a.witness) return;
          return a.witness[0];
        });
        lazy.prop(o, "input", () => {
          if (!o.witness) return;
          return EMPTY_BUFFER;
        });
        lazy.prop(o, "witness", () => {
          if (!a.pubkey) return;
          if (!a.signature) return;
          return [a.signature, a.pubkey];
        });
        if (opts.validate) {
          let hash = Buffer2.from([]);
          if (a.address) {
            if (network && network.bech32 !== _address().prefix)
              throw new TypeError("Invalid prefix or Network mismatch");
            if (_address().version !== 0)
              throw new TypeError("Invalid address version");
            if (_address().data.length !== 20)
              throw new TypeError("Invalid address data");
            hash = _address().data;
          }
          if (a.hash) {
            if (hash.length > 0 && !hash.equals(a.hash))
              throw new TypeError("Hash mismatch");
            else hash = a.hash;
          }
          if (a.output) {
            if (a.output.length !== 22 || a.output[0] !== OPS.OP_0 || a.output[1] !== 20)
              throw new TypeError("Output is invalid");
            if (hash.length > 0 && !hash.equals(a.output.slice(2)))
              throw new TypeError("Hash mismatch");
            else hash = a.output.slice(2);
          }
          if (a.pubkey) {
            const pkh = bcrypto.hash160(a.pubkey);
            if (hash.length > 0 && !hash.equals(pkh))
              throw new TypeError("Hash mismatch");
            else hash = pkh;
            if (!(0, types_1.isPoint)(a.pubkey) || a.pubkey.length !== 33)
              throw new TypeError("Invalid pubkey for p2wpkh");
          }
          if (a.witness) {
            if (a.witness.length !== 2) throw new TypeError("Witness is invalid");
            if (!bscript.isCanonicalScriptSignature(a.witness[0]))
              throw new TypeError("Witness has invalid signature");
            if (!(0, types_1.isPoint)(a.witness[1]) || a.witness[1].length !== 33)
              throw new TypeError("Witness has invalid pubkey");
            if (a.signature && !a.signature.equals(a.witness[0]))
              throw new TypeError("Signature mismatch");
            if (a.pubkey && !a.pubkey.equals(a.witness[1]))
              throw new TypeError("Pubkey mismatch");
            const pkh = bcrypto.hash160(a.witness[1]);
            if (hash.length > 0 && !hash.equals(pkh))
              throw new TypeError("Hash mismatch");
          }
        }
        return Object.assign(o, a);
      }
      exports9.p2wpkh = p2wpkh;
    }
  });

  // node_modules/bitcoinjs-lib/src/payments/p2wsh.js
  var require_p2wsh = __commonJS({
    "node_modules/bitcoinjs-lib/src/payments/p2wsh.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.p2wsh = void 0;
      var bcrypto = require_crypto2();
      var networks_1 = require_networks();
      var bscript = require_script();
      var types_1 = require_types();
      var lazy = require_lazy();
      var bech32_1 = require_dist();
      var OPS = bscript.OPS;
      var EMPTY_BUFFER = Buffer2.alloc(0);
      function chunkHasUncompressedPubkey(chunk) {
        if (Buffer2.isBuffer(chunk) && chunk.length === 65 && chunk[0] === 4 && (0, types_1.isPoint)(chunk)) {
          return true;
        } else {
          return false;
        }
      }
      function p2wsh(a, opts) {
        if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)
          throw new TypeError("Not enough data");
        opts = Object.assign({ validate: true }, opts || {});
        (0, types_1.typeforce)(
          {
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            address: types_1.typeforce.maybe(types_1.typeforce.String),
            hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
            output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
            redeem: types_1.typeforce.maybe({
              input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
              network: types_1.typeforce.maybe(types_1.typeforce.Object),
              output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
              witness: types_1.typeforce.maybe(
                types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
              )
            }),
            input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          },
          a
        );
        const _address = lazy.value(() => {
          const result = bech32_1.bech32.decode(a.address);
          const version2 = result.words.shift();
          const data = bech32_1.bech32.fromWords(result.words);
          return {
            version: version2,
            prefix: result.prefix,
            data: Buffer2.from(data)
          };
        });
        const _rchunks = lazy.value(() => {
          return bscript.decompile(a.redeem.input);
        });
        let network = a.network;
        if (!network) {
          network = a.redeem && a.redeem.network || networks_1.bitcoin;
        }
        const o = { network };
        lazy.prop(o, "address", () => {
          if (!o.hash) return;
          const words = bech32_1.bech32.toWords(o.hash);
          words.unshift(0);
          return bech32_1.bech32.encode(network.bech32, words);
        });
        lazy.prop(o, "hash", () => {
          if (a.output) return a.output.slice(2);
          if (a.address) return _address().data;
          if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);
        });
        lazy.prop(o, "output", () => {
          if (!o.hash) return;
          return bscript.compile([OPS.OP_0, o.hash]);
        });
        lazy.prop(o, "redeem", () => {
          if (!a.witness) return;
          return {
            output: a.witness[a.witness.length - 1],
            input: EMPTY_BUFFER,
            witness: a.witness.slice(0, -1)
          };
        });
        lazy.prop(o, "input", () => {
          if (!o.witness) return;
          return EMPTY_BUFFER;
        });
        lazy.prop(o, "witness", () => {
          if (a.redeem && a.redeem.input && a.redeem.input.length > 0 && a.redeem.output && a.redeem.output.length > 0) {
            const stack = bscript.toStack(_rchunks());
            o.redeem = Object.assign({ witness: stack }, a.redeem);
            o.redeem.input = EMPTY_BUFFER;
            return [].concat(stack, a.redeem.output);
          }
          if (!a.redeem) return;
          if (!a.redeem.output) return;
          if (!a.redeem.witness) return;
          return [].concat(a.redeem.witness, a.redeem.output);
        });
        lazy.prop(o, "name", () => {
          const nameParts = ["p2wsh"];
          if (o.redeem !== void 0 && o.redeem.name !== void 0)
            nameParts.push(o.redeem.name);
          return nameParts.join("-");
        });
        if (opts.validate) {
          let hash = Buffer2.from([]);
          if (a.address) {
            if (_address().prefix !== network.bech32)
              throw new TypeError("Invalid prefix or Network mismatch");
            if (_address().version !== 0)
              throw new TypeError("Invalid address version");
            if (_address().data.length !== 32)
              throw new TypeError("Invalid address data");
            hash = _address().data;
          }
          if (a.hash) {
            if (hash.length > 0 && !hash.equals(a.hash))
              throw new TypeError("Hash mismatch");
            else hash = a.hash;
          }
          if (a.output) {
            if (a.output.length !== 34 || a.output[0] !== OPS.OP_0 || a.output[1] !== 32)
              throw new TypeError("Output is invalid");
            const hash2 = a.output.slice(2);
            if (hash.length > 0 && !hash.equals(hash2))
              throw new TypeError("Hash mismatch");
            else hash = hash2;
          }
          if (a.redeem) {
            if (a.redeem.network && a.redeem.network !== network)
              throw new TypeError("Network mismatch");
            if (a.redeem.input && a.redeem.input.length > 0 && a.redeem.witness && a.redeem.witness.length > 0)
              throw new TypeError("Ambiguous witness source");
            if (a.redeem.output) {
              const decompile = bscript.decompile(a.redeem.output);
              if (!decompile || decompile.length < 1)
                throw new TypeError("Redeem.output is invalid");
              if (a.redeem.output.byteLength > 3600)
                throw new TypeError(
                  "Redeem.output unspendable if larger than 3600 bytes"
                );
              if (bscript.countNonPushOnlyOPs(decompile) > 201)
                throw new TypeError(
                  "Redeem.output unspendable with more than 201 non-push ops"
                );
              const hash2 = bcrypto.sha256(a.redeem.output);
              if (hash.length > 0 && !hash.equals(hash2))
                throw new TypeError("Hash mismatch");
              else hash = hash2;
            }
            if (a.redeem.input && !bscript.isPushOnly(_rchunks()))
              throw new TypeError("Non push-only scriptSig");
            if (a.witness && a.redeem.witness && !(0, types_1.stacksEqual)(a.witness, a.redeem.witness))
              throw new TypeError("Witness and redeem.witness mismatch");
            if (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey) || a.redeem.output && (bscript.decompile(a.redeem.output) || []).some(
              chunkHasUncompressedPubkey
            )) {
              throw new TypeError(
                "redeem.input or redeem.output contains uncompressed pubkey"
              );
            }
          }
          if (a.witness && a.witness.length > 0) {
            const wScript = a.witness[a.witness.length - 1];
            if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))
              throw new TypeError("Witness and redeem.output mismatch");
            if (a.witness.some(chunkHasUncompressedPubkey) || (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey))
              throw new TypeError("Witness contains uncompressed pubkey");
          }
        }
        return Object.assign(o, a);
      }
      exports9.p2wsh = p2wsh;
    }
  });

  // node_modules/bitcoinjs-lib/src/ecc_lib.js
  var require_ecc_lib = __commonJS({
    "node_modules/bitcoinjs-lib/src/ecc_lib.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.getEccLib = exports9.initEccLib = void 0;
      var _ECCLIB_CACHE = {};
      function initEccLib(eccLib, opts) {
        if (!eccLib) {
          _ECCLIB_CACHE.eccLib = eccLib;
        } else if (eccLib !== _ECCLIB_CACHE.eccLib) {
          if (!opts?.DANGER_DO_NOT_VERIFY_ECCLIB)
            verifyEcc(eccLib);
          _ECCLIB_CACHE.eccLib = eccLib;
        }
      }
      exports9.initEccLib = initEccLib;
      function getEccLib() {
        if (!_ECCLIB_CACHE.eccLib)
          throw new Error(
            "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
          );
        return _ECCLIB_CACHE.eccLib;
      }
      exports9.getEccLib = getEccLib;
      var h = (hex) => Buffer2.from(hex, "hex");
      function verifyEcc(ecc) {
        assert2(typeof ecc.isXOnlyPoint === "function");
        assert2(
          ecc.isXOnlyPoint(
            h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
          )
        );
        assert2(
          ecc.isXOnlyPoint(
            h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
          )
        );
        assert2(
          ecc.isXOnlyPoint(
            h("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
          )
        );
        assert2(
          ecc.isXOnlyPoint(
            h("0000000000000000000000000000000000000000000000000000000000000001")
          )
        );
        assert2(
          !ecc.isXOnlyPoint(
            h("0000000000000000000000000000000000000000000000000000000000000000")
          )
        );
        assert2(
          !ecc.isXOnlyPoint(
            h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
          )
        );
        assert2(typeof ecc.xOnlyPointAddTweak === "function");
        tweakAddVectors.forEach((t) => {
          const r = ecc.xOnlyPointAddTweak(h(t.pubkey), h(t.tweak));
          if (t.result === null) {
            assert2(r === null);
          } else {
            assert2(r !== null);
            assert2(r.parity === t.parity);
            assert2(Buffer2.from(r.xOnlyPubkey).equals(h(t.result)));
          }
        });
      }
      function assert2(bool) {
        if (!bool) throw new Error("ecc library invalid");
      }
      var tweakAddVectors = [
        {
          pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
          tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
          parity: -1,
          result: null
        },
        {
          pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
          tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
          parity: 1,
          result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
        },
        {
          pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
          tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
          parity: 0,
          result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
        }
      ];
    }
  });

  // node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "node_modules/safe-buffer/index.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var buffer = (init_buffer(), __toCommonJS(buffer_exports));
      var Buffer3 = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
        module.exports = buffer;
      } else {
        copyProps(buffer, exports9);
        exports9.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer3(arg, encodingOrOffset, length);
      }
      copyProps(Buffer3, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer3(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer3(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer3(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }
  });

  // node_modules/varuint-bitcoin/index.js
  var require_varuint_bitcoin = __commonJS({
    "node_modules/varuint-bitcoin/index.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var Buffer3 = require_safe_buffer().Buffer;
      var MAX_SAFE_INTEGER = 9007199254740991;
      function checkUInt53(n) {
        if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError("value out of range");
      }
      function encode(number, buffer, offset) {
        checkUInt53(number);
        if (!buffer) buffer = Buffer3.allocUnsafe(encodingLength(number));
        if (!Buffer3.isBuffer(buffer)) throw new TypeError("buffer must be a Buffer instance");
        if (!offset) offset = 0;
        if (number < 253) {
          buffer.writeUInt8(number, offset);
          encode.bytes = 1;
        } else if (number <= 65535) {
          buffer.writeUInt8(253, offset);
          buffer.writeUInt16LE(number, offset + 1);
          encode.bytes = 3;
        } else if (number <= 4294967295) {
          buffer.writeUInt8(254, offset);
          buffer.writeUInt32LE(number, offset + 1);
          encode.bytes = 5;
        } else {
          buffer.writeUInt8(255, offset);
          buffer.writeUInt32LE(number >>> 0, offset + 1);
          buffer.writeUInt32LE(number / 4294967296 | 0, offset + 5);
          encode.bytes = 9;
        }
        return buffer;
      }
      function decode(buffer, offset) {
        if (!Buffer3.isBuffer(buffer)) throw new TypeError("buffer must be a Buffer instance");
        if (!offset) offset = 0;
        var first = buffer.readUInt8(offset);
        if (first < 253) {
          decode.bytes = 1;
          return first;
        } else if (first === 253) {
          decode.bytes = 3;
          return buffer.readUInt16LE(offset + 1);
        } else if (first === 254) {
          decode.bytes = 5;
          return buffer.readUInt32LE(offset + 1);
        } else {
          decode.bytes = 9;
          var lo = buffer.readUInt32LE(offset + 1);
          var hi = buffer.readUInt32LE(offset + 5);
          var number = hi * 4294967296 + lo;
          checkUInt53(number);
          return number;
        }
      }
      function encodingLength(number) {
        checkUInt53(number);
        return number < 253 ? 1 : number <= 65535 ? 3 : number <= 4294967295 ? 5 : 9;
      }
      module.exports = { encode, decode, encodingLength };
    }
  });

  // node_modules/bitcoinjs-lib/src/bufferutils.js
  var require_bufferutils = __commonJS({
    "node_modules/bitcoinjs-lib/src/bufferutils.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.BufferReader = exports9.BufferWriter = exports9.cloneBuffer = exports9.reverseBuffer = exports9.writeUInt64LE = exports9.readUInt64LE = exports9.varuint = void 0;
      var types2 = require_types();
      var { typeforce } = types2;
      var varuint = require_varuint_bitcoin();
      exports9.varuint = varuint;
      function verifuint(value, max) {
        if (typeof value !== "number")
          throw new Error("cannot write a non-number as a number");
        if (value < 0)
          throw new Error("specified a negative value for writing an unsigned value");
        if (value > max) throw new Error("RangeError: value out of range");
        if (Math.floor(value) !== value)
          throw new Error("value has a fractional component");
      }
      function readUInt64LE(buffer, offset) {
        const a = buffer.readUInt32LE(offset);
        let b = buffer.readUInt32LE(offset + 4);
        b *= 4294967296;
        verifuint(b + a, 9007199254740991);
        return b + a;
      }
      exports9.readUInt64LE = readUInt64LE;
      function writeUInt64LE(buffer, value, offset) {
        verifuint(value, 9007199254740991);
        buffer.writeInt32LE(value & -1, offset);
        buffer.writeUInt32LE(Math.floor(value / 4294967296), offset + 4);
        return offset + 8;
      }
      exports9.writeUInt64LE = writeUInt64LE;
      function reverseBuffer(buffer) {
        if (buffer.length < 1) return buffer;
        let j = buffer.length - 1;
        let tmp = 0;
        for (let i = 0; i < buffer.length / 2; i++) {
          tmp = buffer[i];
          buffer[i] = buffer[j];
          buffer[j] = tmp;
          j--;
        }
        return buffer;
      }
      exports9.reverseBuffer = reverseBuffer;
      function cloneBuffer(buffer) {
        const clone = Buffer2.allocUnsafe(buffer.length);
        buffer.copy(clone);
        return clone;
      }
      exports9.cloneBuffer = cloneBuffer;
      var BufferWriter = class _BufferWriter {
        static withCapacity(size) {
          return new _BufferWriter(Buffer2.alloc(size));
        }
        constructor(buffer, offset = 0) {
          this.buffer = buffer;
          this.offset = offset;
          typeforce(types2.tuple(types2.Buffer, types2.UInt32), [buffer, offset]);
        }
        writeUInt8(i) {
          this.offset = this.buffer.writeUInt8(i, this.offset);
        }
        writeInt32(i) {
          this.offset = this.buffer.writeInt32LE(i, this.offset);
        }
        writeUInt32(i) {
          this.offset = this.buffer.writeUInt32LE(i, this.offset);
        }
        writeUInt64(i) {
          this.offset = writeUInt64LE(this.buffer, i, this.offset);
        }
        writeVarInt(i) {
          varuint.encode(i, this.buffer, this.offset);
          this.offset += varuint.encode.bytes;
        }
        writeSlice(slice) {
          if (this.buffer.length < this.offset + slice.length) {
            throw new Error("Cannot write slice out of bounds");
          }
          this.offset += slice.copy(this.buffer, this.offset);
        }
        writeVarSlice(slice) {
          this.writeVarInt(slice.length);
          this.writeSlice(slice);
        }
        writeVector(vector) {
          this.writeVarInt(vector.length);
          vector.forEach((buf) => this.writeVarSlice(buf));
        }
        end() {
          if (this.buffer.length === this.offset) {
            return this.buffer;
          }
          throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
        }
      };
      exports9.BufferWriter = BufferWriter;
      var BufferReader = class {
        constructor(buffer, offset = 0) {
          this.buffer = buffer;
          this.offset = offset;
          typeforce(types2.tuple(types2.Buffer, types2.UInt32), [buffer, offset]);
        }
        readUInt8() {
          const result = this.buffer.readUInt8(this.offset);
          this.offset++;
          return result;
        }
        readInt32() {
          const result = this.buffer.readInt32LE(this.offset);
          this.offset += 4;
          return result;
        }
        readUInt32() {
          const result = this.buffer.readUInt32LE(this.offset);
          this.offset += 4;
          return result;
        }
        readUInt64() {
          const result = readUInt64LE(this.buffer, this.offset);
          this.offset += 8;
          return result;
        }
        readVarInt() {
          const vi = varuint.decode(this.buffer, this.offset);
          this.offset += varuint.decode.bytes;
          return vi;
        }
        readSlice(n) {
          if (this.buffer.length < this.offset + n) {
            throw new Error("Cannot read slice out of bounds");
          }
          const result = this.buffer.slice(this.offset, this.offset + n);
          this.offset += n;
          return result;
        }
        readVarSlice() {
          return this.readSlice(this.readVarInt());
        }
        readVector() {
          const count = this.readVarInt();
          const vector = [];
          for (let i = 0; i < count; i++) vector.push(this.readVarSlice());
          return vector;
        }
      };
      exports9.BufferReader = BufferReader;
    }
  });

  // node_modules/bitcoinjs-lib/src/payments/bip341.js
  var require_bip341 = __commonJS({
    "node_modules/bitcoinjs-lib/src/payments/bip341.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.tweakKey = exports9.tapTweakHash = exports9.tapleafHash = exports9.findScriptPath = exports9.toHashTree = exports9.rootHashFromPath = exports9.MAX_TAPTREE_DEPTH = exports9.LEAF_VERSION_TAPSCRIPT = void 0;
      var buffer_1 = (init_buffer(), __toCommonJS(buffer_exports));
      var ecc_lib_1 = require_ecc_lib();
      var bcrypto = require_crypto2();
      var bufferutils_1 = require_bufferutils();
      var types_1 = require_types();
      exports9.LEAF_VERSION_TAPSCRIPT = 192;
      exports9.MAX_TAPTREE_DEPTH = 128;
      var isHashBranch = (ht) => "left" in ht && "right" in ht;
      function rootHashFromPath(controlBlock, leafHash) {
        if (controlBlock.length < 33)
          throw new TypeError(
            `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`
          );
        const m = (controlBlock.length - 33) / 32;
        let kj = leafHash;
        for (let j = 0; j < m; j++) {
          const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);
          if (kj.compare(ej) < 0) {
            kj = tapBranchHash(kj, ej);
          } else {
            kj = tapBranchHash(ej, kj);
          }
        }
        return kj;
      }
      exports9.rootHashFromPath = rootHashFromPath;
      function toHashTree(scriptTree) {
        if ((0, types_1.isTapleaf)(scriptTree))
          return { hash: tapleafHash(scriptTree) };
        const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];
        hashes.sort((a, b) => a.hash.compare(b.hash));
        const [left, right] = hashes;
        return {
          hash: tapBranchHash(left.hash, right.hash),
          left,
          right
        };
      }
      exports9.toHashTree = toHashTree;
      function findScriptPath(node, hash) {
        if (isHashBranch(node)) {
          const leftPath = findScriptPath(node.left, hash);
          if (leftPath !== void 0) return [...leftPath, node.right.hash];
          const rightPath = findScriptPath(node.right, hash);
          if (rightPath !== void 0) return [...rightPath, node.left.hash];
        } else if (node.hash.equals(hash)) {
          return [];
        }
        return void 0;
      }
      exports9.findScriptPath = findScriptPath;
      function tapleafHash(leaf) {
        const version2 = leaf.version || exports9.LEAF_VERSION_TAPSCRIPT;
        return bcrypto.taggedHash(
          "TapLeaf",
          buffer_1.Buffer.concat([
            buffer_1.Buffer.from([version2]),
            serializeScript(leaf.output)
          ])
        );
      }
      exports9.tapleafHash = tapleafHash;
      function tapTweakHash(pubKey, h) {
        return bcrypto.taggedHash(
          "TapTweak",
          buffer_1.Buffer.concat(h ? [pubKey, h] : [pubKey])
        );
      }
      exports9.tapTweakHash = tapTweakHash;
      function tweakKey(pubKey, h) {
        if (!buffer_1.Buffer.isBuffer(pubKey)) return null;
        if (pubKey.length !== 32) return null;
        if (h && h.length !== 32) return null;
        const tweakHash = tapTweakHash(pubKey, h);
        const res = (0, ecc_lib_1.getEccLib)().xOnlyPointAddTweak(pubKey, tweakHash);
        if (!res || res.xOnlyPubkey === null) return null;
        return {
          parity: res.parity,
          x: buffer_1.Buffer.from(res.xOnlyPubkey)
        };
      }
      exports9.tweakKey = tweakKey;
      function tapBranchHash(a, b) {
        return bcrypto.taggedHash("TapBranch", buffer_1.Buffer.concat([a, b]));
      }
      function serializeScript(s) {
        const varintLen = bufferutils_1.varuint.encodingLength(s.length);
        const buffer = buffer_1.Buffer.allocUnsafe(varintLen);
        bufferutils_1.varuint.encode(s.length, buffer);
        return buffer_1.Buffer.concat([buffer, s]);
      }
    }
  });

  // node_modules/bitcoinjs-lib/src/payments/p2tr.js
  var require_p2tr = __commonJS({
    "node_modules/bitcoinjs-lib/src/payments/p2tr.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.p2tr = void 0;
      var buffer_1 = (init_buffer(), __toCommonJS(buffer_exports));
      var networks_1 = require_networks();
      var bscript = require_script();
      var types_1 = require_types();
      var ecc_lib_1 = require_ecc_lib();
      var bip341_1 = require_bip341();
      var lazy = require_lazy();
      var bech32_1 = require_dist();
      var address_1 = require_address();
      var OPS = bscript.OPS;
      var TAPROOT_WITNESS_VERSION = 1;
      var ANNEX_PREFIX = 80;
      function p2tr(a, opts) {
        if (!a.address && !a.output && !a.pubkey && !a.internalPubkey && !(a.witness && a.witness.length > 1))
          throw new TypeError("Not enough data");
        opts = Object.assign({ validate: true }, opts || {});
        (0, types_1.typeforce)(
          {
            address: types_1.typeforce.maybe(types_1.typeforce.String),
            input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
            internalPubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
            hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
            pubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
            signature: types_1.typeforce.maybe(
              types_1.typeforce.anyOf(
                types_1.typeforce.BufferN(64),
                types_1.typeforce.BufferN(65)
              )
            ),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            ),
            scriptTree: types_1.typeforce.maybe(types_1.isTaptree),
            redeem: types_1.typeforce.maybe({
              output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
              redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),
              witness: types_1.typeforce.maybe(
                types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
              )
            }),
            redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number)
          },
          a
        );
        const _address = lazy.value(() => {
          return (0, address_1.fromBech32)(a.address);
        });
        const _witness = lazy.value(() => {
          if (!a.witness || !a.witness.length) return;
          if (a.witness.length >= 2 && a.witness[a.witness.length - 1][0] === ANNEX_PREFIX) {
            return a.witness.slice(0, -1);
          }
          return a.witness.slice();
        });
        const _hashTree = lazy.value(() => {
          if (a.scriptTree) return (0, bip341_1.toHashTree)(a.scriptTree);
          if (a.hash) return { hash: a.hash };
          return;
        });
        const network = a.network || networks_1.bitcoin;
        const o = { name: "p2tr", network };
        lazy.prop(o, "address", () => {
          if (!o.pubkey) return;
          const words = bech32_1.bech32m.toWords(o.pubkey);
          words.unshift(TAPROOT_WITNESS_VERSION);
          return bech32_1.bech32m.encode(network.bech32, words);
        });
        lazy.prop(o, "hash", () => {
          const hashTree = _hashTree();
          if (hashTree) return hashTree.hash;
          const w = _witness();
          if (w && w.length > 1) {
            const controlBlock = w[w.length - 1];
            const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;
            const script = w[w.length - 2];
            const leafHash = (0, bip341_1.tapleafHash)({
              output: script,
              version: leafVersion
            });
            return (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);
          }
          return null;
        });
        lazy.prop(o, "output", () => {
          if (!o.pubkey) return;
          return bscript.compile([OPS.OP_1, o.pubkey]);
        });
        lazy.prop(o, "redeemVersion", () => {
          if (a.redeemVersion) return a.redeemVersion;
          if (a.redeem && a.redeem.redeemVersion !== void 0 && a.redeem.redeemVersion !== null) {
            return a.redeem.redeemVersion;
          }
          return bip341_1.LEAF_VERSION_TAPSCRIPT;
        });
        lazy.prop(o, "redeem", () => {
          const witness = _witness();
          if (!witness || witness.length < 2) return;
          return {
            output: witness[witness.length - 2],
            witness: witness.slice(0, -2),
            redeemVersion: witness[witness.length - 1][0] & types_1.TAPLEAF_VERSION_MASK
          };
        });
        lazy.prop(o, "pubkey", () => {
          if (a.pubkey) return a.pubkey;
          if (a.output) return a.output.slice(2);
          if (a.address) return _address().data;
          if (o.internalPubkey) {
            const tweakedKey = (0, bip341_1.tweakKey)(o.internalPubkey, o.hash);
            if (tweakedKey) return tweakedKey.x;
          }
        });
        lazy.prop(o, "internalPubkey", () => {
          if (a.internalPubkey) return a.internalPubkey;
          const witness = _witness();
          if (witness && witness.length > 1)
            return witness[witness.length - 1].slice(1, 33);
        });
        lazy.prop(o, "signature", () => {
          if (a.signature) return a.signature;
          const witness = _witness();
          if (!witness || witness.length !== 1) return;
          return witness[0];
        });
        lazy.prop(o, "witness", () => {
          if (a.witness) return a.witness;
          const hashTree = _hashTree();
          if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {
            const leafHash = (0, bip341_1.tapleafHash)({
              output: a.redeem.output,
              version: o.redeemVersion
            });
            const path = (0, bip341_1.findScriptPath)(hashTree, leafHash);
            if (!path) return;
            const outputKey = (0, bip341_1.tweakKey)(a.internalPubkey, hashTree.hash);
            if (!outputKey) return;
            const controlBock = buffer_1.Buffer.concat(
              [
                buffer_1.Buffer.from([o.redeemVersion | outputKey.parity]),
                a.internalPubkey
              ].concat(path)
            );
            return [a.redeem.output, controlBock];
          }
          if (a.signature) return [a.signature];
        });
        if (opts.validate) {
          let pubkey = buffer_1.Buffer.from([]);
          if (a.address) {
            if (network && network.bech32 !== _address().prefix)
              throw new TypeError("Invalid prefix or Network mismatch");
            if (_address().version !== TAPROOT_WITNESS_VERSION)
              throw new TypeError("Invalid address version");
            if (_address().data.length !== 32)
              throw new TypeError("Invalid address data");
            pubkey = _address().data;
          }
          if (a.pubkey) {
            if (pubkey.length > 0 && !pubkey.equals(a.pubkey))
              throw new TypeError("Pubkey mismatch");
            else pubkey = a.pubkey;
          }
          if (a.output) {
            if (a.output.length !== 34 || a.output[0] !== OPS.OP_1 || a.output[1] !== 32)
              throw new TypeError("Output is invalid");
            if (pubkey.length > 0 && !pubkey.equals(a.output.slice(2)))
              throw new TypeError("Pubkey mismatch");
            else pubkey = a.output.slice(2);
          }
          if (a.internalPubkey) {
            const tweakedKey = (0, bip341_1.tweakKey)(a.internalPubkey, o.hash);
            if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x))
              throw new TypeError("Pubkey mismatch");
            else pubkey = tweakedKey.x;
          }
          if (pubkey && pubkey.length) {
            if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(pubkey))
              throw new TypeError("Invalid pubkey for p2tr");
          }
          const hashTree = _hashTree();
          if (a.hash && hashTree) {
            if (!a.hash.equals(hashTree.hash)) throw new TypeError("Hash mismatch");
          }
          if (a.redeem && a.redeem.output && hashTree) {
            const leafHash = (0, bip341_1.tapleafHash)({
              output: a.redeem.output,
              version: o.redeemVersion
            });
            if (!(0, bip341_1.findScriptPath)(hashTree, leafHash))
              throw new TypeError("Redeem script not in tree");
          }
          const witness = _witness();
          if (a.redeem && o.redeem) {
            if (a.redeem.redeemVersion) {
              if (a.redeem.redeemVersion !== o.redeem.redeemVersion)
                throw new TypeError("Redeem.redeemVersion and witness mismatch");
            }
            if (a.redeem.output) {
              if (bscript.decompile(a.redeem.output).length === 0)
                throw new TypeError("Redeem.output is invalid");
              if (o.redeem.output && !a.redeem.output.equals(o.redeem.output))
                throw new TypeError("Redeem.output and witness mismatch");
            }
            if (a.redeem.witness) {
              if (o.redeem.witness && !(0, types_1.stacksEqual)(a.redeem.witness, o.redeem.witness))
                throw new TypeError("Redeem.witness and witness mismatch");
            }
          }
          if (witness && witness.length) {
            if (witness.length === 1) {
              if (a.signature && !a.signature.equals(witness[0]))
                throw new TypeError("Signature mismatch");
            } else {
              const controlBlock = witness[witness.length - 1];
              if (controlBlock.length < 33)
                throw new TypeError(
                  `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`
                );
              if ((controlBlock.length - 33) % 32 !== 0)
                throw new TypeError(
                  `The control-block length of ${controlBlock.length} is incorrect!`
                );
              const m = (controlBlock.length - 33) / 32;
              if (m > 128)
                throw new TypeError(
                  `The script path is too long. Got ${m}, expected max 128.`
                );
              const internalPubkey = controlBlock.slice(1, 33);
              if (a.internalPubkey && !a.internalPubkey.equals(internalPubkey))
                throw new TypeError("Internal pubkey mismatch");
              if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(internalPubkey))
                throw new TypeError("Invalid internalPubkey for p2tr witness");
              const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;
              const script = witness[witness.length - 2];
              const leafHash = (0, bip341_1.tapleafHash)({
                output: script,
                version: leafVersion
              });
              const hash = (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);
              const outputKey = (0, bip341_1.tweakKey)(internalPubkey, hash);
              if (!outputKey)
                throw new TypeError("Invalid outputKey for p2tr witness");
              if (pubkey.length && !pubkey.equals(outputKey.x))
                throw new TypeError("Pubkey mismatch for p2tr witness");
              if (outputKey.parity !== (controlBlock[0] & 1))
                throw new Error("Incorrect parity");
            }
          }
        }
        return Object.assign(o, a);
      }
      exports9.p2tr = p2tr;
    }
  });

  // node_modules/bitcoinjs-lib/src/payments/index.js
  var require_payments = __commonJS({
    "node_modules/bitcoinjs-lib/src/payments/index.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.p2tr = exports9.p2wsh = exports9.p2wpkh = exports9.p2sh = exports9.p2pkh = exports9.p2pk = exports9.p2ms = exports9.embed = void 0;
      var embed_1 = require_embed();
      Object.defineProperty(exports9, "embed", {
        enumerable: true,
        get: function() {
          return embed_1.p2data;
        }
      });
      var p2ms_1 = require_p2ms();
      Object.defineProperty(exports9, "p2ms", {
        enumerable: true,
        get: function() {
          return p2ms_1.p2ms;
        }
      });
      var p2pk_1 = require_p2pk();
      Object.defineProperty(exports9, "p2pk", {
        enumerable: true,
        get: function() {
          return p2pk_1.p2pk;
        }
      });
      var p2pkh_1 = require_p2pkh();
      Object.defineProperty(exports9, "p2pkh", {
        enumerable: true,
        get: function() {
          return p2pkh_1.p2pkh;
        }
      });
      var p2sh_1 = require_p2sh();
      Object.defineProperty(exports9, "p2sh", {
        enumerable: true,
        get: function() {
          return p2sh_1.p2sh;
        }
      });
      var p2wpkh_1 = require_p2wpkh();
      Object.defineProperty(exports9, "p2wpkh", {
        enumerable: true,
        get: function() {
          return p2wpkh_1.p2wpkh;
        }
      });
      var p2wsh_1 = require_p2wsh();
      Object.defineProperty(exports9, "p2wsh", {
        enumerable: true,
        get: function() {
          return p2wsh_1.p2wsh;
        }
      });
      var p2tr_1 = require_p2tr();
      Object.defineProperty(exports9, "p2tr", {
        enumerable: true,
        get: function() {
          return p2tr_1.p2tr;
        }
      });
    }
  });

  // node_modules/bitcoinjs-lib/src/address.js
  var require_address = __commonJS({
    "node_modules/bitcoinjs-lib/src/address.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.toOutputScript = exports9.fromOutputScript = exports9.toBech32 = exports9.toBase58Check = exports9.fromBech32 = exports9.fromBase58Check = void 0;
      var networks = require_networks();
      var payments = require_payments();
      var bscript = require_script();
      var types_1 = require_types();
      var bech32_1 = require_dist();
      var bs58check = require_bs58check();
      var FUTURE_SEGWIT_MAX_SIZE = 40;
      var FUTURE_SEGWIT_MIN_SIZE = 2;
      var FUTURE_SEGWIT_MAX_VERSION = 16;
      var FUTURE_SEGWIT_MIN_VERSION = 2;
      var FUTURE_SEGWIT_VERSION_DIFF = 80;
      var FUTURE_SEGWIT_VERSION_WARNING = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
      function _toFutureSegwitAddress(output, network) {
        const data = output.slice(2);
        if (data.length < FUTURE_SEGWIT_MIN_SIZE || data.length > FUTURE_SEGWIT_MAX_SIZE)
          throw new TypeError("Invalid program length for segwit address");
        const version2 = output[0] - FUTURE_SEGWIT_VERSION_DIFF;
        if (version2 < FUTURE_SEGWIT_MIN_VERSION || version2 > FUTURE_SEGWIT_MAX_VERSION)
          throw new TypeError("Invalid version for segwit address");
        if (output[1] !== data.length)
          throw new TypeError("Invalid script for segwit address");
        console.warn(FUTURE_SEGWIT_VERSION_WARNING);
        return toBech32(data, version2, network.bech32);
      }
      function fromBase58Check(address) {
        const payload = Buffer2.from(bs58check.decode(address));
        if (payload.length < 21) throw new TypeError(address + " is too short");
        if (payload.length > 21) throw new TypeError(address + " is too long");
        const version2 = payload.readUInt8(0);
        const hash = payload.slice(1);
        return { version: version2, hash };
      }
      exports9.fromBase58Check = fromBase58Check;
      function fromBech32(address) {
        let result;
        let version2;
        try {
          result = bech32_1.bech32.decode(address);
        } catch (e) {
        }
        if (result) {
          version2 = result.words[0];
          if (version2 !== 0) throw new TypeError(address + " uses wrong encoding");
        } else {
          result = bech32_1.bech32m.decode(address);
          version2 = result.words[0];
          if (version2 === 0) throw new TypeError(address + " uses wrong encoding");
        }
        const data = bech32_1.bech32.fromWords(result.words.slice(1));
        return {
          version: version2,
          prefix: result.prefix,
          data: Buffer2.from(data)
        };
      }
      exports9.fromBech32 = fromBech32;
      function toBase58Check(hash, version2) {
        (0, types_1.typeforce)(
          (0, types_1.tuple)(types_1.Hash160bit, types_1.UInt8),
          arguments
        );
        const payload = Buffer2.allocUnsafe(21);
        payload.writeUInt8(version2, 0);
        hash.copy(payload, 1);
        return bs58check.encode(payload);
      }
      exports9.toBase58Check = toBase58Check;
      function toBech32(data, version2, prefix) {
        const words = bech32_1.bech32.toWords(data);
        words.unshift(version2);
        return version2 === 0 ? bech32_1.bech32.encode(prefix, words) : bech32_1.bech32m.encode(prefix, words);
      }
      exports9.toBech32 = toBech32;
      function fromOutputScript(output, network) {
        network = network || networks.bitcoin;
        try {
          return payments.p2pkh({ output, network }).address;
        } catch (e) {
        }
        try {
          return payments.p2sh({ output, network }).address;
        } catch (e) {
        }
        try {
          return payments.p2wpkh({ output, network }).address;
        } catch (e) {
        }
        try {
          return payments.p2wsh({ output, network }).address;
        } catch (e) {
        }
        try {
          return payments.p2tr({ output, network }).address;
        } catch (e) {
        }
        try {
          return _toFutureSegwitAddress(output, network);
        } catch (e) {
        }
        throw new Error(bscript.toASM(output) + " has no matching Address");
      }
      exports9.fromOutputScript = fromOutputScript;
      function toOutputScript(address, network) {
        network = network || networks.bitcoin;
        let decodeBase58;
        let decodeBech32;
        try {
          decodeBase58 = fromBase58Check(address);
        } catch (e) {
        }
        if (decodeBase58) {
          if (decodeBase58.version === network.pubKeyHash)
            return payments.p2pkh({ hash: decodeBase58.hash }).output;
          if (decodeBase58.version === network.scriptHash)
            return payments.p2sh({ hash: decodeBase58.hash }).output;
        } else {
          try {
            decodeBech32 = fromBech32(address);
          } catch (e) {
          }
          if (decodeBech32) {
            if (decodeBech32.prefix !== network.bech32)
              throw new Error(address + " has an invalid prefix");
            if (decodeBech32.version === 0) {
              if (decodeBech32.data.length === 20)
                return payments.p2wpkh({ hash: decodeBech32.data }).output;
              if (decodeBech32.data.length === 32)
                return payments.p2wsh({ hash: decodeBech32.data }).output;
            } else if (decodeBech32.version === 1) {
              if (decodeBech32.data.length === 32)
                return payments.p2tr({ pubkey: decodeBech32.data }).output;
            } else if (decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION && decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION && decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE && decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE) {
              console.warn(FUTURE_SEGWIT_VERSION_WARNING);
              return bscript.compile([
                decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,
                decodeBech32.data
              ]);
            }
          }
        }
        throw new Error(address + " has no matching Script");
      }
      exports9.toOutputScript = toOutputScript;
    }
  });

  // node_modules/bitcoinjs-lib/src/merkle.js
  var require_merkle = __commonJS({
    "node_modules/bitcoinjs-lib/src/merkle.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.fastMerkleRoot = void 0;
      function fastMerkleRoot(values, digestFn) {
        if (!Array.isArray(values)) throw TypeError("Expected values Array");
        if (typeof digestFn !== "function")
          throw TypeError("Expected digest Function");
        let length = values.length;
        const results = values.concat();
        while (length > 1) {
          let j = 0;
          for (let i = 0; i < length; i += 2, ++j) {
            const left = results[i];
            const right = i + 1 === length ? left : results[i + 1];
            const data = Buffer2.concat([left, right]);
            results[j] = digestFn(data);
          }
          length = j;
        }
        return results[0];
      }
      exports9.fastMerkleRoot = fastMerkleRoot;
    }
  });

  // node_modules/bitcoinjs-lib/src/transaction.js
  var require_transaction = __commonJS({
    "node_modules/bitcoinjs-lib/src/transaction.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.Transaction = void 0;
      var bufferutils_1 = require_bufferutils();
      var bcrypto = require_crypto2();
      var bscript = require_script();
      var script_1 = require_script();
      var types2 = require_types();
      var { typeforce } = types2;
      function varSliceSize(someScript) {
        const length = someScript.length;
        return bufferutils_1.varuint.encodingLength(length) + length;
      }
      function vectorSize(someVector) {
        const length = someVector.length;
        return bufferutils_1.varuint.encodingLength(length) + someVector.reduce((sum, witness) => {
          return sum + varSliceSize(witness);
        }, 0);
      }
      var EMPTY_BUFFER = Buffer2.allocUnsafe(0);
      var EMPTY_WITNESS = [];
      var ZERO = Buffer2.from(
        "0000000000000000000000000000000000000000000000000000000000000000",
        "hex"
      );
      var ONE = Buffer2.from(
        "0000000000000000000000000000000000000000000000000000000000000001",
        "hex"
      );
      var VALUE_UINT64_MAX = Buffer2.from("ffffffffffffffff", "hex");
      var BLANK_OUTPUT = {
        script: EMPTY_BUFFER,
        valueBuffer: VALUE_UINT64_MAX
      };
      function isOutput(out) {
        return out.value !== void 0;
      }
      var Transaction = class _Transaction {
        constructor() {
          this.version = 1;
          this.locktime = 0;
          this.ins = [];
          this.outs = [];
        }
        static fromBuffer(buffer, _NO_STRICT) {
          const bufferReader = new bufferutils_1.BufferReader(buffer);
          const tx = new _Transaction();
          tx.version = bufferReader.readInt32();
          const marker = bufferReader.readUInt8();
          const flag = bufferReader.readUInt8();
          let hasWitnesses = false;
          if (marker === _Transaction.ADVANCED_TRANSACTION_MARKER && flag === _Transaction.ADVANCED_TRANSACTION_FLAG) {
            hasWitnesses = true;
          } else {
            bufferReader.offset -= 2;
          }
          const vinLen = bufferReader.readVarInt();
          for (let i = 0; i < vinLen; ++i) {
            tx.ins.push({
              hash: bufferReader.readSlice(32),
              index: bufferReader.readUInt32(),
              script: bufferReader.readVarSlice(),
              sequence: bufferReader.readUInt32(),
              witness: EMPTY_WITNESS
            });
          }
          const voutLen = bufferReader.readVarInt();
          for (let i = 0; i < voutLen; ++i) {
            tx.outs.push({
              value: bufferReader.readUInt64(),
              script: bufferReader.readVarSlice()
            });
          }
          if (hasWitnesses) {
            for (let i = 0; i < vinLen; ++i) {
              tx.ins[i].witness = bufferReader.readVector();
            }
            if (!tx.hasWitnesses())
              throw new Error("Transaction has superfluous witness data");
          }
          tx.locktime = bufferReader.readUInt32();
          if (_NO_STRICT) return tx;
          if (bufferReader.offset !== buffer.length)
            throw new Error("Transaction has unexpected data");
          return tx;
        }
        static fromHex(hex) {
          return _Transaction.fromBuffer(Buffer2.from(hex, "hex"), false);
        }
        static isCoinbaseHash(buffer) {
          typeforce(types2.Hash256bit, buffer);
          for (let i = 0; i < 32; ++i) {
            if (buffer[i] !== 0) return false;
          }
          return true;
        }
        isCoinbase() {
          return this.ins.length === 1 && _Transaction.isCoinbaseHash(this.ins[0].hash);
        }
        addInput(hash, index, sequence, scriptSig) {
          typeforce(
            types2.tuple(
              types2.Hash256bit,
              types2.UInt32,
              types2.maybe(types2.UInt32),
              types2.maybe(types2.Buffer)
            ),
            arguments
          );
          if (types2.Null(sequence)) {
            sequence = _Transaction.DEFAULT_SEQUENCE;
          }
          return this.ins.push({
            hash,
            index,
            script: scriptSig || EMPTY_BUFFER,
            sequence,
            witness: EMPTY_WITNESS
          }) - 1;
        }
        addOutput(scriptPubKey, value) {
          typeforce(types2.tuple(types2.Buffer, types2.Satoshi), arguments);
          return this.outs.push({
            script: scriptPubKey,
            value
          }) - 1;
        }
        hasWitnesses() {
          return this.ins.some((x) => {
            return x.witness.length !== 0;
          });
        }
        stripWitnesses() {
          this.ins.forEach((input) => {
            input.witness = EMPTY_WITNESS;
          });
        }
        weight() {
          const base = this.byteLength(false);
          const total = this.byteLength(true);
          return base * 3 + total;
        }
        virtualSize() {
          return Math.ceil(this.weight() / 4);
        }
        byteLength(_ALLOW_WITNESS = true) {
          const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
          return (hasWitnesses ? 10 : 8) + bufferutils_1.varuint.encodingLength(this.ins.length) + bufferutils_1.varuint.encodingLength(this.outs.length) + this.ins.reduce((sum, input) => {
            return sum + 40 + varSliceSize(input.script);
          }, 0) + this.outs.reduce((sum, output) => {
            return sum + 8 + varSliceSize(output.script);
          }, 0) + (hasWitnesses ? this.ins.reduce((sum, input) => {
            return sum + vectorSize(input.witness);
          }, 0) : 0);
        }
        clone() {
          const newTx = new _Transaction();
          newTx.version = this.version;
          newTx.locktime = this.locktime;
          newTx.ins = this.ins.map((txIn) => {
            return {
              hash: txIn.hash,
              index: txIn.index,
              script: txIn.script,
              sequence: txIn.sequence,
              witness: txIn.witness
            };
          });
          newTx.outs = this.outs.map((txOut) => {
            return {
              script: txOut.script,
              value: txOut.value
            };
          });
          return newTx;
        }
        /**
         * Hash transaction for signing a specific input.
         *
         * Bitcoin uses a different hash for each signed transaction input.
         * This method copies the transaction, makes the necessary changes based on the
         * hashType, and then hashes the result.
         * This hash can then be used to sign the provided transaction input.
         */
        hashForSignature(inIndex, prevOutScript, hashType) {
          typeforce(
            types2.tuple(
              types2.UInt32,
              types2.Buffer,
              /* types.UInt8 */
              types2.Number
            ),
            arguments
          );
          if (inIndex >= this.ins.length) return ONE;
          const ourScript = bscript.compile(
            bscript.decompile(prevOutScript).filter((x) => {
              return x !== script_1.OPS.OP_CODESEPARATOR;
            })
          );
          const txTmp = this.clone();
          if ((hashType & 31) === _Transaction.SIGHASH_NONE) {
            txTmp.outs = [];
            txTmp.ins.forEach((input, i) => {
              if (i === inIndex) return;
              input.sequence = 0;
            });
          } else if ((hashType & 31) === _Transaction.SIGHASH_SINGLE) {
            if (inIndex >= this.outs.length) return ONE;
            txTmp.outs.length = inIndex + 1;
            for (let i = 0; i < inIndex; i++) {
              txTmp.outs[i] = BLANK_OUTPUT;
            }
            txTmp.ins.forEach((input, y) => {
              if (y === inIndex) return;
              input.sequence = 0;
            });
          }
          if (hashType & _Transaction.SIGHASH_ANYONECANPAY) {
            txTmp.ins = [txTmp.ins[inIndex]];
            txTmp.ins[0].script = ourScript;
          } else {
            txTmp.ins.forEach((input) => {
              input.script = EMPTY_BUFFER;
            });
            txTmp.ins[inIndex].script = ourScript;
          }
          const buffer = Buffer2.allocUnsafe(txTmp.byteLength(false) + 4);
          buffer.writeInt32LE(hashType, buffer.length - 4);
          txTmp.__toBuffer(buffer, 0, false);
          return bcrypto.hash256(buffer);
        }
        hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {
          typeforce(
            types2.tuple(
              types2.UInt32,
              typeforce.arrayOf(types2.Buffer),
              typeforce.arrayOf(types2.Satoshi),
              types2.UInt32
            ),
            arguments
          );
          if (values.length !== this.ins.length || prevOutScripts.length !== this.ins.length) {
            throw new Error("Must supply prevout script and value for all inputs");
          }
          const outputType = hashType === _Transaction.SIGHASH_DEFAULT ? _Transaction.SIGHASH_ALL : hashType & _Transaction.SIGHASH_OUTPUT_MASK;
          const inputType = hashType & _Transaction.SIGHASH_INPUT_MASK;
          const isAnyoneCanPay = inputType === _Transaction.SIGHASH_ANYONECANPAY;
          const isNone = outputType === _Transaction.SIGHASH_NONE;
          const isSingle = outputType === _Transaction.SIGHASH_SINGLE;
          let hashPrevouts = EMPTY_BUFFER;
          let hashAmounts = EMPTY_BUFFER;
          let hashScriptPubKeys = EMPTY_BUFFER;
          let hashSequences = EMPTY_BUFFER;
          let hashOutputs = EMPTY_BUFFER;
          if (!isAnyoneCanPay) {
            let bufferWriter = bufferutils_1.BufferWriter.withCapacity(
              36 * this.ins.length
            );
            this.ins.forEach((txIn) => {
              bufferWriter.writeSlice(txIn.hash);
              bufferWriter.writeUInt32(txIn.index);
            });
            hashPrevouts = bcrypto.sha256(bufferWriter.end());
            bufferWriter = bufferutils_1.BufferWriter.withCapacity(
              8 * this.ins.length
            );
            values.forEach((value) => bufferWriter.writeUInt64(value));
            hashAmounts = bcrypto.sha256(bufferWriter.end());
            bufferWriter = bufferutils_1.BufferWriter.withCapacity(
              prevOutScripts.map(varSliceSize).reduce((a, b) => a + b)
            );
            prevOutScripts.forEach(
              (prevOutScript) => bufferWriter.writeVarSlice(prevOutScript)
            );
            hashScriptPubKeys = bcrypto.sha256(bufferWriter.end());
            bufferWriter = bufferutils_1.BufferWriter.withCapacity(
              4 * this.ins.length
            );
            this.ins.forEach((txIn) => bufferWriter.writeUInt32(txIn.sequence));
            hashSequences = bcrypto.sha256(bufferWriter.end());
          }
          if (!(isNone || isSingle)) {
            const txOutsSize = this.outs.map((output) => 8 + varSliceSize(output.script)).reduce((a, b) => a + b);
            const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);
            this.outs.forEach((out) => {
              bufferWriter.writeUInt64(out.value);
              bufferWriter.writeVarSlice(out.script);
            });
            hashOutputs = bcrypto.sha256(bufferWriter.end());
          } else if (isSingle && inIndex < this.outs.length) {
            const output = this.outs[inIndex];
            const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
              8 + varSliceSize(output.script)
            );
            bufferWriter.writeUInt64(output.value);
            bufferWriter.writeVarSlice(output.script);
            hashOutputs = bcrypto.sha256(bufferWriter.end());
          }
          const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);
          const sigMsgSize = 174 - (isAnyoneCanPay ? 49 : 0) - (isNone ? 32 : 0) + (annex ? 32 : 0) + (leafHash ? 37 : 0);
          const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);
          sigMsgWriter.writeUInt8(hashType);
          sigMsgWriter.writeInt32(this.version);
          sigMsgWriter.writeUInt32(this.locktime);
          sigMsgWriter.writeSlice(hashPrevouts);
          sigMsgWriter.writeSlice(hashAmounts);
          sigMsgWriter.writeSlice(hashScriptPubKeys);
          sigMsgWriter.writeSlice(hashSequences);
          if (!(isNone || isSingle)) {
            sigMsgWriter.writeSlice(hashOutputs);
          }
          sigMsgWriter.writeUInt8(spendType);
          if (isAnyoneCanPay) {
            const input = this.ins[inIndex];
            sigMsgWriter.writeSlice(input.hash);
            sigMsgWriter.writeUInt32(input.index);
            sigMsgWriter.writeUInt64(values[inIndex]);
            sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);
            sigMsgWriter.writeUInt32(input.sequence);
          } else {
            sigMsgWriter.writeUInt32(inIndex);
          }
          if (annex) {
            const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
              varSliceSize(annex)
            );
            bufferWriter.writeVarSlice(annex);
            sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));
          }
          if (isSingle) {
            sigMsgWriter.writeSlice(hashOutputs);
          }
          if (leafHash) {
            sigMsgWriter.writeSlice(leafHash);
            sigMsgWriter.writeUInt8(0);
            sigMsgWriter.writeUInt32(4294967295);
          }
          return bcrypto.taggedHash(
            "TapSighash",
            Buffer2.concat([Buffer2.from([0]), sigMsgWriter.end()])
          );
        }
        hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
          typeforce(
            types2.tuple(types2.UInt32, types2.Buffer, types2.Satoshi, types2.UInt32),
            arguments
          );
          let tbuffer = Buffer2.from([]);
          let bufferWriter;
          let hashOutputs = ZERO;
          let hashPrevouts = ZERO;
          let hashSequence = ZERO;
          if (!(hashType & _Transaction.SIGHASH_ANYONECANPAY)) {
            tbuffer = Buffer2.allocUnsafe(36 * this.ins.length);
            bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
            this.ins.forEach((txIn) => {
              bufferWriter.writeSlice(txIn.hash);
              bufferWriter.writeUInt32(txIn.index);
            });
            hashPrevouts = bcrypto.hash256(tbuffer);
          }
          if (!(hashType & _Transaction.SIGHASH_ANYONECANPAY) && (hashType & 31) !== _Transaction.SIGHASH_SINGLE && (hashType & 31) !== _Transaction.SIGHASH_NONE) {
            tbuffer = Buffer2.allocUnsafe(4 * this.ins.length);
            bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
            this.ins.forEach((txIn) => {
              bufferWriter.writeUInt32(txIn.sequence);
            });
            hashSequence = bcrypto.hash256(tbuffer);
          }
          if ((hashType & 31) !== _Transaction.SIGHASH_SINGLE && (hashType & 31) !== _Transaction.SIGHASH_NONE) {
            const txOutsSize = this.outs.reduce((sum, output) => {
              return sum + 8 + varSliceSize(output.script);
            }, 0);
            tbuffer = Buffer2.allocUnsafe(txOutsSize);
            bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
            this.outs.forEach((out) => {
              bufferWriter.writeUInt64(out.value);
              bufferWriter.writeVarSlice(out.script);
            });
            hashOutputs = bcrypto.hash256(tbuffer);
          } else if ((hashType & 31) === _Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {
            const output = this.outs[inIndex];
            tbuffer = Buffer2.allocUnsafe(8 + varSliceSize(output.script));
            bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
            bufferWriter.writeUInt64(output.value);
            bufferWriter.writeVarSlice(output.script);
            hashOutputs = bcrypto.hash256(tbuffer);
          }
          tbuffer = Buffer2.allocUnsafe(156 + varSliceSize(prevOutScript));
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          const input = this.ins[inIndex];
          bufferWriter.writeInt32(this.version);
          bufferWriter.writeSlice(hashPrevouts);
          bufferWriter.writeSlice(hashSequence);
          bufferWriter.writeSlice(input.hash);
          bufferWriter.writeUInt32(input.index);
          bufferWriter.writeVarSlice(prevOutScript);
          bufferWriter.writeUInt64(value);
          bufferWriter.writeUInt32(input.sequence);
          bufferWriter.writeSlice(hashOutputs);
          bufferWriter.writeUInt32(this.locktime);
          bufferWriter.writeUInt32(hashType);
          return bcrypto.hash256(tbuffer);
        }
        getHash(forWitness) {
          if (forWitness && this.isCoinbase()) return Buffer2.alloc(32, 0);
          return bcrypto.hash256(this.__toBuffer(void 0, void 0, forWitness));
        }
        getId() {
          return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString(
            "hex"
          );
        }
        toBuffer(buffer, initialOffset) {
          return this.__toBuffer(buffer, initialOffset, true);
        }
        toHex() {
          return this.toBuffer(void 0, void 0).toString("hex");
        }
        setInputScript(index, scriptSig) {
          typeforce(types2.tuple(types2.Number, types2.Buffer), arguments);
          this.ins[index].script = scriptSig;
        }
        setWitness(index, witness) {
          typeforce(types2.tuple(types2.Number, [types2.Buffer]), arguments);
          this.ins[index].witness = witness;
        }
        __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {
          if (!buffer) buffer = Buffer2.allocUnsafe(this.byteLength(_ALLOW_WITNESS));
          const bufferWriter = new bufferutils_1.BufferWriter(
            buffer,
            initialOffset || 0
          );
          bufferWriter.writeInt32(this.version);
          const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
          if (hasWitnesses) {
            bufferWriter.writeUInt8(_Transaction.ADVANCED_TRANSACTION_MARKER);
            bufferWriter.writeUInt8(_Transaction.ADVANCED_TRANSACTION_FLAG);
          }
          bufferWriter.writeVarInt(this.ins.length);
          this.ins.forEach((txIn) => {
            bufferWriter.writeSlice(txIn.hash);
            bufferWriter.writeUInt32(txIn.index);
            bufferWriter.writeVarSlice(txIn.script);
            bufferWriter.writeUInt32(txIn.sequence);
          });
          bufferWriter.writeVarInt(this.outs.length);
          this.outs.forEach((txOut) => {
            if (isOutput(txOut)) {
              bufferWriter.writeUInt64(txOut.value);
            } else {
              bufferWriter.writeSlice(txOut.valueBuffer);
            }
            bufferWriter.writeVarSlice(txOut.script);
          });
          if (hasWitnesses) {
            this.ins.forEach((input) => {
              bufferWriter.writeVector(input.witness);
            });
          }
          bufferWriter.writeUInt32(this.locktime);
          if (initialOffset !== void 0)
            return buffer.slice(initialOffset, bufferWriter.offset);
          return buffer;
        }
      };
      exports9.Transaction = Transaction;
      Transaction.DEFAULT_SEQUENCE = 4294967295;
      Transaction.SIGHASH_DEFAULT = 0;
      Transaction.SIGHASH_ALL = 1;
      Transaction.SIGHASH_NONE = 2;
      Transaction.SIGHASH_SINGLE = 3;
      Transaction.SIGHASH_ANYONECANPAY = 128;
      Transaction.SIGHASH_OUTPUT_MASK = 3;
      Transaction.SIGHASH_INPUT_MASK = 128;
      Transaction.ADVANCED_TRANSACTION_MARKER = 0;
      Transaction.ADVANCED_TRANSACTION_FLAG = 1;
    }
  });

  // node_modules/bitcoinjs-lib/src/block.js
  var require_block = __commonJS({
    "node_modules/bitcoinjs-lib/src/block.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.Block = void 0;
      var bufferutils_1 = require_bufferutils();
      var bcrypto = require_crypto2();
      var merkle_1 = require_merkle();
      var transaction_1 = require_transaction();
      var types2 = require_types();
      var { typeforce } = types2;
      var errorMerkleNoTxes = new TypeError(
        "Cannot compute merkle root for zero transactions"
      );
      var errorWitnessNotSegwit = new TypeError(
        "Cannot compute witness commit for non-segwit block"
      );
      var Block = class _Block {
        constructor() {
          this.version = 1;
          this.prevHash = void 0;
          this.merkleRoot = void 0;
          this.timestamp = 0;
          this.witnessCommit = void 0;
          this.bits = 0;
          this.nonce = 0;
          this.transactions = void 0;
        }
        static fromBuffer(buffer) {
          if (buffer.length < 80) throw new Error("Buffer too small (< 80 bytes)");
          const bufferReader = new bufferutils_1.BufferReader(buffer);
          const block = new _Block();
          block.version = bufferReader.readInt32();
          block.prevHash = bufferReader.readSlice(32);
          block.merkleRoot = bufferReader.readSlice(32);
          block.timestamp = bufferReader.readUInt32();
          block.bits = bufferReader.readUInt32();
          block.nonce = bufferReader.readUInt32();
          if (buffer.length === 80) return block;
          const readTransaction = () => {
            const tx = transaction_1.Transaction.fromBuffer(
              bufferReader.buffer.slice(bufferReader.offset),
              true
            );
            bufferReader.offset += tx.byteLength();
            return tx;
          };
          const nTransactions = bufferReader.readVarInt();
          block.transactions = [];
          for (let i = 0; i < nTransactions; ++i) {
            const tx = readTransaction();
            block.transactions.push(tx);
          }
          const witnessCommit = block.getWitnessCommit();
          if (witnessCommit) block.witnessCommit = witnessCommit;
          return block;
        }
        static fromHex(hex) {
          return _Block.fromBuffer(Buffer2.from(hex, "hex"));
        }
        static calculateTarget(bits) {
          const exponent = ((bits & 4278190080) >> 24) - 3;
          const mantissa = bits & 8388607;
          const target = Buffer2.alloc(32, 0);
          target.writeUIntBE(mantissa, 29 - exponent, 3);
          return target;
        }
        static calculateMerkleRoot(transactions, forWitness) {
          typeforce([{ getHash: types2.Function }], transactions);
          if (transactions.length === 0) throw errorMerkleNoTxes;
          if (forWitness && !txesHaveWitnessCommit(transactions))
            throw errorWitnessNotSegwit;
          const hashes = transactions.map(
            (transaction) => transaction.getHash(forWitness)
          );
          const rootHash = (0, merkle_1.fastMerkleRoot)(hashes, bcrypto.hash256);
          return forWitness ? bcrypto.hash256(
            Buffer2.concat([rootHash, transactions[0].ins[0].witness[0]])
          ) : rootHash;
        }
        getWitnessCommit() {
          if (!txesHaveWitnessCommit(this.transactions)) return null;
          const witnessCommits = this.transactions[0].outs.filter(
            (out) => out.script.slice(0, 6).equals(Buffer2.from("6a24aa21a9ed", "hex"))
          ).map((out) => out.script.slice(6, 38));
          if (witnessCommits.length === 0) return null;
          const result = witnessCommits[witnessCommits.length - 1];
          if (!(result instanceof Buffer2 && result.length === 32)) return null;
          return result;
        }
        hasWitnessCommit() {
          if (this.witnessCommit instanceof Buffer2 && this.witnessCommit.length === 32)
            return true;
          if (this.getWitnessCommit() !== null) return true;
          return false;
        }
        hasWitness() {
          return anyTxHasWitness(this.transactions);
        }
        weight() {
          const base = this.byteLength(false, false);
          const total = this.byteLength(false, true);
          return base * 3 + total;
        }
        byteLength(headersOnly, allowWitness = true) {
          if (headersOnly || !this.transactions) return 80;
          return 80 + bufferutils_1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0);
        }
        getHash() {
          return bcrypto.hash256(this.toBuffer(true));
        }
        getId() {
          return (0, bufferutils_1.reverseBuffer)(this.getHash()).toString("hex");
        }
        getUTCDate() {
          const date = /* @__PURE__ */ new Date(0);
          date.setUTCSeconds(this.timestamp);
          return date;
        }
        // TODO: buffer, offset compatibility
        toBuffer(headersOnly) {
          const buffer = Buffer2.allocUnsafe(this.byteLength(headersOnly));
          const bufferWriter = new bufferutils_1.BufferWriter(buffer);
          bufferWriter.writeInt32(this.version);
          bufferWriter.writeSlice(this.prevHash);
          bufferWriter.writeSlice(this.merkleRoot);
          bufferWriter.writeUInt32(this.timestamp);
          bufferWriter.writeUInt32(this.bits);
          bufferWriter.writeUInt32(this.nonce);
          if (headersOnly || !this.transactions) return buffer;
          bufferutils_1.varuint.encode(
            this.transactions.length,
            buffer,
            bufferWriter.offset
          );
          bufferWriter.offset += bufferutils_1.varuint.encode.bytes;
          this.transactions.forEach((tx) => {
            const txSize = tx.byteLength();
            tx.toBuffer(buffer, bufferWriter.offset);
            bufferWriter.offset += txSize;
          });
          return buffer;
        }
        toHex(headersOnly) {
          return this.toBuffer(headersOnly).toString("hex");
        }
        checkTxRoots() {
          const hasWitnessCommit = this.hasWitnessCommit();
          if (!hasWitnessCommit && this.hasWitness()) return false;
          return this.__checkMerkleRoot() && (hasWitnessCommit ? this.__checkWitnessCommit() : true);
        }
        checkProofOfWork() {
          const hash = (0, bufferutils_1.reverseBuffer)(this.getHash());
          const target = _Block.calculateTarget(this.bits);
          return hash.compare(target) <= 0;
        }
        __checkMerkleRoot() {
          if (!this.transactions) throw errorMerkleNoTxes;
          const actualMerkleRoot = _Block.calculateMerkleRoot(this.transactions);
          return this.merkleRoot.compare(actualMerkleRoot) === 0;
        }
        __checkWitnessCommit() {
          if (!this.transactions) throw errorMerkleNoTxes;
          if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
          const actualWitnessCommit = _Block.calculateMerkleRoot(
            this.transactions,
            true
          );
          return this.witnessCommit.compare(actualWitnessCommit) === 0;
        }
      };
      exports9.Block = Block;
      function txesHaveWitnessCommit(transactions) {
        return transactions instanceof Array && transactions[0] && transactions[0].ins && transactions[0].ins instanceof Array && transactions[0].ins[0] && transactions[0].ins[0].witness && transactions[0].ins[0].witness instanceof Array && transactions[0].ins[0].witness.length > 0;
      }
      function anyTxHasWitness(transactions) {
        return transactions instanceof Array && transactions.some(
          (tx) => typeof tx === "object" && tx.ins instanceof Array && tx.ins.some(
            (input) => typeof input === "object" && input.witness instanceof Array && input.witness.length > 0
          )
        );
      }
    }
  });

  // node_modules/bip174/src/lib/typeFields.js
  var require_typeFields = __commonJS({
    "node_modules/bip174/src/lib/typeFields.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var GlobalTypes;
      (function(GlobalTypes2) {
        GlobalTypes2[GlobalTypes2["UNSIGNED_TX"] = 0] = "UNSIGNED_TX";
        GlobalTypes2[GlobalTypes2["GLOBAL_XPUB"] = 1] = "GLOBAL_XPUB";
      })(GlobalTypes = exports9.GlobalTypes || (exports9.GlobalTypes = {}));
      exports9.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"];
      var InputTypes;
      (function(InputTypes2) {
        InputTypes2[InputTypes2["NON_WITNESS_UTXO"] = 0] = "NON_WITNESS_UTXO";
        InputTypes2[InputTypes2["WITNESS_UTXO"] = 1] = "WITNESS_UTXO";
        InputTypes2[InputTypes2["PARTIAL_SIG"] = 2] = "PARTIAL_SIG";
        InputTypes2[InputTypes2["SIGHASH_TYPE"] = 3] = "SIGHASH_TYPE";
        InputTypes2[InputTypes2["REDEEM_SCRIPT"] = 4] = "REDEEM_SCRIPT";
        InputTypes2[InputTypes2["WITNESS_SCRIPT"] = 5] = "WITNESS_SCRIPT";
        InputTypes2[InputTypes2["BIP32_DERIVATION"] = 6] = "BIP32_DERIVATION";
        InputTypes2[InputTypes2["FINAL_SCRIPTSIG"] = 7] = "FINAL_SCRIPTSIG";
        InputTypes2[InputTypes2["FINAL_SCRIPTWITNESS"] = 8] = "FINAL_SCRIPTWITNESS";
        InputTypes2[InputTypes2["POR_COMMITMENT"] = 9] = "POR_COMMITMENT";
        InputTypes2[InputTypes2["TAP_KEY_SIG"] = 19] = "TAP_KEY_SIG";
        InputTypes2[InputTypes2["TAP_SCRIPT_SIG"] = 20] = "TAP_SCRIPT_SIG";
        InputTypes2[InputTypes2["TAP_LEAF_SCRIPT"] = 21] = "TAP_LEAF_SCRIPT";
        InputTypes2[InputTypes2["TAP_BIP32_DERIVATION"] = 22] = "TAP_BIP32_DERIVATION";
        InputTypes2[InputTypes2["TAP_INTERNAL_KEY"] = 23] = "TAP_INTERNAL_KEY";
        InputTypes2[InputTypes2["TAP_MERKLE_ROOT"] = 24] = "TAP_MERKLE_ROOT";
      })(InputTypes = exports9.InputTypes || (exports9.InputTypes = {}));
      exports9.INPUT_TYPE_NAMES = [
        "nonWitnessUtxo",
        "witnessUtxo",
        "partialSig",
        "sighashType",
        "redeemScript",
        "witnessScript",
        "bip32Derivation",
        "finalScriptSig",
        "finalScriptWitness",
        "porCommitment",
        "tapKeySig",
        "tapScriptSig",
        "tapLeafScript",
        "tapBip32Derivation",
        "tapInternalKey",
        "tapMerkleRoot"
      ];
      var OutputTypes;
      (function(OutputTypes2) {
        OutputTypes2[OutputTypes2["REDEEM_SCRIPT"] = 0] = "REDEEM_SCRIPT";
        OutputTypes2[OutputTypes2["WITNESS_SCRIPT"] = 1] = "WITNESS_SCRIPT";
        OutputTypes2[OutputTypes2["BIP32_DERIVATION"] = 2] = "BIP32_DERIVATION";
        OutputTypes2[OutputTypes2["TAP_INTERNAL_KEY"] = 5] = "TAP_INTERNAL_KEY";
        OutputTypes2[OutputTypes2["TAP_TREE"] = 6] = "TAP_TREE";
        OutputTypes2[OutputTypes2["TAP_BIP32_DERIVATION"] = 7] = "TAP_BIP32_DERIVATION";
      })(OutputTypes = exports9.OutputTypes || (exports9.OutputTypes = {}));
      exports9.OUTPUT_TYPE_NAMES = [
        "redeemScript",
        "witnessScript",
        "bip32Derivation",
        "tapInternalKey",
        "tapTree",
        "tapBip32Derivation"
      ];
    }
  });

  // node_modules/bip174/src/lib/converter/global/globalXpub.js
  var require_globalXpub = __commonJS({
    "node_modules/bip174/src/lib/converter/global/globalXpub.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var typeFields_1 = require_typeFields();
      var range = (n) => [...Array(n).keys()];
      function decode(keyVal) {
        if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {
          throw new Error(
            "Decode Error: could not decode globalXpub with key 0x" + keyVal.key.toString("hex")
          );
        }
        if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {
          throw new Error(
            "Decode Error: globalXpub has invalid extended pubkey in key 0x" + keyVal.key.toString("hex")
          );
        }
        if (keyVal.value.length / 4 % 1 !== 0) {
          throw new Error(
            "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
          );
        }
        const extendedPubkey = keyVal.key.slice(1);
        const data = {
          masterFingerprint: keyVal.value.slice(0, 4),
          extendedPubkey,
          path: "m"
        };
        for (const i of range(keyVal.value.length / 4 - 1)) {
          const val = keyVal.value.readUInt32LE(i * 4 + 4);
          const isHard = !!(val & 2147483648);
          const idx = val & 2147483647;
          data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
        }
        return data;
      }
      exports9.decode = decode;
      function encode(data) {
        const head = Buffer2.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);
        const key = Buffer2.concat([head, data.extendedPubkey]);
        const splitPath = data.path.split("/");
        const value = Buffer2.allocUnsafe(splitPath.length * 4);
        data.masterFingerprint.copy(value, 0);
        let offset = 4;
        splitPath.slice(1).forEach((level) => {
          const isHard = level.slice(-1) === "'";
          let num = 2147483647 & parseInt(isHard ? level.slice(0, -1) : level, 10);
          if (isHard) num += 2147483648;
          value.writeUInt32LE(num, offset);
          offset += 4;
        });
        return {
          key,
          value
        };
      }
      exports9.encode = encode;
      exports9.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
      function check(data) {
        const epk = data.extendedPubkey;
        const mfp = data.masterFingerprint;
        const p = data.path;
        return Buffer2.isBuffer(epk) && epk.length === 78 && [2, 3].indexOf(epk[45]) > -1 && Buffer2.isBuffer(mfp) && mfp.length === 4 && typeof p === "string" && !!p.match(/^m(\/\d+'?)*$/);
      }
      exports9.check = check;
      function canAddToArray(array, item, dupeSet) {
        const dupeString = item.extendedPubkey.toString("hex");
        if (dupeSet.has(dupeString)) return false;
        dupeSet.add(dupeString);
        return array.filter((v) => v.extendedPubkey.equals(item.extendedPubkey)).length === 0;
      }
      exports9.canAddToArray = canAddToArray;
    }
  });

  // node_modules/bip174/src/lib/converter/global/unsignedTx.js
  var require_unsignedTx = __commonJS({
    "node_modules/bip174/src/lib/converter/global/unsignedTx.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var typeFields_1 = require_typeFields();
      function encode(data) {
        return {
          key: Buffer2.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),
          value: data.toBuffer()
        };
      }
      exports9.encode = encode;
    }
  });

  // node_modules/bip174/src/lib/converter/input/finalScriptSig.js
  var require_finalScriptSig = __commonJS({
    "node_modules/bip174/src/lib/converter/input/finalScriptSig.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var typeFields_1 = require_typeFields();
      function decode(keyVal) {
        if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {
          throw new Error(
            "Decode Error: could not decode finalScriptSig with key 0x" + keyVal.key.toString("hex")
          );
        }
        return keyVal.value;
      }
      exports9.decode = decode;
      function encode(data) {
        const key = Buffer2.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);
        return {
          key,
          value: data
        };
      }
      exports9.encode = encode;
      exports9.expected = "Buffer";
      function check(data) {
        return Buffer2.isBuffer(data);
      }
      exports9.check = check;
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.finalScriptSig === void 0;
      }
      exports9.canAdd = canAdd;
    }
  });

  // node_modules/bip174/src/lib/converter/input/finalScriptWitness.js
  var require_finalScriptWitness = __commonJS({
    "node_modules/bip174/src/lib/converter/input/finalScriptWitness.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var typeFields_1 = require_typeFields();
      function decode(keyVal) {
        if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {
          throw new Error(
            "Decode Error: could not decode finalScriptWitness with key 0x" + keyVal.key.toString("hex")
          );
        }
        return keyVal.value;
      }
      exports9.decode = decode;
      function encode(data) {
        const key = Buffer2.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);
        return {
          key,
          value: data
        };
      }
      exports9.encode = encode;
      exports9.expected = "Buffer";
      function check(data) {
        return Buffer2.isBuffer(data);
      }
      exports9.check = check;
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.finalScriptWitness === void 0;
      }
      exports9.canAdd = canAdd;
    }
  });

  // node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js
  var require_nonWitnessUtxo = __commonJS({
    "node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var typeFields_1 = require_typeFields();
      function decode(keyVal) {
        if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {
          throw new Error(
            "Decode Error: could not decode nonWitnessUtxo with key 0x" + keyVal.key.toString("hex")
          );
        }
        return keyVal.value;
      }
      exports9.decode = decode;
      function encode(data) {
        return {
          key: Buffer2.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),
          value: data
        };
      }
      exports9.encode = encode;
      exports9.expected = "Buffer";
      function check(data) {
        return Buffer2.isBuffer(data);
      }
      exports9.check = check;
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.nonWitnessUtxo === void 0;
      }
      exports9.canAdd = canAdd;
    }
  });

  // node_modules/bip174/src/lib/converter/input/partialSig.js
  var require_partialSig = __commonJS({
    "node_modules/bip174/src/lib/converter/input/partialSig.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var typeFields_1 = require_typeFields();
      function decode(keyVal) {
        if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {
          throw new Error(
            "Decode Error: could not decode partialSig with key 0x" + keyVal.key.toString("hex")
          );
        }
        if (!(keyVal.key.length === 34 || keyVal.key.length === 66) || ![2, 3, 4].includes(keyVal.key[1])) {
          throw new Error(
            "Decode Error: partialSig has invalid pubkey in key 0x" + keyVal.key.toString("hex")
          );
        }
        const pubkey = keyVal.key.slice(1);
        return {
          pubkey,
          signature: keyVal.value
        };
      }
      exports9.decode = decode;
      function encode(pSig) {
        const head = Buffer2.from([typeFields_1.InputTypes.PARTIAL_SIG]);
        return {
          key: Buffer2.concat([head, pSig.pubkey]),
          value: pSig.signature
        };
      }
      exports9.encode = encode;
      exports9.expected = "{ pubkey: Buffer; signature: Buffer; }";
      function check(data) {
        return Buffer2.isBuffer(data.pubkey) && Buffer2.isBuffer(data.signature) && [33, 65].includes(data.pubkey.length) && [2, 3, 4].includes(data.pubkey[0]) && isDerSigWithSighash(data.signature);
      }
      exports9.check = check;
      function isDerSigWithSighash(buf) {
        if (!Buffer2.isBuffer(buf) || buf.length < 9) return false;
        if (buf[0] !== 48) return false;
        if (buf.length !== buf[1] + 3) return false;
        if (buf[2] !== 2) return false;
        const rLen = buf[3];
        if (rLen > 33 || rLen < 1) return false;
        if (buf[3 + rLen + 1] !== 2) return false;
        const sLen = buf[3 + rLen + 2];
        if (sLen > 33 || sLen < 1) return false;
        if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;
        return true;
      }
      function canAddToArray(array, item, dupeSet) {
        const dupeString = item.pubkey.toString("hex");
        if (dupeSet.has(dupeString)) return false;
        dupeSet.add(dupeString);
        return array.filter((v) => v.pubkey.equals(item.pubkey)).length === 0;
      }
      exports9.canAddToArray = canAddToArray;
    }
  });

  // node_modules/bip174/src/lib/converter/input/porCommitment.js
  var require_porCommitment = __commonJS({
    "node_modules/bip174/src/lib/converter/input/porCommitment.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var typeFields_1 = require_typeFields();
      function decode(keyVal) {
        if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {
          throw new Error(
            "Decode Error: could not decode porCommitment with key 0x" + keyVal.key.toString("hex")
          );
        }
        return keyVal.value.toString("utf8");
      }
      exports9.decode = decode;
      function encode(data) {
        const key = Buffer2.from([typeFields_1.InputTypes.POR_COMMITMENT]);
        return {
          key,
          value: Buffer2.from(data, "utf8")
        };
      }
      exports9.encode = encode;
      exports9.expected = "string";
      function check(data) {
        return typeof data === "string";
      }
      exports9.check = check;
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.porCommitment === void 0;
      }
      exports9.canAdd = canAdd;
    }
  });

  // node_modules/bip174/src/lib/converter/input/sighashType.js
  var require_sighashType = __commonJS({
    "node_modules/bip174/src/lib/converter/input/sighashType.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var typeFields_1 = require_typeFields();
      function decode(keyVal) {
        if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {
          throw new Error(
            "Decode Error: could not decode sighashType with key 0x" + keyVal.key.toString("hex")
          );
        }
        return keyVal.value.readUInt32LE(0);
      }
      exports9.decode = decode;
      function encode(data) {
        const key = Buffer2.from([typeFields_1.InputTypes.SIGHASH_TYPE]);
        const value = Buffer2.allocUnsafe(4);
        value.writeUInt32LE(data, 0);
        return {
          key,
          value
        };
      }
      exports9.encode = encode;
      exports9.expected = "number";
      function check(data) {
        return typeof data === "number";
      }
      exports9.check = check;
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.sighashType === void 0;
      }
      exports9.canAdd = canAdd;
    }
  });

  // node_modules/bip174/src/lib/converter/input/tapKeySig.js
  var require_tapKeySig = __commonJS({
    "node_modules/bip174/src/lib/converter/input/tapKeySig.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var typeFields_1 = require_typeFields();
      function decode(keyVal) {
        if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_KEY_SIG || keyVal.key.length !== 1) {
          throw new Error(
            "Decode Error: could not decode tapKeySig with key 0x" + keyVal.key.toString("hex")
          );
        }
        if (!check(keyVal.value)) {
          throw new Error(
            "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
          );
        }
        return keyVal.value;
      }
      exports9.decode = decode;
      function encode(value) {
        const key = Buffer2.from([typeFields_1.InputTypes.TAP_KEY_SIG]);
        return { key, value };
      }
      exports9.encode = encode;
      exports9.expected = "Buffer";
      function check(data) {
        return Buffer2.isBuffer(data) && (data.length === 64 || data.length === 65);
      }
      exports9.check = check;
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.tapKeySig === void 0;
      }
      exports9.canAdd = canAdd;
    }
  });

  // node_modules/bip174/src/lib/converter/input/tapLeafScript.js
  var require_tapLeafScript = __commonJS({
    "node_modules/bip174/src/lib/converter/input/tapLeafScript.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var typeFields_1 = require_typeFields();
      function decode(keyVal) {
        if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_LEAF_SCRIPT) {
          throw new Error(
            "Decode Error: could not decode tapLeafScript with key 0x" + keyVal.key.toString("hex")
          );
        }
        if ((keyVal.key.length - 2) % 32 !== 0) {
          throw new Error(
            "Decode Error: tapLeafScript has invalid control block in key 0x" + keyVal.key.toString("hex")
          );
        }
        const leafVersion = keyVal.value[keyVal.value.length - 1];
        if ((keyVal.key[1] & 254) !== leafVersion) {
          throw new Error(
            "Decode Error: tapLeafScript bad leaf version in key 0x" + keyVal.key.toString("hex")
          );
        }
        const script = keyVal.value.slice(0, -1);
        const controlBlock = keyVal.key.slice(1);
        return { controlBlock, script, leafVersion };
      }
      exports9.decode = decode;
      function encode(tScript) {
        const head = Buffer2.from([typeFields_1.InputTypes.TAP_LEAF_SCRIPT]);
        const verBuf = Buffer2.from([tScript.leafVersion]);
        return {
          key: Buffer2.concat([head, tScript.controlBlock]),
          value: Buffer2.concat([tScript.script, verBuf])
        };
      }
      exports9.encode = encode;
      exports9.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
      function check(data) {
        return Buffer2.isBuffer(data.controlBlock) && (data.controlBlock.length - 1) % 32 === 0 && (data.controlBlock[0] & 254) === data.leafVersion && Buffer2.isBuffer(data.script);
      }
      exports9.check = check;
      function canAddToArray(array, item, dupeSet) {
        const dupeString = item.controlBlock.toString("hex");
        if (dupeSet.has(dupeString)) return false;
        dupeSet.add(dupeString);
        return array.filter((v) => v.controlBlock.equals(item.controlBlock)).length === 0;
      }
      exports9.canAddToArray = canAddToArray;
    }
  });

  // node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js
  var require_tapMerkleRoot = __commonJS({
    "node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var typeFields_1 = require_typeFields();
      function decode(keyVal) {
        if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_MERKLE_ROOT || keyVal.key.length !== 1) {
          throw new Error(
            "Decode Error: could not decode tapMerkleRoot with key 0x" + keyVal.key.toString("hex")
          );
        }
        if (!check(keyVal.value)) {
          throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
        }
        return keyVal.value;
      }
      exports9.decode = decode;
      function encode(value) {
        const key = Buffer2.from([typeFields_1.InputTypes.TAP_MERKLE_ROOT]);
        return { key, value };
      }
      exports9.encode = encode;
      exports9.expected = "Buffer";
      function check(data) {
        return Buffer2.isBuffer(data) && data.length === 32;
      }
      exports9.check = check;
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.tapMerkleRoot === void 0;
      }
      exports9.canAdd = canAdd;
    }
  });

  // node_modules/bip174/src/lib/converter/input/tapScriptSig.js
  var require_tapScriptSig = __commonJS({
    "node_modules/bip174/src/lib/converter/input/tapScriptSig.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var typeFields_1 = require_typeFields();
      function decode(keyVal) {
        if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_SCRIPT_SIG) {
          throw new Error(
            "Decode Error: could not decode tapScriptSig with key 0x" + keyVal.key.toString("hex")
          );
        }
        if (keyVal.key.length !== 65) {
          throw new Error(
            "Decode Error: tapScriptSig has invalid key 0x" + keyVal.key.toString("hex")
          );
        }
        if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {
          throw new Error(
            "Decode Error: tapScriptSig has invalid signature in key 0x" + keyVal.key.toString("hex")
          );
        }
        const pubkey = keyVal.key.slice(1, 33);
        const leafHash = keyVal.key.slice(33);
        return {
          pubkey,
          leafHash,
          signature: keyVal.value
        };
      }
      exports9.decode = decode;
      function encode(tSig) {
        const head = Buffer2.from([typeFields_1.InputTypes.TAP_SCRIPT_SIG]);
        return {
          key: Buffer2.concat([head, tSig.pubkey, tSig.leafHash]),
          value: tSig.signature
        };
      }
      exports9.encode = encode;
      exports9.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
      function check(data) {
        return Buffer2.isBuffer(data.pubkey) && Buffer2.isBuffer(data.leafHash) && Buffer2.isBuffer(data.signature) && data.pubkey.length === 32 && data.leafHash.length === 32 && (data.signature.length === 64 || data.signature.length === 65);
      }
      exports9.check = check;
      function canAddToArray(array, item, dupeSet) {
        const dupeString = item.pubkey.toString("hex") + item.leafHash.toString("hex");
        if (dupeSet.has(dupeString)) return false;
        dupeSet.add(dupeString);
        return array.filter(
          (v) => v.pubkey.equals(item.pubkey) && v.leafHash.equals(item.leafHash)
        ).length === 0;
      }
      exports9.canAddToArray = canAddToArray;
    }
  });

  // node_modules/bip174/src/lib/converter/varint.js
  var require_varint = __commonJS({
    "node_modules/bip174/src/lib/converter/varint.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var MAX_SAFE_INTEGER = 9007199254740991;
      function checkUInt53(n) {
        if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)
          throw new RangeError("value out of range");
      }
      function encode(_number, buffer, offset) {
        checkUInt53(_number);
        if (!buffer) buffer = Buffer2.allocUnsafe(encodingLength(_number));
        if (!Buffer2.isBuffer(buffer))
          throw new TypeError("buffer must be a Buffer instance");
        if (!offset) offset = 0;
        if (_number < 253) {
          buffer.writeUInt8(_number, offset);
          Object.assign(encode, { bytes: 1 });
        } else if (_number <= 65535) {
          buffer.writeUInt8(253, offset);
          buffer.writeUInt16LE(_number, offset + 1);
          Object.assign(encode, { bytes: 3 });
        } else if (_number <= 4294967295) {
          buffer.writeUInt8(254, offset);
          buffer.writeUInt32LE(_number, offset + 1);
          Object.assign(encode, { bytes: 5 });
        } else {
          buffer.writeUInt8(255, offset);
          buffer.writeUInt32LE(_number >>> 0, offset + 1);
          buffer.writeUInt32LE(_number / 4294967296 | 0, offset + 5);
          Object.assign(encode, { bytes: 9 });
        }
        return buffer;
      }
      exports9.encode = encode;
      function decode(buffer, offset) {
        if (!Buffer2.isBuffer(buffer))
          throw new TypeError("buffer must be a Buffer instance");
        if (!offset) offset = 0;
        const first = buffer.readUInt8(offset);
        if (first < 253) {
          Object.assign(decode, { bytes: 1 });
          return first;
        } else if (first === 253) {
          Object.assign(decode, { bytes: 3 });
          return buffer.readUInt16LE(offset + 1);
        } else if (first === 254) {
          Object.assign(decode, { bytes: 5 });
          return buffer.readUInt32LE(offset + 1);
        } else {
          Object.assign(decode, { bytes: 9 });
          const lo = buffer.readUInt32LE(offset + 1);
          const hi = buffer.readUInt32LE(offset + 5);
          const _number = hi * 4294967296 + lo;
          checkUInt53(_number);
          return _number;
        }
      }
      exports9.decode = decode;
      function encodingLength(_number) {
        checkUInt53(_number);
        return _number < 253 ? 1 : _number <= 65535 ? 3 : _number <= 4294967295 ? 5 : 9;
      }
      exports9.encodingLength = encodingLength;
    }
  });

  // node_modules/bip174/src/lib/converter/tools.js
  var require_tools = __commonJS({
    "node_modules/bip174/src/lib/converter/tools.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var varuint = require_varint();
      exports9.range = (n) => [...Array(n).keys()];
      function reverseBuffer(buffer) {
        if (buffer.length < 1) return buffer;
        let j = buffer.length - 1;
        let tmp = 0;
        for (let i = 0; i < buffer.length / 2; i++) {
          tmp = buffer[i];
          buffer[i] = buffer[j];
          buffer[j] = tmp;
          j--;
        }
        return buffer;
      }
      exports9.reverseBuffer = reverseBuffer;
      function keyValsToBuffer(keyVals) {
        const buffers = keyVals.map(keyValToBuffer);
        buffers.push(Buffer2.from([0]));
        return Buffer2.concat(buffers);
      }
      exports9.keyValsToBuffer = keyValsToBuffer;
      function keyValToBuffer(keyVal) {
        const keyLen = keyVal.key.length;
        const valLen = keyVal.value.length;
        const keyVarIntLen = varuint.encodingLength(keyLen);
        const valVarIntLen = varuint.encodingLength(valLen);
        const buffer = Buffer2.allocUnsafe(
          keyVarIntLen + keyLen + valVarIntLen + valLen
        );
        varuint.encode(keyLen, buffer, 0);
        keyVal.key.copy(buffer, keyVarIntLen);
        varuint.encode(valLen, buffer, keyVarIntLen + keyLen);
        keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);
        return buffer;
      }
      exports9.keyValToBuffer = keyValToBuffer;
      function verifuint(value, max) {
        if (typeof value !== "number")
          throw new Error("cannot write a non-number as a number");
        if (value < 0)
          throw new Error("specified a negative value for writing an unsigned value");
        if (value > max) throw new Error("RangeError: value out of range");
        if (Math.floor(value) !== value)
          throw new Error("value has a fractional component");
      }
      function readUInt64LE(buffer, offset) {
        const a = buffer.readUInt32LE(offset);
        let b = buffer.readUInt32LE(offset + 4);
        b *= 4294967296;
        verifuint(b + a, 9007199254740991);
        return b + a;
      }
      exports9.readUInt64LE = readUInt64LE;
      function writeUInt64LE(buffer, value, offset) {
        verifuint(value, 9007199254740991);
        buffer.writeInt32LE(value & -1, offset);
        buffer.writeUInt32LE(Math.floor(value / 4294967296), offset + 4);
        return offset + 8;
      }
      exports9.writeUInt64LE = writeUInt64LE;
    }
  });

  // node_modules/bip174/src/lib/converter/input/witnessUtxo.js
  var require_witnessUtxo = __commonJS({
    "node_modules/bip174/src/lib/converter/input/witnessUtxo.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var typeFields_1 = require_typeFields();
      var tools_1 = require_tools();
      var varuint = require_varint();
      function decode(keyVal) {
        if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {
          throw new Error(
            "Decode Error: could not decode witnessUtxo with key 0x" + keyVal.key.toString("hex")
          );
        }
        const value = tools_1.readUInt64LE(keyVal.value, 0);
        let _offset = 8;
        const scriptLen = varuint.decode(keyVal.value, _offset);
        _offset += varuint.encodingLength(scriptLen);
        const script = keyVal.value.slice(_offset);
        if (script.length !== scriptLen) {
          throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
        }
        return {
          script,
          value
        };
      }
      exports9.decode = decode;
      function encode(data) {
        const { script, value } = data;
        const varintLen = varuint.encodingLength(script.length);
        const result = Buffer2.allocUnsafe(8 + varintLen + script.length);
        tools_1.writeUInt64LE(result, value, 0);
        varuint.encode(script.length, result, 8);
        script.copy(result, 8 + varintLen);
        return {
          key: Buffer2.from([typeFields_1.InputTypes.WITNESS_UTXO]),
          value: result
        };
      }
      exports9.encode = encode;
      exports9.expected = "{ script: Buffer; value: number; }";
      function check(data) {
        return Buffer2.isBuffer(data.script) && typeof data.value === "number";
      }
      exports9.check = check;
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.witnessUtxo === void 0;
      }
      exports9.canAdd = canAdd;
    }
  });

  // node_modules/bip174/src/lib/converter/output/tapTree.js
  var require_tapTree = __commonJS({
    "node_modules/bip174/src/lib/converter/output/tapTree.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var typeFields_1 = require_typeFields();
      var varuint = require_varint();
      function decode(keyVal) {
        if (keyVal.key[0] !== typeFields_1.OutputTypes.TAP_TREE || keyVal.key.length !== 1) {
          throw new Error(
            "Decode Error: could not decode tapTree with key 0x" + keyVal.key.toString("hex")
          );
        }
        let _offset = 0;
        const data = [];
        while (_offset < keyVal.value.length) {
          const depth = keyVal.value[_offset++];
          const leafVersion = keyVal.value[_offset++];
          const scriptLen = varuint.decode(keyVal.value, _offset);
          _offset += varuint.encodingLength(scriptLen);
          data.push({
            depth,
            leafVersion,
            script: keyVal.value.slice(_offset, _offset + scriptLen)
          });
          _offset += scriptLen;
        }
        return { leaves: data };
      }
      exports9.decode = decode;
      function encode(tree) {
        const key = Buffer2.from([typeFields_1.OutputTypes.TAP_TREE]);
        const bufs = [].concat(
          ...tree.leaves.map((tapLeaf) => [
            Buffer2.of(tapLeaf.depth, tapLeaf.leafVersion),
            varuint.encode(tapLeaf.script.length),
            tapLeaf.script
          ])
        );
        return {
          key,
          value: Buffer2.concat(bufs)
        };
      }
      exports9.encode = encode;
      exports9.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
      function check(data) {
        return Array.isArray(data.leaves) && data.leaves.every(
          (tapLeaf) => tapLeaf.depth >= 0 && tapLeaf.depth <= 128 && (tapLeaf.leafVersion & 254) === tapLeaf.leafVersion && Buffer2.isBuffer(tapLeaf.script)
        );
      }
      exports9.check = check;
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.tapTree === void 0;
      }
      exports9.canAdd = canAdd;
    }
  });

  // node_modules/bip174/src/lib/converter/shared/bip32Derivation.js
  var require_bip32Derivation = __commonJS({
    "node_modules/bip174/src/lib/converter/shared/bip32Derivation.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var range = (n) => [...Array(n).keys()];
      var isValidDERKey = (pubkey) => pubkey.length === 33 && [2, 3].includes(pubkey[0]) || pubkey.length === 65 && 4 === pubkey[0];
      function makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {
        function decode(keyVal) {
          if (keyVal.key[0] !== TYPE_BYTE) {
            throw new Error(
              "Decode Error: could not decode bip32Derivation with key 0x" + keyVal.key.toString("hex")
            );
          }
          const pubkey = keyVal.key.slice(1);
          if (!isValidPubkey(pubkey)) {
            throw new Error(
              "Decode Error: bip32Derivation has invalid pubkey in key 0x" + keyVal.key.toString("hex")
            );
          }
          if (keyVal.value.length / 4 % 1 !== 0) {
            throw new Error(
              "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
            );
          }
          const data = {
            masterFingerprint: keyVal.value.slice(0, 4),
            pubkey,
            path: "m"
          };
          for (const i of range(keyVal.value.length / 4 - 1)) {
            const val = keyVal.value.readUInt32LE(i * 4 + 4);
            const isHard = !!(val & 2147483648);
            const idx = val & 2147483647;
            data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
          }
          return data;
        }
        function encode(data) {
          const head = Buffer2.from([TYPE_BYTE]);
          const key = Buffer2.concat([head, data.pubkey]);
          const splitPath = data.path.split("/");
          const value = Buffer2.allocUnsafe(splitPath.length * 4);
          data.masterFingerprint.copy(value, 0);
          let offset = 4;
          splitPath.slice(1).forEach((level) => {
            const isHard = level.slice(-1) === "'";
            let num = 2147483647 & parseInt(isHard ? level.slice(0, -1) : level, 10);
            if (isHard) num += 2147483648;
            value.writeUInt32LE(num, offset);
            offset += 4;
          });
          return {
            key,
            value
          };
        }
        const expected = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
        function check(data) {
          return Buffer2.isBuffer(data.pubkey) && Buffer2.isBuffer(data.masterFingerprint) && typeof data.path === "string" && isValidPubkey(data.pubkey) && data.masterFingerprint.length === 4;
        }
        function canAddToArray(array, item, dupeSet) {
          const dupeString = item.pubkey.toString("hex");
          if (dupeSet.has(dupeString)) return false;
          dupeSet.add(dupeString);
          return array.filter((v) => v.pubkey.equals(item.pubkey)).length === 0;
        }
        return {
          decode,
          encode,
          check,
          expected,
          canAddToArray
        };
      }
      exports9.makeConverter = makeConverter;
    }
  });

  // node_modules/bip174/src/lib/converter/shared/checkPubkey.js
  var require_checkPubkey = __commonJS({
    "node_modules/bip174/src/lib/converter/shared/checkPubkey.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      function makeChecker(pubkeyTypes) {
        return checkPubkey;
        function checkPubkey(keyVal) {
          let pubkey;
          if (pubkeyTypes.includes(keyVal.key[0])) {
            pubkey = keyVal.key.slice(1);
            if (!(pubkey.length === 33 || pubkey.length === 65) || ![2, 3, 4].includes(pubkey[0])) {
              throw new Error(
                "Format Error: invalid pubkey in key 0x" + keyVal.key.toString("hex")
              );
            }
          }
          return pubkey;
        }
      }
      exports9.makeChecker = makeChecker;
    }
  });

  // node_modules/bip174/src/lib/converter/shared/redeemScript.js
  var require_redeemScript = __commonJS({
    "node_modules/bip174/src/lib/converter/shared/redeemScript.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      function makeConverter(TYPE_BYTE) {
        function decode(keyVal) {
          if (keyVal.key[0] !== TYPE_BYTE) {
            throw new Error(
              "Decode Error: could not decode redeemScript with key 0x" + keyVal.key.toString("hex")
            );
          }
          return keyVal.value;
        }
        function encode(data) {
          const key = Buffer2.from([TYPE_BYTE]);
          return {
            key,
            value: data
          };
        }
        const expected = "Buffer";
        function check(data) {
          return Buffer2.isBuffer(data);
        }
        function canAdd(currentData, newData) {
          return !!currentData && !!newData && currentData.redeemScript === void 0;
        }
        return {
          decode,
          encode,
          check,
          expected,
          canAdd
        };
      }
      exports9.makeConverter = makeConverter;
    }
  });

  // node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js
  var require_tapBip32Derivation = __commonJS({
    "node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var varuint = require_varint();
      var bip32Derivation = require_bip32Derivation();
      var isValidBIP340Key = (pubkey) => pubkey.length === 32;
      function makeConverter(TYPE_BYTE) {
        const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);
        function decode(keyVal) {
          const nHashes = varuint.decode(keyVal.value);
          const nHashesLen = varuint.encodingLength(nHashes);
          const base = parent.decode({
            key: keyVal.key,
            value: keyVal.value.slice(nHashesLen + nHashes * 32)
          });
          const leafHashes = new Array(nHashes);
          for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {
            leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);
          }
          return Object.assign({}, base, { leafHashes });
        }
        function encode(data) {
          const base = parent.encode(data);
          const nHashesLen = varuint.encodingLength(data.leafHashes.length);
          const nHashesBuf = Buffer2.allocUnsafe(nHashesLen);
          varuint.encode(data.leafHashes.length, nHashesBuf);
          const value = Buffer2.concat([nHashesBuf, ...data.leafHashes, base.value]);
          return Object.assign({}, base, { value });
        }
        const expected = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
        function check(data) {
          return Array.isArray(data.leafHashes) && data.leafHashes.every(
            (leafHash) => Buffer2.isBuffer(leafHash) && leafHash.length === 32
          ) && parent.check(data);
        }
        return {
          decode,
          encode,
          check,
          expected,
          canAddToArray: parent.canAddToArray
        };
      }
      exports9.makeConverter = makeConverter;
    }
  });

  // node_modules/bip174/src/lib/converter/shared/tapInternalKey.js
  var require_tapInternalKey = __commonJS({
    "node_modules/bip174/src/lib/converter/shared/tapInternalKey.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      function makeConverter(TYPE_BYTE) {
        function decode(keyVal) {
          if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {
            throw new Error(
              "Decode Error: could not decode tapInternalKey with key 0x" + keyVal.key.toString("hex")
            );
          }
          if (keyVal.value.length !== 32) {
            throw new Error(
              "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
            );
          }
          return keyVal.value;
        }
        function encode(value) {
          const key = Buffer2.from([TYPE_BYTE]);
          return { key, value };
        }
        const expected = "Buffer";
        function check(data) {
          return Buffer2.isBuffer(data) && data.length === 32;
        }
        function canAdd(currentData, newData) {
          return !!currentData && !!newData && currentData.tapInternalKey === void 0;
        }
        return {
          decode,
          encode,
          check,
          expected,
          canAdd
        };
      }
      exports9.makeConverter = makeConverter;
    }
  });

  // node_modules/bip174/src/lib/converter/shared/witnessScript.js
  var require_witnessScript = __commonJS({
    "node_modules/bip174/src/lib/converter/shared/witnessScript.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      function makeConverter(TYPE_BYTE) {
        function decode(keyVal) {
          if (keyVal.key[0] !== TYPE_BYTE) {
            throw new Error(
              "Decode Error: could not decode witnessScript with key 0x" + keyVal.key.toString("hex")
            );
          }
          return keyVal.value;
        }
        function encode(data) {
          const key = Buffer2.from([TYPE_BYTE]);
          return {
            key,
            value: data
          };
        }
        const expected = "Buffer";
        function check(data) {
          return Buffer2.isBuffer(data);
        }
        function canAdd(currentData, newData) {
          return !!currentData && !!newData && currentData.witnessScript === void 0;
        }
        return {
          decode,
          encode,
          check,
          expected,
          canAdd
        };
      }
      exports9.makeConverter = makeConverter;
    }
  });

  // node_modules/bip174/src/lib/converter/index.js
  var require_converter = __commonJS({
    "node_modules/bip174/src/lib/converter/index.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var typeFields_1 = require_typeFields();
      var globalXpub = require_globalXpub();
      var unsignedTx = require_unsignedTx();
      var finalScriptSig = require_finalScriptSig();
      var finalScriptWitness = require_finalScriptWitness();
      var nonWitnessUtxo = require_nonWitnessUtxo();
      var partialSig = require_partialSig();
      var porCommitment = require_porCommitment();
      var sighashType = require_sighashType();
      var tapKeySig = require_tapKeySig();
      var tapLeafScript = require_tapLeafScript();
      var tapMerkleRoot = require_tapMerkleRoot();
      var tapScriptSig = require_tapScriptSig();
      var witnessUtxo = require_witnessUtxo();
      var tapTree = require_tapTree();
      var bip32Derivation = require_bip32Derivation();
      var checkPubkey = require_checkPubkey();
      var redeemScript = require_redeemScript();
      var tapBip32Derivation = require_tapBip32Derivation();
      var tapInternalKey = require_tapInternalKey();
      var witnessScript = require_witnessScript();
      var globals = {
        unsignedTx,
        globalXpub,
        // pass an Array of key bytes that require pubkey beside the key
        checkPubkey: checkPubkey.makeChecker([])
      };
      exports9.globals = globals;
      var inputs = {
        nonWitnessUtxo,
        partialSig,
        sighashType,
        finalScriptSig,
        finalScriptWitness,
        porCommitment,
        witnessUtxo,
        bip32Derivation: bip32Derivation.makeConverter(
          typeFields_1.InputTypes.BIP32_DERIVATION
        ),
        redeemScript: redeemScript.makeConverter(
          typeFields_1.InputTypes.REDEEM_SCRIPT
        ),
        witnessScript: witnessScript.makeConverter(
          typeFields_1.InputTypes.WITNESS_SCRIPT
        ),
        checkPubkey: checkPubkey.makeChecker([
          typeFields_1.InputTypes.PARTIAL_SIG,
          typeFields_1.InputTypes.BIP32_DERIVATION
        ]),
        tapKeySig,
        tapScriptSig,
        tapLeafScript,
        tapBip32Derivation: tapBip32Derivation.makeConverter(
          typeFields_1.InputTypes.TAP_BIP32_DERIVATION
        ),
        tapInternalKey: tapInternalKey.makeConverter(
          typeFields_1.InputTypes.TAP_INTERNAL_KEY
        ),
        tapMerkleRoot
      };
      exports9.inputs = inputs;
      var outputs = {
        bip32Derivation: bip32Derivation.makeConverter(
          typeFields_1.OutputTypes.BIP32_DERIVATION
        ),
        redeemScript: redeemScript.makeConverter(
          typeFields_1.OutputTypes.REDEEM_SCRIPT
        ),
        witnessScript: witnessScript.makeConverter(
          typeFields_1.OutputTypes.WITNESS_SCRIPT
        ),
        checkPubkey: checkPubkey.makeChecker([
          typeFields_1.OutputTypes.BIP32_DERIVATION
        ]),
        tapBip32Derivation: tapBip32Derivation.makeConverter(
          typeFields_1.OutputTypes.TAP_BIP32_DERIVATION
        ),
        tapTree,
        tapInternalKey: tapInternalKey.makeConverter(
          typeFields_1.OutputTypes.TAP_INTERNAL_KEY
        )
      };
      exports9.outputs = outputs;
    }
  });

  // node_modules/bip174/src/lib/parser/fromBuffer.js
  var require_fromBuffer = __commonJS({
    "node_modules/bip174/src/lib/parser/fromBuffer.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var convert = require_converter();
      var tools_1 = require_tools();
      var varuint = require_varint();
      var typeFields_1 = require_typeFields();
      function psbtFromBuffer(buffer, txGetter) {
        let offset = 0;
        function varSlice() {
          const keyLen = varuint.decode(buffer, offset);
          offset += varuint.encodingLength(keyLen);
          const key = buffer.slice(offset, offset + keyLen);
          offset += keyLen;
          return key;
        }
        function readUInt32BE() {
          const num = buffer.readUInt32BE(offset);
          offset += 4;
          return num;
        }
        function readUInt82() {
          const num = buffer.readUInt8(offset);
          offset += 1;
          return num;
        }
        function getKeyValue() {
          const key = varSlice();
          const value = varSlice();
          return {
            key,
            value
          };
        }
        function checkEndOfKeyValPairs() {
          if (offset >= buffer.length) {
            throw new Error("Format Error: Unexpected End of PSBT");
          }
          const isEnd = buffer.readUInt8(offset) === 0;
          if (isEnd) {
            offset++;
          }
          return isEnd;
        }
        if (readUInt32BE() !== 1886610036) {
          throw new Error("Format Error: Invalid Magic Number");
        }
        if (readUInt82() !== 255) {
          throw new Error(
            "Format Error: Magic Number must be followed by 0xff separator"
          );
        }
        const globalMapKeyVals = [];
        const globalKeyIndex = {};
        while (!checkEndOfKeyValPairs()) {
          const keyVal = getKeyValue();
          const hexKey = keyVal.key.toString("hex");
          if (globalKeyIndex[hexKey]) {
            throw new Error(
              "Format Error: Keys must be unique for global keymap: key " + hexKey
            );
          }
          globalKeyIndex[hexKey] = 1;
          globalMapKeyVals.push(keyVal);
        }
        const unsignedTxMaps = globalMapKeyVals.filter(
          (keyVal) => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX
        );
        if (unsignedTxMaps.length !== 1) {
          throw new Error("Format Error: Only one UNSIGNED_TX allowed");
        }
        const unsignedTx = txGetter(unsignedTxMaps[0].value);
        const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();
        const inputKeyVals = [];
        const outputKeyVals = [];
        for (const index of tools_1.range(inputCount)) {
          const inputKeyIndex = {};
          const input = [];
          while (!checkEndOfKeyValPairs()) {
            const keyVal = getKeyValue();
            const hexKey = keyVal.key.toString("hex");
            if (inputKeyIndex[hexKey]) {
              throw new Error(
                "Format Error: Keys must be unique for each input: input index " + index + " key " + hexKey
              );
            }
            inputKeyIndex[hexKey] = 1;
            input.push(keyVal);
          }
          inputKeyVals.push(input);
        }
        for (const index of tools_1.range(outputCount)) {
          const outputKeyIndex = {};
          const output = [];
          while (!checkEndOfKeyValPairs()) {
            const keyVal = getKeyValue();
            const hexKey = keyVal.key.toString("hex");
            if (outputKeyIndex[hexKey]) {
              throw new Error(
                "Format Error: Keys must be unique for each output: output index " + index + " key " + hexKey
              );
            }
            outputKeyIndex[hexKey] = 1;
            output.push(keyVal);
          }
          outputKeyVals.push(output);
        }
        return psbtFromKeyVals(unsignedTx, {
          globalMapKeyVals,
          inputKeyVals,
          outputKeyVals
        });
      }
      exports9.psbtFromBuffer = psbtFromBuffer;
      function checkKeyBuffer(type, keyBuf, keyNum) {
        if (!keyBuf.equals(Buffer2.from([keyNum]))) {
          throw new Error(
            `Format Error: Invalid ${type} key: ${keyBuf.toString("hex")}`
          );
        }
      }
      exports9.checkKeyBuffer = checkKeyBuffer;
      function psbtFromKeyVals(unsignedTx, { globalMapKeyVals, inputKeyVals, outputKeyVals }) {
        const globalMap = {
          unsignedTx
        };
        let txCount = 0;
        for (const keyVal of globalMapKeyVals) {
          switch (keyVal.key[0]) {
            case typeFields_1.GlobalTypes.UNSIGNED_TX:
              checkKeyBuffer(
                "global",
                keyVal.key,
                typeFields_1.GlobalTypes.UNSIGNED_TX
              );
              if (txCount > 0) {
                throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
              }
              txCount++;
              break;
            case typeFields_1.GlobalTypes.GLOBAL_XPUB:
              if (globalMap.globalXpub === void 0) {
                globalMap.globalXpub = [];
              }
              globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));
              break;
            default:
              if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];
              globalMap.unknownKeyVals.push(keyVal);
          }
        }
        const inputCount = inputKeyVals.length;
        const outputCount = outputKeyVals.length;
        const inputs = [];
        const outputs = [];
        for (const index of tools_1.range(inputCount)) {
          const input = {};
          for (const keyVal of inputKeyVals[index]) {
            convert.inputs.checkPubkey(keyVal);
            switch (keyVal.key[0]) {
              case typeFields_1.InputTypes.NON_WITNESS_UTXO:
                checkKeyBuffer(
                  "input",
                  keyVal.key,
                  typeFields_1.InputTypes.NON_WITNESS_UTXO
                );
                if (input.nonWitnessUtxo !== void 0) {
                  throw new Error(
                    "Format Error: Input has multiple NON_WITNESS_UTXO"
                  );
                }
                input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);
                break;
              case typeFields_1.InputTypes.WITNESS_UTXO:
                checkKeyBuffer(
                  "input",
                  keyVal.key,
                  typeFields_1.InputTypes.WITNESS_UTXO
                );
                if (input.witnessUtxo !== void 0) {
                  throw new Error("Format Error: Input has multiple WITNESS_UTXO");
                }
                input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);
                break;
              case typeFields_1.InputTypes.PARTIAL_SIG:
                if (input.partialSig === void 0) {
                  input.partialSig = [];
                }
                input.partialSig.push(convert.inputs.partialSig.decode(keyVal));
                break;
              case typeFields_1.InputTypes.SIGHASH_TYPE:
                checkKeyBuffer(
                  "input",
                  keyVal.key,
                  typeFields_1.InputTypes.SIGHASH_TYPE
                );
                if (input.sighashType !== void 0) {
                  throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
                }
                input.sighashType = convert.inputs.sighashType.decode(keyVal);
                break;
              case typeFields_1.InputTypes.REDEEM_SCRIPT:
                checkKeyBuffer(
                  "input",
                  keyVal.key,
                  typeFields_1.InputTypes.REDEEM_SCRIPT
                );
                if (input.redeemScript !== void 0) {
                  throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
                }
                input.redeemScript = convert.inputs.redeemScript.decode(keyVal);
                break;
              case typeFields_1.InputTypes.WITNESS_SCRIPT:
                checkKeyBuffer(
                  "input",
                  keyVal.key,
                  typeFields_1.InputTypes.WITNESS_SCRIPT
                );
                if (input.witnessScript !== void 0) {
                  throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
                }
                input.witnessScript = convert.inputs.witnessScript.decode(keyVal);
                break;
              case typeFields_1.InputTypes.BIP32_DERIVATION:
                if (input.bip32Derivation === void 0) {
                  input.bip32Derivation = [];
                }
                input.bip32Derivation.push(
                  convert.inputs.bip32Derivation.decode(keyVal)
                );
                break;
              case typeFields_1.InputTypes.FINAL_SCRIPTSIG:
                checkKeyBuffer(
                  "input",
                  keyVal.key,
                  typeFields_1.InputTypes.FINAL_SCRIPTSIG
                );
                input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);
                break;
              case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:
                checkKeyBuffer(
                  "input",
                  keyVal.key,
                  typeFields_1.InputTypes.FINAL_SCRIPTWITNESS
                );
                input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(
                  keyVal
                );
                break;
              case typeFields_1.InputTypes.POR_COMMITMENT:
                checkKeyBuffer(
                  "input",
                  keyVal.key,
                  typeFields_1.InputTypes.POR_COMMITMENT
                );
                input.porCommitment = convert.inputs.porCommitment.decode(keyVal);
                break;
              case typeFields_1.InputTypes.TAP_KEY_SIG:
                checkKeyBuffer(
                  "input",
                  keyVal.key,
                  typeFields_1.InputTypes.TAP_KEY_SIG
                );
                input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);
                break;
              case typeFields_1.InputTypes.TAP_SCRIPT_SIG:
                if (input.tapScriptSig === void 0) {
                  input.tapScriptSig = [];
                }
                input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));
                break;
              case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:
                if (input.tapLeafScript === void 0) {
                  input.tapLeafScript = [];
                }
                input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));
                break;
              case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:
                if (input.tapBip32Derivation === void 0) {
                  input.tapBip32Derivation = [];
                }
                input.tapBip32Derivation.push(
                  convert.inputs.tapBip32Derivation.decode(keyVal)
                );
                break;
              case typeFields_1.InputTypes.TAP_INTERNAL_KEY:
                checkKeyBuffer(
                  "input",
                  keyVal.key,
                  typeFields_1.InputTypes.TAP_INTERNAL_KEY
                );
                input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);
                break;
              case typeFields_1.InputTypes.TAP_MERKLE_ROOT:
                checkKeyBuffer(
                  "input",
                  keyVal.key,
                  typeFields_1.InputTypes.TAP_MERKLE_ROOT
                );
                input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);
                break;
              default:
                if (!input.unknownKeyVals) input.unknownKeyVals = [];
                input.unknownKeyVals.push(keyVal);
            }
          }
          inputs.push(input);
        }
        for (const index of tools_1.range(outputCount)) {
          const output = {};
          for (const keyVal of outputKeyVals[index]) {
            convert.outputs.checkPubkey(keyVal);
            switch (keyVal.key[0]) {
              case typeFields_1.OutputTypes.REDEEM_SCRIPT:
                checkKeyBuffer(
                  "output",
                  keyVal.key,
                  typeFields_1.OutputTypes.REDEEM_SCRIPT
                );
                if (output.redeemScript !== void 0) {
                  throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
                }
                output.redeemScript = convert.outputs.redeemScript.decode(keyVal);
                break;
              case typeFields_1.OutputTypes.WITNESS_SCRIPT:
                checkKeyBuffer(
                  "output",
                  keyVal.key,
                  typeFields_1.OutputTypes.WITNESS_SCRIPT
                );
                if (output.witnessScript !== void 0) {
                  throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
                }
                output.witnessScript = convert.outputs.witnessScript.decode(keyVal);
                break;
              case typeFields_1.OutputTypes.BIP32_DERIVATION:
                if (output.bip32Derivation === void 0) {
                  output.bip32Derivation = [];
                }
                output.bip32Derivation.push(
                  convert.outputs.bip32Derivation.decode(keyVal)
                );
                break;
              case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:
                checkKeyBuffer(
                  "output",
                  keyVal.key,
                  typeFields_1.OutputTypes.TAP_INTERNAL_KEY
                );
                output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);
                break;
              case typeFields_1.OutputTypes.TAP_TREE:
                checkKeyBuffer(
                  "output",
                  keyVal.key,
                  typeFields_1.OutputTypes.TAP_TREE
                );
                output.tapTree = convert.outputs.tapTree.decode(keyVal);
                break;
              case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:
                if (output.tapBip32Derivation === void 0) {
                  output.tapBip32Derivation = [];
                }
                output.tapBip32Derivation.push(
                  convert.outputs.tapBip32Derivation.decode(keyVal)
                );
                break;
              default:
                if (!output.unknownKeyVals) output.unknownKeyVals = [];
                output.unknownKeyVals.push(keyVal);
            }
          }
          outputs.push(output);
        }
        return { globalMap, inputs, outputs };
      }
      exports9.psbtFromKeyVals = psbtFromKeyVals;
    }
  });

  // node_modules/bip174/src/lib/parser/toBuffer.js
  var require_toBuffer = __commonJS({
    "node_modules/bip174/src/lib/parser/toBuffer.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var convert = require_converter();
      var tools_1 = require_tools();
      function psbtToBuffer({ globalMap, inputs, outputs }) {
        const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({
          globalMap,
          inputs,
          outputs
        });
        const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);
        const keyValsOrEmptyToBuffer = (keyVals) => keyVals.length === 0 ? [Buffer2.from([0])] : keyVals.map(tools_1.keyValsToBuffer);
        const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);
        const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);
        const header = Buffer2.allocUnsafe(5);
        header.writeUIntBE(482972169471, 0, 5);
        return Buffer2.concat(
          [header, globalBuffer].concat(inputBuffers, outputBuffers)
        );
      }
      exports9.psbtToBuffer = psbtToBuffer;
      var sortKeyVals = (a, b) => {
        return a.key.compare(b.key);
      };
      function keyValsFromMap(keyValMap, converterFactory) {
        const keyHexSet = /* @__PURE__ */ new Set();
        const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {
          if (key === "unknownKeyVals") return result;
          const converter = converterFactory[key];
          if (converter === void 0) return result;
          const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(
            converter.encode
          );
          const keyHexes = encodedKeyVals.map((kv) => kv.key.toString("hex"));
          keyHexes.forEach((hex) => {
            if (keyHexSet.has(hex))
              throw new Error("Serialize Error: Duplicate key: " + hex);
            keyHexSet.add(hex);
          });
          return result.concat(encodedKeyVals);
        }, []);
        const otherKeyVals = keyValMap.unknownKeyVals ? keyValMap.unknownKeyVals.filter((keyVal) => {
          return !keyHexSet.has(keyVal.key.toString("hex"));
        }) : [];
        return keyVals.concat(otherKeyVals).sort(sortKeyVals);
      }
      function psbtToKeyVals({ globalMap, inputs, outputs }) {
        return {
          globalKeyVals: keyValsFromMap(globalMap, convert.globals),
          inputKeyVals: inputs.map((i) => keyValsFromMap(i, convert.inputs)),
          outputKeyVals: outputs.map((o) => keyValsFromMap(o, convert.outputs))
        };
      }
      exports9.psbtToKeyVals = psbtToKeyVals;
    }
  });

  // node_modules/bip174/src/lib/parser/index.js
  var require_parser = __commonJS({
    "node_modules/bip174/src/lib/parser/index.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      function __export2(m) {
        for (var p in m) if (!exports9.hasOwnProperty(p)) exports9[p] = m[p];
      }
      Object.defineProperty(exports9, "__esModule", { value: true });
      __export2(require_fromBuffer());
      __export2(require_toBuffer());
    }
  });

  // node_modules/bip174/src/lib/combiner/index.js
  var require_combiner = __commonJS({
    "node_modules/bip174/src/lib/combiner/index.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var parser_1 = require_parser();
      function combine(psbts) {
        const self2 = psbts[0];
        const selfKeyVals = parser_1.psbtToKeyVals(self2);
        const others = psbts.slice(1);
        if (others.length === 0) throw new Error("Combine: Nothing to combine");
        const selfTx = getTx(self2);
        if (selfTx === void 0) {
          throw new Error("Combine: Self missing transaction");
        }
        const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);
        const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);
        const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);
        for (const other of others) {
          const otherTx = getTx(other);
          if (otherTx === void 0 || !otherTx.toBuffer().equals(selfTx.toBuffer())) {
            throw new Error(
              "Combine: One of the Psbts does not have the same transaction."
            );
          }
          const otherKeyVals = parser_1.psbtToKeyVals(other);
          const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);
          otherGlobalSet.forEach(
            keyPusher(
              selfGlobalSet,
              selfKeyVals.globalKeyVals,
              otherKeyVals.globalKeyVals
            )
          );
          const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);
          otherInputSets.forEach(
            (inputSet, idx) => inputSet.forEach(
              keyPusher(
                selfInputSets[idx],
                selfKeyVals.inputKeyVals[idx],
                otherKeyVals.inputKeyVals[idx]
              )
            )
          );
          const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);
          otherOutputSets.forEach(
            (outputSet, idx) => outputSet.forEach(
              keyPusher(
                selfOutputSets[idx],
                selfKeyVals.outputKeyVals[idx],
                otherKeyVals.outputKeyVals[idx]
              )
            )
          );
        }
        return parser_1.psbtFromKeyVals(selfTx, {
          globalMapKeyVals: selfKeyVals.globalKeyVals,
          inputKeyVals: selfKeyVals.inputKeyVals,
          outputKeyVals: selfKeyVals.outputKeyVals
        });
      }
      exports9.combine = combine;
      function keyPusher(selfSet, selfKeyVals, otherKeyVals) {
        return (key) => {
          if (selfSet.has(key)) return;
          const newKv = otherKeyVals.filter((kv) => kv.key.toString("hex") === key)[0];
          selfKeyVals.push(newKv);
          selfSet.add(key);
        };
      }
      function getTx(psbt) {
        return psbt.globalMap.unsignedTx;
      }
      function getKeySet(keyVals) {
        const set = /* @__PURE__ */ new Set();
        keyVals.forEach((keyVal) => {
          const hex = keyVal.key.toString("hex");
          if (set.has(hex))
            throw new Error("Combine: KeyValue Map keys should be unique");
          set.add(hex);
        });
        return set;
      }
    }
  });

  // node_modules/bip174/src/lib/utils.js
  var require_utils2 = __commonJS({
    "node_modules/bip174/src/lib/utils.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var converter = require_converter();
      function checkForInput(inputs, inputIndex) {
        const input = inputs[inputIndex];
        if (input === void 0) throw new Error(`No input #${inputIndex}`);
        return input;
      }
      exports9.checkForInput = checkForInput;
      function checkForOutput(outputs, outputIndex) {
        const output = outputs[outputIndex];
        if (output === void 0) throw new Error(`No output #${outputIndex}`);
        return output;
      }
      exports9.checkForOutput = checkForOutput;
      function checkHasKey(checkKeyVal, keyVals, enumLength) {
        if (checkKeyVal.key[0] < enumLength) {
          throw new Error(
            `Use the method for your specific key instead of addUnknownKeyVal*`
          );
        }
        if (keyVals && keyVals.filter((kv) => kv.key.equals(checkKeyVal.key)).length !== 0) {
          throw new Error(`Duplicate Key: ${checkKeyVal.key.toString("hex")}`);
        }
      }
      exports9.checkHasKey = checkHasKey;
      function getEnumLength(myenum) {
        let count = 0;
        Object.keys(myenum).forEach((val) => {
          if (Number(isNaN(Number(val)))) {
            count++;
          }
        });
        return count;
      }
      exports9.getEnumLength = getEnumLength;
      function inputCheckUncleanFinalized(inputIndex, input) {
        let result = false;
        if (input.nonWitnessUtxo || input.witnessUtxo) {
          const needScriptSig = !!input.redeemScript;
          const needWitnessScript = !!input.witnessScript;
          const scriptSigOK = !needScriptSig || !!input.finalScriptSig;
          const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;
          const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;
          result = scriptSigOK && witnessScriptOK && hasOneFinal;
        }
        if (result === false) {
          throw new Error(
            `Input #${inputIndex} has too much or too little data to clean`
          );
        }
      }
      exports9.inputCheckUncleanFinalized = inputCheckUncleanFinalized;
      function throwForUpdateMaker(typeName, name2, expected, data) {
        throw new Error(
          `Data for ${typeName} key ${name2} is incorrect: Expected ${expected} and got ${JSON.stringify(data)}`
        );
      }
      function updateMaker(typeName) {
        return (updateData, mainData) => {
          for (const name2 of Object.keys(updateData)) {
            const data = updateData[name2];
            const { canAdd, canAddToArray, check, expected } = (
              // @ts-ignore
              converter[typeName + "s"][name2] || {}
            );
            const isArray2 = !!canAddToArray;
            if (check) {
              if (isArray2) {
                if (!Array.isArray(data) || // @ts-ignore
                mainData[name2] && !Array.isArray(mainData[name2])) {
                  throw new Error(`Key type ${name2} must be an array`);
                }
                if (!data.every(check)) {
                  throwForUpdateMaker(typeName, name2, expected, data);
                }
                const arr = mainData[name2] || [];
                const dupeCheckSet = /* @__PURE__ */ new Set();
                if (!data.every((v) => canAddToArray(arr, v, dupeCheckSet))) {
                  throw new Error("Can not add duplicate data to array");
                }
                mainData[name2] = arr.concat(data);
              } else {
                if (!check(data)) {
                  throwForUpdateMaker(typeName, name2, expected, data);
                }
                if (!canAdd(mainData, data)) {
                  throw new Error(`Can not add duplicate data to ${typeName}`);
                }
                mainData[name2] = data;
              }
            }
          }
        };
      }
      exports9.updateGlobal = updateMaker("global");
      exports9.updateInput = updateMaker("input");
      exports9.updateOutput = updateMaker("output");
      function addInputAttributes(inputs, data) {
        const index = inputs.length - 1;
        const input = checkForInput(inputs, index);
        exports9.updateInput(data, input);
      }
      exports9.addInputAttributes = addInputAttributes;
      function addOutputAttributes(outputs, data) {
        const index = outputs.length - 1;
        const output = checkForOutput(outputs, index);
        exports9.updateOutput(data, output);
      }
      exports9.addOutputAttributes = addOutputAttributes;
      function defaultVersionSetter(version2, txBuf) {
        if (!Buffer2.isBuffer(txBuf) || txBuf.length < 4) {
          throw new Error("Set Version: Invalid Transaction");
        }
        txBuf.writeUInt32LE(version2, 0);
        return txBuf;
      }
      exports9.defaultVersionSetter = defaultVersionSetter;
      function defaultLocktimeSetter(locktime, txBuf) {
        if (!Buffer2.isBuffer(txBuf) || txBuf.length < 4) {
          throw new Error("Set Locktime: Invalid Transaction");
        }
        txBuf.writeUInt32LE(locktime, txBuf.length - 4);
        return txBuf;
      }
      exports9.defaultLocktimeSetter = defaultLocktimeSetter;
    }
  });

  // node_modules/bip174/src/lib/psbt.js
  var require_psbt = __commonJS({
    "node_modules/bip174/src/lib/psbt.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var combiner_1 = require_combiner();
      var parser_1 = require_parser();
      var typeFields_1 = require_typeFields();
      var utils_1 = require_utils2();
      var Psbt = class {
        constructor(tx) {
          this.inputs = [];
          this.outputs = [];
          this.globalMap = {
            unsignedTx: tx
          };
        }
        static fromBase64(data, txFromBuffer) {
          const buffer = Buffer2.from(data, "base64");
          return this.fromBuffer(buffer, txFromBuffer);
        }
        static fromHex(data, txFromBuffer) {
          const buffer = Buffer2.from(data, "hex");
          return this.fromBuffer(buffer, txFromBuffer);
        }
        static fromBuffer(buffer, txFromBuffer) {
          const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);
          const psbt = new this(results.globalMap.unsignedTx);
          Object.assign(psbt, results);
          return psbt;
        }
        toBase64() {
          const buffer = this.toBuffer();
          return buffer.toString("base64");
        }
        toHex() {
          const buffer = this.toBuffer();
          return buffer.toString("hex");
        }
        toBuffer() {
          return parser_1.psbtToBuffer(this);
        }
        updateGlobal(updateData) {
          utils_1.updateGlobal(updateData, this.globalMap);
          return this;
        }
        updateInput(inputIndex, updateData) {
          const input = utils_1.checkForInput(this.inputs, inputIndex);
          utils_1.updateInput(updateData, input);
          return this;
        }
        updateOutput(outputIndex, updateData) {
          const output = utils_1.checkForOutput(this.outputs, outputIndex);
          utils_1.updateOutput(updateData, output);
          return this;
        }
        addUnknownKeyValToGlobal(keyVal) {
          utils_1.checkHasKey(
            keyVal,
            this.globalMap.unknownKeyVals,
            utils_1.getEnumLength(typeFields_1.GlobalTypes)
          );
          if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];
          this.globalMap.unknownKeyVals.push(keyVal);
          return this;
        }
        addUnknownKeyValToInput(inputIndex, keyVal) {
          const input = utils_1.checkForInput(this.inputs, inputIndex);
          utils_1.checkHasKey(
            keyVal,
            input.unknownKeyVals,
            utils_1.getEnumLength(typeFields_1.InputTypes)
          );
          if (!input.unknownKeyVals) input.unknownKeyVals = [];
          input.unknownKeyVals.push(keyVal);
          return this;
        }
        addUnknownKeyValToOutput(outputIndex, keyVal) {
          const output = utils_1.checkForOutput(this.outputs, outputIndex);
          utils_1.checkHasKey(
            keyVal,
            output.unknownKeyVals,
            utils_1.getEnumLength(typeFields_1.OutputTypes)
          );
          if (!output.unknownKeyVals) output.unknownKeyVals = [];
          output.unknownKeyVals.push(keyVal);
          return this;
        }
        addInput(inputData) {
          this.globalMap.unsignedTx.addInput(inputData);
          this.inputs.push({
            unknownKeyVals: []
          });
          const addKeyVals = inputData.unknownKeyVals || [];
          const inputIndex = this.inputs.length - 1;
          if (!Array.isArray(addKeyVals)) {
            throw new Error("unknownKeyVals must be an Array");
          }
          addKeyVals.forEach(
            (keyVal) => this.addUnknownKeyValToInput(inputIndex, keyVal)
          );
          utils_1.addInputAttributes(this.inputs, inputData);
          return this;
        }
        addOutput(outputData) {
          this.globalMap.unsignedTx.addOutput(outputData);
          this.outputs.push({
            unknownKeyVals: []
          });
          const addKeyVals = outputData.unknownKeyVals || [];
          const outputIndex = this.outputs.length - 1;
          if (!Array.isArray(addKeyVals)) {
            throw new Error("unknownKeyVals must be an Array");
          }
          addKeyVals.forEach(
            (keyVal) => this.addUnknownKeyValToOutput(outputIndex, keyVal)
          );
          utils_1.addOutputAttributes(this.outputs, outputData);
          return this;
        }
        clearFinalizedInput(inputIndex) {
          const input = utils_1.checkForInput(this.inputs, inputIndex);
          utils_1.inputCheckUncleanFinalized(inputIndex, input);
          for (const key of Object.keys(input)) {
            if (![
              "witnessUtxo",
              "nonWitnessUtxo",
              "finalScriptSig",
              "finalScriptWitness",
              "unknownKeyVals"
            ].includes(key)) {
              delete input[key];
            }
          }
          return this;
        }
        combine(...those) {
          const result = combiner_1.combine([this].concat(those));
          Object.assign(this, result);
          return this;
        }
        getTransaction() {
          return this.globalMap.unsignedTx.toBuffer();
        }
      };
      exports9.Psbt = Psbt;
    }
  });

  // node_modules/bitcoinjs-lib/src/psbt/psbtutils.js
  var require_psbtutils = __commonJS({
    "node_modules/bitcoinjs-lib/src/psbt/psbtutils.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.signatureBlocksAction = exports9.checkInputForSig = exports9.pubkeyInScript = exports9.pubkeyPositionInScript = exports9.witnessStackToScriptWitness = exports9.isP2TR = exports9.isP2SHScript = exports9.isP2WSHScript = exports9.isP2WPKH = exports9.isP2PKH = exports9.isP2PK = exports9.isP2MS = void 0;
      var varuint = require_varint();
      var bscript = require_script();
      var transaction_1 = require_transaction();
      var crypto_1 = require_crypto2();
      var payments = require_payments();
      function isPaymentFactory(payment) {
        return (script) => {
          try {
            payment({ output: script });
            return true;
          } catch (err) {
            return false;
          }
        };
      }
      exports9.isP2MS = isPaymentFactory(payments.p2ms);
      exports9.isP2PK = isPaymentFactory(payments.p2pk);
      exports9.isP2PKH = isPaymentFactory(payments.p2pkh);
      exports9.isP2WPKH = isPaymentFactory(payments.p2wpkh);
      exports9.isP2WSHScript = isPaymentFactory(payments.p2wsh);
      exports9.isP2SHScript = isPaymentFactory(payments.p2sh);
      exports9.isP2TR = isPaymentFactory(payments.p2tr);
      function witnessStackToScriptWitness(witness) {
        let buffer = Buffer2.allocUnsafe(0);
        function writeSlice(slice) {
          buffer = Buffer2.concat([buffer, Buffer2.from(slice)]);
        }
        function writeVarInt(i) {
          const currentLen = buffer.length;
          const varintLen = varuint.encodingLength(i);
          buffer = Buffer2.concat([buffer, Buffer2.allocUnsafe(varintLen)]);
          varuint.encode(i, buffer, currentLen);
        }
        function writeVarSlice(slice) {
          writeVarInt(slice.length);
          writeSlice(slice);
        }
        function writeVector(vector) {
          writeVarInt(vector.length);
          vector.forEach(writeVarSlice);
        }
        writeVector(witness);
        return buffer;
      }
      exports9.witnessStackToScriptWitness = witnessStackToScriptWitness;
      function pubkeyPositionInScript(pubkey, script) {
        const pubkeyHash = (0, crypto_1.hash160)(pubkey);
        const pubkeyXOnly = pubkey.slice(1, 33);
        const decompiled = bscript.decompile(script);
        if (decompiled === null) throw new Error("Unknown script error");
        return decompiled.findIndex((element) => {
          if (typeof element === "number") return false;
          return element.equals(pubkey) || element.equals(pubkeyHash) || element.equals(pubkeyXOnly);
        });
      }
      exports9.pubkeyPositionInScript = pubkeyPositionInScript;
      function pubkeyInScript(pubkey, script) {
        return pubkeyPositionInScript(pubkey, script) !== -1;
      }
      exports9.pubkeyInScript = pubkeyInScript;
      function checkInputForSig(input, action) {
        const pSigs = extractPartialSigs(input);
        return pSigs.some(
          (pSig) => signatureBlocksAction(pSig, bscript.signature.decode, action)
        );
      }
      exports9.checkInputForSig = checkInputForSig;
      function signatureBlocksAction(signature, signatureDecodeFn, action) {
        const { hashType } = signatureDecodeFn(signature);
        const whitelist = [];
        const isAnyoneCanPay = hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;
        if (isAnyoneCanPay) whitelist.push("addInput");
        const hashMod = hashType & 31;
        switch (hashMod) {
          case transaction_1.Transaction.SIGHASH_ALL:
            break;
          case transaction_1.Transaction.SIGHASH_SINGLE:
          case transaction_1.Transaction.SIGHASH_NONE:
            whitelist.push("addOutput");
            whitelist.push("setInputSequence");
            break;
        }
        if (whitelist.indexOf(action) === -1) {
          return true;
        }
        return false;
      }
      exports9.signatureBlocksAction = signatureBlocksAction;
      function extractPartialSigs(input) {
        let pSigs = [];
        if ((input.partialSig || []).length === 0) {
          if (!input.finalScriptSig && !input.finalScriptWitness) return [];
          pSigs = getPsigsFromInputFinalScripts(input);
        } else {
          pSigs = input.partialSig;
        }
        return pSigs.map((p) => p.signature);
      }
      function getPsigsFromInputFinalScripts(input) {
        const scriptItems = !input.finalScriptSig ? [] : bscript.decompile(input.finalScriptSig) || [];
        const witnessItems = !input.finalScriptWitness ? [] : bscript.decompile(input.finalScriptWitness) || [];
        return scriptItems.concat(witnessItems).filter((item) => {
          return Buffer2.isBuffer(item) && bscript.isCanonicalScriptSignature(item);
        }).map((sig) => ({ signature: sig }));
      }
    }
  });

  // node_modules/bitcoinjs-lib/src/psbt/bip371.js
  var require_bip371 = __commonJS({
    "node_modules/bitcoinjs-lib/src/psbt/bip371.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.checkTaprootInputForSigs = exports9.tapTreeFromList = exports9.tapTreeToList = exports9.tweakInternalPubKey = exports9.checkTaprootOutputFields = exports9.checkTaprootInputFields = exports9.isTaprootOutput = exports9.isTaprootInput = exports9.serializeTaprootSignature = exports9.tapScriptFinalizer = exports9.toXOnly = void 0;
      var types_1 = require_types();
      var transaction_1 = require_transaction();
      var psbtutils_1 = require_psbtutils();
      var bip341_1 = require_bip341();
      var payments_1 = require_payments();
      var psbtutils_2 = require_psbtutils();
      var toXOnly = (pubKey) => pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
      exports9.toXOnly = toXOnly;
      function tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {
        const tapLeaf = findTapLeafToFinalize(
          input,
          inputIndex,
          tapLeafHashToFinalize
        );
        try {
          const sigs = sortSignatures(input, tapLeaf);
          const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);
          return {
            finalScriptWitness: (0, psbtutils_1.witnessStackToScriptWitness)(witness)
          };
        } catch (err) {
          throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);
        }
      }
      exports9.tapScriptFinalizer = tapScriptFinalizer;
      function serializeTaprootSignature(sig, sighashType) {
        const sighashTypeByte = sighashType ? Buffer2.from([sighashType]) : Buffer2.from([]);
        return Buffer2.concat([sig, sighashTypeByte]);
      }
      exports9.serializeTaprootSignature = serializeTaprootSignature;
      function isTaprootInput(input) {
        return input && !!(input.tapInternalKey || input.tapMerkleRoot || input.tapLeafScript && input.tapLeafScript.length || input.tapBip32Derivation && input.tapBip32Derivation.length || input.witnessUtxo && (0, psbtutils_1.isP2TR)(input.witnessUtxo.script));
      }
      exports9.isTaprootInput = isTaprootInput;
      function isTaprootOutput(output, script) {
        return output && !!(output.tapInternalKey || output.tapTree || output.tapBip32Derivation && output.tapBip32Derivation.length || script && (0, psbtutils_1.isP2TR)(script));
      }
      exports9.isTaprootOutput = isTaprootOutput;
      function checkTaprootInputFields(inputData, newInputData, action) {
        checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);
        checkIfTapLeafInTree(inputData, newInputData, action);
      }
      exports9.checkTaprootInputFields = checkTaprootInputFields;
      function checkTaprootOutputFields(outputData, newOutputData, action) {
        checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);
        checkTaprootScriptPubkey(outputData, newOutputData);
      }
      exports9.checkTaprootOutputFields = checkTaprootOutputFields;
      function checkTaprootScriptPubkey(outputData, newOutputData) {
        if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;
        const tapInternalKey = newOutputData.tapInternalKey || outputData.tapInternalKey;
        const tapTree = newOutputData.tapTree || outputData.tapTree;
        if (tapInternalKey) {
          const { script: scriptPubkey } = outputData;
          const script = getTaprootScripPubkey(tapInternalKey, tapTree);
          if (scriptPubkey && !scriptPubkey.equals(script))
            throw new Error("Error adding output. Script or address missmatch.");
        }
      }
      function getTaprootScripPubkey(tapInternalKey, tapTree) {
        const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);
        const { output } = (0, payments_1.p2tr)({
          internalPubkey: tapInternalKey,
          scriptTree
        });
        return output;
      }
      function tweakInternalPubKey(inputIndex, input) {
        const tapInternalKey = input.tapInternalKey;
        const outputKey = tapInternalKey && (0, bip341_1.tweakKey)(tapInternalKey, input.tapMerkleRoot);
        if (!outputKey)
          throw new Error(
            `Cannot tweak tap internal key for input #${inputIndex}. Public key: ${tapInternalKey && tapInternalKey.toString("hex")}`
          );
        return outputKey.x;
      }
      exports9.tweakInternalPubKey = tweakInternalPubKey;
      function tapTreeToList(tree) {
        if (!(0, types_1.isTaptree)(tree))
          throw new Error(
            "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
          );
        return _tapTreeToList(tree);
      }
      exports9.tapTreeToList = tapTreeToList;
      function tapTreeFromList(leaves = []) {
        if (leaves.length === 1 && leaves[0].depth === 0)
          return {
            output: leaves[0].script,
            version: leaves[0].leafVersion
          };
        return instertLeavesInTree(leaves);
      }
      exports9.tapTreeFromList = tapTreeFromList;
      function checkTaprootInputForSigs(input, action) {
        const sigs = extractTaprootSigs(input);
        return sigs.some(
          (sig) => (0, psbtutils_2.signatureBlocksAction)(sig, decodeSchnorrSignature, action)
        );
      }
      exports9.checkTaprootInputForSigs = checkTaprootInputForSigs;
      function decodeSchnorrSignature(signature) {
        return {
          signature: signature.slice(0, 64),
          hashType: signature.slice(64)[0] || transaction_1.Transaction.SIGHASH_DEFAULT
        };
      }
      function extractTaprootSigs(input) {
        const sigs = [];
        if (input.tapKeySig) sigs.push(input.tapKeySig);
        if (input.tapScriptSig)
          sigs.push(...input.tapScriptSig.map((s) => s.signature));
        if (!sigs.length) {
          const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);
          if (finalTapKeySig) sigs.push(finalTapKeySig);
        }
        return sigs;
      }
      function getTapKeySigFromWithness(finalScriptWitness) {
        if (!finalScriptWitness) return;
        const witness = finalScriptWitness.slice(2);
        if (witness.length === 64 || witness.length === 65) return witness;
      }
      function _tapTreeToList(tree, leaves = [], depth = 0) {
        if (depth > bip341_1.MAX_TAPTREE_DEPTH)
          throw new Error("Max taptree depth exceeded.");
        if (!tree) return [];
        if ((0, types_1.isTapleaf)(tree)) {
          leaves.push({
            depth,
            leafVersion: tree.version || bip341_1.LEAF_VERSION_TAPSCRIPT,
            script: tree.output
          });
          return leaves;
        }
        if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);
        if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);
        return leaves;
      }
      function instertLeavesInTree(leaves) {
        let tree;
        for (const leaf of leaves) {
          tree = instertLeafInTree(leaf, tree);
          if (!tree) throw new Error(`No room left to insert tapleaf in tree`);
        }
        return tree;
      }
      function instertLeafInTree(leaf, tree, depth = 0) {
        if (depth > bip341_1.MAX_TAPTREE_DEPTH)
          throw new Error("Max taptree depth exceeded.");
        if (leaf.depth === depth) {
          if (!tree)
            return {
              output: leaf.script,
              version: leaf.leafVersion
            };
          return;
        }
        if ((0, types_1.isTapleaf)(tree)) return;
        const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);
        if (leftSide) return [leftSide, tree && tree[1]];
        const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);
        if (rightSide) return [tree && tree[0], rightSide];
      }
      function checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action) {
        const isBadTaprootUpdate = isTaprootInput(inputData) && hasNonTaprootFields(newInputData);
        const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootInput(newInputData);
        const hasMixedFields = inputData === newInputData && isTaprootInput(newInputData) && hasNonTaprootFields(newInputData);
        if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
          throw new Error(
            `Invalid arguments for Psbt.${action}. Cannot use both taproot and non-taproot fields.`
          );
      }
      function checkMixedTaprootAndNonTaprootOutputFields(inputData, newInputData, action) {
        const isBadTaprootUpdate = isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);
        const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);
        const hasMixedFields = inputData === newInputData && isTaprootOutput(newInputData) && hasNonTaprootFields(newInputData);
        if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
          throw new Error(
            `Invalid arguments for Psbt.${action}. Cannot use both taproot and non-taproot fields.`
          );
      }
      function checkIfTapLeafInTree(inputData, newInputData, action) {
        if (newInputData.tapMerkleRoot) {
          const newLeafsInTree = (newInputData.tapLeafScript || []).every(
            (l) => isTapLeafInTree(l, newInputData.tapMerkleRoot)
          );
          const oldLeafsInTree = (inputData.tapLeafScript || []).every(
            (l) => isTapLeafInTree(l, newInputData.tapMerkleRoot)
          );
          if (!newLeafsInTree || !oldLeafsInTree)
            throw new Error(
              `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`
            );
        } else if (inputData.tapMerkleRoot) {
          const newLeafsInTree = (newInputData.tapLeafScript || []).every(
            (l) => isTapLeafInTree(l, inputData.tapMerkleRoot)
          );
          if (!newLeafsInTree)
            throw new Error(
              `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`
            );
        }
      }
      function isTapLeafInTree(tapLeaf, merkleRoot) {
        if (!merkleRoot) return true;
        const leafHash = (0, bip341_1.tapleafHash)({
          output: tapLeaf.script,
          version: tapLeaf.leafVersion
        });
        const rootHash = (0, bip341_1.rootHashFromPath)(
          tapLeaf.controlBlock,
          leafHash
        );
        return rootHash.equals(merkleRoot);
      }
      function sortSignatures(input, tapLeaf) {
        const leafHash = (0, bip341_1.tapleafHash)({
          output: tapLeaf.script,
          version: tapLeaf.leafVersion
        });
        return (input.tapScriptSig || []).filter((tss) => tss.leafHash.equals(leafHash)).map((tss) => addPubkeyPositionInScript(tapLeaf.script, tss)).sort((t1, t2) => t2.positionInScript - t1.positionInScript).map((t) => t.signature);
      }
      function addPubkeyPositionInScript(script, tss) {
        return Object.assign(
          {
            positionInScript: (0, psbtutils_1.pubkeyPositionInScript)(
              tss.pubkey,
              script
            )
          },
          tss
        );
      }
      function findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {
        if (!input.tapScriptSig || !input.tapScriptSig.length)
          throw new Error(
            `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`
          );
        const tapLeaf = (input.tapLeafScript || []).sort((a, b) => a.controlBlock.length - b.controlBlock.length).find(
          (leaf) => canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize)
        );
        if (!tapLeaf)
          throw new Error(
            `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`
          );
        return tapLeaf;
      }
      function canFinalizeLeaf(leaf, tapScriptSig, hash) {
        const leafHash = (0, bip341_1.tapleafHash)({
          output: leaf.script,
          version: leaf.leafVersion
        });
        const whiteListedHash = !hash || hash.equals(leafHash);
        return whiteListedHash && tapScriptSig.find((tss) => tss.leafHash.equals(leafHash)) !== void 0;
      }
      function hasNonTaprootFields(io) {
        return io && !!(io.redeemScript || io.witnessScript || io.bip32Derivation && io.bip32Derivation.length);
      }
    }
  });

  // node_modules/bitcoinjs-lib/src/psbt.js
  var require_psbt2 = __commonJS({
    "node_modules/bitcoinjs-lib/src/psbt.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.Psbt = void 0;
      var bip174_1 = require_psbt();
      var varuint = require_varint();
      var utils_1 = require_utils2();
      var address_1 = require_address();
      var bufferutils_1 = require_bufferutils();
      var networks_1 = require_networks();
      var payments = require_payments();
      var bip341_1 = require_bip341();
      var bscript = require_script();
      var transaction_1 = require_transaction();
      var bip371_1 = require_bip371();
      var psbtutils_1 = require_psbtutils();
      var DEFAULT_OPTS = {
        /**
         * A bitcoinjs Network object. This is only used if you pass an `address`
         * parameter to addOutput. Otherwise it is not needed and can be left default.
         */
        network: networks_1.bitcoin,
        /**
         * When extractTransaction is called, the fee rate is checked.
         * THIS IS NOT TO BE RELIED ON.
         * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
         */
        maximumFeeRate: 5e3
        // satoshi per byte
      };
      var Psbt = class _Psbt {
        static fromBase64(data, opts = {}) {
          const buffer = Buffer2.from(data, "base64");
          return this.fromBuffer(buffer, opts);
        }
        static fromHex(data, opts = {}) {
          const buffer = Buffer2.from(data, "hex");
          return this.fromBuffer(buffer, opts);
        }
        static fromBuffer(buffer, opts = {}) {
          const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);
          const psbt = new _Psbt(opts, psbtBase);
          checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);
          return psbt;
        }
        constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {
          this.data = data;
          this.opts = Object.assign({}, DEFAULT_OPTS, opts);
          this.__CACHE = {
            __NON_WITNESS_UTXO_TX_CACHE: [],
            __NON_WITNESS_UTXO_BUF_CACHE: [],
            __TX_IN_CACHE: {},
            __TX: this.data.globalMap.unsignedTx.tx,
            // Psbt's predecessor (TransactionBuilder - now removed) behavior
            // was to not confirm input values  before signing.
            // Even though we highly encourage people to get
            // the full parent transaction to verify values, the ability to
            // sign non-segwit inputs without the full transaction was often
            // requested. So the only way to activate is to use @ts-ignore.
            // We will disable exporting the Psbt when unsafe sign is active.
            // because it is not BIP174 compliant.
            __UNSAFE_SIGN_NONSEGWIT: false
          };
          if (this.data.inputs.length === 0) this.setVersion(2);
          const dpew = (obj, attr, enumerable, writable) => Object.defineProperty(obj, attr, {
            enumerable,
            writable
          });
          dpew(this, "__CACHE", false, true);
          dpew(this, "opts", false, true);
        }
        get inputCount() {
          return this.data.inputs.length;
        }
        get version() {
          return this.__CACHE.__TX.version;
        }
        set version(version2) {
          this.setVersion(version2);
        }
        get locktime() {
          return this.__CACHE.__TX.locktime;
        }
        set locktime(locktime) {
          this.setLocktime(locktime);
        }
        get txInputs() {
          return this.__CACHE.__TX.ins.map((input) => ({
            hash: (0, bufferutils_1.cloneBuffer)(input.hash),
            index: input.index,
            sequence: input.sequence
          }));
        }
        get txOutputs() {
          return this.__CACHE.__TX.outs.map((output) => {
            let address;
            try {
              address = (0, address_1.fromOutputScript)(
                output.script,
                this.opts.network
              );
            } catch (_) {
            }
            return {
              script: (0, bufferutils_1.cloneBuffer)(output.script),
              value: output.value,
              address
            };
          });
        }
        combine(...those) {
          this.data.combine(...those.map((o) => o.data));
          return this;
        }
        clone() {
          const res = _Psbt.fromBuffer(this.data.toBuffer());
          res.opts = JSON.parse(JSON.stringify(this.opts));
          return res;
        }
        setMaximumFeeRate(satoshiPerByte) {
          check32Bit(satoshiPerByte);
          this.opts.maximumFeeRate = satoshiPerByte;
        }
        setVersion(version2) {
          check32Bit(version2);
          checkInputsForPartialSig(this.data.inputs, "setVersion");
          const c = this.__CACHE;
          c.__TX.version = version2;
          c.__EXTRACTED_TX = void 0;
          return this;
        }
        setLocktime(locktime) {
          check32Bit(locktime);
          checkInputsForPartialSig(this.data.inputs, "setLocktime");
          const c = this.__CACHE;
          c.__TX.locktime = locktime;
          c.__EXTRACTED_TX = void 0;
          return this;
        }
        setInputSequence(inputIndex, sequence) {
          check32Bit(sequence);
          checkInputsForPartialSig(this.data.inputs, "setInputSequence");
          const c = this.__CACHE;
          if (c.__TX.ins.length <= inputIndex) {
            throw new Error("Input index too high");
          }
          c.__TX.ins[inputIndex].sequence = sequence;
          c.__EXTRACTED_TX = void 0;
          return this;
        }
        addInputs(inputDatas) {
          inputDatas.forEach((inputData) => this.addInput(inputData));
          return this;
        }
        addInput(inputData) {
          if (arguments.length > 1 || !inputData || inputData.hash === void 0 || inputData.index === void 0) {
            throw new Error(
              `Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]`
            );
          }
          (0, bip371_1.checkTaprootInputFields)(inputData, inputData, "addInput");
          checkInputsForPartialSig(this.data.inputs, "addInput");
          if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);
          const c = this.__CACHE;
          this.data.addInput(inputData);
          const txIn = c.__TX.ins[c.__TX.ins.length - 1];
          checkTxInputCache(c, txIn);
          const inputIndex = this.data.inputs.length - 1;
          const input = this.data.inputs[inputIndex];
          if (input.nonWitnessUtxo) {
            addNonWitnessTxCache(this.__CACHE, input, inputIndex);
          }
          c.__FEE = void 0;
          c.__FEE_RATE = void 0;
          c.__EXTRACTED_TX = void 0;
          return this;
        }
        addOutputs(outputDatas) {
          outputDatas.forEach((outputData) => this.addOutput(outputData));
          return this;
        }
        addOutput(outputData) {
          if (arguments.length > 1 || !outputData || outputData.value === void 0 || outputData.address === void 0 && outputData.script === void 0) {
            throw new Error(
              `Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]`
            );
          }
          checkInputsForPartialSig(this.data.inputs, "addOutput");
          const { address } = outputData;
          if (typeof address === "string") {
            const { network } = this.opts;
            const script = (0, address_1.toOutputScript)(address, network);
            outputData = Object.assign({}, outputData, { script });
          }
          (0, bip371_1.checkTaprootOutputFields)(outputData, outputData, "addOutput");
          const c = this.__CACHE;
          this.data.addOutput(outputData);
          c.__FEE = void 0;
          c.__FEE_RATE = void 0;
          c.__EXTRACTED_TX = void 0;
          return this;
        }
        extractTransaction(disableFeeCheck) {
          if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
          const c = this.__CACHE;
          if (!disableFeeCheck) {
            checkFees(this, c, this.opts);
          }
          if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;
          const tx = c.__TX.clone();
          inputFinalizeGetAmts(this.data.inputs, tx, c, true);
          return tx;
        }
        getFeeRate() {
          return getTxCacheValue(
            "__FEE_RATE",
            "fee rate",
            this.data.inputs,
            this.__CACHE
          );
        }
        getFee() {
          return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
        }
        finalizeAllInputs() {
          (0, utils_1.checkForInput)(this.data.inputs, 0);
          range(this.data.inputs.length).forEach((idx) => this.finalizeInput(idx));
          return this;
        }
        finalizeInput(inputIndex, finalScriptsFunc) {
          const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
          if ((0, bip371_1.isTaprootInput)(input))
            return this._finalizeTaprootInput(
              inputIndex,
              input,
              void 0,
              finalScriptsFunc
            );
          return this._finalizeInput(inputIndex, input, finalScriptsFunc);
        }
        finalizeTaprootInput(inputIndex, tapLeafHashToFinalize, finalScriptsFunc = bip371_1.tapScriptFinalizer) {
          const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
          if ((0, bip371_1.isTaprootInput)(input))
            return this._finalizeTaprootInput(
              inputIndex,
              input,
              tapLeafHashToFinalize,
              finalScriptsFunc
            );
          throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);
        }
        _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {
          const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(
            inputIndex,
            input,
            this.__CACHE
          );
          if (!script) throw new Error(`No script found for input #${inputIndex}`);
          checkPartialSigSighashes(input);
          const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(
            inputIndex,
            input,
            script,
            isSegwit,
            isP2SH,
            isP2WSH
          );
          if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });
          if (finalScriptWitness)
            this.data.updateInput(inputIndex, { finalScriptWitness });
          if (!finalScriptSig && !finalScriptWitness)
            throw new Error(`Unknown error finalizing input #${inputIndex}`);
          this.data.clearFinalizedInput(inputIndex);
          return this;
        }
        _finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc = bip371_1.tapScriptFinalizer) {
          if (!input.witnessUtxo)
            throw new Error(
              `Cannot finalize input #${inputIndex}. Missing withness utxo.`
            );
          if (input.tapKeySig) {
            const payment = payments.p2tr({
              output: input.witnessUtxo.script,
              signature: input.tapKeySig
            });
            const finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
              payment.witness
            );
            this.data.updateInput(inputIndex, { finalScriptWitness });
          } else {
            const { finalScriptWitness } = finalScriptsFunc(
              inputIndex,
              input,
              tapLeafHashToFinalize
            );
            this.data.updateInput(inputIndex, { finalScriptWitness });
          }
          this.data.clearFinalizedInput(inputIndex);
          return this;
        }
        getInputType(inputIndex) {
          const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
          const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);
          const result = getMeaningfulScript(
            script,
            inputIndex,
            "input",
            input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),
            input.witnessScript || redeemFromFinalWitnessScript(input.finalScriptWitness)
          );
          const type = result.type === "raw" ? "" : result.type + "-";
          const mainType = classifyScript(result.meaningfulScript);
          return type + mainType;
        }
        inputHasPubkey(inputIndex, pubkey) {
          const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
          return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);
        }
        inputHasHDKey(inputIndex, root) {
          const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
          const derivationIsMine = bip32DerivationIsMine(root);
          return !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine);
        }
        outputHasPubkey(outputIndex, pubkey) {
          const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
          return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);
        }
        outputHasHDKey(outputIndex, root) {
          const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
          const derivationIsMine = bip32DerivationIsMine(root);
          return !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine);
        }
        validateSignaturesOfAllInputs(validator) {
          (0, utils_1.checkForInput)(this.data.inputs, 0);
          const results = range(this.data.inputs.length).map(
            (idx) => this.validateSignaturesOfInput(idx, validator)
          );
          return results.reduce((final, res) => res === true && final, true);
        }
        validateSignaturesOfInput(inputIndex, validator, pubkey) {
          const input = this.data.inputs[inputIndex];
          if ((0, bip371_1.isTaprootInput)(input))
            return this.validateSignaturesOfTaprootInput(
              inputIndex,
              validator,
              pubkey
            );
          return this._validateSignaturesOfInput(inputIndex, validator, pubkey);
        }
        _validateSignaturesOfInput(inputIndex, validator, pubkey) {
          const input = this.data.inputs[inputIndex];
          const partialSig = (input || {}).partialSig;
          if (!input || !partialSig || partialSig.length < 1)
            throw new Error("No signatures to validate");
          if (typeof validator !== "function")
            throw new Error("Need validator function to validate signatures");
          const mySigs = pubkey ? partialSig.filter((sig) => sig.pubkey.equals(pubkey)) : partialSig;
          if (mySigs.length < 1) throw new Error("No signatures for this pubkey");
          const results = [];
          let hashCache;
          let scriptCache;
          let sighashCache;
          for (const pSig of mySigs) {
            const sig = bscript.signature.decode(pSig.signature);
            const { hash, script } = sighashCache !== sig.hashType ? getHashForSig(
              inputIndex,
              Object.assign({}, input, { sighashType: sig.hashType }),
              this.__CACHE,
              true
            ) : { hash: hashCache, script: scriptCache };
            sighashCache = sig.hashType;
            hashCache = hash;
            scriptCache = script;
            checkScriptForPubkey(pSig.pubkey, script, "verify");
            results.push(validator(pSig.pubkey, hash, sig.signature));
          }
          return results.every((res) => res === true);
        }
        validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {
          const input = this.data.inputs[inputIndex];
          const tapKeySig = (input || {}).tapKeySig;
          const tapScriptSig = (input || {}).tapScriptSig;
          if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))
            throw new Error("No signatures to validate");
          if (typeof validator !== "function")
            throw new Error("Need validator function to validate signatures");
          pubkey = pubkey && (0, bip371_1.toXOnly)(pubkey);
          const allHashses = pubkey ? getTaprootHashesForSig(
            inputIndex,
            input,
            this.data.inputs,
            pubkey,
            this.__CACHE
          ) : getAllTaprootHashesForSig(
            inputIndex,
            input,
            this.data.inputs,
            this.__CACHE
          );
          if (!allHashses.length) throw new Error("No signatures for this pubkey");
          const tapKeyHash = allHashses.find((h) => !h.leafHash);
          let validationResultCount = 0;
          if (tapKeySig && tapKeyHash) {
            const isValidTapkeySig = validator(
              tapKeyHash.pubkey,
              tapKeyHash.hash,
              trimTaprootSig(tapKeySig)
            );
            if (!isValidTapkeySig) return false;
            validationResultCount++;
          }
          if (tapScriptSig) {
            for (const tapSig of tapScriptSig) {
              const tapSigHash = allHashses.find((h) => tapSig.pubkey.equals(h.pubkey));
              if (tapSigHash) {
                const isValidTapScriptSig = validator(
                  tapSig.pubkey,
                  tapSigHash.hash,
                  trimTaprootSig(tapSig.signature)
                );
                if (!isValidTapScriptSig) return false;
                validationResultCount++;
              }
            }
          }
          return validationResultCount > 0;
        }
        signAllInputsHD(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
          if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            throw new Error("Need HDSigner to sign input");
          }
          const results = [];
          for (const i of range(this.data.inputs.length)) {
            try {
              this.signInputHD(i, hdKeyPair, sighashTypes);
              results.push(true);
            } catch (err) {
              results.push(false);
            }
          }
          if (results.every((v) => v === false)) {
            throw new Error("No inputs were signed");
          }
          return this;
        }
        signAllInputsHDAsync(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
          return new Promise((resolve, reject) => {
            if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
              return reject(new Error("Need HDSigner to sign input"));
            }
            const results = [];
            const promises2 = [];
            for (const i of range(this.data.inputs.length)) {
              promises2.push(
                this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(
                  () => {
                    results.push(true);
                  },
                  () => {
                    results.push(false);
                  }
                )
              );
            }
            return Promise.all(promises2).then(() => {
              if (results.every((v) => v === false)) {
                return reject(new Error("No inputs were signed"));
              }
              resolve();
            });
          });
        }
        signInputHD(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
          if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            throw new Error("Need HDSigner to sign input");
          }
          const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
          signers.forEach((signer) => this.signInput(inputIndex, signer, sighashTypes));
          return this;
        }
        signInputHDAsync(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
          return new Promise((resolve, reject) => {
            if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
              return reject(new Error("Need HDSigner to sign input"));
            }
            const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
            const promises2 = signers.map(
              (signer) => this.signInputAsync(inputIndex, signer, sighashTypes)
            );
            return Promise.all(promises2).then(() => {
              resolve();
            }).catch(reject);
          });
        }
        signAllInputs(keyPair, sighashTypes) {
          if (!keyPair || !keyPair.publicKey)
            throw new Error("Need Signer to sign input");
          const results = [];
          for (const i of range(this.data.inputs.length)) {
            try {
              this.signInput(i, keyPair, sighashTypes);
              results.push(true);
            } catch (err) {
              results.push(false);
            }
          }
          if (results.every((v) => v === false)) {
            throw new Error("No inputs were signed");
          }
          return this;
        }
        signAllInputsAsync(keyPair, sighashTypes) {
          return new Promise((resolve, reject) => {
            if (!keyPair || !keyPair.publicKey)
              return reject(new Error("Need Signer to sign input"));
            const results = [];
            const promises2 = [];
            for (const [i] of this.data.inputs.entries()) {
              promises2.push(
                this.signInputAsync(i, keyPair, sighashTypes).then(
                  () => {
                    results.push(true);
                  },
                  () => {
                    results.push(false);
                  }
                )
              );
            }
            return Promise.all(promises2).then(() => {
              if (results.every((v) => v === false)) {
                return reject(new Error("No inputs were signed"));
              }
              resolve();
            });
          });
        }
        signInput(inputIndex, keyPair, sighashTypes) {
          if (!keyPair || !keyPair.publicKey)
            throw new Error("Need Signer to sign input");
          const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
          if ((0, bip371_1.isTaprootInput)(input)) {
            return this._signTaprootInput(
              inputIndex,
              input,
              keyPair,
              void 0,
              sighashTypes
            );
          }
          return this._signInput(inputIndex, keyPair, sighashTypes);
        }
        signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {
          if (!keyPair || !keyPair.publicKey)
            throw new Error("Need Signer to sign input");
          const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
          if ((0, bip371_1.isTaprootInput)(input))
            return this._signTaprootInput(
              inputIndex,
              input,
              keyPair,
              tapLeafHashToSign,
              sighashTypes
            );
          throw new Error(`Input #${inputIndex} is not of type Taproot.`);
        }
        _signInput(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
          const { hash, sighashType } = getHashAndSighashType(
            this.data.inputs,
            inputIndex,
            keyPair.publicKey,
            this.__CACHE,
            sighashTypes
          );
          const partialSig = [
            {
              pubkey: keyPair.publicKey,
              signature: bscript.signature.encode(keyPair.sign(hash), sighashType)
            }
          ];
          this.data.updateInput(inputIndex, { partialSig });
          return this;
        }
        _signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
          const hashesForSig = this.checkTaprootHashesForSig(
            inputIndex,
            input,
            keyPair,
            tapLeafHashToSign,
            allowedSighashTypes
          );
          const tapKeySig = hashesForSig.filter((h) => !h.leafHash).map(
            (h) => (0, bip371_1.serializeTaprootSignature)(
              keyPair.signSchnorr(h.hash),
              input.sighashType
            )
          )[0];
          const tapScriptSig = hashesForSig.filter((h) => !!h.leafHash).map((h) => ({
            pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),
            signature: (0, bip371_1.serializeTaprootSignature)(
              keyPair.signSchnorr(h.hash),
              input.sighashType
            ),
            leafHash: h.leafHash
          }));
          if (tapKeySig) {
            this.data.updateInput(inputIndex, { tapKeySig });
          }
          if (tapScriptSig.length) {
            this.data.updateInput(inputIndex, { tapScriptSig });
          }
          return this;
        }
        signInputAsync(inputIndex, keyPair, sighashTypes) {
          return Promise.resolve().then(() => {
            if (!keyPair || !keyPair.publicKey)
              throw new Error("Need Signer to sign input");
            const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
            if ((0, bip371_1.isTaprootInput)(input))
              return this._signTaprootInputAsync(
                inputIndex,
                input,
                keyPair,
                void 0,
                sighashTypes
              );
            return this._signInputAsync(inputIndex, keyPair, sighashTypes);
          });
        }
        signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {
          return Promise.resolve().then(() => {
            if (!keyPair || !keyPair.publicKey)
              throw new Error("Need Signer to sign input");
            const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
            if ((0, bip371_1.isTaprootInput)(input))
              return this._signTaprootInputAsync(
                inputIndex,
                input,
                keyPair,
                tapLeafHash,
                sighashTypes
              );
            throw new Error(`Input #${inputIndex} is not of type Taproot.`);
          });
        }
        _signInputAsync(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
          const { hash, sighashType } = getHashAndSighashType(
            this.data.inputs,
            inputIndex,
            keyPair.publicKey,
            this.__CACHE,
            sighashTypes
          );
          return Promise.resolve(keyPair.sign(hash)).then((signature) => {
            const partialSig = [
              {
                pubkey: keyPair.publicKey,
                signature: bscript.signature.encode(signature, sighashType)
              }
            ];
            this.data.updateInput(inputIndex, { partialSig });
          });
        }
        async _signTaprootInputAsync(inputIndex, input, keyPair, tapLeafHash, sighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
          const hashesForSig = this.checkTaprootHashesForSig(
            inputIndex,
            input,
            keyPair,
            tapLeafHash,
            sighashTypes
          );
          const signaturePromises = [];
          const tapKeyHash = hashesForSig.filter((h) => !h.leafHash)[0];
          if (tapKeyHash) {
            const tapKeySigPromise = Promise.resolve(
              keyPair.signSchnorr(tapKeyHash.hash)
            ).then((sig) => {
              return {
                tapKeySig: (0, bip371_1.serializeTaprootSignature)(
                  sig,
                  input.sighashType
                )
              };
            });
            signaturePromises.push(tapKeySigPromise);
          }
          const tapScriptHashes = hashesForSig.filter((h) => !!h.leafHash);
          if (tapScriptHashes.length) {
            const tapScriptSigPromises = tapScriptHashes.map((tsh) => {
              return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(
                (signature) => {
                  const tapScriptSig = [
                    {
                      pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),
                      signature: (0, bip371_1.serializeTaprootSignature)(
                        signature,
                        input.sighashType
                      ),
                      leafHash: tsh.leafHash
                    }
                  ];
                  return { tapScriptSig };
                }
              );
            });
            signaturePromises.push(...tapScriptSigPromises);
          }
          return Promise.all(signaturePromises).then((results) => {
            results.forEach((v) => this.data.updateInput(inputIndex, v));
          });
        }
        checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes) {
          if (typeof keyPair.signSchnorr !== "function")
            throw new Error(
              `Need Schnorr Signer to sign taproot input #${inputIndex}.`
            );
          const hashesForSig = getTaprootHashesForSig(
            inputIndex,
            input,
            this.data.inputs,
            keyPair.publicKey,
            this.__CACHE,
            tapLeafHashToSign,
            allowedSighashTypes
          );
          if (!hashesForSig || !hashesForSig.length)
            throw new Error(
              `Can not sign for input #${inputIndex} with the key ${keyPair.publicKey.toString(
                "hex"
              )}`
            );
          return hashesForSig;
        }
        toBuffer() {
          checkCache(this.__CACHE);
          return this.data.toBuffer();
        }
        toHex() {
          checkCache(this.__CACHE);
          return this.data.toHex();
        }
        toBase64() {
          checkCache(this.__CACHE);
          return this.data.toBase64();
        }
        updateGlobal(updateData) {
          this.data.updateGlobal(updateData);
          return this;
        }
        updateInput(inputIndex, updateData) {
          if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);
          (0, bip371_1.checkTaprootInputFields)(
            this.data.inputs[inputIndex],
            updateData,
            "updateInput"
          );
          this.data.updateInput(inputIndex, updateData);
          if (updateData.nonWitnessUtxo) {
            addNonWitnessTxCache(
              this.__CACHE,
              this.data.inputs[inputIndex],
              inputIndex
            );
          }
          return this;
        }
        updateOutput(outputIndex, updateData) {
          const outputData = this.data.outputs[outputIndex];
          (0, bip371_1.checkTaprootOutputFields)(
            outputData,
            updateData,
            "updateOutput"
          );
          this.data.updateOutput(outputIndex, updateData);
          return this;
        }
        addUnknownKeyValToGlobal(keyVal) {
          this.data.addUnknownKeyValToGlobal(keyVal);
          return this;
        }
        addUnknownKeyValToInput(inputIndex, keyVal) {
          this.data.addUnknownKeyValToInput(inputIndex, keyVal);
          return this;
        }
        addUnknownKeyValToOutput(outputIndex, keyVal) {
          this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
          return this;
        }
        clearFinalizedInput(inputIndex) {
          this.data.clearFinalizedInput(inputIndex);
          return this;
        }
      };
      exports9.Psbt = Psbt;
      var transactionFromBuffer = (buffer) => new PsbtTransaction(buffer);
      var PsbtTransaction = class {
        constructor(buffer = Buffer2.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
          this.tx = transaction_1.Transaction.fromBuffer(buffer);
          checkTxEmpty(this.tx);
          Object.defineProperty(this, "tx", {
            enumerable: false,
            writable: true
          });
        }
        getInputOutputCounts() {
          return {
            inputCount: this.tx.ins.length,
            outputCount: this.tx.outs.length
          };
        }
        addInput(input) {
          if (input.hash === void 0 || input.index === void 0 || !Buffer2.isBuffer(input.hash) && typeof input.hash !== "string" || typeof input.index !== "number") {
            throw new Error("Error adding input.");
          }
          const hash = typeof input.hash === "string" ? (0, bufferutils_1.reverseBuffer)(Buffer2.from(input.hash, "hex")) : input.hash;
          this.tx.addInput(hash, input.index, input.sequence);
        }
        addOutput(output) {
          if (output.script === void 0 || output.value === void 0 || !Buffer2.isBuffer(output.script) || typeof output.value !== "number") {
            throw new Error("Error adding output.");
          }
          this.tx.addOutput(output.script, output.value);
        }
        toBuffer() {
          return this.tx.toBuffer();
        }
      };
      function canFinalize(input, script, scriptType) {
        switch (scriptType) {
          case "pubkey":
          case "pubkeyhash":
          case "witnesspubkeyhash":
            return hasSigs(1, input.partialSig);
          case "multisig":
            const p2ms = payments.p2ms({ output: script });
            return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);
          default:
            return false;
        }
      }
      function checkCache(cache) {
        if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {
          throw new Error("Not BIP174 compliant, can not export");
        }
      }
      function hasSigs(neededSigs, partialSig, pubkeys) {
        if (!partialSig) return false;
        let sigs;
        if (pubkeys) {
          sigs = pubkeys.map((pkey) => {
            const pubkey = compressPubkey(pkey);
            return partialSig.find((pSig) => pSig.pubkey.equals(pubkey));
          }).filter((v) => !!v);
        } else {
          sigs = partialSig;
        }
        if (sigs.length > neededSigs) throw new Error("Too many signatures");
        return sigs.length === neededSigs;
      }
      function isFinalized(input) {
        return !!input.finalScriptSig || !!input.finalScriptWitness;
      }
      function bip32DerivationIsMine(root) {
        return (d) => {
          if (!d.masterFingerprint.equals(root.fingerprint)) return false;
          if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;
          return true;
        };
      }
      function check32Bit(num) {
        if (typeof num !== "number" || num !== Math.floor(num) || num > 4294967295 || num < 0) {
          throw new Error("Invalid 32 bit integer");
        }
      }
      function checkFees(psbt, cache, opts) {
        const feeRate = cache.__FEE_RATE || psbt.getFeeRate();
        const vsize = cache.__EXTRACTED_TX.virtualSize();
        const satoshis = feeRate * vsize;
        if (feeRate >= opts.maximumFeeRate) {
          throw new Error(
            `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in fees, which is ${feeRate} satoshi per byte for a transaction with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
          );
        }
      }
      function checkInputsForPartialSig(inputs, action) {
        inputs.forEach((input) => {
          const throws = (0, bip371_1.isTaprootInput)(input) ? (0, bip371_1.checkTaprootInputForSigs)(input, action) : (0, psbtutils_1.checkInputForSig)(input, action);
          if (throws)
            throw new Error("Can not modify transaction, signatures exist.");
        });
      }
      function checkPartialSigSighashes(input) {
        if (!input.sighashType || !input.partialSig) return;
        const { partialSig, sighashType } = input;
        partialSig.forEach((pSig) => {
          const { hashType } = bscript.signature.decode(pSig.signature);
          if (sighashType !== hashType) {
            throw new Error("Signature sighash does not match input sighash type");
          }
        });
      }
      function checkScriptForPubkey(pubkey, script, action) {
        if (!(0, psbtutils_1.pubkeyInScript)(pubkey, script)) {
          throw new Error(
            `Can not ${action} for this input with the key ${pubkey.toString("hex")}`
          );
        }
      }
      function checkTxEmpty(tx) {
        const isEmpty = tx.ins.every(
          (input) => input.script && input.script.length === 0 && input.witness && input.witness.length === 0
        );
        if (!isEmpty) {
          throw new Error("Format Error: Transaction ScriptSigs are not empty");
        }
      }
      function checkTxForDupeIns(tx, cache) {
        tx.ins.forEach((input) => {
          checkTxInputCache(cache, input);
        });
      }
      function checkTxInputCache(cache, input) {
        const key = (0, bufferutils_1.reverseBuffer)(Buffer2.from(input.hash)).toString("hex") + ":" + input.index;
        if (cache.__TX_IN_CACHE[key]) throw new Error("Duplicate input detected.");
        cache.__TX_IN_CACHE[key] = 1;
      }
      function scriptCheckerFactory(payment, paymentScriptName) {
        return (inputIndex, scriptPubKey, redeemScript, ioType) => {
          const redeemScriptOutput = payment({
            redeem: { output: redeemScript }
          }).output;
          if (!scriptPubKey.equals(redeemScriptOutput)) {
            throw new Error(
              `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`
            );
          }
        };
      }
      var checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script");
      var checkWitnessScript = scriptCheckerFactory(
        payments.p2wsh,
        "Witness script"
      );
      function getTxCacheValue(key, name2, inputs, c) {
        if (!inputs.every(isFinalized))
          throw new Error(`PSBT must be finalized to calculate ${name2}`);
        if (key === "__FEE_RATE" && c.__FEE_RATE) return c.__FEE_RATE;
        if (key === "__FEE" && c.__FEE) return c.__FEE;
        let tx;
        let mustFinalize = true;
        if (c.__EXTRACTED_TX) {
          tx = c.__EXTRACTED_TX;
          mustFinalize = false;
        } else {
          tx = c.__TX.clone();
        }
        inputFinalizeGetAmts(inputs, tx, c, mustFinalize);
        if (key === "__FEE_RATE") return c.__FEE_RATE;
        else if (key === "__FEE") return c.__FEE;
      }
      function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {
        const scriptType = classifyScript(script);
        if (!canFinalize(input, script, scriptType))
          throw new Error(`Can not finalize input #${inputIndex}`);
        return prepareFinalScripts(
          script,
          scriptType,
          input.partialSig,
          isSegwit,
          isP2SH,
          isP2WSH
        );
      }
      function prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH) {
        let finalScriptSig;
        let finalScriptWitness;
        const payment = getPayment(script, scriptType, partialSig);
        const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });
        const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });
        if (isSegwit) {
          if (p2wsh) {
            finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
              p2wsh.witness
            );
          } else {
            finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
              payment.witness
            );
          }
          if (p2sh) {
            finalScriptSig = p2sh.input;
          }
        } else {
          if (p2sh) {
            finalScriptSig = p2sh.input;
          } else {
            finalScriptSig = payment.input;
          }
        }
        return {
          finalScriptSig,
          finalScriptWitness
        };
      }
      function getHashAndSighashType(inputs, inputIndex, pubkey, cache, sighashTypes) {
        const input = (0, utils_1.checkForInput)(inputs, inputIndex);
        const { hash, sighashType, script } = getHashForSig(
          inputIndex,
          input,
          cache,
          false,
          sighashTypes
        );
        checkScriptForPubkey(pubkey, script, "sign");
        return {
          hash,
          sighashType
        };
      }
      function getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {
        const unsignedTx = cache.__TX;
        const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_ALL;
        checkSighashTypeAllowed(sighashType, sighashTypes);
        let hash;
        let prevout;
        if (input.nonWitnessUtxo) {
          const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
            cache,
            input,
            inputIndex
          );
          const prevoutHash = unsignedTx.ins[inputIndex].hash;
          const utxoHash = nonWitnessUtxoTx.getHash();
          if (!prevoutHash.equals(utxoHash)) {
            throw new Error(
              `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`
            );
          }
          const prevoutIndex = unsignedTx.ins[inputIndex].index;
          prevout = nonWitnessUtxoTx.outs[prevoutIndex];
        } else if (input.witnessUtxo) {
          prevout = input.witnessUtxo;
        } else {
          throw new Error("Need a Utxo input item for signing");
        }
        const { meaningfulScript, type } = getMeaningfulScript(
          prevout.script,
          inputIndex,
          "input",
          input.redeemScript,
          input.witnessScript
        );
        if (["p2sh-p2wsh", "p2wsh"].indexOf(type) >= 0) {
          hash = unsignedTx.hashForWitnessV0(
            inputIndex,
            meaningfulScript,
            prevout.value,
            sighashType
          );
        } else if ((0, psbtutils_1.isP2WPKH)(meaningfulScript)) {
          const signingScript = payments.p2pkh({
            hash: meaningfulScript.slice(2)
          }).output;
          hash = unsignedTx.hashForWitnessV0(
            inputIndex,
            signingScript,
            prevout.value,
            sighashType
          );
        } else {
          if (input.nonWitnessUtxo === void 0 && cache.__UNSAFE_SIGN_NONSEGWIT === false)
            throw new Error(
              `Input #${inputIndex} has witnessUtxo but non-segwit script: ${meaningfulScript.toString("hex")}`
            );
          if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)
            console.warn(
              "Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n*********************"
            );
          hash = unsignedTx.hashForSignature(
            inputIndex,
            meaningfulScript,
            sighashType
          );
        }
        return {
          script: meaningfulScript,
          sighashType,
          hash
        };
      }
      function getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {
        const allPublicKeys = [];
        if (input.tapInternalKey) {
          const key = getPrevoutTaprootKey(inputIndex, input, cache);
          if (key) {
            allPublicKeys.push(key);
          }
        }
        if (input.tapScriptSig) {
          const tapScriptPubkeys = input.tapScriptSig.map((tss) => tss.pubkey);
          allPublicKeys.push(...tapScriptPubkeys);
        }
        const allHashes = allPublicKeys.map(
          (pubicKey) => getTaprootHashesForSig(inputIndex, input, inputs, pubicKey, cache)
        );
        return allHashes.flat();
      }
      function getPrevoutTaprootKey(inputIndex, input, cache) {
        const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);
        return (0, psbtutils_1.isP2TR)(script) ? script.subarray(2, 34) : null;
      }
      function trimTaprootSig(signature) {
        return signature.length === 64 ? signature : signature.subarray(0, 64);
      }
      function getTaprootHashesForSig(inputIndex, input, inputs, pubkey, cache, tapLeafHashToSign, allowedSighashTypes) {
        const unsignedTx = cache.__TX;
        const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
        checkSighashTypeAllowed(sighashType, allowedSighashTypes);
        const prevOuts = inputs.map(
          (i, index) => getScriptAndAmountFromUtxo(index, i, cache)
        );
        const signingScripts = prevOuts.map((o) => o.script);
        const values = prevOuts.map((o) => o.value);
        const hashes = [];
        if (input.tapInternalKey && !tapLeafHashToSign) {
          const outputKey = getPrevoutTaprootKey(inputIndex, input, cache) || Buffer2.from([]);
          if ((0, bip371_1.toXOnly)(pubkey).equals(outputKey)) {
            const tapKeyHash = unsignedTx.hashForWitnessV1(
              inputIndex,
              signingScripts,
              values,
              sighashType
            );
            hashes.push({ pubkey, hash: tapKeyHash });
          }
        }
        const tapLeafHashes = (input.tapLeafScript || []).filter((tapLeaf) => (0, psbtutils_1.pubkeyInScript)(pubkey, tapLeaf.script)).map((tapLeaf) => {
          const hash = (0, bip341_1.tapleafHash)({
            output: tapLeaf.script,
            version: tapLeaf.leafVersion
          });
          return Object.assign({ hash }, tapLeaf);
        }).filter(
          (tapLeaf) => !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash)
        ).map((tapLeaf) => {
          const tapScriptHash = unsignedTx.hashForWitnessV1(
            inputIndex,
            signingScripts,
            values,
            sighashType,
            tapLeaf.hash
          );
          return {
            pubkey,
            hash: tapScriptHash,
            leafHash: tapLeaf.hash
          };
        });
        return hashes.concat(tapLeafHashes);
      }
      function checkSighashTypeAllowed(sighashType, sighashTypes) {
        if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
          const str = sighashTypeToString(sighashType);
          throw new Error(
            `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${str}`
          );
        }
      }
      function getPayment(script, scriptType, partialSig) {
        let payment;
        switch (scriptType) {
          case "multisig":
            const sigs = getSortedSigs(script, partialSig);
            payment = payments.p2ms({
              output: script,
              signatures: sigs
            });
            break;
          case "pubkey":
            payment = payments.p2pk({
              output: script,
              signature: partialSig[0].signature
            });
            break;
          case "pubkeyhash":
            payment = payments.p2pkh({
              output: script,
              pubkey: partialSig[0].pubkey,
              signature: partialSig[0].signature
            });
            break;
          case "witnesspubkeyhash":
            payment = payments.p2wpkh({
              output: script,
              pubkey: partialSig[0].pubkey,
              signature: partialSig[0].signature
            });
            break;
        }
        return payment;
      }
      function getScriptFromInput(inputIndex, input, cache) {
        const unsignedTx = cache.__TX;
        const res = {
          script: null,
          isSegwit: false,
          isP2SH: false,
          isP2WSH: false
        };
        res.isP2SH = !!input.redeemScript;
        res.isP2WSH = !!input.witnessScript;
        if (input.witnessScript) {
          res.script = input.witnessScript;
        } else if (input.redeemScript) {
          res.script = input.redeemScript;
        } else {
          if (input.nonWitnessUtxo) {
            const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
              cache,
              input,
              inputIndex
            );
            const prevoutIndex = unsignedTx.ins[inputIndex].index;
            res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
          } else if (input.witnessUtxo) {
            res.script = input.witnessUtxo.script;
          }
        }
        if (input.witnessScript || (0, psbtutils_1.isP2WPKH)(res.script)) {
          res.isSegwit = true;
        }
        return res;
      }
      function getSignersFromHD(inputIndex, inputs, hdKeyPair) {
        const input = (0, utils_1.checkForInput)(inputs, inputIndex);
        if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
          throw new Error("Need bip32Derivation to sign with HD");
        }
        const myDerivations = input.bip32Derivation.map((bipDv) => {
          if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
            return bipDv;
          } else {
            return;
          }
        }).filter((v) => !!v);
        if (myDerivations.length === 0) {
          throw new Error(
            "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
          );
        }
        const signers = myDerivations.map((bipDv) => {
          const node = hdKeyPair.derivePath(bipDv.path);
          if (!bipDv.pubkey.equals(node.publicKey)) {
            throw new Error("pubkey did not match bip32Derivation");
          }
          return node;
        });
        return signers;
      }
      function getSortedSigs(script, partialSig) {
        const p2ms = payments.p2ms({ output: script });
        return p2ms.pubkeys.map((pk) => {
          return (partialSig.filter((ps) => {
            return ps.pubkey.equals(pk);
          })[0] || {}).signature;
        }).filter((v) => !!v);
      }
      function scriptWitnessToWitnessStack(buffer) {
        let offset = 0;
        function readSlice(n) {
          offset += n;
          return buffer.slice(offset - n, offset);
        }
        function readVarInt() {
          const vi = varuint.decode(buffer, offset);
          offset += varuint.decode.bytes;
          return vi;
        }
        function readVarSlice() {
          return readSlice(readVarInt());
        }
        function readVector() {
          const count = readVarInt();
          const vector = [];
          for (let i = 0; i < count; i++) vector.push(readVarSlice());
          return vector;
        }
        return readVector();
      }
      function sighashTypeToString(sighashType) {
        let text = sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
        const sigMod = sighashType & 31;
        switch (sigMod) {
          case transaction_1.Transaction.SIGHASH_ALL:
            text += "SIGHASH_ALL";
            break;
          case transaction_1.Transaction.SIGHASH_SINGLE:
            text += "SIGHASH_SINGLE";
            break;
          case transaction_1.Transaction.SIGHASH_NONE:
            text += "SIGHASH_NONE";
            break;
        }
        return text;
      }
      function addNonWitnessTxCache(cache, input, inputIndex) {
        cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;
        const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);
        cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;
        const self2 = cache;
        const selfIndex = inputIndex;
        delete input.nonWitnessUtxo;
        Object.defineProperty(input, "nonWitnessUtxo", {
          enumerable: true,
          get() {
            const buf = self2.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];
            const txCache = self2.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];
            if (buf !== void 0) {
              return buf;
            } else {
              const newBuf = txCache.toBuffer();
              self2.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;
              return newBuf;
            }
          },
          set(data) {
            self2.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;
          }
        });
      }
      function inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {
        let inputAmount = 0;
        inputs.forEach((input, idx) => {
          if (mustFinalize && input.finalScriptSig)
            tx.ins[idx].script = input.finalScriptSig;
          if (mustFinalize && input.finalScriptWitness) {
            tx.ins[idx].witness = scriptWitnessToWitnessStack(
              input.finalScriptWitness
            );
          }
          if (input.witnessUtxo) {
            inputAmount += input.witnessUtxo.value;
          } else if (input.nonWitnessUtxo) {
            const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);
            const vout = tx.ins[idx].index;
            const out = nwTx.outs[vout];
            inputAmount += out.value;
          }
        });
        const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);
        const fee = inputAmount - outputAmount;
        if (fee < 0) {
          throw new Error("Outputs are spending more than Inputs");
        }
        const bytes = tx.virtualSize();
        cache.__FEE = fee;
        cache.__EXTRACTED_TX = tx;
        cache.__FEE_RATE = Math.floor(fee / bytes);
      }
      function nonWitnessUtxoTxFromCache(cache, input, inputIndex) {
        const c = cache.__NON_WITNESS_UTXO_TX_CACHE;
        if (!c[inputIndex]) {
          addNonWitnessTxCache(cache, input, inputIndex);
        }
        return c[inputIndex];
      }
      function getScriptFromUtxo(inputIndex, input, cache) {
        const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);
        return script;
      }
      function getScriptAndAmountFromUtxo(inputIndex, input, cache) {
        if (input.witnessUtxo !== void 0) {
          return {
            script: input.witnessUtxo.script,
            value: input.witnessUtxo.value
          };
        } else if (input.nonWitnessUtxo !== void 0) {
          const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
            cache,
            input,
            inputIndex
          );
          const o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];
          return { script: o.script, value: o.value };
        } else {
          throw new Error("Can't find pubkey in input without Utxo data");
        }
      }
      function pubkeyInInput(pubkey, input, inputIndex, cache) {
        const script = getScriptFromUtxo(inputIndex, input, cache);
        const { meaningfulScript } = getMeaningfulScript(
          script,
          inputIndex,
          "input",
          input.redeemScript,
          input.witnessScript
        );
        return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);
      }
      function pubkeyInOutput(pubkey, output, outputIndex, cache) {
        const script = cache.__TX.outs[outputIndex].script;
        const { meaningfulScript } = getMeaningfulScript(
          script,
          outputIndex,
          "output",
          output.redeemScript,
          output.witnessScript
        );
        return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);
      }
      function redeemFromFinalScriptSig(finalScript) {
        if (!finalScript) return;
        const decomp = bscript.decompile(finalScript);
        if (!decomp) return;
        const lastItem = decomp[decomp.length - 1];
        if (!Buffer2.isBuffer(lastItem) || isPubkeyLike(lastItem) || isSigLike(lastItem))
          return;
        const sDecomp = bscript.decompile(lastItem);
        if (!sDecomp) return;
        return lastItem;
      }
      function redeemFromFinalWitnessScript(finalScript) {
        if (!finalScript) return;
        const decomp = scriptWitnessToWitnessStack(finalScript);
        const lastItem = decomp[decomp.length - 1];
        if (isPubkeyLike(lastItem)) return;
        const sDecomp = bscript.decompile(lastItem);
        if (!sDecomp) return;
        return lastItem;
      }
      function compressPubkey(pubkey) {
        if (pubkey.length === 65) {
          const parity = pubkey[64] & 1;
          const newKey = pubkey.slice(0, 33);
          newKey[0] = 2 | parity;
          return newKey;
        }
        return pubkey.slice();
      }
      function isPubkeyLike(buf) {
        return buf.length === 33 && bscript.isCanonicalPubKey(buf);
      }
      function isSigLike(buf) {
        return bscript.isCanonicalScriptSignature(buf);
      }
      function getMeaningfulScript(script, index, ioType, redeemScript, witnessScript) {
        const isP2SH = (0, psbtutils_1.isP2SHScript)(script);
        const isP2SHP2WSH = isP2SH && redeemScript && (0, psbtutils_1.isP2WSHScript)(redeemScript);
        const isP2WSH = (0, psbtutils_1.isP2WSHScript)(script);
        if (isP2SH && redeemScript === void 0)
          throw new Error("scriptPubkey is P2SH but redeemScript missing");
        if ((isP2WSH || isP2SHP2WSH) && witnessScript === void 0)
          throw new Error(
            "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
          );
        let meaningfulScript;
        if (isP2SHP2WSH) {
          meaningfulScript = witnessScript;
          checkRedeemScript(index, script, redeemScript, ioType);
          checkWitnessScript(index, redeemScript, witnessScript, ioType);
          checkInvalidP2WSH(meaningfulScript);
        } else if (isP2WSH) {
          meaningfulScript = witnessScript;
          checkWitnessScript(index, script, witnessScript, ioType);
          checkInvalidP2WSH(meaningfulScript);
        } else if (isP2SH) {
          meaningfulScript = redeemScript;
          checkRedeemScript(index, script, redeemScript, ioType);
        } else {
          meaningfulScript = script;
        }
        return {
          meaningfulScript,
          type: isP2SHP2WSH ? "p2sh-p2wsh" : isP2SH ? "p2sh" : isP2WSH ? "p2wsh" : "raw"
        };
      }
      function checkInvalidP2WSH(script) {
        if ((0, psbtutils_1.isP2WPKH)(script) || (0, psbtutils_1.isP2SHScript)(script)) {
          throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
        }
      }
      function classifyScript(script) {
        if ((0, psbtutils_1.isP2WPKH)(script)) return "witnesspubkeyhash";
        if ((0, psbtutils_1.isP2PKH)(script)) return "pubkeyhash";
        if ((0, psbtutils_1.isP2MS)(script)) return "multisig";
        if ((0, psbtutils_1.isP2PK)(script)) return "pubkey";
        return "nonstandard";
      }
      function range(n) {
        return [...Array(n).keys()];
      }
    }
  });

  // node_modules/bitcoinjs-lib/src/index.js
  var require_src2 = __commonJS({
    "node_modules/bitcoinjs-lib/src/index.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.initEccLib = exports9.Transaction = exports9.opcodes = exports9.Psbt = exports9.Block = exports9.script = exports9.payments = exports9.networks = exports9.crypto = exports9.address = void 0;
      var address = require_address();
      exports9.address = address;
      var crypto2 = require_crypto2();
      exports9.crypto = crypto2;
      var networks = require_networks();
      exports9.networks = networks;
      var payments = require_payments();
      exports9.payments = payments;
      var script = require_script();
      exports9.script = script;
      var block_1 = require_block();
      Object.defineProperty(exports9, "Block", {
        enumerable: true,
        get: function() {
          return block_1.Block;
        }
      });
      var psbt_1 = require_psbt2();
      Object.defineProperty(exports9, "Psbt", {
        enumerable: true,
        get: function() {
          return psbt_1.Psbt;
        }
      });
      var ops_1 = require_ops();
      Object.defineProperty(exports9, "opcodes", {
        enumerable: true,
        get: function() {
          return ops_1.OPS;
        }
      });
      var transaction_1 = require_transaction();
      Object.defineProperty(exports9, "Transaction", {
        enumerable: true,
        get: function() {
          return transaction_1.Transaction;
        }
      });
      var ecc_lib_1 = require_ecc_lib();
      Object.defineProperty(exports9, "initEccLib", {
        enumerable: true,
        get: function() {
          return ecc_lib_1.initEccLib;
        }
      });
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      if (typeof Object.create === "function") {
        module.exports = function inherits2(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits2(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/events.js
  function dew2() {
    if (_dewExec2) return exports$12;
    _dewExec2 = true;
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter2() {
      EventEmitter2.init.call(this);
    }
    exports$12 = EventEmitter2;
    exports$12.once = once3;
    EventEmitter2.EventEmitter = EventEmitter2;
    EventEmitter2.prototype._events = void 0;
    EventEmitter2.prototype._eventsCount = 0;
    EventEmitter2.prototype._maxListeners = void 0;
    var defaultMaxListeners2 = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners2;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners2 = arg;
      }
    });
    EventEmitter2.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0) return EventEmitter2.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter2.prototype.emit = function emit2(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0) doError = doError && events.error === void 0;
      else if (!doError) return false;
      if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0) return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners2 = arrayClone(handler, len);
        for (var i = 0; i < len; ++i) ReflectApply(listeners2[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit("newListener", type, listener.listener ? listener.listener : listener);
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter2.prototype.addListener = function addListener2(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
    EventEmitter2.prototype.prependListener = function prependListener2(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = {
        fired: false,
        wrapFn: void 0,
        target,
        type,
        listener
      };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter2.prototype.once = function once4(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.prependOnceListener = function prependOnceListener2(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.removeListener = function removeListener2(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0) return this;
      list = events[type];
      if (list === void 0) return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== void 0) this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners2(type) {
      var listeners2, events, i;
      events = this._events;
      if (events === void 0) return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0) this._events = /* @__PURE__ */ Object.create(null);
          else delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type];
      if (typeof listeners2 === "function") {
        this.removeListener(type, listeners2);
      } else if (listeners2 !== void 0) {
        for (i = listeners2.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners2[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0) return [];
      var evlistener = events[type];
      if (evlistener === void 0) return [];
      if (typeof evlistener === "function") return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter2.prototype.listeners = function listeners2(type) {
      return _listeners(this, type, true);
    };
    EventEmitter2.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter2.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount2.call(emitter, type);
      }
    };
    EventEmitter2.prototype.listenerCount = listenerCount2;
    function listenerCount2(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i) copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++) list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once3(emitter, name2) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name2, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name2, resolver, {
          once: true
        });
        if (name2 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, {
            once: true
          });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name2, listener);
        } else {
          emitter.on(name2, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name2, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name2, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
    return exports$12;
  }
  var exports$12, _dewExec2, exports3, EventEmitter, defaultMaxListeners, init, listenerCount, on, once;
  var init_events = __esm({
    "node_modules/@jspm/core/nodelibs/browser/events.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      exports$12 = {};
      _dewExec2 = false;
      exports3 = dew2();
      exports3["once"];
      exports3.once = function(emitter, event) {
        return new Promise((resolve, reject) => {
          function eventListener(...args) {
            if (errorListener !== void 0) {
              emitter.removeListener("error", errorListener);
            }
            resolve(args);
          }
          let errorListener;
          if (event !== "error") {
            errorListener = (err) => {
              emitter.removeListener(name, eventListener);
              reject(err);
            };
            emitter.once("error", errorListener);
          }
          emitter.once(event, eventListener);
        });
      };
      exports3.on = function(emitter, event) {
        const unconsumedEventValues = [];
        const unconsumedPromises = [];
        let error = null;
        let finished2 = false;
        const iterator = {
          async next() {
            const value = unconsumedEventValues.shift();
            if (value) {
              return createIterResult(value, false);
            }
            if (error) {
              const p = Promise.reject(error);
              error = null;
              return p;
            }
            if (finished2) {
              return createIterResult(void 0, true);
            }
            return new Promise((resolve, reject) => unconsumedPromises.push({ resolve, reject }));
          },
          async return() {
            emitter.removeListener(event, eventHandler);
            emitter.removeListener("error", errorHandler);
            finished2 = true;
            for (const promise of unconsumedPromises) {
              promise.resolve(createIterResult(void 0, true));
            }
            return createIterResult(void 0, true);
          },
          throw(err) {
            error = err;
            emitter.removeListener(event, eventHandler);
            emitter.removeListener("error", errorHandler);
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
        emitter.on(event, eventHandler);
        emitter.on("error", errorHandler);
        return iterator;
        function eventHandler(...args) {
          const promise = unconsumedPromises.shift();
          if (promise) {
            promise.resolve(createIterResult(args, false));
          } else {
            unconsumedEventValues.push(args);
          }
        }
        function errorHandler(err) {
          finished2 = true;
          const toError = unconsumedPromises.shift();
          if (toError) {
            toError.reject(err);
          } else {
            error = err;
          }
          iterator.return();
        }
      };
      ({
        EventEmitter,
        defaultMaxListeners,
        init,
        listenerCount,
        on,
        once
      } = exports3);
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-DEMDiNwt.js
  function unimplemented(name2) {
    throw new Error("Node.js process " + name2 + " is not supported by JSPM core outside of Node.js");
  }
  function cleanUpNextTick() {
    if (!draining || !currentQueue)
      return;
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length)
      drainQueue();
  }
  function drainQueue() {
    if (draining)
      return;
    var timeout = setTimeout(cleanUpNextTick, 0);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue)
          currentQueue[queueIndex].run();
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++)
        args[i - 1] = arguments[i];
    }
    queue.push(new Item2(fun, args));
    if (queue.length === 1 && !draining)
      setTimeout(drainQueue, 0);
  }
  function Item2(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function noop() {
  }
  function _linkedBinding(name2) {
    unimplemented("_linkedBinding");
  }
  function dlopen(name2) {
    unimplemented("dlopen");
  }
  function _getActiveRequests() {
    return [];
  }
  function _getActiveHandles() {
    return [];
  }
  function assert(condition, message) {
    if (!condition) throw new Error(message || "assertion error");
  }
  function hasUncaughtExceptionCaptureCallback() {
    return false;
  }
  function uptime() {
    return _performance2.now() / 1e3;
  }
  function hrtime2(previousTimestamp) {
    var baseNow = Math.floor((Date.now() - _performance2.now()) * 1e-3);
    var clocktime = _performance2.now() * 1e-3;
    var seconds = Math.floor(clocktime) + baseNow;
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += nanoPerSec2;
      }
    }
    return [seconds, nanoseconds];
  }
  function on2() {
    return process;
  }
  function listeners(name2) {
    return [];
  }
  var queue, draining, currentQueue, queueIndex, title, arch, platform, env2, argv, execArgv, version, versions, emitWarning, binding, umask, cwd, chdir, release, _rawDebug, moduleLoadList, domain, _exiting, config, reallyExit, _kill, cpuUsage, resourceUsage, memoryUsage, kill, exit, openStdin, allowedNodeEnvironmentFlags, features, _fatalExceptions, setUncaughtExceptionCaptureCallback, _tickCallback, _debugProcess, _debugEnd, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, stdout, stderr, stdin, abort, pid, ppid, execPath, debugPort, argv0, _preload_modules, setSourceMapsEnabled, _performance2, nowOffset, nanoPerSec2, _maxListeners, _events, _eventsCount, addListener, once2, off, removeListener, removeAllListeners, emit, prependListener, prependOnceListener, process;
  var init_chunk_DEMDiNwt = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-DEMDiNwt.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      queue = [];
      draining = false;
      queueIndex = -1;
      Item2.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      title = "browser";
      arch = "x64";
      platform = "browser";
      env2 = {
        PATH: "/usr/bin",
        LANG: navigator.language + ".UTF-8",
        PWD: "/",
        HOME: "/home",
        TMP: "/tmp"
      };
      argv = ["/usr/bin/node"];
      execArgv = [];
      version = "v16.8.0";
      versions = {};
      emitWarning = function(message, type) {
        console.warn((type ? type + ": " : "") + message);
      };
      binding = function(name2) {
        unimplemented("binding");
      };
      umask = function(mask) {
        return 0;
      };
      cwd = function() {
        return "/";
      };
      chdir = function(dir) {
      };
      release = {
        name: "node",
        sourceUrl: "",
        headersUrl: "",
        libUrl: ""
      };
      _rawDebug = noop;
      moduleLoadList = [];
      domain = {};
      _exiting = false;
      config = {};
      reallyExit = noop;
      _kill = noop;
      cpuUsage = function() {
        return {};
      };
      resourceUsage = cpuUsage;
      memoryUsage = cpuUsage;
      kill = noop;
      exit = noop;
      openStdin = noop;
      allowedNodeEnvironmentFlags = {};
      features = {
        inspector: false,
        debug: false,
        uv: false,
        ipv6: false,
        tls_alpn: false,
        tls_sni: false,
        tls_ocsp: false,
        tls: false,
        cached_builtins: true
      };
      _fatalExceptions = noop;
      setUncaughtExceptionCaptureCallback = noop;
      _tickCallback = noop;
      _debugProcess = noop;
      _debugEnd = noop;
      _startProfilerIdleNotifier = noop;
      _stopProfilerIdleNotifier = noop;
      stdout = void 0;
      stderr = void 0;
      stdin = void 0;
      abort = noop;
      pid = 2;
      ppid = 1;
      execPath = "/bin/usr/node";
      debugPort = 9229;
      argv0 = "node";
      _preload_modules = [];
      setSourceMapsEnabled = noop;
      _performance2 = {
        now: typeof performance !== "undefined" ? performance.now.bind(performance) : void 0,
        timing: typeof performance !== "undefined" ? performance.timing : void 0
      };
      if (_performance2.now === void 0) {
        nowOffset = Date.now();
        if (_performance2.timing && _performance2.timing.navigationStart) {
          nowOffset = _performance2.timing.navigationStart;
        }
        _performance2.now = () => Date.now() - nowOffset;
      }
      nanoPerSec2 = 1e9;
      hrtime2.bigint = function(time) {
        var diff = hrtime2(time);
        if (typeof BigInt === "undefined") {
          return diff[0] * nanoPerSec2 + diff[1];
        }
        return BigInt(diff[0] * nanoPerSec2) + BigInt(diff[1]);
      };
      _maxListeners = 10;
      _events = {};
      _eventsCount = 0;
      addListener = on2;
      once2 = on2;
      off = on2;
      removeListener = on2;
      removeAllListeners = on2;
      emit = noop;
      prependListener = on2;
      prependOnceListener = on2;
      process = {
        version,
        versions,
        arch,
        platform,
        release,
        _rawDebug,
        moduleLoadList,
        binding,
        _linkedBinding,
        _events,
        _eventsCount,
        _maxListeners,
        on: on2,
        addListener,
        once: once2,
        off,
        removeListener,
        removeAllListeners,
        emit,
        prependListener,
        prependOnceListener,
        listeners,
        domain,
        _exiting,
        config,
        dlopen,
        uptime,
        _getActiveRequests,
        _getActiveHandles,
        reallyExit,
        _kill,
        cpuUsage,
        resourceUsage,
        memoryUsage,
        kill,
        exit,
        openStdin,
        allowedNodeEnvironmentFlags,
        assert,
        features,
        _fatalExceptions,
        setUncaughtExceptionCaptureCallback,
        hasUncaughtExceptionCaptureCallback,
        emitWarning,
        nextTick,
        _tickCallback,
        _debugProcess,
        _debugEnd,
        _startProfilerIdleNotifier,
        _stopProfilerIdleNotifier,
        stdout,
        stdin,
        stderr,
        abort,
        umask,
        chdir,
        cwd,
        env: env2,
        title,
        argv,
        execArgv,
        pid,
        ppid,
        execPath,
        debugPort,
        hrtime: hrtime2,
        argv0,
        _preload_modules,
        setSourceMapsEnabled
      };
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-CcCWfKp1.js
  function dew$12() {
    if (_dewExec$12) return exports$22;
    _dewExec$12 = true;
    var buffer = dew();
    var Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      exports$22 = buffer;
    } else {
      copyProps(buffer, exports$22);
      exports$22.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
    return exports$22;
  }
  function dew3() {
    if (_dewExec3) return exports$13;
    _dewExec3 = true;
    var Buffer3 = dew$12().Buffer;
    var isEncoding = Buffer3.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports$13.StringDecoder = StringDecoder2;
    function StringDecoder2(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer3.allocUnsafe(nb);
    }
    StringDecoder2.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder2.prototype.end = utf8End;
    StringDecoder2.prototype.text = utf8Text;
    StringDecoder2.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
    return exports$13;
  }
  var exports$22, _dewExec$12, exports$13, _dewExec3, exports4, StringDecoder;
  var init_chunk_CcCWfKp1 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-CcCWfKp1.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_DtuTasat();
      exports$22 = {};
      _dewExec$12 = false;
      exports$13 = {};
      _dewExec3 = false;
      exports4 = dew3();
      exports4["StringDecoder"];
      StringDecoder = exports4.StringDecoder;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-DtcTpLWz.js
  function dew$k() {
    if (_dewExec$k) return exports$k;
    _dewExec$k = true;
    exports$k = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
    return exports$k;
  }
  function dew$j() {
    if (_dewExec$j) return exports$j;
    _dewExec$j = true;
    exports$j = Error;
    return exports$j;
  }
  function dew$i() {
    if (_dewExec$i) return exports$i;
    _dewExec$i = true;
    exports$i = EvalError;
    return exports$i;
  }
  function dew$h() {
    if (_dewExec$h) return exports$h;
    _dewExec$h = true;
    exports$h = RangeError;
    return exports$h;
  }
  function dew$g() {
    if (_dewExec$g) return exports$g;
    _dewExec$g = true;
    exports$g = ReferenceError;
    return exports$g;
  }
  function dew$f() {
    if (_dewExec$f) return exports$f;
    _dewExec$f = true;
    exports$f = SyntaxError;
    return exports$f;
  }
  function dew$e() {
    if (_dewExec$e) return exports$e;
    _dewExec$e = true;
    exports$e = TypeError;
    return exports$e;
  }
  function dew$d() {
    if (_dewExec$d) return exports$d;
    _dewExec$d = true;
    exports$d = URIError;
    return exports$d;
  }
  function dew$c() {
    if (_dewExec$c) return exports$c;
    _dewExec$c = true;
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = dew$k();
    exports$c = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
    return exports$c;
  }
  function dew$b() {
    if (_dewExec$b) return exports$b;
    _dewExec$b = true;
    var test = {
      __proto__: null,
      foo: {}
    };
    var $Object = Object;
    exports$b = function hasProto() {
      return {
        __proto__: test
      }.foo === test.foo && !(test instanceof $Object);
    };
    return exports$b;
  }
  function dew$a() {
    if (_dewExec$a) return exports$a;
    _dewExec$a = true;
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    exports$a = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(this, concatty(args, arguments));
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(that, concatty(args, arguments));
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
    return exports$a;
  }
  function dew$9() {
    if (_dewExec$9) return exports$9;
    _dewExec$9 = true;
    var implementation = dew$a();
    exports$9 = Function.prototype.bind || implementation;
    return exports$9;
  }
  function dew$8() {
    if (_dewExec$8) return exports$8;
    _dewExec$8 = true;
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = dew$9();
    exports$8 = bind.call(call, $hasOwn);
    return exports$8;
  }
  function dew$7() {
    if (_dewExec$7) return exports$7;
    _dewExec$7 = true;
    var undefined$1;
    var $Error = dew$j();
    var $EvalError = dew$i();
    var $RangeError = dew$h();
    var $ReferenceError = dew$g();
    var $SyntaxError = dew$f();
    var $TypeError = dew$e();
    var $URIError = dew$d();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = dew$c()();
    var hasProto = dew$b()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
      "%AsyncFromSyncIteratorPrototype%": undefined$1,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
      "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
      "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
      "%Symbol%": hasSymbols ? Symbol : undefined$1,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        var errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var doEval = function doEval2(name2) {
      var value;
      if (name2 === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name2 === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name2 === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name2 === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name2 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name2] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = dew$9();
    var hasOwn = dew$8();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
      var intrinsicName = name2;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
    };
    exports$7 = function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name2) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name2);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || last === '"' || last === "'" || last === "`") && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            }
            return void undefined$1;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
    return exports$7;
  }
  function dew$6() {
    if (_dewExec$6) return exports$6;
    _dewExec$6 = true;
    var GetIntrinsic = dew$7();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", {
          value: 1
        });
      } catch (e) {
        $defineProperty = false;
      }
    }
    exports$6 = $defineProperty;
    return exports$6;
  }
  function dew$5() {
    if (_dewExec$5) return exports$5;
    _dewExec$5 = true;
    var GetIntrinsic = dew$7();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    exports$5 = $gOPD;
    return exports$5;
  }
  function dew$4() {
    if (_dewExec$4) return exports$4;
    _dewExec$4 = true;
    var $defineProperty = dew$6();
    var $SyntaxError = dew$f();
    var $TypeError = dew$e();
    var gopd = dew$5();
    exports$4 = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
    return exports$4;
  }
  function dew$3() {
    if (_dewExec$3) return exports$3;
    _dewExec$3 = true;
    var $defineProperty = dew$6();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", {
          value: 1
        }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    exports$3 = hasPropertyDescriptors;
    return exports$3;
  }
  function dew$22() {
    if (_dewExec$22) return exports$23;
    _dewExec$22 = true;
    var GetIntrinsic = dew$7();
    var define = dew$4();
    var hasDescriptors = dew$3()();
    var gOPD = dew$5();
    var $TypeError = dew$e();
    var $floor = GetIntrinsic("%Math.floor%");
    exports$23 = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
    return exports$23;
  }
  function dew$13() {
    if (_dewExec$13) return exports$14;
    _dewExec$13 = true;
    var bind = dew$9();
    var GetIntrinsic = dew$7();
    var setFunctionLength = dew$22();
    var $TypeError = dew$e();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = dew$6();
    var $max = GetIntrinsic("%Math.max%");
    exports$14 = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(exports$14, "apply", {
        value: applyBind
      });
    } else {
      exports$14.apply = applyBind;
    }
    return exports$14;
  }
  function dew4() {
    if (_dewExec4) return exports5;
    _dewExec4 = true;
    var GetIntrinsic = dew$7();
    var callBind = dew$13();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    exports5 = function callBoundIntrinsic(name2, allowMissing) {
      var intrinsic = GetIntrinsic(name2, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
    return exports5;
  }
  var exports$k, _dewExec$k, exports$j, _dewExec$j, exports$i, _dewExec$i, exports$h, _dewExec$h, exports$g, _dewExec$g, exports$f, _dewExec$f, exports$e, _dewExec$e, exports$d, _dewExec$d, exports$c, _dewExec$c, exports$b, _dewExec$b, exports$a, _dewExec$a, exports$9, _dewExec$9, exports$8, _dewExec$8, exports$7, _dewExec$7, exports$6, _dewExec$6, exports$5, _dewExec$5, exports$4, _dewExec$4, exports$3, _dewExec$3, exports$23, _dewExec$22, exports$14, _dewExec$13, exports5, _dewExec4;
  var init_chunk_DtcTpLWz = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-DtcTpLWz.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      exports$k = {};
      _dewExec$k = false;
      exports$j = {};
      _dewExec$j = false;
      exports$i = {};
      _dewExec$i = false;
      exports$h = {};
      _dewExec$h = false;
      exports$g = {};
      _dewExec$g = false;
      exports$f = {};
      _dewExec$f = false;
      exports$e = {};
      _dewExec$e = false;
      exports$d = {};
      _dewExec$d = false;
      exports$c = {};
      _dewExec$c = false;
      exports$b = {};
      _dewExec$b = false;
      exports$a = {};
      _dewExec$a = false;
      exports$9 = {};
      _dewExec$9 = false;
      exports$8 = {};
      _dewExec$8 = false;
      exports$7 = {};
      _dewExec$7 = false;
      exports$6 = {};
      _dewExec$6 = false;
      exports$5 = {};
      _dewExec$5 = false;
      exports$4 = {};
      _dewExec$4 = false;
      exports$3 = {};
      _dewExec$3 = false;
      exports$23 = {};
      _dewExec$22 = false;
      exports$14 = {};
      _dewExec$13 = false;
      exports5 = {};
      _dewExec4 = false;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-CkFCi-G1.js
  function dew5() {
    if (_dewExec5) return exports6;
    _dewExec5 = true;
    if (typeof Object.create === "function") {
      exports6 = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      exports6 = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
    return exports6;
  }
  var exports6, _dewExec5;
  var init_chunk_CkFCi_G1 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-CkFCi-G1.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      exports6 = {};
      _dewExec5 = false;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/util.js
  function dew$b2() {
    if (_dewExec$b2) return exports$c2;
    _dewExec$b2 = true;
    var hasSymbols = dew$k();
    exports$c2 = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
    return exports$c2;
  }
  function dew$a2() {
    if (_dewExec$a2) return exports$b2;
    _dewExec$a2 = true;
    var hasToStringTag = dew$b2()();
    var callBound = dew4();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    exports$b2 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    return exports$b2;
  }
  function dew$92() {
    if (_dewExec$92) return exports$a2;
    _dewExec$92 = true;
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = dew$b2()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e) {
      }
    };
    var GeneratorFunction;
    exports$a2 = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
    return exports$a2;
  }
  function dew$82() {
    if (_dewExec$82) return exports$92;
    _dewExec$82 = true;
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      var all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    exports$92 = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
    return exports$92;
  }
  function dew$72() {
    if (_dewExec$72) return exports$82;
    _dewExec$72 = true;
    var isCallable = dew$82();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
          if (receiver == null) {
            iterator(array[i], i, array);
          } else {
            iterator.call(receiver, array[i], i, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i = 0, len = string.length; i < len; i++) {
        if (receiver == null) {
          iterator(string.charAt(i), i, string);
        } else {
          iterator.call(receiver, string.charAt(i), i, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
          if (receiver == null) {
            iterator(object[k], k, object);
          } else {
            iterator.call(receiver, object[k], k, object);
          }
        }
      }
    };
    var forEach = function forEach2(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr.call(list) === "[object Array]") {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
    exports$82 = forEach;
    return exports$82;
  }
  function dew$62() {
    if (_dewExec$62) return exports$72;
    _dewExec$62 = true;
    exports$72 = ["Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"];
    return exports$72;
  }
  function dew$52() {
    if (_dewExec$52) return exports$62;
    _dewExec$52 = true;
    var possibleNames = dew$62();
    var g = typeof globalThis === "undefined" ? _global$2 : globalThis;
    exports$62 = function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
    return exports$62;
  }
  function dew$42() {
    if (_dewExec$42) return exports$52;
    _dewExec$42 = true;
    var forEach = dew$72();
    var availableTypedArrays = dew$52();
    var callBind = dew$13();
    var callBound = dew4();
    var gOPD = dew$5();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = dew$b2()();
    var g = typeof globalThis === "undefined" ? _global$1 : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var getPrototypeOf = Object.getPrototypeOf;
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var cache = {
      __proto__: null
    };
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          cache["$" + typedArray] = callBind(descriptor.get);
        }
      });
    } else {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
          cache["$" + typedArray] = callBind(fn);
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var found = false;
      forEach(
        // eslint-disable-next-line no-extra-parens
        /** @type {Record<`\$${TypedArrayName}`, Getter>} */
        /** @type {any} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, typedArray) {
          if (!found) {
            try {
              if ("$" + getter(value) === typedArray) {
                found = $slice(typedArray, 1);
              }
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    var trySlices = function tryAllSlices(value) {
      var found = false;
      forEach(
        // eslint-disable-next-line no-extra-parens
        /** @type {Record<`\$${TypedArrayName}`, Getter>} */
        /** @type {any} */
        cache,
        /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, name2) {
          if (!found) {
            try {
              getter(value);
              found = $slice(name2, 1);
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    exports$52 = function whichTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value);
    };
    return exports$52;
  }
  function dew$32() {
    if (_dewExec$32) return exports$42;
    _dewExec$32 = true;
    var whichTypedArray = dew$42();
    exports$42 = function isTypedArray(value) {
      return !!whichTypedArray(value);
    };
    return exports$42;
  }
  function dew$23() {
    if (_dewExec$23) return exports$32;
    _dewExec$23 = true;
    var isArgumentsObject = dew$a2();
    var isGeneratorFunction = dew$92();
    var whichTypedArray = dew$42();
    var isTypedArray = dew$32();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    if (SymbolSupported) {
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports$32.isArgumentsObject = isArgumentsObject;
    exports$32.isGeneratorFunction = isGeneratorFunction;
    exports$32.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports$32.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray(value) || isDataView(value);
    }
    exports$32.isArrayBufferView = isArrayBufferView;
    function isUint8Array2(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports$32.isUint8Array = isUint8Array2;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports$32.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports$32.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports$32.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports$32.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports$32.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports$32.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports$32.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports$32.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports$32.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports$32.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports$32.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports$32.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports$32.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports$32.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports$32.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports$32.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports$32.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports$32.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports$32.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports$32.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports$32.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports$32.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports$32.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports$32.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports$32.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports$32.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports$32.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports$32.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports$32.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports$32, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
    return exports$32;
  }
  function dew$14() {
    if (_dewExec$14) return exports$24;
    _dewExec$14 = true;
    exports$24 = function isBuffer2(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
    return exports$24;
  }
  function dew6() {
    if (_dewExec6) return exports$15;
    _dewExec6 = true;
    var process$1 = process;
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys.length; i++) {
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports$15.format = function(f) {
      if (!isString2(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect2(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%") return "%";
        if (i >= len) return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull2(x) || !isObject2(x)) {
          str += " " + x;
        } else {
          str += " " + inspect2(x);
        }
      }
      return str;
    };
    exports$15.deprecate = function(fn, msg) {
      if (typeof process$1 !== "undefined" && process$1.noDeprecation === true) {
        return fn;
      }
      if (typeof process$1 === "undefined") {
        return function() {
          return exports$15.deprecate(fn, msg).apply(this || _global, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process$1.throwDeprecation) {
            throw new Error(msg);
          } else if (process$1.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this || _global, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var debugEnv = process$1.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    exports$15.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid2 = process$1.pid;
          debugs[set] = function() {
            var msg = exports$15.format.apply(exports$15, arguments);
            console.error("%s %d: %s", set, pid2, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect2(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean2(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports$15._extend(ctx, opts);
      }
      if (isUndefined2(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined2(ctx.depth)) ctx.depth = 2;
      if (isUndefined2(ctx.colors)) ctx.colors = false;
      if (isUndefined2(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports$15.inspect = inspect2;
    inspect2.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect2.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect2.styles[styleType];
      if (style) {
        return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction2(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports$15.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString2(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError2(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction2(value)) {
          var name2 = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name2 + "]", "special");
        }
        if (isRegExp2(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate2(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError2(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray2(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction2(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
      }
      if (isRegExp2(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate2(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError2(value)) {
        base = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp2(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined2(value)) return ctx.stylize("undefined", "undefined");
      if (isString2(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber2(value)) return ctx.stylize("" + value, "number");
      if (isBoolean2(value)) return ctx.stylize("" + value, "boolean");
      if (isNull2(value)) return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name2, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
      };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name2 = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull2(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined2(name2)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name2 = JSON.stringify("" + key);
        if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name2 = name2.slice(1, -1);
          name2 = ctx.stylize(name2, "name");
        } else {
          name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name2 = ctx.stylize(name2, "string");
        }
      }
      return name2 + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf("\n") >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports$15.types = dew$23();
    function isArray2(ar) {
      return Array.isArray(ar);
    }
    exports$15.isArray = isArray2;
    function isBoolean2(arg) {
      return typeof arg === "boolean";
    }
    exports$15.isBoolean = isBoolean2;
    function isNull2(arg) {
      return arg === null;
    }
    exports$15.isNull = isNull2;
    function isNullOrUndefined2(arg) {
      return arg == null;
    }
    exports$15.isNullOrUndefined = isNullOrUndefined2;
    function isNumber2(arg) {
      return typeof arg === "number";
    }
    exports$15.isNumber = isNumber2;
    function isString2(arg) {
      return typeof arg === "string";
    }
    exports$15.isString = isString2;
    function isSymbol2(arg) {
      return typeof arg === "symbol";
    }
    exports$15.isSymbol = isSymbol2;
    function isUndefined2(arg) {
      return arg === void 0;
    }
    exports$15.isUndefined = isUndefined2;
    function isRegExp2(re) {
      return isObject2(re) && objectToString(re) === "[object RegExp]";
    }
    exports$15.isRegExp = isRegExp2;
    exports$15.types.isRegExp = isRegExp2;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports$15.isObject = isObject2;
    function isDate2(d) {
      return isObject2(d) && objectToString(d) === "[object Date]";
    }
    exports$15.isDate = isDate2;
    exports$15.types.isDate = isDate2;
    function isError2(e) {
      return isObject2(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports$15.isError = isError2;
    exports$15.types.isNativeError = isError2;
    function isFunction2(arg) {
      return typeof arg === "function";
    }
    exports$15.isFunction = isFunction2;
    function isPrimitive2(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports$15.isPrimitive = isPrimitive2;
    exports$15.isBuffer = dew$14();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    function timestamp() {
      var d = /* @__PURE__ */ new Date();
      var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports$15.log = function() {
      console.log("%s - %s", timestamp(), exports$15.format.apply(exports$15, arguments));
    };
    exports$15.inherits = dew5();
    exports$15._extend = function(origin, add) {
      if (!add || !isObject2(add)) return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports$15.promisify = function promisify2(original) {
      if (typeof original !== "function") throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this || _global, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
    };
    exports$15.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify2(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this || _global;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this || _global, args).then(function(ret) {
          process$1.nextTick(cb.bind(null, null, ret));
        }, function(rej) {
          process$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
        });
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
      return callbackified;
    }
    exports$15.callbackify = callbackify2;
    return exports$15;
  }
  var exports$c2, _dewExec$b2, exports$b2, _dewExec$a2, exports$a2, _dewExec$92, exports$92, _dewExec$82, exports$82, _dewExec$72, exports$72, _dewExec$62, exports$62, _dewExec$52, _global$2, exports$52, _dewExec$42, _global$1, exports$42, _dewExec$32, exports$32, _dewExec$23, exports$24, _dewExec$14, exports$15, _dewExec6, _global, exports7, _extend, callbackify, debuglog, deprecate, format, inherits, inspect, isArray, isBoolean, isBuffer, isDate, isError, isFunction, isNull, isNullOrUndefined, isNumber, isObject, isPrimitive, isRegExp, isString, isSymbol, isUndefined, log, promisify, types, TextEncoder2, TextDecoder2;
  var init_util = __esm({
    "node_modules/@jspm/core/nodelibs/browser/util.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_DtcTpLWz();
      init_chunk_CkFCi_G1();
      init_chunk_DEMDiNwt();
      exports$c2 = {};
      _dewExec$b2 = false;
      exports$b2 = {};
      _dewExec$a2 = false;
      exports$a2 = {};
      _dewExec$92 = false;
      exports$92 = {};
      _dewExec$82 = false;
      exports$82 = {};
      _dewExec$72 = false;
      exports$72 = {};
      _dewExec$62 = false;
      exports$62 = {};
      _dewExec$52 = false;
      _global$2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$52 = {};
      _dewExec$42 = false;
      _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$42 = {};
      _dewExec$32 = false;
      exports$32 = {};
      _dewExec$23 = false;
      exports$24 = {};
      _dewExec$14 = false;
      exports$15 = {};
      _dewExec6 = false;
      _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports7 = dew6();
      exports7["format"];
      exports7["deprecate"];
      exports7["debuglog"];
      exports7["inspect"];
      exports7["types"];
      exports7["isArray"];
      exports7["isBoolean"];
      exports7["isNull"];
      exports7["isNullOrUndefined"];
      exports7["isNumber"];
      exports7["isString"];
      exports7["isSymbol"];
      exports7["isUndefined"];
      exports7["isRegExp"];
      exports7["isObject"];
      exports7["isDate"];
      exports7["isError"];
      exports7["isFunction"];
      exports7["isPrimitive"];
      exports7["isBuffer"];
      exports7["log"];
      exports7["inherits"];
      exports7["_extend"];
      exports7["promisify"];
      exports7["callbackify"];
      _extend = exports7._extend;
      callbackify = exports7.callbackify;
      debuglog = exports7.debuglog;
      deprecate = exports7.deprecate;
      format = exports7.format;
      inherits = exports7.inherits;
      inspect = exports7.inspect;
      isArray = exports7.isArray;
      isBoolean = exports7.isBoolean;
      isBuffer = exports7.isBuffer;
      isDate = exports7.isDate;
      isError = exports7.isError;
      isFunction = exports7.isFunction;
      isNull = exports7.isNull;
      isNullOrUndefined = exports7.isNullOrUndefined;
      isNumber = exports7.isNumber;
      isObject = exports7.isObject;
      isPrimitive = exports7.isPrimitive;
      isRegExp = exports7.isRegExp;
      isString = exports7.isString;
      isSymbol = exports7.isSymbol;
      isUndefined = exports7.isUndefined;
      log = exports7.log;
      promisify = exports7.promisify;
      types = exports7.types;
      TextEncoder2 = exports7.TextEncoder = globalThis.TextEncoder;
      TextDecoder2 = exports7.TextDecoder = globalThis.TextDecoder;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/stream.js
  var stream_exports = {};
  __export(stream_exports, {
    Duplex: () => Duplex,
    PassThrough: () => PassThrough,
    Readable: () => Readable,
    Stream: () => Stream,
    Transform: () => Transform,
    Writable: () => Writable,
    default: () => exports8,
    finished: () => finished,
    pipeline: () => pipeline,
    promises: () => promises
  });
  function dew$o() {
    if (_dewExec$o) return exports$p;
    _dewExec$o = true;
    exports$p = {
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name2, prop) {
        return Object.defineProperty(self2, name2, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name2) {
        return Object.getOwnPropertyDescriptor(self2, name2);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      PromiseResolve(val) {
        return Promise.resolve(val);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
      SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
      TypedArrayPrototypeSet(self2, buf, len) {
        return self2.set(buf, len);
      },
      Boolean,
      Uint8Array
    };
    return exports$p;
  }
  function dew$n() {
    if (_dewExec$n) return exports$o;
    _dewExec$n = true;
    const {
      AbortController,
      AbortSignal
    } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    exports$o = AbortController;
    exports$o.AbortSignal = AbortSignal;
    exports$o.default = AbortController;
    return exports$o;
  }
  function dew$m() {
    if (_dewExec$m) return exports$n;
    _dewExec$m = true;
    const bufferModule = dew();
    const {
      kResistStopPropagation,
      SymbolDispose
    } = dew$o();
    const AbortSignal = globalThis.AbortSignal || dew$n().AbortSignal;
    const AbortController = globalThis.AbortController || dew$n().AbortController;
    const AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    const Blob2 = globalThis.Blob || bufferModule.Blob;
    const isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    const validateAbortSignal = (signal, name2) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name2, "AbortSignal", signal);
      }
    };
    const validateFunction = (value, name2) => {
      if (typeof value !== "function") throw new ERR_INVALID_ARG_TYPE(name2, "Function", value);
    };
    class AggregateError2 extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message = "";
        for (let i = 0; i < errors.length; i++) {
          message += `    ${errors[i].stack}
`;
        }
        super(message);
        this.name = "AggregateError";
        this.errors = errors;
      }
    }
    exports$n = {
      AggregateError: AggregateError2,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        return {
          promise,
          resolve,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format(format2, ...args) {
        return format2.replace(/%([sdifj])/g, function(...[_unused, type]) {
          const replacement = args.shift();
          if (type === "f") {
            return replacement.toFixed(6);
          } else if (type === "j") {
            return JSON.stringify(replacement);
          } else if (type === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      },
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob,
      deprecate(fn, message) {
        return fn;
      },
      addAbortListener: exports3.addAbortListener || function addAbortListener(signal, listener) {
        if (signal === void 0) {
          throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
        }
        validateAbortSignal(signal, "signal");
        validateFunction(listener, "listener");
        let removeEventListener;
        if (signal.aborted) {
          queueMicrotask(() => listener());
        } else {
          signal.addEventListener("abort", listener, {
            __proto__: null,
            once: true,
            [kResistStopPropagation]: true
          });
          removeEventListener = () => {
            signal.removeEventListener("abort", listener);
          };
        }
        return {
          __proto__: null,
          [SymbolDispose]() {
            var _removeEventListener;
            (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 ? void 0 : _removeEventListener();
          }
        };
      },
      AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {
        if (signals.length === 1) {
          return signals[0];
        }
        const ac = new AbortController();
        const abort2 = () => ac.abort();
        signals.forEach((signal) => {
          validateAbortSignal(signal, "signals");
          signal.addEventListener("abort", abort2, {
            once: true
          });
        });
        ac.signal.addEventListener("abort", () => {
          signals.forEach((signal) => signal.removeEventListener("abort", abort2));
        }, {
          once: true
        });
        return ac.signal;
      }
    };
    exports$n.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
    return exports$n;
  }
  function dew$l() {
    if (_dewExec$l) return exports$m;
    _dewExec$l = true;
    const {
      format: format2,
      inspect: inspect2,
      AggregateError: CustomAggregateError
    } = dew$m();
    const AggregateError2 = globalThis.AggregateError || CustomAggregateError;
    const kIsNodeError = Symbol("kIsNodeError");
    const kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    const classRegExp = /^([A-Z][a-z0-9]*)+$/;
    const nodeInternalPrefix = "__node_internal_";
    const codes = {};
    function assert2(value, message) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert2(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert2(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`);
      if (args.length === 0) {
        return msg;
      }
      return format2(msg, ...args);
    }
    function E(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError2([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    class AbortError extends Error {
      constructor(message = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    }
    E("ERR_ASSERTION", "%s", Error);
    E("ERR_INVALID_ARG_TYPE", (name2, expected, actual) => {
      assert2(typeof name2 === "string", "'name' must be a string");
      if (!Array.isArray(expected)) {
        expected = [expected];
      }
      let msg = "The ";
      if (name2.endsWith(" argument")) {
        msg += `${name2} `;
      } else {
        msg += `"${name2}" ${name2.includes(".") ? "property" : "argument"} `;
      }
      msg += "must be ";
      const types2 = [];
      const instances = [];
      const other = [];
      for (const value of expected) {
        assert2(typeof value === "string", "All expected entries have to be of type string");
        if (kTypes.includes(value)) {
          types2.push(value.toLowerCase());
        } else if (classRegExp.test(value)) {
          instances.push(value);
        } else {
          assert2(value !== "object", 'The value "object" should be written as "Object"');
          other.push(value);
        }
      }
      if (instances.length > 0) {
        const pos = types2.indexOf("object");
        if (pos !== -1) {
          types2.splice(types2, pos, 1);
          instances.push("Object");
        }
      }
      if (types2.length > 0) {
        switch (types2.length) {
          case 1:
            msg += `of type ${types2[0]}`;
            break;
          case 2:
            msg += `one of type ${types2[0]} or ${types2[1]}`;
            break;
          default: {
            const last = types2.pop();
            msg += `one of type ${types2.join(", ")}, or ${last}`;
          }
        }
        if (instances.length > 0 || other.length > 0) {
          msg += " or ";
        }
      }
      if (instances.length > 0) {
        switch (instances.length) {
          case 1:
            msg += `an instance of ${instances[0]}`;
            break;
          case 2:
            msg += `an instance of ${instances[0]} or ${instances[1]}`;
            break;
          default: {
            const last = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last}`;
          }
        }
        if (other.length > 0) {
          msg += " or ";
        }
      }
      switch (other.length) {
        case 0:
          break;
        case 1:
          if (other[0].toLowerCase() !== other[0]) {
            msg += "an ";
          }
          msg += `${other[0]}`;
          break;
        case 2:
          msg += `one of ${other[0]} or ${other[1]}`;
          break;
        default: {
          const last = other.pop();
          msg += `one of ${other.join(", ")}, or ${last}`;
        }
      }
      if (actual == null) {
        msg += `. Received ${actual}`;
      } else if (typeof actual === "function" && actual.name) {
        msg += `. Received function ${actual.name}`;
      } else if (typeof actual === "object") {
        var _actual$constructor;
        if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
          msg += `. Received an instance of ${actual.constructor.name}`;
        } else {
          const inspected = inspect2(actual, {
            depth: -1
          });
          msg += `. Received ${inspected}`;
        }
      } else {
        let inspected = inspect2(actual, {
          colors: false
        });
        if (inspected.length > 25) {
          inspected = `${inspected.slice(0, 25)}...`;
        }
        msg += `. Received type ${typeof actual} (${inspected})`;
      }
      return msg;
    }, TypeError);
    E("ERR_INVALID_ARG_VALUE", (name2, value, reason = "is invalid") => {
      let inspected = inspect2(value);
      if (inspected.length > 128) {
        inspected = inspected.slice(0, 128) + "...";
      }
      const type = name2.includes(".") ? "property" : "argument";
      return `The ${type} '${name2}' ${reason}. Received ${inspected}`;
    }, TypeError);
    E("ERR_INVALID_RETURN_VALUE", (input, name2, value) => {
      var _value$constructor;
      const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
      return `Expected ${input} to be returned from the "${name2}" function but got ${type}.`;
    }, TypeError);
    E("ERR_MISSING_ARGS", (...args) => {
      assert2(args.length > 0, "At least one arg needs to be specified");
      let msg;
      const len = args.length;
      args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
      switch (len) {
        case 1:
          msg += `The ${args[0]} argument`;
          break;
        case 2:
          msg += `The ${args[0]} and ${args[1]} arguments`;
          break;
        default:
          {
            const last = args.pop();
            msg += `The ${args.join(", ")}, and ${last} arguments`;
          }
          break;
      }
      return `${msg} must be specified`;
    }, TypeError);
    E("ERR_OUT_OF_RANGE", (str, range, input) => {
      assert2(range, 'Missing "range" argument');
      let received;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > 2n ** 32n || input < -(2n ** 32n)) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      } else {
        received = inspect2(input);
      }
      return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
    }, RangeError);
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    exports$m = {
      AbortError,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
    return exports$m;
  }
  function dew$k2() {
    if (_dewExec$k2) return exports$l;
    _dewExec$k2 = true;
    const {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = dew$o();
    const {
      hideStackFrames,
      codes: {
        ERR_SOCKET_BAD_PORT,
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_INVALID_ARG_VALUE,
        ERR_OUT_OF_RANGE,
        ERR_UNKNOWN_SIGNAL
      }
    } = dew$l();
    const {
      normalizeEncoding
    } = dew$m();
    const {
      isAsyncFunction,
      isArrayBufferView
    } = dew$m().types;
    const signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    const octalReg = /^[0-7]+$/;
    const modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name2, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name2, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name2);
      return value;
    }
    const validateInteger = hideStackFrames((value, name2, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE2(name2, "number", value);
      if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name2, "an integer", value);
      if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name2, `>= ${min} && <= ${max}`, value);
    });
    const validateInt32 = hideStackFrames((value, name2, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE2(name2, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name2, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name2, `>= ${min} && <= ${max}`, value);
      }
    });
    const validateUint32 = hideStackFrames((value, name2, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE2(name2, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name2, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name2, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name2) {
      if (typeof value !== "string") throw new ERR_INVALID_ARG_TYPE2(name2, "string", value);
    }
    function validateNumber(value, name2, min = void 0, max) {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE2(name2, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(name2, `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`, value);
      }
    }
    const validateOneOf = hideStackFrames((value, name2, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)), ", ");
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name2, value, reason);
      }
    });
    function validateBoolean(value, name2) {
      if (typeof value !== "boolean") throw new ERR_INVALID_ARG_TYPE2(name2, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    const validateObject = hideStackFrames((value, name2, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE2(name2, "Object", value);
      }
    });
    const validateDictionary = hideStackFrames((value, name2) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE2(name2, "a dictionary", value);
      }
    });
    const validateArray = hideStackFrames((value, name2, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE2(name2, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name2, value, reason);
      }
    });
    function validateStringArray(value, name2) {
      validateArray(value, name2);
      for (let i = 0; i < value.length; i++) {
        validateString(value[i], `${name2}[${i}]`);
      }
    }
    function validateBooleanArray(value, name2) {
      validateArray(value, name2);
      for (let i = 0; i < value.length; i++) {
        validateBoolean(value[i], `${name2}[${i}]`);
      }
    }
    function validateAbortSignalArray(value, name2) {
      validateArray(value, name2);
      for (let i = 0; i < value.length; i++) {
        const signal = value[i];
        const indexedName = `${name2}[${i}]`;
        if (signal == null) {
          throw new ERR_INVALID_ARG_TYPE2(indexedName, "AbortSignal", signal);
        }
        validateAbortSignal(signal, indexedName);
      }
    }
    function validateSignalName(signal, name2 = "signal") {
      validateString(signal, name2);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    const validateBuffer = hideStackFrames((buffer, name2 = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE2(name2, ["Buffer", "TypedArray", "DataView"], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name2 = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name2, port, allowZero);
      }
      return port | 0;
    }
    const validateAbortSignal = hideStackFrames((signal, name2) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE2(name2, "AbortSignal", signal);
      }
    });
    const validateFunction = hideStackFrames((value, name2) => {
      if (typeof value !== "function") throw new ERR_INVALID_ARG_TYPE2(name2, "Function", value);
    });
    const validatePlainFunction = hideStackFrames((value, name2) => {
      if (typeof value !== "function" || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE2(name2, "Function", value);
    });
    const validateUndefined = hideStackFrames((value, name2) => {
      if (value !== void 0) throw new ERR_INVALID_ARG_TYPE2(name2, "undefined", value);
    });
    function validateUnion(value, name2, union) {
      if (!ArrayPrototypeIncludes(union, value)) {
        throw new ERR_INVALID_ARG_TYPE2(name2, `('${ArrayPrototypeJoin(union, "|")}')`, value);
      }
    }
    const linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name2) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(name2, value, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i = 0; i < hintsLength; i++) {
          const link = hints[i];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE("hints", hints, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    exports$l = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateAbortSignalArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
    return exports$l;
  }
  function dew$j2() {
    if (_dewExec$j2) return exports$k2;
    _dewExec$j2 = true;
    const {
      SymbolAsyncIterator,
      SymbolIterator,
      SymbolFor
    } = dew$o();
    const kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
    const kIsErrored = SymbolFor("nodejs.stream.errored");
    const kIsReadable = SymbolFor("nodejs.stream.readable");
    const kIsWritable = SymbolFor("nodejs.stream.writable");
    const kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
    const kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    const kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null) return false;
      if (isAsync === true) return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false) return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableEnded === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean") return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableFinished === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean") return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream)) return null;
      if (stream.readableEnded === true) return true;
      const rState = stream._readableState;
      if (!rState || rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean") return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream)) return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean") return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null) return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null) return stream[kIsWritable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    exports$k2 = {
      isDestroyed,
      kIsDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      kIsWritable,
      isClosed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
    return exports$k2;
  }
  function dew$i2() {
    if (_dewExec$i2) return exports$j2;
    _dewExec$i2 = true;
    const process$1 = process;
    const {
      AbortError,
      codes
    } = dew$l();
    const {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_STREAM_PREMATURE_CLOSE
    } = codes;
    const {
      kEmptyObject,
      once: once3
    } = dew$m();
    const {
      validateAbortSignal,
      validateFunction,
      validateObject,
      validateBoolean
    } = dew$k2();
    const {
      Promise: Promise2,
      PromisePrototypeThen,
      SymbolDispose
    } = dew$o();
    const {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableStream,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = dew$j2();
    let addAbortListener;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    const nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once3(callback);
      if (isReadableStream(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process$1.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process$1.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process$1.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process$1.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process$1.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort2 = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(stream, new AbortError(void 0, {
            cause: options.signal.reason
          }));
        };
        if (options.signal.aborted) {
          process$1.nextTick(abort2);
        } else {
          addAbortListener = addAbortListener || dew$m().addAbortListener;
          const disposable = addAbortListener(options.signal, abort2);
          const originalCallback = callback;
          callback = once3((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort2 = nop;
      if (options.signal) {
        abort2 = () => {
          isAborted = true;
          callback.call(stream, new AbortError(void 0, {
            cause: options.signal.reason
          }));
        };
        if (options.signal.aborted) {
          process$1.nextTick(abort2);
        } else {
          addAbortListener = addAbortListener || dew$m().addAbortListener;
          const disposable = addAbortListener(options.signal, abort2);
          const originalCallback = callback;
          callback = once3((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process$1.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    function finished2(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve, reject) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    exports$j2 = eos;
    exports$j2.finished = finished2;
    return exports$j2;
  }
  function dew$h2() {
    if (_dewExec$h2) return exports$i2;
    _dewExec$h2 = true;
    const process$1 = process;
    const {
      aggregateTwoErrors,
      codes: {
        ERR_MULTIPLE_CALLBACK
      },
      AbortError
    } = dew$l();
    const {
      Symbol: Symbol2
    } = dew$o();
    const {
      kIsDestroyed,
      isDestroyed,
      isFinished,
      isServerRequest
    } = dew$j2();
    const kDestroy = Symbol2("kDestroy");
    const kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    function destroy(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self2._readableState;
        const w = self2._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process$1.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process$1.nextTick(emitCloseNT, self2);
        }
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        return this;
      }
      if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy) stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process$1.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process$1.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process$1.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process$1.nextTick(onConstruct, err);
        });
      } catch (err) {
        process$1.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process$1.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process$1.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process$1.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kIsDestroyed] = true;
      }
    }
    exports$i2 = {
      construct,
      destroyer,
      destroy,
      undestroy,
      errorOrDestroy
    };
    return exports$i2;
  }
  function dew$g2() {
    if (_dewExec$g2) return exports$h2;
    _dewExec$g2 = true;
    const {
      ArrayIsArray,
      ObjectSetPrototypeOf
    } = dew$o();
    const {
      EventEmitter: EE
    } = exports3;
    function Stream2(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream2.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream2, EE);
    Stream2.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener2(source, "error", onerror);
      prependListener2(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener2(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    exports$h2 = {
      Stream: Stream2,
      prependListener: prependListener2
    };
    return exports$h2;
  }
  function dew$f2() {
    if (_dewExec$f2) return exports$g2;
    _dewExec$f2 = true;
    const {
      SymbolDispose
    } = dew$o();
    const {
      AbortError,
      codes
    } = dew$l();
    const {
      isNodeStream,
      isWebStream,
      kControllerErrorFunction
    } = dew$j2();
    const eos = dew$i2();
    const {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2
    } = codes;
    let addAbortListener;
    const validateAbortSignal = (signal, name2) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE2(name2, "AbortSignal", signal);
      }
    };
    exports$g2.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return exports$g2.addAbortSignalNoValidate(signal, stream);
    };
    exports$g2.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(new AbortError(void 0, {
          cause: signal.reason
        }));
      } : () => {
        stream[kControllerErrorFunction](new AbortError(void 0, {
          cause: signal.reason
        }));
      };
      if (signal.aborted) {
        onAbort();
      } else {
        addAbortListener = addAbortListener || dew$m().addAbortListener;
        const disposable = addAbortListener(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
    return exports$g2;
  }
  function dew$e2() {
    if (_dewExec$e2) return exports$f2;
    _dewExec$e2 = true;
    const {
      StringPrototypeSlice,
      SymbolIterator,
      TypedArrayPrototypeSet,
      Uint8Array: Uint8Array2
    } = dew$o();
    const {
      Buffer: Buffer3
    } = dew();
    const {
      inspect: inspect2
    } = dew$m();
    exports$f2 = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0) return;
        const ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0) return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null) ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0) return Buffer3.alloc(0);
        const ret = Buffer3.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str = p.data;
          if (n > str.length) {
            ret += str;
            n -= str.length;
          } else {
            if (n === str.length) {
              ret += str;
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n) {
        const ret = Buffer3.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_, options) {
        return inspect2(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
    return exports$f2;
  }
  function dew$d2() {
    if (_dewExec$d2) return exports$e2;
    _dewExec$d2 = true;
    const {
      MathFloor,
      NumberIsInteger
    } = dew$o();
    const {
      validateInteger
    } = dew$k2();
    const {
      ERR_INVALID_ARG_VALUE
    } = dew$l().codes;
    let defaultHighWaterMarkBytes = 16 * 1024;
    let defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value) {
      validateInteger(value, "value", 0);
      if (objectMode) {
        defaultHighWaterMarkObjectMode = value;
      } else {
        defaultHighWaterMarkBytes = value;
      }
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name2 = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name2, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    exports$e2 = {
      getHighWaterMark,
      getDefaultHighWaterMark,
      setDefaultHighWaterMark
    };
    return exports$e2;
  }
  function dew$c2() {
    if (_dewExec$c2) return exports$d2;
    _dewExec$c2 = true;
    const process$1 = process;
    const {
      PromisePrototypeThen,
      SymbolAsyncIterator,
      SymbolIterator
    } = dew$o();
    const {
      Buffer: Buffer3
    } = dew();
    const {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_STREAM_NULL_VALUES
    } = dew$l().codes;
    function from(Readable2, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer3) {
        return new Readable2({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE2("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable2({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close(error),
          () => process$1.nextTick(cb, error),
          // nextTick is here in case cb throws
          (e) => process$1.nextTick(cb, e || error)
        );
      };
      async function close(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const {
            value,
            done
          } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const {
            value
          } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const {
              value,
              done
            } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    exports$d2 = from;
    return exports$d2;
  }
  function dew$b3() {
    if (_dewExec$b3) return exports$c3;
    _dewExec$b3 = true;
    const process$1 = process;
    const {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncDispose,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = dew$o();
    exports$c3 = Readable2;
    Readable2.ReadableState = ReadableState;
    const {
      EventEmitter: EE
    } = exports3;
    const {
      Stream: Stream2,
      prependListener: prependListener2
    } = dew$g2();
    const {
      Buffer: Buffer3
    } = dew();
    const {
      addAbortSignal
    } = dew$f2();
    const eos = dew$i2();
    let debug = dew$m().debuglog("stream", (fn) => {
      debug = fn;
    });
    const BufferList = dew$e2();
    const destroyImpl = dew$h2();
    const {
      getHighWaterMark,
      getDefaultHighWaterMark
    } = dew$d2();
    const {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      },
      AbortError
    } = dew$l();
    const {
      validateObject
    } = dew$k2();
    const kPaused = Symbol2("kPaused");
    const {
      StringDecoder: StringDecoder2
    } = exports4;
    const from = dew$c2();
    ObjectSetPrototypeOf(Readable2.prototype, Stream2.prototype);
    ObjectSetPrototypeOf(Readable2, Stream2);
    const nop = () => {
    };
    const {
      errorOrDestroy
    } = destroyImpl;
    const kObjectMode = 1 << 0;
    const kEnded = 1 << 1;
    const kEndEmitted = 1 << 2;
    const kReading = 1 << 3;
    const kConstructed = 1 << 4;
    const kSync = 1 << 5;
    const kNeedReadable = 1 << 6;
    const kEmittedReadable = 1 << 7;
    const kReadableListening = 1 << 8;
    const kResumeScheduled = 1 << 9;
    const kErrorEmitted = 1 << 10;
    const kEmitClose = 1 << 11;
    const kAutoDestroy = 1 << 12;
    const kDestroyed = 1 << 13;
    const kClosed = 1 << 14;
    const kCloseEmitted = 1 << 15;
    const kMultiAwaitDrain = 1 << 16;
    const kReadingMore = 1 << 17;
    const kDataEmitted = 1 << 18;
    function makeBitMapDescriptor(bit) {
      return {
        enumerable: false,
        get() {
          return ((this || _global$22).state & bit) !== 0;
        },
        set(value) {
          if (value) (this || _global$22).state |= bit;
          else (this || _global$22).state &= ~bit;
        }
      };
    }
    ObjectDefineProperties(ReadableState.prototype, {
      objectMode: makeBitMapDescriptor(kObjectMode),
      ended: makeBitMapDescriptor(kEnded),
      endEmitted: makeBitMapDescriptor(kEndEmitted),
      reading: makeBitMapDescriptor(kReading),
      // Stream is still being constructed and cannot be
      // destroyed until construction finished or failed.
      // Async construction is opt in, therefore we start as
      // constructed.
      constructed: makeBitMapDescriptor(kConstructed),
      // A flag to be able to tell if the event 'readable'/'data' is emitted
      // immediately, or on a later tick.  We set this to true at first, because
      // any actions that shouldn't happen until "later" should generally also
      // not happen before the first read call.
      sync: makeBitMapDescriptor(kSync),
      // Whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      needReadable: makeBitMapDescriptor(kNeedReadable),
      emittedReadable: makeBitMapDescriptor(kEmittedReadable),
      readableListening: makeBitMapDescriptor(kReadableListening),
      resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
      // True if the error was already emitted and should not be thrown again.
      errorEmitted: makeBitMapDescriptor(kErrorEmitted),
      emitClose: makeBitMapDescriptor(kEmitClose),
      autoDestroy: makeBitMapDescriptor(kAutoDestroy),
      // Has it been destroyed.
      destroyed: makeBitMapDescriptor(kDestroyed),
      // Indicates whether the stream has finished destroying.
      closed: makeBitMapDescriptor(kClosed),
      // True if close has been emitted or would have been emitted
      // depending on emitClose.
      closeEmitted: makeBitMapDescriptor(kCloseEmitted),
      multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
      // If true, a maybeReadMore has been scheduled.
      readingMore: makeBitMapDescriptor(kReadingMore),
      dataEmitted: makeBitMapDescriptor(kDataEmitted)
    });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof dew$83();
      (this || _global$22).state = kEmitClose | kAutoDestroy | kConstructed | kSync;
      if (options && options.objectMode) (this || _global$22).state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode) (this || _global$22).state |= kObjectMode;
      (this || _global$22).highWaterMark = options ? getHighWaterMark(this || _global$22, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      (this || _global$22).buffer = new BufferList();
      (this || _global$22).length = 0;
      (this || _global$22).pipes = [];
      (this || _global$22).flowing = null;
      (this || _global$22)[kPaused] = null;
      if (options && options.emitClose === false) (this || _global$22).state &= ~kEmitClose;
      if (options && options.autoDestroy === false) (this || _global$22).state &= ~kAutoDestroy;
      (this || _global$22).errored = null;
      (this || _global$22).defaultEncoding = options && options.defaultEncoding || "utf8";
      (this || _global$22).awaitDrainWriters = null;
      (this || _global$22).decoder = null;
      (this || _global$22).encoding = null;
      if (options && options.encoding) {
        (this || _global$22).decoder = new StringDecoder2(options.encoding);
        (this || _global$22).encoding = options.encoding;
      }
    }
    function Readable2(options) {
      if (!((this || _global$22) instanceof Readable2)) return new Readable2(options);
      const isDuplex = (this || _global$22) instanceof dew$83();
      (this || _global$22)._readableState = new ReadableState(options, this || _global$22, isDuplex);
      if (options) {
        if (typeof options.read === "function") (this || _global$22)._read = options.read;
        if (typeof options.destroy === "function") (this || _global$22)._destroy = options.destroy;
        if (typeof options.construct === "function") (this || _global$22)._construct = options.construct;
        if (options.signal && !isDuplex) addAbortSignal(options.signal, this || _global$22);
      }
      Stream2.call(this || _global$22, options);
      destroyImpl.construct(this || _global$22, () => {
        if ((this || _global$22)._readableState.needReadable) {
          maybeReadMore(this || _global$22, (this || _global$22)._readableState);
        }
      });
    }
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable2.prototype[SymbolAsyncDispose] = function() {
      let error;
      if (!(this || _global$22).destroyed) {
        error = (this || _global$22).readableEnded ? null : new AbortError();
        this.destroy(error);
      }
      return new Promise2((resolve, reject) => eos(this || _global$22, (err) => err && err !== error ? reject(err) : resolve(null)));
    };
    Readable2.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this || _global$22, chunk, encoding, false);
    };
    Readable2.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this || _global$22, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if ((state.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer3.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer3.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer3) {
          encoding = "";
        } else if (Stream2._isUint8Array(chunk)) {
          chunk = Stream2._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.state &= ~kReading;
        onEofChunk(stream, state);
      } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
        if (addToFront) {
          if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored) return false;
          else addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.state &= ~kReading;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
            else maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.state &= ~kReading;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if ((state.state & kMultiAwaitDrain) !== 0) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if ((state.state & kNeedReadable) !== 0) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable2.prototype.isPaused = function() {
      const state = (this || _global$22)._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder2(enc);
      (this || _global$22)._readableState.decoder = decoder;
      (this || _global$22)._readableState.encoding = (this || _global$22)._readableState.decoder.encoding;
      const buffer = (this || _global$22)._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder.write(data);
      }
      buffer.clear();
      if (content !== "") buffer.push(content);
      (this || _global$22)._readableState.length = content.length;
      return this || _global$22;
    };
    const MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if ((state.state & kObjectMode) !== 0) return 1;
      if (NumberIsNaN(n)) {
        if (state.flowing && state.length) return state.buffer.first().length;
        return state.length;
      }
      if (n <= state.length) return n;
      return state.ended ? state.length : 0;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state = (this || _global$22)._readableState;
      const nOrig = n;
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0) state.state &= ~kEmittedReadable;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this || _global$22);
        else emitReadable(this || _global$22);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this || _global$22);
        return null;
      }
      let doRead = (state.state & kNeedReadable) !== 0;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.state |= kReading | kSync;
        if (state.length === 0) state.state |= kNeedReadable;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this || _global$22, err);
        }
        state.state &= ~kSync;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this || _global$22);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process$1.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process$1.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      const src = this || _global$22;
      const state = (this || _global$22)._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process$1.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        pause();
      } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      const state = (this || _global$22)._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0) return this || _global$22;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i = 0; i < dests.length; i++) dests[i].emit("unpipe", this || _global$22, {
          hasUnpiped: false
        });
        return this || _global$22;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1) return this || _global$22;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0) this.pause();
      dest.emit("unpipe", this || _global$22, unpipeInfo);
      return this || _global$22;
    };
    Readable2.prototype.on = function(ev, fn) {
      const res = Stream2.prototype.on.call(this || _global$22, ev, fn);
      const state = (this || _global$22)._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this || _global$22);
          } else if (!state.reading) {
            process$1.nextTick(nReadingNextTick, this || _global$22);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      const res = Stream2.prototype.removeListener.call(this || _global$22, ev, fn);
      if (ev === "readable") {
        process$1.nextTick(updateReadableListening, this || _global$22);
      }
      return res;
    };
    Readable2.prototype.off = Readable2.prototype.removeListener;
    Readable2.prototype.removeAllListeners = function(ev) {
      const res = Stream2.prototype.removeAllListeners.apply(this || _global$22, arguments);
      if (ev === "readable" || ev === void 0) {
        process$1.nextTick(updateReadableListening, this || _global$22);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      const state = (this || _global$22)._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this || _global$22, state);
      }
      state[kPaused] = false;
      return this || _global$22;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process$1.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", (this || _global$22)._readableState.flowing);
      if ((this || _global$22)._readableState.flowing !== false) {
        debug("pause");
        (this || _global$22)._readableState.flowing = false;
        this.emit("pause");
      }
      (this || _global$22)._readableState[kPaused] = true;
      return this || _global$22;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable2.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this || _global$22, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      (this || _global$22)._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if ((this || _global$22)[i] === void 0 && typeof stream[i] === "function") {
          (this || _global$22)[i] = stream[i].bind(stream);
        }
      }
      return this || _global$22;
    };
    Readable2.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this || _global$22);
    };
    Readable2.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this || _global$22, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable2.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if ((this || _global$22) === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos(stream, {
        writable: false
      }, (err) => {
        error = err ? aggregateTwoErrors(error, err) : null;
        callback();
        callback = nop;
      });
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable2.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r = (this || _global$22)._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if ((this || _global$22)._readableState) {
            (this || _global$22)._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return (this || _global$22)._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!((this || _global$22)._readableState.readable !== false && ((this || _global$22)._readableState.destroyed || (this || _global$22)._readableState.errored) && !(this || _global$22)._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return (this || _global$22)._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return (this || _global$22)._readableState && (this || _global$22)._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return (this || _global$22)._readableState.flowing;
        },
        set: function(state) {
          if ((this || _global$22)._readableState) {
            (this || _global$22)._readableState.flowing = state;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return (this || _global$22)._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return (this || _global$22)._readableState ? (this || _global$22)._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return (this || _global$22)._readableState ? (this || _global$22)._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return (this || _global$22)._readableState ? (this || _global$22)._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return (this || _global$22)._readableState ? (this || _global$22)._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return (this || _global$22)._readableState ? (this || _global$22)._readableState.destroyed : false;
        },
        set(value) {
          if (!(this || _global$22)._readableState) {
            return;
          }
          (this || _global$22)._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return (this || _global$22)._readableState ? (this || _global$22)._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return (this || _global$22).pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return (this || _global$22)[kPaused] !== false;
        },
        set(value) {
          (this || _global$22)[kPaused] = !!value;
        }
      }
    });
    Readable2._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0) return null;
      let ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process$1.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process$1.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable2.from = function(iterable, opts) {
      return from(Readable2, iterable, opts);
    };
    let webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable2.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable2.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable2.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable2({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
    return exports$c3;
  }
  function dew$a3() {
    if (_dewExec$a3) return exports$b3;
    _dewExec$a3 = true;
    const process$1 = process;
    const {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = dew$o();
    exports$b3 = Writable2;
    Writable2.WritableState = WritableState;
    const {
      EventEmitter: EE
    } = exports3;
    const Stream2 = dew$g2().Stream;
    const {
      Buffer: Buffer3
    } = dew();
    const destroyImpl = dew$h2();
    const {
      addAbortSignal
    } = dew$f2();
    const {
      getHighWaterMark,
      getDefaultHighWaterMark
    } = dew$d2();
    const {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = dew$l().codes;
    const {
      errorOrDestroy
    } = destroyImpl;
    ObjectSetPrototypeOf(Writable2.prototype, Stream2.prototype);
    ObjectSetPrototypeOf(Writable2, Stream2);
    function nop() {
    }
    const kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof dew$83();
      (this || _global$12).objectMode = !!(options && options.objectMode);
      if (isDuplex) (this || _global$12).objectMode = (this || _global$12).objectMode || !!(options && options.writableObjectMode);
      (this || _global$12).highWaterMark = options ? getHighWaterMark(this || _global$12, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      (this || _global$12).finalCalled = false;
      (this || _global$12).needDrain = false;
      (this || _global$12).ending = false;
      (this || _global$12).ended = false;
      (this || _global$12).finished = false;
      (this || _global$12).destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      (this || _global$12).decodeStrings = !noDecode;
      (this || _global$12).defaultEncoding = options && options.defaultEncoding || "utf8";
      (this || _global$12).length = 0;
      (this || _global$12).writing = false;
      (this || _global$12).corked = 0;
      (this || _global$12).sync = true;
      (this || _global$12).bufferProcessing = false;
      (this || _global$12).onwrite = onwrite.bind(void 0, stream);
      (this || _global$12).writecb = null;
      (this || _global$12).writelen = 0;
      (this || _global$12).afterWriteTickInfo = null;
      resetBuffer(this || _global$12);
      (this || _global$12).pendingcb = 0;
      (this || _global$12).constructed = true;
      (this || _global$12).prefinished = false;
      (this || _global$12).errorEmitted = false;
      (this || _global$12).emitClose = !options || options.emitClose !== false;
      (this || _global$12).autoDestroy = !options || options.autoDestroy !== false;
      (this || _global$12).errored = null;
      (this || _global$12).closed = false;
      (this || _global$12).closeEmitted = false;
      (this || _global$12)[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice((this || _global$12).buffered, (this || _global$12).bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return (this || _global$12).buffered.length - (this || _global$12).bufferedIndex;
      }
    });
    function Writable2(options) {
      const isDuplex = (this || _global$12) instanceof dew$83();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable2, this || _global$12)) return new Writable2(options);
      (this || _global$12)._writableState = new WritableState(options, this || _global$12, isDuplex);
      if (options) {
        if (typeof options.write === "function") (this || _global$12)._write = options.write;
        if (typeof options.writev === "function") (this || _global$12)._writev = options.writev;
        if (typeof options.destroy === "function") (this || _global$12)._destroy = options.destroy;
        if (typeof options.final === "function") (this || _global$12)._final = options.final;
        if (typeof options.construct === "function") (this || _global$12)._construct = options.construct;
        if (options.signal) addAbortSignal(options.signal, this || _global$12);
      }
      Stream2.call(this || _global$12, options);
      destroyImpl.construct(this || _global$12, () => {
        const state = (this || _global$12)._writableState;
        if (!state.writing) {
          clearBuffer(this || _global$12, state);
        }
        finishMaybe(this || _global$12, state);
      });
    }
    ObjectDefineProperty(Writable2, SymbolHasInstance, {
      __proto__: null,
      value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this || _global$12, object)) return true;
        if ((this || _global$12) !== Writable2) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
    Writable2.prototype.pipe = function() {
      errorOrDestroy(this || _global$12, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding) encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer3.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function") cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer3.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer3) {
          encoding = "buffer";
        } else if (Stream2._isUint8Array(chunk)) {
          chunk = Stream2._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process$1.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable2.prototype.write = function(chunk, encoding, cb) {
      return _write(this || _global$12, chunk, encoding, cb) === true;
    };
    Writable2.prototype.cork = function() {
      (this || _global$12)._writableState.corked++;
    };
    Writable2.prototype.uncork = function() {
      const state = (this || _global$12)._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing) clearBuffer(this || _global$12, state);
      }
    };
    Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer3.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
      (this || _global$12)._writableState.defaultEncoding = encoding;
      return this || _global$12;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process$1.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process$1.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    function afterWriteTick({
      stream,
      state,
      count,
      cb
    }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
        var _state$errored;
        const {
          chunk,
          callback
        } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback((_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write"));
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        var _state$errored2;
        onfinishCallbacks[i]((_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end"));
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const {
        buffered,
        bufferedIndex,
        objectMode
      } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const {
            chunk,
            encoding,
            callback
          } = buffered[i];
          buffered[i++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state.writing);
        if (i === buffered.length) {
          resetBuffer(state);
        } else if (i > 256) {
          buffered.splice(0, i);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i;
        }
      }
      state.bufferProcessing = false;
    }
    Writable2.prototype._write = function(chunk, encoding, cb) {
      if ((this || _global$12)._writev) {
        this._writev([{
          chunk,
          encoding
        }], cb);
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable2.prototype._writev = null;
    Writable2.prototype.end = function(chunk, encoding, cb) {
      const state = (this || _global$12)._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this || _global$12, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) ;
      else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this || _global$12, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process$1.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this || _global$12;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i = 0; i < onfinishCallbacks.length; i++) {
            onfinishCallbacks[i](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process$1.nextTick(finish, stream, state);
        }
      }
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process$1.nextTick((stream2, state2) => {
              if (needFinish(state2)) {
                finish(stream2, state2);
              } else {
                state2.pendingcb--;
              }
            }, stream, state);
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable2.prototype, {
      closed: {
        __proto__: null,
        get() {
          return (this || _global$12)._writableState ? (this || _global$12)._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return (this || _global$12)._writableState ? (this || _global$12)._writableState.destroyed : false;
        },
        set(value) {
          if ((this || _global$12)._writableState) {
            (this || _global$12)._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w = (this || _global$12)._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if ((this || _global$12)._writableState) {
            (this || _global$12)._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return (this || _global$12)._writableState ? (this || _global$12)._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return (this || _global$12)._writableState ? (this || _global$12)._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return (this || _global$12)._writableState && (this || _global$12)._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return (this || _global$12)._writableState ? (this || _global$12)._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = (this || _global$12)._writableState;
          if (!wState) return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return (this || _global$12)._writableState && (this || _global$12)._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return (this || _global$12)._writableState ? (this || _global$12)._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return (this || _global$12)._writableState && (this || _global$12)._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return (this || _global$12)._writableState ? (this || _global$12)._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!((this || _global$12)._writableState.writable !== false && ((this || _global$12)._writableState.destroyed || (this || _global$12)._writableState.errored) && !(this || _global$12)._writableState.finished);
        }
      }
    });
    const destroy = destroyImpl.destroy;
    Writable2.prototype.destroy = function(err, cb) {
      const state = (this || _global$12)._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process$1.nextTick(errorBuffer, state);
      }
      destroy.call(this || _global$12, err, cb);
      return this || _global$12;
    };
    Writable2.prototype._undestroy = destroyImpl.undestroy;
    Writable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable2.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    let webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable2.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable2.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
    return exports$b3;
  }
  function dew$93() {
    if (_dewExec$93) return exports$a3;
    _dewExec$93 = true;
    const process$1 = process;
    const bufferModule = dew();
    const {
      isReadable,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream,
      isReadableStream,
      isWritableStream
    } = dew$j2();
    const eos = dew$i2();
    const {
      AbortError,
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_INVALID_RETURN_VALUE
      }
    } = dew$l();
    const {
      destroyer
    } = dew$h2();
    const Duplex2 = dew$83();
    const Readable2 = dew$b3();
    const Writable2 = dew$a3();
    const {
      createDeferredPromise
    } = dew$m();
    const from = dew$c2();
    const Blob2 = globalThis.Blob || bufferModule.Blob;
    const isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    const AbortController = globalThis.AbortController || dew$n().AbortController;
    const {
      FunctionPrototypeCall
    } = dew$o();
    class Duplexify extends Duplex2 {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    }
    exports$a3 = function duplexify(body, name2) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (isReadableStream(body)) {
        return _duplexify({
          readable: Readable2.fromWeb(body)
        });
      }
      if (isWritableStream(body)) {
        return _duplexify({
          writable: Writable2.fromWeb(body)
        });
      }
      if (typeof body === "function") {
        const {
          value,
          write,
          final,
          destroy
        } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise = FunctionPrototypeCall(then2, value, (val) => {
            if (val != null) {
              throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
            }
          }, (err) => {
            destroyer(d, err);
          });
          return d = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process$1.nextTick(cb, null);
                } catch (err) {
                  process$1.nextTick(cb, err);
                }
              });
            },
            destroy
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name2, value);
      }
      if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (isReadableStream(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable)) {
        return Duplexify.fromWeb(body);
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(then, body, (val) => {
          if (val != null) {
            d.push(val);
          }
          d.push(null);
        }, (err) => {
          destroyer(d, err);
        });
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE2(name2, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], body);
    };
    function fromAsyncGen(fn) {
      let {
        promise,
        resolve
      } = createDeferredPromise();
      const ac = new AbortController();
      const signal = ac.signal;
      const value = fn(async function* () {
        while (true) {
          const _promise = promise;
          promise = null;
          const {
            chunk,
            done,
            cb
          } = await _promise;
          process$1.nextTick(cb);
          if (done) return;
          if (signal.aborted) throw new AbortError(void 0, {
            cause: signal.reason
          });
          ({
            promise,
            resolve
          } = createDeferredPromise());
          yield chunk;
        }
      }(), {
        signal
      });
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable2.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        }
      }
      d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
    return exports$a3;
  }
  function dew$83() {
    if (_dewExec$83) return exports$93;
    _dewExec$83 = true;
    const {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = dew$o();
    exports$93 = Duplex2;
    const Readable2 = dew$b3();
    const Writable2 = dew$a3();
    ObjectSetPrototypeOf(Duplex2.prototype, Readable2.prototype);
    ObjectSetPrototypeOf(Duplex2, Readable2);
    {
      const keys = ObjectKeys(Writable2.prototype);
      for (let i = 0; i < keys.length; i++) {
        const method = keys[i];
        if (!Duplex2.prototype[method]) Duplex2.prototype[method] = Writable2.prototype[method];
      }
    }
    function Duplex2(options) {
      if (!(this instanceof Duplex2)) return new Duplex2(options);
      Readable2.call(this, options);
      Writable2.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex2.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    let webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex2.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex2.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    let duplexify;
    Duplex2.from = function(body) {
      if (!duplexify) {
        duplexify = dew$93();
      }
      return duplexify(body, "body");
    };
    return exports$93;
  }
  function dew$73() {
    if (_dewExec$73) return exports$83;
    _dewExec$73 = true;
    const {
      ObjectSetPrototypeOf,
      Symbol: Symbol2
    } = dew$o();
    exports$83 = Transform2;
    const {
      ERR_METHOD_NOT_IMPLEMENTED
    } = dew$l().codes;
    const Duplex2 = dew$83();
    const {
      getHighWaterMark
    } = dew$d2();
    ObjectSetPrototypeOf(Transform2.prototype, Duplex2.prototype);
    ObjectSetPrototypeOf(Transform2, Duplex2);
    const kCallback = Symbol2("kCallback");
    function Transform2(options) {
      if (!(this instanceof Transform2)) return new Transform2(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex2.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform2.prototype._final = final;
    Transform2.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform2.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform2.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
    return exports$83;
  }
  function dew$63() {
    if (_dewExec$63) return exports$73;
    _dewExec$63 = true;
    const {
      ObjectSetPrototypeOf
    } = dew$o();
    exports$73 = PassThrough2;
    const Transform2 = dew$73();
    ObjectSetPrototypeOf(PassThrough2.prototype, Transform2.prototype);
    ObjectSetPrototypeOf(PassThrough2, Transform2);
    function PassThrough2(options) {
      if (!(this instanceof PassThrough2)) return new PassThrough2(options);
      Transform2.call(this, options);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
    return exports$73;
  }
  function dew$53() {
    if (_dewExec$53) return exports$63;
    _dewExec$53 = true;
    const process$1 = process;
    const {
      ArrayIsArray,
      Promise: Promise2,
      SymbolAsyncIterator,
      SymbolDispose
    } = dew$o();
    const eos = dew$i2();
    const {
      once: once3
    } = dew$m();
    const destroyImpl = dew$h2();
    const Duplex2 = dew$83();
    const {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError
    } = dew$l();
    const {
      validateFunction,
      validateAbortSignal
    } = dew$k2();
    const {
      isIterable,
      isReadable,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream,
      isReadableFinished
    } = dew$j2();
    const AbortController = globalThis.AbortController || dew$n().AbortController;
    let PassThrough2;
    let Readable2;
    let addAbortListener;
    function destroyer(stream, reading, writing) {
      let finished2 = false;
      stream.on("close", () => {
        finished2 = true;
      });
      const cleanup = eos(stream, {
        readable: reading,
        writable: writing
      }, (err) => {
        finished2 = !err;
      });
      return {
        destroy: (err) => {
          if (finished2) return;
          finished2 = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable2) {
        Readable2 = dew$b3();
      }
      yield* Readable2.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, {
      end
    }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(writable, {
        readable: false
      }, resume);
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
          await wait();
        }
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, {
      end
    }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline2(...streams) {
      return pipelineImpl(streams, once3(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort2() {
        finishImpl(new AbortError());
      }
      addAbortListener = addAbortListener || dew$m().addAbortListener;
      let disposable;
      if (outerSignal) {
        disposable = addAbortListener(outerSignal, abort2);
      }
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable[SymbolDispose]();
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process$1.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          if (end) {
            const {
              destroy,
              cleanup
            } = destroyer(stream, reading, writing);
            destroys.push(destroy);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError);
            });
          }
        }
        if (i === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex2.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough2) {
              PassThrough2 = dew$63();
            }
            const pt = new PassThrough2({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(ret, (val) => {
                value = val;
                if (val != null) {
                  pt.write(val);
                }
                if (end) {
                  pt.end();
                }
                process$1.nextTick(finish);
              }, (err) => {
                pt.destroy(err);
                process$1.nextTick(finish, err);
              });
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const {
              destroy,
              cleanup
            } = destroyer(ret, false, true);
            destroys.push(destroy);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
          }
          ret = stream;
        } else {
          ret = Duplex2.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process$1.nextTick(abort2);
      }
      return ret;
    }
    function pipe(src, dst, finish, {
      end
    }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn = function() {
          ended = true;
          dst.end();
        };
        if (isReadableFinished(src)) {
          process$1.nextTick(endFn);
        } else {
          src.once("end", endFn);
        }
      } else {
        finish();
      }
      eos(src, {
        readable: true,
        writable: false
      }, (err) => {
        const rState = src._readableState;
        if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
          src.once("end", finish).once("error", finish);
        } else {
          finish(err);
        }
      });
      return eos(dst, {
        readable: false,
        writable: true
      }, finish);
    }
    exports$63 = {
      pipelineImpl,
      pipeline: pipeline2
    };
    return exports$63;
  }
  function dew$43() {
    if (_dewExec$43) return exports$53;
    _dewExec$43 = true;
    const {
      pipeline: pipeline2
    } = dew$53();
    const Duplex2 = dew$83();
    const {
      destroyer
    } = dew$h2();
    const {
      isNodeStream,
      isReadable,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream
    } = dew$j2();
    const {
      AbortError,
      codes: {
        ERR_INVALID_ARG_VALUE,
        ERR_MISSING_ARGS
      }
    } = dew$l();
    const eos = dew$i2();
    exports$53 = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex2.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex2.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex2.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline2(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      d = new Duplex2({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d._read = async function() {
            while (true) {
              try {
                const {
                  value,
                  done
                } = await reader.read();
                if (!d.push(value)) {
                  return;
                }
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d;
    };
    return exports$53;
  }
  function dew$33() {
    if (_dewExec$33) return exports$43;
    _dewExec$33 = true;
    const AbortController = globalThis.AbortController || dew$n().AbortController;
    const {
      codes: {
        ERR_INVALID_ARG_VALUE,
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_MISSING_ARGS,
        ERR_OUT_OF_RANGE
      },
      AbortError
    } = dew$l();
    const {
      validateAbortSignal,
      validateInteger,
      validateObject
    } = dew$k2();
    const kWeakHandler = dew$o().Symbol("kWeak");
    const kResistStopPropagation = dew$o().Symbol("kResistStopPropagation");
    const {
      finished: finished2
    } = dew$i2();
    const staticCompose = dew$43();
    const {
      addAbortSignalNoValidate
    } = dew$f2();
    const {
      isWritable,
      isNodeStream
    } = dew$j2();
    const {
      deprecate: deprecate2
    } = dew$m();
    const {
      ArrayPrototypePush,
      Boolean: Boolean2,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromiseResolve,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = dew$o();
    const kEmpty = Symbol2("kEmpty");
    const kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      let highWaterMark = concurrency - 1;
      if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) {
        highWaterMark = MathFloor(options.highWaterMark);
      }
      validateInteger(concurrency, "options.concurrency", 1);
      validateInteger(highWaterMark, "options.highWaterMark", 0);
      highWaterMark += concurrency;
      return async function* map2() {
        const signal = dew$m().AbortSignalAny([options === null || options === void 0 ? void 0 : options.signal].filter(Boolean2));
        const stream = this;
        const queue2 = [];
        const signalOpt = {
          signal
        };
        let next;
        let resume;
        let done = false;
        let cnt = 0;
        function onCatch() {
          done = true;
          afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1;
          maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue2.length < highWaterMark) {
            resume();
            resume = null;
          }
        }
        async function pump() {
          try {
            for await (let val of stream) {
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              try {
                val = fn(val, signalOpt);
                if (val === kEmpty) {
                  continue;
                }
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              cnt += 1;
              PromisePrototypeThen(val, afterItemProcessed, onCatch);
              queue2.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && (queue2.length >= highWaterMark || cnt >= concurrency)) {
                await new Promise2((resolve) => {
                  resume = resolve;
                });
              }
            }
            queue2.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue2.push(val);
          } finally {
            done = true;
            if (next) {
              next();
              next = null;
            }
          }
        }
        pump();
        try {
          while (true) {
            while (queue2.length > 0) {
              const val = await queue2[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue2.shift();
              maybeResume();
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }.call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal;
          if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
            throw new AbortError({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }.call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(this, async (...args) => {
        return !await fn(...args);
      }, options);
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map.call(this, forEachFn, options)) ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }
    class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    }
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
        const err = new AbortError(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished2(this.destroy(err));
        throw err;
      }
      const ac = new AbortController();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this,
          [kResistStopPropagation]: true
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal3;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) {
            throw new AbortError();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal4;
        if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
          throw new AbortError(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map.call(this, fn, options);
      return async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }.call(this);
    }
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* drop2() {
        var _options$signal5;
        if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal6;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }.call(this);
    }
    function take(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* take2() {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal8;
          if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
            throw new AbortError();
          }
          if (number-- > 0) {
            yield val;
          }
          if (number <= 0) {
            return;
          }
        }
      }.call(this);
    }
    exports$43.streamReturningOperators = {
      asIndexedPairs: deprecate2(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
      drop,
      filter,
      flatMap,
      map,
      take,
      compose
    };
    exports$43.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find
    };
    return exports$43;
  }
  function dew$24() {
    if (_dewExec$24) return exports$33;
    _dewExec$24 = true;
    const {
      ArrayPrototypePop,
      Promise: Promise2
    } = dew$o();
    const {
      isIterable,
      isNodeStream,
      isWebStream
    } = dew$j2();
    const {
      pipelineImpl: pl
    } = dew$53();
    const {
      finished: finished2
    } = dew$i2();
    dew$15();
    function pipeline2(...streams) {
      return new Promise2((resolve, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(streams, (err, value) => {
          if (err) {
            reject(err);
          } else {
            resolve(value);
          }
        }, {
          signal,
          end
        });
      });
    }
    exports$33 = {
      finished: finished2,
      pipeline: pipeline2
    };
    return exports$33;
  }
  function dew$15() {
    if (_dewExec$15) return exports$25;
    _dewExec$15 = true;
    const {
      Buffer: Buffer3
    } = dew();
    const {
      ObjectDefineProperty,
      ObjectKeys,
      ReflectApply
    } = dew$o();
    const {
      promisify: {
        custom: customPromisify
      }
    } = dew$m();
    const {
      streamReturningOperators,
      promiseReturningOperators
    } = dew$33();
    const {
      codes: {
        ERR_ILLEGAL_CONSTRUCTOR
      }
    } = dew$l();
    const compose = dew$43();
    const {
      setDefaultHighWaterMark,
      getDefaultHighWaterMark
    } = dew$d2();
    const {
      pipeline: pipeline2
    } = dew$53();
    const {
      destroyer
    } = dew$h2();
    const eos = dew$i2();
    const promises2 = dew$24();
    const utils = dew$j2();
    const Stream2 = exports$25 = dew$g2().Stream;
    Stream2.isDestroyed = utils.isDestroyed;
    Stream2.isDisturbed = utils.isDisturbed;
    Stream2.isErrored = utils.isErrored;
    Stream2.isReadable = utils.isReadable;
    Stream2.isWritable = utils.isWritable;
    Stream2.Readable = dew$b3();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream2.Readable.from(ReflectApply(op, this || _global2, args));
      };
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream2.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this || _global2, args);
      };
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream2.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    Stream2.Writable = dew$a3();
    Stream2.Duplex = dew$83();
    Stream2.Transform = dew$73();
    Stream2.PassThrough = dew$63();
    Stream2.pipeline = pipeline2;
    const {
      addAbortSignal
    } = dew$f2();
    Stream2.addAbortSignal = addAbortSignal;
    Stream2.finished = eos;
    Stream2.destroy = destroyer;
    Stream2.compose = compose;
    Stream2.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream2.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream2, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises2;
      }
    });
    ObjectDefineProperty(pipeline2, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises2.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises2.finished;
      }
    });
    Stream2.Stream = Stream2;
    Stream2._isUint8Array = function isUint8Array2(value) {
      return value instanceof Uint8Array;
    };
    Stream2._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
    return exports$25;
  }
  function dew7() {
    if (_dewExec7) return exports$16;
    _dewExec7 = true;
    const CustomStream = dew$15();
    const promises2 = dew$24();
    const originalDestroy = CustomStream.Readable.destroy;
    exports$16 = CustomStream.Readable;
    exports$16._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
    exports$16._isUint8Array = CustomStream._isUint8Array;
    exports$16.isDisturbed = CustomStream.isDisturbed;
    exports$16.isErrored = CustomStream.isErrored;
    exports$16.isReadable = CustomStream.isReadable;
    exports$16.Readable = CustomStream.Readable;
    exports$16.Writable = CustomStream.Writable;
    exports$16.Duplex = CustomStream.Duplex;
    exports$16.Transform = CustomStream.Transform;
    exports$16.PassThrough = CustomStream.PassThrough;
    exports$16.addAbortSignal = CustomStream.addAbortSignal;
    exports$16.finished = CustomStream.finished;
    exports$16.destroy = CustomStream.destroy;
    exports$16.destroy = originalDestroy;
    exports$16.pipeline = CustomStream.pipeline;
    exports$16.compose = CustomStream.compose;
    Object.defineProperty(CustomStream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises2;
      }
    });
    exports$16.Stream = CustomStream.Stream;
    exports$16.default = exports$16;
    return exports$16;
  }
  var exports$p, _dewExec$o, exports$o, _dewExec$n, exports$n, _dewExec$m, exports$m, _dewExec$l, exports$l, _dewExec$k2, exports$k2, _dewExec$j2, exports$j2, _dewExec$i2, exports$i2, _dewExec$h2, exports$h2, _dewExec$g2, exports$g2, _dewExec$f2, exports$f2, _dewExec$e2, exports$e2, _dewExec$d2, exports$d2, _dewExec$c2, exports$c3, _dewExec$b3, _global$22, exports$b3, _dewExec$a3, _global$12, exports$a3, _dewExec$93, exports$93, _dewExec$83, exports$83, _dewExec$73, exports$73, _dewExec$63, exports$63, _dewExec$53, exports$53, _dewExec$43, exports$43, _dewExec$33, exports$33, _dewExec$24, exports$25, _dewExec$15, _global2, exports$16, _dewExec7, exports8, Readable, Writable, Duplex, Transform, PassThrough, finished, pipeline, Stream, promises;
  var init_stream = __esm({
    "node_modules/@jspm/core/nodelibs/browser/stream.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_DtuTasat();
      init_events();
      init_chunk_DEMDiNwt();
      init_chunk_CcCWfKp1();
      init_util();
      init_chunk_DtcTpLWz();
      init_chunk_CkFCi_G1();
      exports$p = {};
      _dewExec$o = false;
      exports$o = {};
      _dewExec$n = false;
      exports$n = {};
      _dewExec$m = false;
      exports$m = {};
      _dewExec$l = false;
      exports$l = {};
      _dewExec$k2 = false;
      exports$k2 = {};
      _dewExec$j2 = false;
      exports$j2 = {};
      _dewExec$i2 = false;
      exports$i2 = {};
      _dewExec$h2 = false;
      exports$h2 = {};
      _dewExec$g2 = false;
      exports$g2 = {};
      _dewExec$f2 = false;
      exports$f2 = {};
      _dewExec$e2 = false;
      exports$e2 = {};
      _dewExec$d2 = false;
      exports$d2 = {};
      _dewExec$c2 = false;
      exports$c3 = {};
      _dewExec$b3 = false;
      _global$22 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$b3 = {};
      _dewExec$a3 = false;
      _global$12 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$a3 = {};
      _dewExec$93 = false;
      exports$93 = {};
      _dewExec$83 = false;
      exports$83 = {};
      _dewExec$73 = false;
      exports$73 = {};
      _dewExec$63 = false;
      exports$63 = {};
      _dewExec$53 = false;
      exports$53 = {};
      _dewExec$43 = false;
      exports$43 = {};
      _dewExec$33 = false;
      exports$33 = {};
      _dewExec$24 = false;
      exports$25 = {};
      _dewExec$15 = false;
      _global2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$16 = {};
      _dewExec7 = false;
      exports8 = dew7();
      exports8["_uint8ArrayToBuffer"];
      exports8["_isUint8Array"];
      exports8["isDisturbed"];
      exports8["isErrored"];
      exports8["isReadable"];
      exports8["Readable"];
      exports8["Writable"];
      exports8["Duplex"];
      exports8["Transform"];
      exports8["PassThrough"];
      exports8["addAbortSignal"];
      exports8["finished"];
      exports8["destroy"];
      exports8["pipeline"];
      exports8["compose"];
      exports8["Stream"];
      Readable = exports8.Readable;
      Readable.wrap = function(src, options) {
        options = Object.assign({ objectMode: src.readableObjectMode != null || src.objectMode != null || true }, options);
        options.destroy = function(err, callback) {
          src.destroy(err);
          callback(err);
        };
        return new Readable(options).wrap(src);
      };
      Writable = exports8.Writable;
      Duplex = exports8.Duplex;
      Transform = exports8.Transform;
      PassThrough = exports8.PassThrough;
      finished = exports8.finished;
      pipeline = exports8.pipeline;
      Stream = exports8.Stream;
      promises = {
        finished: promisify(exports8.finished),
        pipeline: promisify(exports8.pipeline)
      };
    }
  });

  // node_modules/hash-base/index.js
  var require_hash_base = __commonJS({
    "node_modules/hash-base/index.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var Buffer3 = require_safe_buffer().Buffer;
      var Transform2 = (init_stream(), __toCommonJS(stream_exports)).Transform;
      var inherits2 = require_inherits_browser();
      function throwIfNotStringOrBuffer(val, prefix) {
        if (!Buffer3.isBuffer(val) && typeof val !== "string") {
          throw new TypeError(prefix + " must be a string or a buffer");
        }
      }
      function HashBase(blockSize) {
        Transform2.call(this);
        this._block = Buffer3.allocUnsafe(blockSize);
        this._blockSize = blockSize;
        this._blockOffset = 0;
        this._length = [0, 0, 0, 0];
        this._finalized = false;
      }
      inherits2(HashBase, Transform2);
      HashBase.prototype._transform = function(chunk, encoding, callback) {
        var error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      HashBase.prototype._flush = function(callback) {
        var error = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      HashBase.prototype.update = function(data, encoding) {
        throwIfNotStringOrBuffer(data, "Data");
        if (this._finalized) throw new Error("Digest already called");
        if (!Buffer3.isBuffer(data)) data = Buffer3.from(data, encoding);
        var block = this._block;
        var offset = 0;
        while (this._blockOffset + data.length - offset >= this._blockSize) {
          for (var i = this._blockOffset; i < this._blockSize; ) block[i++] = data[offset++];
          this._update();
          this._blockOffset = 0;
        }
        while (offset < data.length) block[this._blockOffset++] = data[offset++];
        for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
          this._length[j] += carry;
          carry = this._length[j] / 4294967296 | 0;
          if (carry > 0) this._length[j] -= 4294967296 * carry;
        }
        return this;
      };
      HashBase.prototype._update = function() {
        throw new Error("_update is not implemented");
      };
      HashBase.prototype.digest = function(encoding) {
        if (this._finalized) throw new Error("Digest already called");
        this._finalized = true;
        var digest = this._digest();
        if (encoding !== void 0) digest = digest.toString(encoding);
        this._block.fill(0);
        this._blockOffset = 0;
        for (var i = 0; i < 4; ++i) this._length[i] = 0;
        return digest;
      };
      HashBase.prototype._digest = function() {
        throw new Error("_digest is not implemented");
      };
      module.exports = HashBase;
    }
  });

  // node_modules/md5.js/index.js
  var require_md5 = __commonJS({
    "node_modules/md5.js/index.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var inherits2 = require_inherits_browser();
      var HashBase = require_hash_base();
      var Buffer3 = require_safe_buffer().Buffer;
      var ARRAY16 = new Array(16);
      function MD5() {
        HashBase.call(this, 64);
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
      }
      inherits2(MD5, HashBase);
      MD5.prototype._update = function() {
        var M = ARRAY16;
        for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);
        var a = this._a;
        var b = this._b;
        var c = this._c;
        var d = this._d;
        a = fnF(a, b, c, d, M[0], 3614090360, 7);
        d = fnF(d, a, b, c, M[1], 3905402710, 12);
        c = fnF(c, d, a, b, M[2], 606105819, 17);
        b = fnF(b, c, d, a, M[3], 3250441966, 22);
        a = fnF(a, b, c, d, M[4], 4118548399, 7);
        d = fnF(d, a, b, c, M[5], 1200080426, 12);
        c = fnF(c, d, a, b, M[6], 2821735955, 17);
        b = fnF(b, c, d, a, M[7], 4249261313, 22);
        a = fnF(a, b, c, d, M[8], 1770035416, 7);
        d = fnF(d, a, b, c, M[9], 2336552879, 12);
        c = fnF(c, d, a, b, M[10], 4294925233, 17);
        b = fnF(b, c, d, a, M[11], 2304563134, 22);
        a = fnF(a, b, c, d, M[12], 1804603682, 7);
        d = fnF(d, a, b, c, M[13], 4254626195, 12);
        c = fnF(c, d, a, b, M[14], 2792965006, 17);
        b = fnF(b, c, d, a, M[15], 1236535329, 22);
        a = fnG(a, b, c, d, M[1], 4129170786, 5);
        d = fnG(d, a, b, c, M[6], 3225465664, 9);
        c = fnG(c, d, a, b, M[11], 643717713, 14);
        b = fnG(b, c, d, a, M[0], 3921069994, 20);
        a = fnG(a, b, c, d, M[5], 3593408605, 5);
        d = fnG(d, a, b, c, M[10], 38016083, 9);
        c = fnG(c, d, a, b, M[15], 3634488961, 14);
        b = fnG(b, c, d, a, M[4], 3889429448, 20);
        a = fnG(a, b, c, d, M[9], 568446438, 5);
        d = fnG(d, a, b, c, M[14], 3275163606, 9);
        c = fnG(c, d, a, b, M[3], 4107603335, 14);
        b = fnG(b, c, d, a, M[8], 1163531501, 20);
        a = fnG(a, b, c, d, M[13], 2850285829, 5);
        d = fnG(d, a, b, c, M[2], 4243563512, 9);
        c = fnG(c, d, a, b, M[7], 1735328473, 14);
        b = fnG(b, c, d, a, M[12], 2368359562, 20);
        a = fnH(a, b, c, d, M[5], 4294588738, 4);
        d = fnH(d, a, b, c, M[8], 2272392833, 11);
        c = fnH(c, d, a, b, M[11], 1839030562, 16);
        b = fnH(b, c, d, a, M[14], 4259657740, 23);
        a = fnH(a, b, c, d, M[1], 2763975236, 4);
        d = fnH(d, a, b, c, M[4], 1272893353, 11);
        c = fnH(c, d, a, b, M[7], 4139469664, 16);
        b = fnH(b, c, d, a, M[10], 3200236656, 23);
        a = fnH(a, b, c, d, M[13], 681279174, 4);
        d = fnH(d, a, b, c, M[0], 3936430074, 11);
        c = fnH(c, d, a, b, M[3], 3572445317, 16);
        b = fnH(b, c, d, a, M[6], 76029189, 23);
        a = fnH(a, b, c, d, M[9], 3654602809, 4);
        d = fnH(d, a, b, c, M[12], 3873151461, 11);
        c = fnH(c, d, a, b, M[15], 530742520, 16);
        b = fnH(b, c, d, a, M[2], 3299628645, 23);
        a = fnI(a, b, c, d, M[0], 4096336452, 6);
        d = fnI(d, a, b, c, M[7], 1126891415, 10);
        c = fnI(c, d, a, b, M[14], 2878612391, 15);
        b = fnI(b, c, d, a, M[5], 4237533241, 21);
        a = fnI(a, b, c, d, M[12], 1700485571, 6);
        d = fnI(d, a, b, c, M[3], 2399980690, 10);
        c = fnI(c, d, a, b, M[10], 4293915773, 15);
        b = fnI(b, c, d, a, M[1], 2240044497, 21);
        a = fnI(a, b, c, d, M[8], 1873313359, 6);
        d = fnI(d, a, b, c, M[15], 4264355552, 10);
        c = fnI(c, d, a, b, M[6], 2734768916, 15);
        b = fnI(b, c, d, a, M[13], 1309151649, 21);
        a = fnI(a, b, c, d, M[4], 4149444226, 6);
        d = fnI(d, a, b, c, M[11], 3174756917, 10);
        c = fnI(c, d, a, b, M[2], 718787259, 15);
        b = fnI(b, c, d, a, M[9], 3951481745, 21);
        this._a = this._a + a | 0;
        this._b = this._b + b | 0;
        this._c = this._c + c | 0;
        this._d = this._d + d | 0;
      };
      MD5.prototype._digest = function() {
        this._block[this._blockOffset++] = 128;
        if (this._blockOffset > 56) {
          this._block.fill(0, this._blockOffset, 64);
          this._update();
          this._blockOffset = 0;
        }
        this._block.fill(0, this._blockOffset, 56);
        this._block.writeUInt32LE(this._length[0], 56);
        this._block.writeUInt32LE(this._length[1], 60);
        this._update();
        var buffer = Buffer3.allocUnsafe(16);
        buffer.writeInt32LE(this._a, 0);
        buffer.writeInt32LE(this._b, 4);
        buffer.writeInt32LE(this._c, 8);
        buffer.writeInt32LE(this._d, 12);
        return buffer;
      };
      function rotl(x, n) {
        return x << n | x >>> 32 - n;
      }
      function fnF(a, b, c, d, m, k, s) {
        return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
      }
      function fnG(a, b, c, d, m, k, s) {
        return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
      }
      function fnH(a, b, c, d, m, k, s) {
        return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
      }
      function fnI(a, b, c, d, m, k, s) {
        return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
      }
      module.exports = MD5;
    }
  });

  // node_modules/ripemd160/index.js
  var require_ripemd1602 = __commonJS({
    "node_modules/ripemd160/index.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var Buffer3 = (init_buffer(), __toCommonJS(buffer_exports)).Buffer;
      var inherits2 = require_inherits_browser();
      var HashBase = require_hash_base();
      var ARRAY16 = new Array(16);
      var zl = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
      ];
      var zr = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
      ];
      var sl = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
      ];
      var sr = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
      ];
      var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
      var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
      function RIPEMD160() {
        HashBase.call(this, 64);
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
      }
      inherits2(RIPEMD160, HashBase);
      RIPEMD160.prototype._update = function() {
        var words = ARRAY16;
        for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4);
        var al = this._a | 0;
        var bl = this._b | 0;
        var cl = this._c | 0;
        var dl = this._d | 0;
        var el = this._e | 0;
        var ar = this._a | 0;
        var br = this._b | 0;
        var cr = this._c | 0;
        var dr = this._d | 0;
        var er = this._e | 0;
        for (var i = 0; i < 80; i += 1) {
          var tl;
          var tr;
          if (i < 16) {
            tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
            tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
          } else if (i < 32) {
            tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
            tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
          } else if (i < 48) {
            tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
            tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
          } else if (i < 64) {
            tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
            tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
          } else {
            tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
            tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
          }
          al = el;
          el = dl;
          dl = rotl(cl, 10);
          cl = bl;
          bl = tl;
          ar = er;
          er = dr;
          dr = rotl(cr, 10);
          cr = br;
          br = tr;
        }
        var t = this._b + cl + dr | 0;
        this._b = this._c + dl + er | 0;
        this._c = this._d + el + ar | 0;
        this._d = this._e + al + br | 0;
        this._e = this._a + bl + cr | 0;
        this._a = t;
      };
      RIPEMD160.prototype._digest = function() {
        this._block[this._blockOffset++] = 128;
        if (this._blockOffset > 56) {
          this._block.fill(0, this._blockOffset, 64);
          this._update();
          this._blockOffset = 0;
        }
        this._block.fill(0, this._blockOffset, 56);
        this._block.writeUInt32LE(this._length[0], 56);
        this._block.writeUInt32LE(this._length[1], 60);
        this._update();
        var buffer = Buffer3.alloc ? Buffer3.alloc(20) : new Buffer3(20);
        buffer.writeInt32LE(this._a, 0);
        buffer.writeInt32LE(this._b, 4);
        buffer.writeInt32LE(this._c, 8);
        buffer.writeInt32LE(this._d, 12);
        buffer.writeInt32LE(this._e, 16);
        return buffer;
      };
      function rotl(x, n) {
        return x << n | x >>> 32 - n;
      }
      function fn1(a, b, c, d, e, m, k, s) {
        return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
      }
      function fn2(a, b, c, d, e, m, k, s) {
        return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
      }
      function fn3(a, b, c, d, e, m, k, s) {
        return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
      }
      function fn4(a, b, c, d, e, m, k, s) {
        return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
      }
      function fn5(a, b, c, d, e, m, k, s) {
        return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
      }
      module.exports = RIPEMD160;
    }
  });

  // node_modules/sha.js/hash.js
  var require_hash = __commonJS({
    "node_modules/sha.js/hash.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var Buffer3 = require_safe_buffer().Buffer;
      function Hash(blockSize, finalSize) {
        this._block = Buffer3.alloc(blockSize);
        this._finalSize = finalSize;
        this._blockSize = blockSize;
        this._len = 0;
      }
      Hash.prototype.update = function(data, enc) {
        if (typeof data === "string") {
          enc = enc || "utf8";
          data = Buffer3.from(data, enc);
        }
        var block = this._block;
        var blockSize = this._blockSize;
        var length = data.length;
        var accum = this._len;
        for (var offset = 0; offset < length; ) {
          var assigned = accum % blockSize;
          var remainder = Math.min(length - offset, blockSize - assigned);
          for (var i = 0; i < remainder; i++) {
            block[assigned + i] = data[offset + i];
          }
          accum += remainder;
          offset += remainder;
          if (accum % blockSize === 0) {
            this._update(block);
          }
        }
        this._len += length;
        return this;
      };
      Hash.prototype.digest = function(enc) {
        var rem = this._len % this._blockSize;
        this._block[rem] = 128;
        this._block.fill(0, rem + 1);
        if (rem >= this._finalSize) {
          this._update(this._block);
          this._block.fill(0);
        }
        var bits = this._len * 8;
        if (bits <= 4294967295) {
          this._block.writeUInt32BE(bits, this._blockSize - 4);
        } else {
          var lowBits = (bits & 4294967295) >>> 0;
          var highBits = (bits - lowBits) / 4294967296;
          this._block.writeUInt32BE(highBits, this._blockSize - 8);
          this._block.writeUInt32BE(lowBits, this._blockSize - 4);
        }
        this._update(this._block);
        var hash = this._hash();
        return enc ? hash.toString(enc) : hash;
      };
      Hash.prototype._update = function() {
        throw new Error("_update must be implemented by subclass");
      };
      module.exports = Hash;
    }
  });

  // node_modules/sha.js/sha.js
  var require_sha = __commonJS({
    "node_modules/sha.js/sha.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var inherits2 = require_inherits_browser();
      var Hash = require_hash();
      var Buffer3 = require_safe_buffer().Buffer;
      var K = [
        1518500249,
        1859775393,
        2400959708 | 0,
        3395469782 | 0
      ];
      var W = new Array(80);
      function Sha() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits2(Sha, Hash);
      Sha.prototype.init = function() {
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
        return this;
      };
      function rotl5(num) {
        return num << 5 | num >>> 27;
      }
      function rotl30(num) {
        return num << 30 | num >>> 2;
      }
      function ft(s, b, c, d) {
        if (s === 0) return b & c | ~b & d;
        if (s === 2) return b & c | b & d | c & d;
        return b ^ c ^ d;
      }
      Sha.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
        for (; i < 80; ++i) W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
        for (var j = 0; j < 80; ++j) {
          var s = ~~(j / 20);
          var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
          e = d;
          d = c;
          c = rotl30(b);
          b = a;
          a = t;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
      };
      Sha.prototype._hash = function() {
        var H = Buffer3.allocUnsafe(20);
        H.writeInt32BE(this._a | 0, 0);
        H.writeInt32BE(this._b | 0, 4);
        H.writeInt32BE(this._c | 0, 8);
        H.writeInt32BE(this._d | 0, 12);
        H.writeInt32BE(this._e | 0, 16);
        return H;
      };
      module.exports = Sha;
    }
  });

  // node_modules/sha.js/sha1.js
  var require_sha12 = __commonJS({
    "node_modules/sha.js/sha1.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var inherits2 = require_inherits_browser();
      var Hash = require_hash();
      var Buffer3 = require_safe_buffer().Buffer;
      var K = [
        1518500249,
        1859775393,
        2400959708 | 0,
        3395469782 | 0
      ];
      var W = new Array(80);
      function Sha1() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits2(Sha1, Hash);
      Sha1.prototype.init = function() {
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
        return this;
      };
      function rotl1(num) {
        return num << 1 | num >>> 31;
      }
      function rotl5(num) {
        return num << 5 | num >>> 27;
      }
      function rotl30(num) {
        return num << 30 | num >>> 2;
      }
      function ft(s, b, c, d) {
        if (s === 0) return b & c | ~b & d;
        if (s === 2) return b & c | b & d | c & d;
        return b ^ c ^ d;
      }
      Sha1.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
        for (; i < 80; ++i) W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);
        for (var j = 0; j < 80; ++j) {
          var s = ~~(j / 20);
          var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
          e = d;
          d = c;
          c = rotl30(b);
          b = a;
          a = t;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
      };
      Sha1.prototype._hash = function() {
        var H = Buffer3.allocUnsafe(20);
        H.writeInt32BE(this._a | 0, 0);
        H.writeInt32BE(this._b | 0, 4);
        H.writeInt32BE(this._c | 0, 8);
        H.writeInt32BE(this._d | 0, 12);
        H.writeInt32BE(this._e | 0, 16);
        return H;
      };
      module.exports = Sha1;
    }
  });

  // node_modules/sha.js/sha256.js
  var require_sha2562 = __commonJS({
    "node_modules/sha.js/sha256.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var inherits2 = require_inherits_browser();
      var Hash = require_hash();
      var Buffer3 = require_safe_buffer().Buffer;
      var K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      var W = new Array(64);
      function Sha256() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits2(Sha256, Hash);
      Sha256.prototype.init = function() {
        this._a = 1779033703;
        this._b = 3144134277;
        this._c = 1013904242;
        this._d = 2773480762;
        this._e = 1359893119;
        this._f = 2600822924;
        this._g = 528734635;
        this._h = 1541459225;
        return this;
      };
      function ch(x, y, z) {
        return z ^ x & (y ^ z);
      }
      function maj(x, y, z) {
        return x & y | z & (x | y);
      }
      function sigma0(x) {
        return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
      }
      function sigma1(x) {
        return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
      }
      function gamma0(x) {
        return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
      }
      function gamma1(x) {
        return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
      }
      Sha256.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        var f = this._f | 0;
        var g = this._g | 0;
        var h = this._h | 0;
        for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
        for (; i < 64; ++i) W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;
        for (var j = 0; j < 64; ++j) {
          var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W2[j] | 0;
          var T2 = sigma0(a) + maj(a, b, c) | 0;
          h = g;
          g = f;
          f = e;
          e = d + T1 | 0;
          d = c;
          c = b;
          b = a;
          a = T1 + T2 | 0;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
        this._f = f + this._f | 0;
        this._g = g + this._g | 0;
        this._h = h + this._h | 0;
      };
      Sha256.prototype._hash = function() {
        var H = Buffer3.allocUnsafe(32);
        H.writeInt32BE(this._a, 0);
        H.writeInt32BE(this._b, 4);
        H.writeInt32BE(this._c, 8);
        H.writeInt32BE(this._d, 12);
        H.writeInt32BE(this._e, 16);
        H.writeInt32BE(this._f, 20);
        H.writeInt32BE(this._g, 24);
        H.writeInt32BE(this._h, 28);
        return H;
      };
      module.exports = Sha256;
    }
  });

  // node_modules/sha.js/sha224.js
  var require_sha224 = __commonJS({
    "node_modules/sha.js/sha224.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var inherits2 = require_inherits_browser();
      var Sha256 = require_sha2562();
      var Hash = require_hash();
      var Buffer3 = require_safe_buffer().Buffer;
      var W = new Array(64);
      function Sha224() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits2(Sha224, Sha256);
      Sha224.prototype.init = function() {
        this._a = 3238371032;
        this._b = 914150663;
        this._c = 812702999;
        this._d = 4144912697;
        this._e = 4290775857;
        this._f = 1750603025;
        this._g = 1694076839;
        this._h = 3204075428;
        return this;
      };
      Sha224.prototype._hash = function() {
        var H = Buffer3.allocUnsafe(28);
        H.writeInt32BE(this._a, 0);
        H.writeInt32BE(this._b, 4);
        H.writeInt32BE(this._c, 8);
        H.writeInt32BE(this._d, 12);
        H.writeInt32BE(this._e, 16);
        H.writeInt32BE(this._f, 20);
        H.writeInt32BE(this._g, 24);
        return H;
      };
      module.exports = Sha224;
    }
  });

  // node_modules/sha.js/sha512.js
  var require_sha512 = __commonJS({
    "node_modules/sha.js/sha512.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var inherits2 = require_inherits_browser();
      var Hash = require_hash();
      var Buffer3 = require_safe_buffer().Buffer;
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      var W = new Array(160);
      function Sha512() {
        this.init();
        this._w = W;
        Hash.call(this, 128, 112);
      }
      inherits2(Sha512, Hash);
      Sha512.prototype.init = function() {
        this._ah = 1779033703;
        this._bh = 3144134277;
        this._ch = 1013904242;
        this._dh = 2773480762;
        this._eh = 1359893119;
        this._fh = 2600822924;
        this._gh = 528734635;
        this._hh = 1541459225;
        this._al = 4089235720;
        this._bl = 2227873595;
        this._cl = 4271175723;
        this._dl = 1595750129;
        this._el = 2917565137;
        this._fl = 725511199;
        this._gl = 4215389547;
        this._hl = 327033209;
        return this;
      };
      function Ch(x, y, z) {
        return z ^ x & (y ^ z);
      }
      function maj(x, y, z) {
        return x & y | z & (x | y);
      }
      function sigma0(x, xl) {
        return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
      }
      function sigma1(x, xl) {
        return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
      }
      function Gamma0(x, xl) {
        return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
      }
      function Gamma0l(x, xl) {
        return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
      }
      function Gamma1(x, xl) {
        return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
      }
      function Gamma1l(x, xl) {
        return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
      }
      function getCarry(a, b) {
        return a >>> 0 < b >>> 0 ? 1 : 0;
      }
      Sha512.prototype._update = function(M) {
        var W2 = this._w;
        var ah = this._ah | 0;
        var bh = this._bh | 0;
        var ch = this._ch | 0;
        var dh = this._dh | 0;
        var eh = this._eh | 0;
        var fh = this._fh | 0;
        var gh = this._gh | 0;
        var hh = this._hh | 0;
        var al = this._al | 0;
        var bl = this._bl | 0;
        var cl = this._cl | 0;
        var dl = this._dl | 0;
        var el = this._el | 0;
        var fl = this._fl | 0;
        var gl = this._gl | 0;
        var hl = this._hl | 0;
        for (var i = 0; i < 32; i += 2) {
          W2[i] = M.readInt32BE(i * 4);
          W2[i + 1] = M.readInt32BE(i * 4 + 4);
        }
        for (; i < 160; i += 2) {
          var xh = W2[i - 15 * 2];
          var xl = W2[i - 15 * 2 + 1];
          var gamma0 = Gamma0(xh, xl);
          var gamma0l = Gamma0l(xl, xh);
          xh = W2[i - 2 * 2];
          xl = W2[i - 2 * 2 + 1];
          var gamma1 = Gamma1(xh, xl);
          var gamma1l = Gamma1l(xl, xh);
          var Wi7h = W2[i - 7 * 2];
          var Wi7l = W2[i - 7 * 2 + 1];
          var Wi16h = W2[i - 16 * 2];
          var Wi16l = W2[i - 16 * 2 + 1];
          var Wil = gamma0l + Wi7l | 0;
          var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
          Wil = Wil + gamma1l | 0;
          Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
          Wil = Wil + Wi16l | 0;
          Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
          W2[i] = Wih;
          W2[i + 1] = Wil;
        }
        for (var j = 0; j < 160; j += 2) {
          Wih = W2[j];
          Wil = W2[j + 1];
          var majh = maj(ah, bh, ch);
          var majl = maj(al, bl, cl);
          var sigma0h = sigma0(ah, al);
          var sigma0l = sigma0(al, ah);
          var sigma1h = sigma1(eh, el);
          var sigma1l = sigma1(el, eh);
          var Kih = K[j];
          var Kil = K[j + 1];
          var chh = Ch(eh, fh, gh);
          var chl = Ch(el, fl, gl);
          var t1l = hl + sigma1l | 0;
          var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
          t1l = t1l + chl | 0;
          t1h = t1h + chh + getCarry(t1l, chl) | 0;
          t1l = t1l + Kil | 0;
          t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
          t1l = t1l + Wil | 0;
          t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
          var t2l = sigma0l + majl | 0;
          var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          el = dl + t1l | 0;
          eh = dh + t1h + getCarry(el, dl) | 0;
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          al = t1l + t2l | 0;
          ah = t1h + t2h + getCarry(al, t1l) | 0;
        }
        this._al = this._al + al | 0;
        this._bl = this._bl + bl | 0;
        this._cl = this._cl + cl | 0;
        this._dl = this._dl + dl | 0;
        this._el = this._el + el | 0;
        this._fl = this._fl + fl | 0;
        this._gl = this._gl + gl | 0;
        this._hl = this._hl + hl | 0;
        this._ah = this._ah + ah + getCarry(this._al, al) | 0;
        this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
        this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
        this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
        this._eh = this._eh + eh + getCarry(this._el, el) | 0;
        this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
        this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
        this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
      };
      Sha512.prototype._hash = function() {
        var H = Buffer3.allocUnsafe(64);
        function writeInt64BE(h, l, offset) {
          H.writeInt32BE(h, offset);
          H.writeInt32BE(l, offset + 4);
        }
        writeInt64BE(this._ah, this._al, 0);
        writeInt64BE(this._bh, this._bl, 8);
        writeInt64BE(this._ch, this._cl, 16);
        writeInt64BE(this._dh, this._dl, 24);
        writeInt64BE(this._eh, this._el, 32);
        writeInt64BE(this._fh, this._fl, 40);
        writeInt64BE(this._gh, this._gl, 48);
        writeInt64BE(this._hh, this._hl, 56);
        return H;
      };
      module.exports = Sha512;
    }
  });

  // node_modules/sha.js/sha384.js
  var require_sha384 = __commonJS({
    "node_modules/sha.js/sha384.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var inherits2 = require_inherits_browser();
      var SHA512 = require_sha512();
      var Hash = require_hash();
      var Buffer3 = require_safe_buffer().Buffer;
      var W = new Array(160);
      function Sha384() {
        this.init();
        this._w = W;
        Hash.call(this, 128, 112);
      }
      inherits2(Sha384, SHA512);
      Sha384.prototype.init = function() {
        this._ah = 3418070365;
        this._bh = 1654270250;
        this._ch = 2438529370;
        this._dh = 355462360;
        this._eh = 1731405415;
        this._fh = 2394180231;
        this._gh = 3675008525;
        this._hh = 1203062813;
        this._al = 3238371032;
        this._bl = 914150663;
        this._cl = 812702999;
        this._dl = 4144912697;
        this._el = 4290775857;
        this._fl = 1750603025;
        this._gl = 1694076839;
        this._hl = 3204075428;
        return this;
      };
      Sha384.prototype._hash = function() {
        var H = Buffer3.allocUnsafe(48);
        function writeInt64BE(h, l, offset) {
          H.writeInt32BE(h, offset);
          H.writeInt32BE(l, offset + 4);
        }
        writeInt64BE(this._ah, this._al, 0);
        writeInt64BE(this._bh, this._bl, 8);
        writeInt64BE(this._ch, this._cl, 16);
        writeInt64BE(this._dh, this._dl, 24);
        writeInt64BE(this._eh, this._el, 32);
        writeInt64BE(this._fh, this._fl, 40);
        return H;
      };
      module.exports = Sha384;
    }
  });

  // node_modules/sha.js/index.js
  var require_sha2 = __commonJS({
    "node_modules/sha.js/index.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var exports9 = module.exports = function SHA(algorithm) {
        algorithm = algorithm.toLowerCase();
        var Algorithm = exports9[algorithm];
        if (!Algorithm) throw new Error(algorithm + " is not supported (we accept pull requests)");
        return new Algorithm();
      };
      exports9.sha = require_sha();
      exports9.sha1 = require_sha12();
      exports9.sha224 = require_sha224();
      exports9.sha256 = require_sha2562();
      exports9.sha384 = require_sha384();
      exports9.sha512 = require_sha512();
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/string_decoder.js
  var string_decoder_exports = {};
  __export(string_decoder_exports, {
    StringDecoder: () => StringDecoder,
    default: () => exports4
  });
  var init_string_decoder = __esm({
    "node_modules/@jspm/core/nodelibs/browser/string_decoder.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_CcCWfKp1();
      init_chunk_DtuTasat();
    }
  });

  // node_modules/cipher-base/index.js
  var require_cipher_base = __commonJS({
    "node_modules/cipher-base/index.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var Buffer3 = require_safe_buffer().Buffer;
      var Transform2 = (init_stream(), __toCommonJS(stream_exports)).Transform;
      var StringDecoder2 = (init_string_decoder(), __toCommonJS(string_decoder_exports)).StringDecoder;
      var inherits2 = require_inherits_browser();
      function CipherBase(hashMode) {
        Transform2.call(this);
        this.hashMode = typeof hashMode === "string";
        if (this.hashMode) {
          this[hashMode] = this._finalOrDigest;
        } else {
          this.final = this._finalOrDigest;
        }
        if (this._final) {
          this.__final = this._final;
          this._final = null;
        }
        this._decoder = null;
        this._encoding = null;
      }
      inherits2(CipherBase, Transform2);
      CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
        if (typeof data === "string") {
          data = Buffer3.from(data, inputEnc);
        }
        var outData = this._update(data);
        if (this.hashMode) return this;
        if (outputEnc) {
          outData = this._toString(outData, outputEnc);
        }
        return outData;
      };
      CipherBase.prototype.setAutoPadding = function() {
      };
      CipherBase.prototype.getAuthTag = function() {
        throw new Error("trying to get auth tag in unsupported state");
      };
      CipherBase.prototype.setAuthTag = function() {
        throw new Error("trying to set auth tag in unsupported state");
      };
      CipherBase.prototype.setAAD = function() {
        throw new Error("trying to set aad in unsupported state");
      };
      CipherBase.prototype._transform = function(data, _, next) {
        var err;
        try {
          if (this.hashMode) {
            this._update(data);
          } else {
            this.push(this._update(data));
          }
        } catch (e) {
          err = e;
        } finally {
          next(err);
        }
      };
      CipherBase.prototype._flush = function(done) {
        var err;
        try {
          this.push(this.__final());
        } catch (e) {
          err = e;
        }
        done(err);
      };
      CipherBase.prototype._finalOrDigest = function(outputEnc) {
        var outData = this.__final() || Buffer3.alloc(0);
        if (outputEnc) {
          outData = this._toString(outData, outputEnc, true);
        }
        return outData;
      };
      CipherBase.prototype._toString = function(value, enc, fin) {
        if (!this._decoder) {
          this._decoder = new StringDecoder2(enc);
          this._encoding = enc;
        }
        if (this._encoding !== enc) throw new Error("can't switch encodings");
        var out = this._decoder.write(value);
        if (fin) {
          out += this._decoder.end();
        }
        return out;
      };
      module.exports = CipherBase;
    }
  });

  // node_modules/create-hash/browser.js
  var require_browser = __commonJS({
    "node_modules/create-hash/browser.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var inherits2 = require_inherits_browser();
      var MD5 = require_md5();
      var RIPEMD160 = require_ripemd1602();
      var sha = require_sha2();
      var Base = require_cipher_base();
      function Hash(hash) {
        Base.call(this, "digest");
        this._hash = hash;
      }
      inherits2(Hash, Base);
      Hash.prototype._update = function(data) {
        this._hash.update(data);
      };
      Hash.prototype._final = function() {
        return this._hash.digest();
      };
      module.exports = function createHash(alg) {
        alg = alg.toLowerCase();
        if (alg === "md5") return new MD5();
        if (alg === "rmd160" || alg === "ripemd160") return new RIPEMD160();
        return new Hash(sha(alg));
      };
    }
  });

  // node_modules/bitcoinjs-message/node_modules/base-x/src/index.js
  var require_src3 = __commonJS({
    "node_modules/bitcoinjs-message/node_modules/base-x/src/index.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var _Buffer = require_safe_buffer().Buffer;
      function base(ALPHABET) {
        if (ALPHABET.length >= 255) {
          throw new TypeError("Alphabet too long");
        }
        var BASE_MAP = new Uint8Array(256);
        for (var j = 0; j < BASE_MAP.length; j++) {
          BASE_MAP[j] = 255;
        }
        for (var i = 0; i < ALPHABET.length; i++) {
          var x = ALPHABET.charAt(i);
          var xc = x.charCodeAt(0);
          if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + " is ambiguous");
          }
          BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        var FACTOR = Math.log(BASE) / Math.log(256);
        var iFACTOR = Math.log(256) / Math.log(BASE);
        function encode(source) {
          if (Array.isArray(source) || source instanceof Uint8Array) {
            source = _Buffer.from(source);
          }
          if (!_Buffer.isBuffer(source)) {
            throw new TypeError("Expected Buffer");
          }
          if (source.length === 0) {
            return "";
          }
          var zeroes = 0;
          var length = 0;
          var pbegin = 0;
          var pend = source.length;
          while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
          }
          var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
          var b58 = new Uint8Array(size);
          while (pbegin !== pend) {
            var carry = source[pbegin];
            var i2 = 0;
            for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
              carry += 256 * b58[it1] >>> 0;
              b58[it1] = carry % BASE >>> 0;
              carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            pbegin++;
          }
          var it2 = size - length;
          while (it2 !== size && b58[it2] === 0) {
            it2++;
          }
          var str = LEADER.repeat(zeroes);
          for (; it2 < size; ++it2) {
            str += ALPHABET.charAt(b58[it2]);
          }
          return str;
        }
        function decodeUnsafe(source) {
          if (typeof source !== "string") {
            throw new TypeError("Expected String");
          }
          if (source.length === 0) {
            return _Buffer.alloc(0);
          }
          var psz = 0;
          var zeroes = 0;
          var length = 0;
          while (source[psz] === LEADER) {
            zeroes++;
            psz++;
          }
          var size = (source.length - psz) * FACTOR + 1 >>> 0;
          var b256 = new Uint8Array(size);
          while (psz < source.length) {
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (carry === 255) {
              return;
            }
            var i2 = 0;
            for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
              carry += BASE * b256[it3] >>> 0;
              b256[it3] = carry % 256 >>> 0;
              carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            psz++;
          }
          var it4 = size - length;
          while (it4 !== size && b256[it4] === 0) {
            it4++;
          }
          var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
          vch.fill(0, 0, zeroes);
          var j2 = zeroes;
          while (it4 !== size) {
            vch[j2++] = b256[it4++];
          }
          return vch;
        }
        function decode(string) {
          var buffer = decodeUnsafe(string);
          if (buffer) {
            return buffer;
          }
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode,
          decodeUnsafe,
          decode
        };
      }
      module.exports = base;
    }
  });

  // node_modules/bitcoinjs-message/node_modules/bs58/index.js
  var require_bs582 = __commonJS({
    "node_modules/bitcoinjs-message/node_modules/bs58/index.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var basex = require_src3();
      var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      module.exports = basex(ALPHABET);
    }
  });

  // node_modules/bitcoinjs-message/node_modules/bs58check/base.js
  var require_base2 = __commonJS({
    "node_modules/bitcoinjs-message/node_modules/bs58check/base.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var base58 = require_bs582();
      var Buffer3 = require_safe_buffer().Buffer;
      module.exports = function(checksumFn) {
        function encode(payload) {
          var checksum = checksumFn(payload);
          return base58.encode(Buffer3.concat([
            payload,
            checksum
          ], payload.length + 4));
        }
        function decodeRaw(buffer) {
          var payload = buffer.slice(0, -4);
          var checksum = buffer.slice(-4);
          var newChecksum = checksumFn(payload);
          if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
          return payload;
        }
        function decodeUnsafe(string) {
          var buffer = base58.decodeUnsafe(string);
          if (!buffer) return;
          return decodeRaw(buffer);
        }
        function decode(string) {
          var buffer = base58.decode(string);
          var payload = decodeRaw(buffer, checksumFn);
          if (!payload) throw new Error("Invalid checksum");
          return payload;
        }
        return {
          encode,
          decode,
          decodeUnsafe
        };
      };
    }
  });

  // node_modules/bitcoinjs-message/node_modules/bs58check/index.js
  var require_bs58check2 = __commonJS({
    "node_modules/bitcoinjs-message/node_modules/bs58check/index.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var createHash = require_browser();
      var bs58checkBase = require_base2();
      function sha256x2(buffer) {
        var tmp = createHash("sha256").update(buffer).digest();
        return createHash("sha256").update(tmp).digest();
      }
      module.exports = bs58checkBase(sha256x2);
    }
  });

  // node_modules/bitcoinjs-message/node_modules/bech32/index.js
  var require_bech32 = __commonJS({
    "node_modules/bitcoinjs-message/node_modules/bech32/index.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
      var ALPHABET_MAP = {};
      for (z = 0; z < ALPHABET.length; z++) {
        x = ALPHABET.charAt(z);
        if (ALPHABET_MAP[x] !== void 0) throw new TypeError(x + " is ambiguous");
        ALPHABET_MAP[x] = z;
      }
      var x;
      var z;
      function polymodStep(pre) {
        var b = pre >> 25;
        return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
      }
      function prefixChk(prefix) {
        var chk = 1;
        for (var i = 0; i < prefix.length; ++i) {
          var c = prefix.charCodeAt(i);
          if (c < 33 || c > 126) return "Invalid prefix (" + prefix + ")";
          chk = polymodStep(chk) ^ c >> 5;
        }
        chk = polymodStep(chk);
        for (i = 0; i < prefix.length; ++i) {
          var v = prefix.charCodeAt(i);
          chk = polymodStep(chk) ^ v & 31;
        }
        return chk;
      }
      function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT) throw new TypeError("Exceeds length limit");
        prefix = prefix.toLowerCase();
        var chk = prefixChk(prefix);
        if (typeof chk === "string") throw new Error(chk);
        var result = prefix + "1";
        for (var i = 0; i < words.length; ++i) {
          var x2 = words[i];
          if (x2 >> 5 !== 0) throw new Error("Non 5-bit word");
          chk = polymodStep(chk) ^ x2;
          result += ALPHABET.charAt(x2);
        }
        for (i = 0; i < 6; ++i) {
          chk = polymodStep(chk);
        }
        chk ^= 1;
        for (i = 0; i < 6; ++i) {
          var v = chk >> (5 - i) * 5 & 31;
          result += ALPHABET.charAt(v);
        }
        return result;
      }
      function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8) return str + " too short";
        if (str.length > LIMIT) return "Exceeds length limit";
        var lowered = str.toLowerCase();
        var uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered) return "Mixed-case string " + str;
        str = lowered;
        var split = str.lastIndexOf("1");
        if (split === -1) return "No separator character for " + str;
        if (split === 0) return "Missing prefix for " + str;
        var prefix = str.slice(0, split);
        var wordChars = str.slice(split + 1);
        if (wordChars.length < 6) return "Data too short";
        var chk = prefixChk(prefix);
        if (typeof chk === "string") return chk;
        var words = [];
        for (var i = 0; i < wordChars.length; ++i) {
          var c = wordChars.charAt(i);
          var v = ALPHABET_MAP[c];
          if (v === void 0) return "Unknown character " + c;
          chk = polymodStep(chk) ^ v;
          if (i + 6 >= wordChars.length) continue;
          words.push(v);
        }
        if (chk !== 1) return "Invalid checksum for " + str;
        return { prefix, words };
      }
      function decodeUnsafe() {
        var res = __decode.apply(null, arguments);
        if (typeof res === "object") return res;
      }
      function decode(str) {
        var res = __decode.apply(null, arguments);
        if (typeof res === "object") return res;
        throw new Error(res);
      }
      function convert(data, inBits, outBits, pad) {
        var value = 0;
        var bits = 0;
        var maxV = (1 << outBits) - 1;
        var result = [];
        for (var i = 0; i < data.length; ++i) {
          value = value << inBits | data[i];
          bits += inBits;
          while (bits >= outBits) {
            bits -= outBits;
            result.push(value >> bits & maxV);
          }
        }
        if (pad) {
          if (bits > 0) {
            result.push(value << outBits - bits & maxV);
          }
        } else {
          if (bits >= inBits) return "Excess padding";
          if (value << outBits - bits & maxV) return "Non-zero padding";
        }
        return result;
      }
      function toWordsUnsafe(bytes) {
        var res = convert(bytes, 8, 5, true);
        if (Array.isArray(res)) return res;
      }
      function toWords(bytes) {
        var res = convert(bytes, 8, 5, true);
        if (Array.isArray(res)) return res;
        throw new Error(res);
      }
      function fromWordsUnsafe(words) {
        var res = convert(words, 5, 8, false);
        if (Array.isArray(res)) return res;
      }
      function fromWords(words) {
        var res = convert(words, 5, 8, false);
        if (Array.isArray(res)) return res;
        throw new Error(res);
      }
      module.exports = {
        decodeUnsafe,
        decode,
        encode,
        toWordsUnsafe,
        toWords,
        fromWordsUnsafe,
        fromWords
      };
    }
  });

  // node_modules/buffer-equals/index.js
  var require_buffer_equals = __commonJS({
    "node_modules/buffer-equals/index.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module.exports = function(a, b) {
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError("Arguments must be Buffers");
        }
        if (a === b) {
          return true;
        }
        if (typeof a.equals === "function") {
          return a.equals(b);
        }
        if (a.length !== b.length) {
          return false;
        }
        for (var i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/secp256k1/lib/assert.js
  var require_assert2 = __commonJS({
    "node_modules/secp256k1/lib/assert.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var toString = Object.prototype.toString;
      exports9.isArray = function(value, message) {
        if (!Array.isArray(value)) throw TypeError(message);
      };
      exports9.isBoolean = function(value, message) {
        if (toString.call(value) !== "[object Boolean]") throw TypeError(message);
      };
      exports9.isBuffer = function(value, message) {
        if (!Buffer2.isBuffer(value)) throw TypeError(message);
      };
      exports9.isFunction = function(value, message) {
        if (toString.call(value) !== "[object Function]") throw TypeError(message);
      };
      exports9.isNumber = function(value, message) {
        if (toString.call(value) !== "[object Number]") throw TypeError(message);
      };
      exports9.isObject = function(value, message) {
        if (toString.call(value) !== "[object Object]") throw TypeError(message);
      };
      exports9.isBufferLength = function(buffer, length, message) {
        if (buffer.length !== length) throw RangeError(message);
      };
      exports9.isBufferLength2 = function(buffer, length1, length2, message) {
        if (buffer.length !== length1 && buffer.length !== length2) throw RangeError(message);
      };
      exports9.isLengthGTZero = function(value, message) {
        if (value.length === 0) throw RangeError(message);
      };
      exports9.isNumberInInterval = function(number, x, y, message) {
        if (number <= x || number >= y) throw RangeError(message);
      };
    }
  });

  // node_modules/bip66/index.js
  var require_bip662 = __commonJS({
    "node_modules/bip66/index.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var Buffer3 = require_safe_buffer().Buffer;
      function check(buffer) {
        if (buffer.length < 8) return false;
        if (buffer.length > 72) return false;
        if (buffer[0] !== 48) return false;
        if (buffer[1] !== buffer.length - 2) return false;
        if (buffer[2] !== 2) return false;
        var lenR = buffer[3];
        if (lenR === 0) return false;
        if (5 + lenR >= buffer.length) return false;
        if (buffer[4 + lenR] !== 2) return false;
        var lenS = buffer[5 + lenR];
        if (lenS === 0) return false;
        if (6 + lenR + lenS !== buffer.length) return false;
        if (buffer[4] & 128) return false;
        if (lenR > 1 && buffer[4] === 0 && !(buffer[5] & 128)) return false;
        if (buffer[lenR + 6] & 128) return false;
        if (lenS > 1 && buffer[lenR + 6] === 0 && !(buffer[lenR + 7] & 128)) return false;
        return true;
      }
      function decode(buffer) {
        if (buffer.length < 8) throw new Error("DER sequence length is too short");
        if (buffer.length > 72) throw new Error("DER sequence length is too long");
        if (buffer[0] !== 48) throw new Error("Expected DER sequence");
        if (buffer[1] !== buffer.length - 2) throw new Error("DER sequence length is invalid");
        if (buffer[2] !== 2) throw new Error("Expected DER integer");
        var lenR = buffer[3];
        if (lenR === 0) throw new Error("R length is zero");
        if (5 + lenR >= buffer.length) throw new Error("R length is too long");
        if (buffer[4 + lenR] !== 2) throw new Error("Expected DER integer (2)");
        var lenS = buffer[5 + lenR];
        if (lenS === 0) throw new Error("S length is zero");
        if (6 + lenR + lenS !== buffer.length) throw new Error("S length is invalid");
        if (buffer[4] & 128) throw new Error("R value is negative");
        if (lenR > 1 && buffer[4] === 0 && !(buffer[5] & 128)) throw new Error("R value excessively padded");
        if (buffer[lenR + 6] & 128) throw new Error("S value is negative");
        if (lenS > 1 && buffer[lenR + 6] === 0 && !(buffer[lenR + 7] & 128)) throw new Error("S value excessively padded");
        return {
          r: buffer.slice(4, 4 + lenR),
          s: buffer.slice(6 + lenR)
        };
      }
      function encode(r, s) {
        var lenR = r.length;
        var lenS = s.length;
        if (lenR === 0) throw new Error("R length is zero");
        if (lenS === 0) throw new Error("S length is zero");
        if (lenR > 33) throw new Error("R length is too long");
        if (lenS > 33) throw new Error("S length is too long");
        if (r[0] & 128) throw new Error("R value is negative");
        if (s[0] & 128) throw new Error("S value is negative");
        if (lenR > 1 && r[0] === 0 && !(r[1] & 128)) throw new Error("R value excessively padded");
        if (lenS > 1 && s[0] === 0 && !(s[1] & 128)) throw new Error("S value excessively padded");
        var signature = Buffer3.allocUnsafe(6 + lenR + lenS);
        signature[0] = 48;
        signature[1] = signature.length - 2;
        signature[2] = 2;
        signature[3] = r.length;
        r.copy(signature, 4);
        signature[4 + lenR] = 2;
        signature[5 + lenR] = s.length;
        s.copy(signature, 6 + lenR);
        return signature;
      }
      module.exports = {
        check,
        decode,
        encode
      };
    }
  });

  // node_modules/secp256k1/lib/der.js
  var require_der = __commonJS({
    "node_modules/secp256k1/lib/der.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var Buffer3 = require_safe_buffer().Buffer;
      var bip66 = require_bip662();
      var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer3.from([
        // begin
        48,
        129,
        211,
        2,
        1,
        1,
        4,
        32,
        // private key
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // middle
        160,
        129,
        133,
        48,
        129,
        130,
        2,
        1,
        1,
        48,
        44,
        6,
        7,
        42,
        134,
        72,
        206,
        61,
        1,
        1,
        2,
        33,
        0,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        254,
        255,
        255,
        252,
        47,
        48,
        6,
        4,
        1,
        0,
        4,
        1,
        7,
        4,
        33,
        2,
        121,
        190,
        102,
        126,
        249,
        220,
        187,
        172,
        85,
        160,
        98,
        149,
        206,
        135,
        11,
        7,
        2,
        155,
        252,
        219,
        45,
        206,
        40,
        217,
        89,
        242,
        129,
        91,
        22,
        248,
        23,
        152,
        2,
        33,
        0,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        254,
        186,
        174,
        220,
        230,
        175,
        72,
        160,
        59,
        191,
        210,
        94,
        140,
        208,
        54,
        65,
        65,
        2,
        1,
        1,
        161,
        36,
        3,
        34,
        0,
        // public key
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]);
      var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer3.from([
        // begin
        48,
        130,
        1,
        19,
        2,
        1,
        1,
        4,
        32,
        // private key
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // middle
        160,
        129,
        165,
        48,
        129,
        162,
        2,
        1,
        1,
        48,
        44,
        6,
        7,
        42,
        134,
        72,
        206,
        61,
        1,
        1,
        2,
        33,
        0,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        254,
        255,
        255,
        252,
        47,
        48,
        6,
        4,
        1,
        0,
        4,
        1,
        7,
        4,
        65,
        4,
        121,
        190,
        102,
        126,
        249,
        220,
        187,
        172,
        85,
        160,
        98,
        149,
        206,
        135,
        11,
        7,
        2,
        155,
        252,
        219,
        45,
        206,
        40,
        217,
        89,
        242,
        129,
        91,
        22,
        248,
        23,
        152,
        72,
        58,
        218,
        119,
        38,
        163,
        196,
        101,
        93,
        164,
        251,
        252,
        14,
        17,
        8,
        168,
        253,
        23,
        180,
        72,
        166,
        133,
        84,
        25,
        156,
        71,
        208,
        143,
        251,
        16,
        212,
        184,
        2,
        33,
        0,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        254,
        186,
        174,
        220,
        230,
        175,
        72,
        160,
        59,
        191,
        210,
        94,
        140,
        208,
        54,
        65,
        65,
        2,
        1,
        1,
        161,
        68,
        3,
        66,
        0,
        // public key
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]);
      exports9.privateKeyExport = function(privateKey, publicKey, compressed) {
        var result = Buffer3.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
        privateKey.copy(result, compressed ? 8 : 9);
        publicKey.copy(result, compressed ? 181 : 214);
        return result;
      };
      exports9.privateKeyImport = function(privateKey) {
        var length = privateKey.length;
        var index = 0;
        if (length < index + 1 || privateKey[index] !== 48) return;
        index += 1;
        if (length < index + 1 || !(privateKey[index] & 128)) return;
        var lenb = privateKey[index] & 127;
        index += 1;
        if (lenb < 1 || lenb > 2) return;
        if (length < index + lenb) return;
        var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
        index += lenb;
        if (length < index + len) return;
        if (length < index + 3 || privateKey[index] !== 2 || privateKey[index + 1] !== 1 || privateKey[index + 2] !== 1) {
          return;
        }
        index += 3;
        if (length < index + 2 || privateKey[index] !== 4 || privateKey[index + 1] > 32 || length < index + 2 + privateKey[index + 1]) {
          return;
        }
        return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
      };
      exports9.signatureExport = function(sigObj) {
        var r = Buffer3.concat([Buffer3.from([0]), sigObj.r]);
        for (var lenR = 33, posR = 0; lenR > 1 && r[posR] === 0 && !(r[posR + 1] & 128); --lenR, ++posR) ;
        var s = Buffer3.concat([Buffer3.from([0]), sigObj.s]);
        for (var lenS = 33, posS = 0; lenS > 1 && s[posS] === 0 && !(s[posS + 1] & 128); --lenS, ++posS) ;
        return bip66.encode(r.slice(posR), s.slice(posS));
      };
      exports9.signatureImport = function(sig) {
        var r = Buffer3.alloc(32, 0);
        var s = Buffer3.alloc(32, 0);
        try {
          var sigObj = bip66.decode(sig);
          if (sigObj.r.length === 33 && sigObj.r[0] === 0) sigObj.r = sigObj.r.slice(1);
          if (sigObj.r.length > 32) throw new Error("R length is too long");
          if (sigObj.s.length === 33 && sigObj.s[0] === 0) sigObj.s = sigObj.s.slice(1);
          if (sigObj.s.length > 32) throw new Error("S length is too long");
        } catch (err) {
          return;
        }
        sigObj.r.copy(r, 32 - sigObj.r.length);
        sigObj.s.copy(s, 32 - sigObj.s.length);
        return { r, s };
      };
      exports9.signatureImportLax = function(sig) {
        var r = Buffer3.alloc(32, 0);
        var s = Buffer3.alloc(32, 0);
        var length = sig.length;
        var index = 0;
        if (sig[index++] !== 48) return;
        var lenbyte = sig[index++];
        if (lenbyte & 128) {
          index += lenbyte - 128;
          if (index > length) return;
        }
        if (sig[index++] !== 2) return;
        var rlen = sig[index++];
        if (rlen & 128) {
          lenbyte = rlen - 128;
          if (index + lenbyte > length) return;
          for (; lenbyte > 0 && sig[index] === 0; index += 1, lenbyte -= 1) ;
          for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) rlen = (rlen << 8) + sig[index];
        }
        if (rlen > length - index) return;
        var rindex = index;
        index += rlen;
        if (sig[index++] !== 2) return;
        var slen = sig[index++];
        if (slen & 128) {
          lenbyte = slen - 128;
          if (index + lenbyte > length) return;
          for (; lenbyte > 0 && sig[index] === 0; index += 1, lenbyte -= 1) ;
          for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) slen = (slen << 8) + sig[index];
        }
        if (slen > length - index) return;
        var sindex = index;
        index += slen;
        for (; rlen > 0 && sig[rindex] === 0; rlen -= 1, rindex += 1) ;
        if (rlen > 32) return;
        var rvalue = sig.slice(rindex, rindex + rlen);
        rvalue.copy(r, 32 - rvalue.length);
        for (; slen > 0 && sig[sindex] === 0; slen -= 1, sindex += 1) ;
        if (slen > 32) return;
        var svalue = sig.slice(sindex, sindex + slen);
        svalue.copy(s, 32 - svalue.length);
        return { r, s };
      };
    }
  });

  // node_modules/secp256k1/lib/messages.json
  var require_messages = __commonJS({
    "node_modules/secp256k1/lib/messages.json"(exports9, module) {
      module.exports = {
        COMPRESSED_TYPE_INVALID: "compressed should be a boolean",
        EC_PRIVATE_KEY_TYPE_INVALID: "private key should be a Buffer",
        EC_PRIVATE_KEY_LENGTH_INVALID: "private key length is invalid",
        EC_PRIVATE_KEY_RANGE_INVALID: "private key range is invalid",
        EC_PRIVATE_KEY_TWEAK_ADD_FAIL: "tweak out of range or resulting private key is invalid",
        EC_PRIVATE_KEY_TWEAK_MUL_FAIL: "tweak out of range",
        EC_PRIVATE_KEY_EXPORT_DER_FAIL: "couldn't export to DER format",
        EC_PRIVATE_KEY_IMPORT_DER_FAIL: "couldn't import from DER format",
        EC_PUBLIC_KEYS_TYPE_INVALID: "public keys should be an Array",
        EC_PUBLIC_KEYS_LENGTH_INVALID: "public keys Array should have at least 1 element",
        EC_PUBLIC_KEY_TYPE_INVALID: "public key should be a Buffer",
        EC_PUBLIC_KEY_LENGTH_INVALID: "public key length is invalid",
        EC_PUBLIC_KEY_PARSE_FAIL: "the public key could not be parsed or is invalid",
        EC_PUBLIC_KEY_CREATE_FAIL: "private was invalid, try again",
        EC_PUBLIC_KEY_TWEAK_ADD_FAIL: "tweak out of range or resulting public key is invalid",
        EC_PUBLIC_KEY_TWEAK_MUL_FAIL: "tweak out of range",
        EC_PUBLIC_KEY_COMBINE_FAIL: "the sum of the public keys is not valid",
        ECDH_FAIL: "scalar was invalid (zero or overflow)",
        ECDSA_SIGNATURE_TYPE_INVALID: "signature should be a Buffer",
        ECDSA_SIGNATURE_LENGTH_INVALID: "signature length is invalid",
        ECDSA_SIGNATURE_PARSE_FAIL: "couldn't parse signature",
        ECDSA_SIGNATURE_PARSE_DER_FAIL: "couldn't parse DER signature",
        ECDSA_SIGNATURE_SERIALIZE_DER_FAIL: "couldn't serialize signature to DER format",
        ECDSA_SIGN_FAIL: "nonce generation function failed or private key is invalid",
        ECDSA_RECOVER_FAIL: "couldn't recover public key from signature",
        MSG32_TYPE_INVALID: "message should be a Buffer",
        MSG32_LENGTH_INVALID: "message length is invalid",
        OPTIONS_TYPE_INVALID: "options should be an Object",
        OPTIONS_DATA_TYPE_INVALID: "options.data should be a Buffer",
        OPTIONS_DATA_LENGTH_INVALID: "options.data length is invalid",
        OPTIONS_NONCEFN_TYPE_INVALID: "options.noncefn should be a Function",
        RECOVERY_ID_TYPE_INVALID: "recovery should be a Number",
        RECOVERY_ID_VALUE_INVALID: "recovery should have value between -1 and 4",
        TWEAK_TYPE_INVALID: "tweak should be a Buffer",
        TWEAK_LENGTH_INVALID: "tweak length is invalid"
      };
    }
  });

  // node_modules/secp256k1/lib/index.js
  var require_lib = __commonJS({
    "node_modules/secp256k1/lib/index.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var assert2 = require_assert2();
      var der = require_der();
      var messages = require_messages();
      function initCompressedValue(value, defaultValue) {
        if (value === void 0) return defaultValue;
        assert2.isBoolean(value, messages.COMPRESSED_TYPE_INVALID);
        return value;
      }
      module.exports = function(secp256k1) {
        return {
          privateKeyVerify: function(privateKey) {
            assert2.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
            return privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey);
          },
          privateKeyExport: function(privateKey, compressed) {
            assert2.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
            assert2.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
            compressed = initCompressedValue(compressed, true);
            var publicKey = secp256k1.privateKeyExport(privateKey, compressed);
            return der.privateKeyExport(privateKey, publicKey, compressed);
          },
          privateKeyImport: function(privateKey) {
            assert2.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
            privateKey = der.privateKeyImport(privateKey);
            if (privateKey && privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey)) return privateKey;
            throw new Error(messages.EC_PRIVATE_KEY_IMPORT_DER_FAIL);
          },
          privateKeyNegate: function(privateKey) {
            assert2.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
            assert2.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
            return secp256k1.privateKeyNegate(privateKey);
          },
          privateKeyModInverse: function(privateKey) {
            assert2.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
            assert2.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
            return secp256k1.privateKeyModInverse(privateKey);
          },
          privateKeyTweakAdd: function(privateKey, tweak) {
            assert2.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
            assert2.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
            assert2.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
            assert2.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
            return secp256k1.privateKeyTweakAdd(privateKey, tweak);
          },
          privateKeyTweakMul: function(privateKey, tweak) {
            assert2.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
            assert2.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
            assert2.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
            assert2.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
            return secp256k1.privateKeyTweakMul(privateKey, tweak);
          },
          publicKeyCreate: function(privateKey, compressed) {
            assert2.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
            assert2.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
            compressed = initCompressedValue(compressed, true);
            return secp256k1.publicKeyCreate(privateKey, compressed);
          },
          publicKeyConvert: function(publicKey, compressed) {
            assert2.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
            assert2.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
            compressed = initCompressedValue(compressed, true);
            return secp256k1.publicKeyConvert(publicKey, compressed);
          },
          publicKeyVerify: function(publicKey) {
            assert2.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
            return secp256k1.publicKeyVerify(publicKey);
          },
          publicKeyTweakAdd: function(publicKey, tweak, compressed) {
            assert2.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
            assert2.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
            assert2.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
            assert2.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
            compressed = initCompressedValue(compressed, true);
            return secp256k1.publicKeyTweakAdd(publicKey, tweak, compressed);
          },
          publicKeyTweakMul: function(publicKey, tweak, compressed) {
            assert2.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
            assert2.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
            assert2.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
            assert2.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
            compressed = initCompressedValue(compressed, true);
            return secp256k1.publicKeyTweakMul(publicKey, tweak, compressed);
          },
          publicKeyCombine: function(publicKeys, compressed) {
            assert2.isArray(publicKeys, messages.EC_PUBLIC_KEYS_TYPE_INVALID);
            assert2.isLengthGTZero(publicKeys, messages.EC_PUBLIC_KEYS_LENGTH_INVALID);
            for (var i = 0; i < publicKeys.length; ++i) {
              assert2.isBuffer(publicKeys[i], messages.EC_PUBLIC_KEY_TYPE_INVALID);
              assert2.isBufferLength2(publicKeys[i], 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
            }
            compressed = initCompressedValue(compressed, true);
            return secp256k1.publicKeyCombine(publicKeys, compressed);
          },
          signatureNormalize: function(signature) {
            assert2.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID);
            assert2.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
            return secp256k1.signatureNormalize(signature);
          },
          signatureExport: function(signature) {
            assert2.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID);
            assert2.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
            var sigObj = secp256k1.signatureExport(signature);
            return der.signatureExport(sigObj);
          },
          signatureImport: function(sig) {
            assert2.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID);
            assert2.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
            var sigObj = der.signatureImport(sig);
            if (sigObj) return secp256k1.signatureImport(sigObj);
            throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL);
          },
          signatureImportLax: function(sig) {
            assert2.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID);
            assert2.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
            var sigObj = der.signatureImportLax(sig);
            if (sigObj) return secp256k1.signatureImport(sigObj);
            throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL);
          },
          sign: function(message, privateKey, options) {
            assert2.isBuffer(message, messages.MSG32_TYPE_INVALID);
            assert2.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID);
            assert2.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
            assert2.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
            var data = null;
            var noncefn = null;
            if (options !== void 0) {
              assert2.isObject(options, messages.OPTIONS_TYPE_INVALID);
              if (options.data !== void 0) {
                assert2.isBuffer(options.data, messages.OPTIONS_DATA_TYPE_INVALID);
                assert2.isBufferLength(options.data, 32, messages.OPTIONS_DATA_LENGTH_INVALID);
                data = options.data;
              }
              if (options.noncefn !== void 0) {
                assert2.isFunction(options.noncefn, messages.OPTIONS_NONCEFN_TYPE_INVALID);
                noncefn = options.noncefn;
              }
            }
            return secp256k1.sign(message, privateKey, noncefn, data);
          },
          verify: function(message, signature, publicKey) {
            assert2.isBuffer(message, messages.MSG32_TYPE_INVALID);
            assert2.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID);
            assert2.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID);
            assert2.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
            assert2.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
            assert2.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
            return secp256k1.verify(message, signature, publicKey);
          },
          recover: function(message, signature, recovery, compressed) {
            assert2.isBuffer(message, messages.MSG32_TYPE_INVALID);
            assert2.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID);
            assert2.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID);
            assert2.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
            assert2.isNumber(recovery, messages.RECOVERY_ID_TYPE_INVALID);
            assert2.isNumberInInterval(recovery, -1, 4, messages.RECOVERY_ID_VALUE_INVALID);
            compressed = initCompressedValue(compressed, true);
            return secp256k1.recover(message, signature, recovery, compressed);
          },
          ecdh: function(publicKey, privateKey) {
            assert2.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
            assert2.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
            assert2.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
            assert2.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
            return secp256k1.ecdh(publicKey, privateKey);
          },
          ecdhUnsafe: function(publicKey, privateKey, compressed) {
            assert2.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
            assert2.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
            assert2.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
            assert2.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
            compressed = initCompressedValue(compressed, true);
            return secp256k1.ecdhUnsafe(publicKey, privateKey, compressed);
          }
        };
      };
    }
  });

  // node_modules/secp256k1/node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "node_modules/secp256k1/node_modules/bn.js/lib/bn.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      (function(module2, exports10) {
        "use strict";
        function assert2(val, msg) {
          if (!val) throw new Error(msg || "Assertion failed");
        }
        function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number, base, endian) {
          if (BN.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN;
        } else {
          exports10.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer3;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer3 = window.Buffer;
          } else {
            Buffer3 = (init_buffer(), __toCommonJS(buffer_exports)).Buffer;
          }
        } catch (e) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max(left, right) {
          if (left.cmp(right) > 0) return left;
          return right;
        };
        BN.min = function min(left, right) {
          if (left.cmp(right) < 0) return left;
          return right;
        };
        BN.prototype._init = function init2(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert2(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert2(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le") return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initArray = function _initArray(number, base, endian) {
          assert2(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off2 = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off2 & 67108863;
              this.words[j + 1] = w >>> 26 - off2 & 67108863;
              off2 += 24;
              if (off2 >= 26) {
                off2 -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off2 & 67108863;
              this.words[j + 1] = w >>> 26 - off2 & 67108863;
              off2 += 24;
              if (off2 >= 26) {
                off2 -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex4Bits(string, index) {
          var c = string.charCodeAt(index);
          if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            return c - 48 & 15;
          }
        }
        function parseHexByte(string, lowerBound, index) {
          var r = parseHex4Bits(string, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string, index - 1) << 4;
          }
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off2 = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number, start, i) << off2;
              this.words[j] |= w & 67108863;
              if (off2 >= 18) {
                off2 -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off2 += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
              w = parseHexByte(number, start, i) << off2;
              this.words[j] |= w & 67108863;
              if (off2 >= 18) {
                off2 -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off2 += 8;
              }
            }
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              r += c - 49 + 10;
            } else if (c >= 17) {
              r += c - 17 + 10;
            } else {
              r += c;
            }
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this.strip();
        };
        BN.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN.prototype.clone = function clone() {
          var r = new BN(null);
          this.copy(r);
          return r;
        };
        BN.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN.prototype.inspect = function inspect2() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN.prototype.toString = function toString(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off2 = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off2 | carry) & 16777215).toString(16);
              carry = w >>> 24 - off2 & 16777215;
              off2 += 2;
              if (off2 >= 26) {
                off2 -= 26;
                i--;
              }
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert2(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert2(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          assert2(typeof Buffer3 !== "undefined");
          return this.toArrayLike(Buffer3, endian, length);
        };
        BN.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert2(byteLength <= reqLength, "byte array longer than desired length");
          assert2(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i;
          var q = this.clone();
          if (!littleEndian) {
            for (i = 0; i < reqLength - byteLength; i++) {
              res[i] = 0;
            }
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i - 1] = b;
            }
          } else {
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i] = b;
            }
            for (; i < reqLength; i++) {
              res[i] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0) return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off2 = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off2] & 1 << wbit) >>> wbit;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero()) return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
          }
          return r;
        };
        BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this.strip();
        };
        BN.prototype.ior = function ior(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or(num) {
          if (this.length > num.length) return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length) return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this.strip();
        };
        BN.prototype.iand = function iand(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and(num) {
          if (this.length > num.length) return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length) return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor(num) {
          if (this.length > num.length) return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length) return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width) {
          assert2(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert2(typeof bit === "number" && bit >= 0);
          var off2 = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off2 + 1);
          if (val) {
            this.words[off2] = this.words[off2] | 1 << wbit;
          } else {
            this.words[off2] = this.words[off2] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length) return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1) return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1) return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert2(carry === 0);
          assert2((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out.strip();
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0) return new BN(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0) break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0) continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert2(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert2(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert2(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert2(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert2(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert2(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert2(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          if (num < 0) return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          if (num < 0) return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0) return this.strip();
          assert2(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert2(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN(0),
              mod: new BN(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero()) return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modn = function modn(num) {
          assert2(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return acc;
        };
        BN.prototype.idivn = function idivn(num) {
          assert2(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          return this.strip();
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p) {
          assert2(p.negative === 0);
          assert2(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN(1);
          var B = new BN(0);
          var C = new BN(0);
          var D = new BN(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN.prototype._invmp = function _invmp(p) {
          assert2(p.negative === 0);
          assert2(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN(1);
          var x2 = new BN(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN.prototype.gcd = function gcd(num) {
          if (this.isZero()) return num.abs();
          if (num.isZero()) return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert2(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero2() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative) return -1;
          if (this.negative === 0 && negative) return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert2(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0) return -1;
          if (this.negative === 0 && num.negative !== 0) return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length) return 1;
          if (this.length < num.length) return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert2(!this.red, "Already a number in reduction context");
          assert2(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert2(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert2(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert2(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert2(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert2(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert2(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert2(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert2(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert2(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert2(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert2(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert2(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert2(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert2(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert2(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name2, p) {
          this.name = name2;
          this.p = new BN(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits2(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits2(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits2(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits2(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN._prime = function prime(name2) {
          if (primes[name2]) return primes[name2];
          var prime2;
          if (name2 === "k256") {
            prime2 = new K256();
          } else if (name2 === "p224") {
            prime2 = new P224();
          } else if (name2 === "p192") {
            prime2 = new P192();
          } else if (name2 === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name2);
          }
          primes[name2] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert2(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert2(a.negative === 0, "red works only with positives");
          assert2(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert2((a.negative | b.negative) === 0, "red works only with positives");
          assert2(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime) return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero()) return a.clone();
          var mod3 = this.m.andln(3);
          assert2(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert2(!q.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert2(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero()) return new BN(1).toRed(this);
          if (num.cmpn(1) === 0) return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits2(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports9);
    }
  });

  // node_modules/elliptic/package.json
  var require_package = __commonJS({
    "node_modules/elliptic/package.json"(exports9, module) {
      module.exports = {
        name: "elliptic",
        version: "6.5.7",
        description: "EC cryptography",
        main: "lib/elliptic.js",
        files: [
          "lib"
        ],
        scripts: {
          lint: "eslint lib test",
          "lint:fix": "npm run lint -- --fix",
          unit: "istanbul test _mocha --reporter=spec test/index.js",
          test: "npm run lint && npm run unit",
          version: "grunt dist && git add dist/"
        },
        repository: {
          type: "git",
          url: "git@github.com:indutny/elliptic"
        },
        keywords: [
          "EC",
          "Elliptic",
          "curve",
          "Cryptography"
        ],
        author: "Fedor Indutny <fedor@indutny.com>",
        license: "MIT",
        bugs: {
          url: "https://github.com/indutny/elliptic/issues"
        },
        homepage: "https://github.com/indutny/elliptic",
        devDependencies: {
          brfs: "^2.0.2",
          coveralls: "^3.1.0",
          eslint: "^7.6.0",
          grunt: "^1.2.1",
          "grunt-browserify": "^5.3.0",
          "grunt-cli": "^1.3.2",
          "grunt-contrib-connect": "^3.0.0",
          "grunt-contrib-copy": "^1.0.0",
          "grunt-contrib-uglify": "^5.0.0",
          "grunt-mocha-istanbul": "^5.0.2",
          "grunt-saucelabs": "^9.0.1",
          istanbul: "^0.4.5",
          mocha: "^8.0.1"
        },
        dependencies: {
          "bn.js": "^4.11.9",
          brorand: "^1.1.0",
          "hash.js": "^1.0.0",
          "hmac-drbg": "^1.0.1",
          inherits: "^2.0.4",
          "minimalistic-assert": "^1.0.1",
          "minimalistic-crypto-utils": "^1.0.1"
        }
      };
    }
  });

  // node_modules/elliptic/node_modules/bn.js/lib/bn.js
  var require_bn2 = __commonJS({
    "node_modules/elliptic/node_modules/bn.js/lib/bn.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      (function(module2, exports10) {
        "use strict";
        function assert2(val, msg) {
          if (!val) throw new Error(msg || "Assertion failed");
        }
        function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number, base, endian) {
          if (BN.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN;
        } else {
          exports10.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer3;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer3 = window.Buffer;
          } else {
            Buffer3 = (init_buffer(), __toCommonJS(buffer_exports)).Buffer;
          }
        } catch (e) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max(left, right) {
          if (left.cmp(right) > 0) return left;
          return right;
        };
        BN.min = function min(left, right) {
          if (left.cmp(right) < 0) return left;
          return right;
        };
        BN.prototype._init = function init2(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert2(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert2(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le") return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initArray = function _initArray(number, base, endian) {
          assert2(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off2 = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off2 & 67108863;
              this.words[j + 1] = w >>> 26 - off2 & 67108863;
              off2 += 24;
              if (off2 >= 26) {
                off2 -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off2 & 67108863;
              this.words[j + 1] = w >>> 26 - off2 & 67108863;
              off2 += 24;
              if (off2 >= 26) {
                off2 -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex4Bits(string, index) {
          var c = string.charCodeAt(index);
          if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            return c - 48 & 15;
          }
        }
        function parseHexByte(string, lowerBound, index) {
          var r = parseHex4Bits(string, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string, index - 1) << 4;
          }
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off2 = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number, start, i) << off2;
              this.words[j] |= w & 67108863;
              if (off2 >= 18) {
                off2 -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off2 += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
              w = parseHexByte(number, start, i) << off2;
              this.words[j] |= w & 67108863;
              if (off2 >= 18) {
                off2 -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off2 += 8;
              }
            }
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              r += c - 49 + 10;
            } else if (c >= 17) {
              r += c - 17 + 10;
            } else {
              r += c;
            }
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this.strip();
        };
        BN.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN.prototype.clone = function clone() {
          var r = new BN(null);
          this.copy(r);
          return r;
        };
        BN.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN.prototype.inspect = function inspect2() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN.prototype.toString = function toString(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off2 = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off2 | carry) & 16777215).toString(16);
              carry = w >>> 24 - off2 & 16777215;
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off2 += 2;
              if (off2 >= 26) {
                off2 -= 26;
                i--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert2(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert2(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          assert2(typeof Buffer3 !== "undefined");
          return this.toArrayLike(Buffer3, endian, length);
        };
        BN.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert2(byteLength <= reqLength, "byte array longer than desired length");
          assert2(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i;
          var q = this.clone();
          if (!littleEndian) {
            for (i = 0; i < reqLength - byteLength; i++) {
              res[i] = 0;
            }
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i - 1] = b;
            }
          } else {
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i] = b;
            }
            for (; i < reqLength; i++) {
              res[i] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0) return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off2 = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off2] & 1 << wbit) >>> wbit;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero()) return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
          }
          return r;
        };
        BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this.strip();
        };
        BN.prototype.ior = function ior(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or(num) {
          if (this.length > num.length) return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length) return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this.strip();
        };
        BN.prototype.iand = function iand(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and(num) {
          if (this.length > num.length) return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length) return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor(num) {
          if (this.length > num.length) return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length) return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width) {
          assert2(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert2(typeof bit === "number" && bit >= 0);
          var off2 = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off2 + 1);
          if (val) {
            this.words[off2] = this.words[off2] | 1 << wbit;
          } else {
            this.words[off2] = this.words[off2] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length) return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1) return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1) return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert2(carry === 0);
          assert2((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out.strip();
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0) return new BN(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0) break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0) continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert2(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert2(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert2(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert2(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert2(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert2(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert2(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          if (num < 0) return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          if (num < 0) return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0) return this.strip();
          assert2(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert2(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN(0),
              mod: new BN(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero()) return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modn = function modn(num) {
          assert2(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return acc;
        };
        BN.prototype.idivn = function idivn(num) {
          assert2(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          return this.strip();
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p) {
          assert2(p.negative === 0);
          assert2(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN(1);
          var B = new BN(0);
          var C = new BN(0);
          var D = new BN(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN.prototype._invmp = function _invmp(p) {
          assert2(p.negative === 0);
          assert2(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN(1);
          var x2 = new BN(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN.prototype.gcd = function gcd(num) {
          if (this.isZero()) return num.abs();
          if (num.isZero()) return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert2(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero2() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative) return -1;
          if (this.negative === 0 && negative) return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert2(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0) return -1;
          if (this.negative === 0 && num.negative !== 0) return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length) return 1;
          if (this.length < num.length) return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert2(!this.red, "Already a number in reduction context");
          assert2(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert2(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert2(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert2(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert2(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert2(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert2(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert2(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert2(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert2(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert2(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert2(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert2(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert2(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert2(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert2(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name2, p) {
          this.name = name2;
          this.p = new BN(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits2(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits2(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits2(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits2(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN._prime = function prime(name2) {
          if (primes[name2]) return primes[name2];
          var prime2;
          if (name2 === "k256") {
            prime2 = new K256();
          } else if (name2 === "p224") {
            prime2 = new P224();
          } else if (name2 === "p192") {
            prime2 = new P192();
          } else if (name2 === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name2);
          }
          primes[name2] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert2(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert2(a.negative === 0, "red works only with positives");
          assert2(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert2((a.negative | b.negative) === 0, "red works only with positives");
          assert2(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime) return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero()) return a.clone();
          var mod3 = this.m.andln(3);
          assert2(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert2(!q.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert2(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero()) return new BN(1).toRed(this);
          if (num.cmpn(1) === 0) return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits2(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports9);
    }
  });

  // node_modules/minimalistic-assert/index.js
  var require_minimalistic_assert = __commonJS({
    "node_modules/minimalistic-assert/index.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      module.exports = assert2;
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      assert2.equal = function assertEqual(l, r, msg) {
        if (l != r)
          throw new Error(msg || "Assertion failed: " + l + " != " + r);
      };
    }
  });

  // node_modules/minimalistic-crypto-utils/lib/utils.js
  var require_utils3 = __commonJS({
    "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var utils = exports9;
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg !== "string") {
          for (var i = 0; i < msg.length; i++)
            res[i] = msg[i] | 0;
          return res;
        }
        if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (var i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        } else {
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            var hi = c >> 8;
            var lo = c & 255;
            if (hi)
              res.push(hi, lo);
            else
              res.push(lo);
          }
        }
        return res;
      }
      utils.toArray = toArray;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      utils.zero2 = zero2;
      function toHex2(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++)
          res += zero2(msg[i].toString(16));
        return res;
      }
      utils.toHex = toHex2;
      utils.encode = function encode(arr, enc) {
        if (enc === "hex")
          return toHex2(arr);
        else
          return arr;
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/utils.js
  var require_utils4 = __commonJS({
    "node_modules/elliptic/lib/elliptic/utils.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var utils = exports9;
      var BN = require_bn2();
      var minAssert = require_minimalistic_assert();
      var minUtils = require_utils3();
      utils.assert = minAssert;
      utils.toArray = minUtils.toArray;
      utils.zero2 = minUtils.zero2;
      utils.toHex = minUtils.toHex;
      utils.encode = minUtils.encode;
      function getNAF(num, w, bits) {
        var naf = new Array(Math.max(num.bitLength(), bits) + 1);
        var i;
        for (i = 0; i < naf.length; i += 1) {
          naf[i] = 0;
        }
        var ws = 1 << w + 1;
        var k = num.clone();
        for (i = 0; i < naf.length; i++) {
          var z;
          var mod = k.andln(ws - 1);
          if (k.isOdd()) {
            if (mod > (ws >> 1) - 1)
              z = (ws >> 1) - mod;
            else
              z = mod;
            k.isubn(z);
          } else {
            z = 0;
          }
          naf[i] = z;
          k.iushrn(1);
        }
        return naf;
      }
      utils.getNAF = getNAF;
      function getJSF(k1, k2) {
        var jsf = [
          [],
          []
        ];
        k1 = k1.clone();
        k2 = k2.clone();
        var d1 = 0;
        var d2 = 0;
        var m8;
        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
          var m14 = k1.andln(3) + d1 & 3;
          var m24 = k2.andln(3) + d2 & 3;
          if (m14 === 3)
            m14 = -1;
          if (m24 === 3)
            m24 = -1;
          var u1;
          if ((m14 & 1) === 0) {
            u1 = 0;
          } else {
            m8 = k1.andln(7) + d1 & 7;
            if ((m8 === 3 || m8 === 5) && m24 === 2)
              u1 = -m14;
            else
              u1 = m14;
          }
          jsf[0].push(u1);
          var u2;
          if ((m24 & 1) === 0) {
            u2 = 0;
          } else {
            m8 = k2.andln(7) + d2 & 7;
            if ((m8 === 3 || m8 === 5) && m14 === 2)
              u2 = -m24;
            else
              u2 = m24;
          }
          jsf[1].push(u2);
          if (2 * d1 === u1 + 1)
            d1 = 1 - d1;
          if (2 * d2 === u2 + 1)
            d2 = 1 - d2;
          k1.iushrn(1);
          k2.iushrn(1);
        }
        return jsf;
      }
      utils.getJSF = getJSF;
      function cachedProperty(obj, name2, computer) {
        var key = "_" + name2;
        obj.prototype[name2] = function cachedProperty2() {
          return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
        };
      }
      utils.cachedProperty = cachedProperty;
      function parseBytes(bytes) {
        return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
      }
      utils.parseBytes = parseBytes;
      function intFromLE(bytes) {
        return new BN(bytes, "hex", "le");
      }
      utils.intFromLE = intFromLE;
    }
  });

  // node_modules/esbuild-plugin-polyfill-node/polyfills/empty.js
  var empty_exports = {};
  __export(empty_exports, {
    default: () => empty_default
  });
  var empty_default;
  var init_empty = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/empty.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      empty_default = {};
    }
  });

  // node_modules/brorand/index.js
  var require_brorand = __commonJS({
    "node_modules/brorand/index.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var r;
      module.exports = function rand(len) {
        if (!r)
          r = new Rand(null);
        return r.generate(len);
      };
      function Rand(rand) {
        this.rand = rand;
      }
      module.exports.Rand = Rand;
      Rand.prototype.generate = function generate(len) {
        return this._rand(len);
      };
      Rand.prototype._rand = function _rand(n) {
        if (this.rand.getBytes)
          return this.rand.getBytes(n);
        var res = new Uint8Array(n);
        for (var i = 0; i < res.length; i++)
          res[i] = this.rand.getByte();
        return res;
      };
      if (typeof self === "object") {
        if (self.crypto && self.crypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.crypto.getRandomValues(arr);
            return arr;
          };
        } else if (self.msCrypto && self.msCrypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.msCrypto.getRandomValues(arr);
            return arr;
          };
        } else if (typeof window === "object") {
          Rand.prototype._rand = function() {
            throw new Error("Not implemented yet");
          };
        }
      } else {
        try {
          crypto2 = (init_empty(), __toCommonJS(empty_exports));
          if (typeof crypto2.randomBytes !== "function")
            throw new Error("Not supported");
          Rand.prototype._rand = function _rand(n) {
            return crypto2.randomBytes(n);
          };
        } catch (e) {
        }
      }
      var crypto2;
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/base.js
  var require_base3 = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/base.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var BN = require_bn2();
      var utils = require_utils4();
      var getNAF = utils.getNAF;
      var getJSF = utils.getJSF;
      var assert2 = utils.assert;
      function BaseCurve(type, conf) {
        this.type = type;
        this.p = new BN(conf.p, 16);
        this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
        this.zero = new BN(0).toRed(this.red);
        this.one = new BN(1).toRed(this.red);
        this.two = new BN(2).toRed(this.red);
        this.n = conf.n && new BN(conf.n, 16);
        this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
        this._wnafT1 = new Array(4);
        this._wnafT2 = new Array(4);
        this._wnafT3 = new Array(4);
        this._wnafT4 = new Array(4);
        this._bitLength = this.n ? this.n.bitLength() : 0;
        var adjustCount = this.n && this.p.div(this.n);
        if (!adjustCount || adjustCount.cmpn(100) > 0) {
          this.redN = null;
        } else {
          this._maxwellTrick = true;
          this.redN = this.n.toRed(this.red);
        }
      }
      module.exports = BaseCurve;
      BaseCurve.prototype.point = function point() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype.validate = function validate() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
        assert2(p.precomputed);
        var doubles = p._getDoubles();
        var naf = getNAF(k, 1, this._bitLength);
        var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
        I /= 3;
        var repr = [];
        var j;
        var nafW;
        for (j = 0; j < naf.length; j += doubles.step) {
          nafW = 0;
          for (var l = j + doubles.step - 1; l >= j; l--)
            nafW = (nafW << 1) + naf[l];
          repr.push(nafW);
        }
        var a = this.jpoint(null, null, null);
        var b = this.jpoint(null, null, null);
        for (var i = I; i > 0; i--) {
          for (j = 0; j < repr.length; j++) {
            nafW = repr[j];
            if (nafW === i)
              b = b.mixedAdd(doubles.points[j]);
            else if (nafW === -i)
              b = b.mixedAdd(doubles.points[j].neg());
          }
          a = a.add(b);
        }
        return a.toP();
      };
      BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
        var w = 4;
        var nafPoints = p._getNAFPoints(w);
        w = nafPoints.wnd;
        var wnd = nafPoints.points;
        var naf = getNAF(k, w, this._bitLength);
        var acc = this.jpoint(null, null, null);
        for (var i = naf.length - 1; i >= 0; i--) {
          for (var l = 0; i >= 0 && naf[i] === 0; i--)
            l++;
          if (i >= 0)
            l++;
          acc = acc.dblp(l);
          if (i < 0)
            break;
          var z = naf[i];
          assert2(z !== 0);
          if (p.type === "affine") {
            if (z > 0)
              acc = acc.mixedAdd(wnd[z - 1 >> 1]);
            else
              acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
          } else {
            if (z > 0)
              acc = acc.add(wnd[z - 1 >> 1]);
            else
              acc = acc.add(wnd[-z - 1 >> 1].neg());
          }
        }
        return p.type === "affine" ? acc.toP() : acc;
      };
      BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
        var wndWidth = this._wnafT1;
        var wnd = this._wnafT2;
        var naf = this._wnafT3;
        var max = 0;
        var i;
        var j;
        var p;
        for (i = 0; i < len; i++) {
          p = points[i];
          var nafPoints = p._getNAFPoints(defW);
          wndWidth[i] = nafPoints.wnd;
          wnd[i] = nafPoints.points;
        }
        for (i = len - 1; i >= 1; i -= 2) {
          var a = i - 1;
          var b = i;
          if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
            naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
            max = Math.max(naf[a].length, max);
            max = Math.max(naf[b].length, max);
            continue;
          }
          var comb = [
            points[a],
            /* 1 */
            null,
            /* 3 */
            null,
            /* 5 */
            points[b]
            /* 7 */
          ];
          if (points[a].y.cmp(points[b].y) === 0) {
            comb[1] = points[a].add(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].add(points[b].neg());
          } else {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          }
          var index = [
            -3,
            /* -1 -1 */
            -1,
            /* -1 0 */
            -5,
            /* -1 1 */
            -7,
            /* 0 -1 */
            0,
            /* 0 0 */
            7,
            /* 0 1 */
            5,
            /* 1 -1 */
            1,
            /* 1 0 */
            3
            /* 1 1 */
          ];
          var jsf = getJSF(coeffs[a], coeffs[b]);
          max = Math.max(jsf[0].length, max);
          naf[a] = new Array(max);
          naf[b] = new Array(max);
          for (j = 0; j < max; j++) {
            var ja = jsf[0][j] | 0;
            var jb = jsf[1][j] | 0;
            naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
            naf[b][j] = 0;
            wnd[a] = comb;
          }
        }
        var acc = this.jpoint(null, null, null);
        var tmp = this._wnafT4;
        for (i = max; i >= 0; i--) {
          var k = 0;
          while (i >= 0) {
            var zero = true;
            for (j = 0; j < len; j++) {
              tmp[j] = naf[j][i] | 0;
              if (tmp[j] !== 0)
                zero = false;
            }
            if (!zero)
              break;
            k++;
            i--;
          }
          if (i >= 0)
            k++;
          acc = acc.dblp(k);
          if (i < 0)
            break;
          for (j = 0; j < len; j++) {
            var z = tmp[j];
            p;
            if (z === 0)
              continue;
            else if (z > 0)
              p = wnd[j][z - 1 >> 1];
            else if (z < 0)
              p = wnd[j][-z - 1 >> 1].neg();
            if (p.type === "affine")
              acc = acc.mixedAdd(p);
            else
              acc = acc.add(p);
          }
        }
        for (i = 0; i < len; i++)
          wnd[i] = null;
        if (jacobianResult)
          return acc;
        else
          return acc.toP();
      };
      function BasePoint(curve, type) {
        this.curve = curve;
        this.type = type;
        this.precomputed = null;
      }
      BaseCurve.BasePoint = BasePoint;
      BasePoint.prototype.eq = function eq() {
        throw new Error("Not implemented");
      };
      BasePoint.prototype.validate = function validate() {
        return this.curve.validate(this);
      };
      BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        bytes = utils.toArray(bytes, enc);
        var len = this.p.byteLength();
        if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
          if (bytes[0] === 6)
            assert2(bytes[bytes.length - 1] % 2 === 0);
          else if (bytes[0] === 7)
            assert2(bytes[bytes.length - 1] % 2 === 1);
          var res = this.point(
            bytes.slice(1, 1 + len),
            bytes.slice(1 + len, 1 + 2 * len)
          );
          return res;
        } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
          return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
        }
        throw new Error("Unknown point format");
      };
      BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
        return this.encode(enc, true);
      };
      BasePoint.prototype._encode = function _encode(compact) {
        var len = this.curve.p.byteLength();
        var x = this.getX().toArray("be", len);
        if (compact)
          return [this.getY().isEven() ? 2 : 3].concat(x);
        return [4].concat(x, this.getY().toArray("be", len));
      };
      BasePoint.prototype.encode = function encode(enc, compact) {
        return utils.encode(this._encode(compact), enc);
      };
      BasePoint.prototype.precompute = function precompute(power) {
        if (this.precomputed)
          return this;
        var precomputed = {
          doubles: null,
          naf: null,
          beta: null
        };
        precomputed.naf = this._getNAFPoints(8);
        precomputed.doubles = this._getDoubles(4, power);
        precomputed.beta = this._getBeta();
        this.precomputed = precomputed;
        return this;
      };
      BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
        if (!this.precomputed)
          return false;
        var doubles = this.precomputed.doubles;
        if (!doubles)
          return false;
        return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
      };
      BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
        if (this.precomputed && this.precomputed.doubles)
          return this.precomputed.doubles;
        var doubles = [this];
        var acc = this;
        for (var i = 0; i < power; i += step) {
          for (var j = 0; j < step; j++)
            acc = acc.dbl();
          doubles.push(acc);
        }
        return {
          step,
          points: doubles
        };
      };
      BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
        if (this.precomputed && this.precomputed.naf)
          return this.precomputed.naf;
        var res = [this];
        var max = (1 << wnd) - 1;
        var dbl = max === 1 ? null : this.dbl();
        for (var i = 1; i < max; i++)
          res[i] = res[i - 1].add(dbl);
        return {
          wnd,
          points: res
        };
      };
      BasePoint.prototype._getBeta = function _getBeta() {
        return null;
      };
      BasePoint.prototype.dblp = function dblp(k) {
        var r = this;
        for (var i = 0; i < k; i++)
          r = r.dbl();
        return r;
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/short.js
  var require_short = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/short.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var utils = require_utils4();
      var BN = require_bn2();
      var inherits2 = require_inherits_browser();
      var Base = require_base3();
      var assert2 = utils.assert;
      function ShortCurve(conf) {
        Base.call(this, "short", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.tinv = this.two.redInvm();
        this.zeroA = this.a.fromRed().cmpn(0) === 0;
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
        this.endo = this._getEndomorphism(conf);
        this._endoWnafT1 = new Array(4);
        this._endoWnafT2 = new Array(4);
      }
      inherits2(ShortCurve, Base);
      module.exports = ShortCurve;
      ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
        if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
          return;
        var beta;
        var lambda;
        if (conf.beta) {
          beta = new BN(conf.beta, 16).toRed(this.red);
        } else {
          var betas = this._getEndoRoots(this.p);
          beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
          beta = beta.toRed(this.red);
        }
        if (conf.lambda) {
          lambda = new BN(conf.lambda, 16);
        } else {
          var lambdas = this._getEndoRoots(this.n);
          if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
            lambda = lambdas[0];
          } else {
            lambda = lambdas[1];
            assert2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
          }
        }
        var basis;
        if (conf.basis) {
          basis = conf.basis.map(function(vec) {
            return {
              a: new BN(vec.a, 16),
              b: new BN(vec.b, 16)
            };
          });
        } else {
          basis = this._getEndoBasis(lambda);
        }
        return {
          beta,
          lambda,
          basis
        };
      };
      ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
        var red = num === this.p ? this.red : BN.mont(num);
        var tinv = new BN(2).toRed(red).redInvm();
        var ntinv = tinv.redNeg();
        var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
        var l1 = ntinv.redAdd(s).fromRed();
        var l2 = ntinv.redSub(s).fromRed();
        return [l1, l2];
      };
      ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
        var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
        var u = lambda;
        var v = this.n.clone();
        var x1 = new BN(1);
        var y1 = new BN(0);
        var x2 = new BN(0);
        var y2 = new BN(1);
        var a0;
        var b0;
        var a1;
        var b1;
        var a2;
        var b2;
        var prevR;
        var i = 0;
        var r;
        var x;
        while (u.cmpn(0) !== 0) {
          var q = v.div(u);
          r = v.sub(q.mul(u));
          x = x2.sub(q.mul(x1));
          var y = y2.sub(q.mul(y1));
          if (!a1 && r.cmp(aprxSqrt) < 0) {
            a0 = prevR.neg();
            b0 = x1;
            a1 = r.neg();
            b1 = x;
          } else if (a1 && ++i === 2) {
            break;
          }
          prevR = r;
          v = u;
          u = r;
          x2 = x1;
          x1 = x;
          y2 = y1;
          y1 = y;
        }
        a2 = r.neg();
        b2 = x;
        var len1 = a1.sqr().add(b1.sqr());
        var len2 = a2.sqr().add(b2.sqr());
        if (len2.cmp(len1) >= 0) {
          a2 = a0;
          b2 = b0;
        }
        if (a1.negative) {
          a1 = a1.neg();
          b1 = b1.neg();
        }
        if (a2.negative) {
          a2 = a2.neg();
          b2 = b2.neg();
        }
        return [
          { a: a1, b: b1 },
          { a: a2, b: b2 }
        ];
      };
      ShortCurve.prototype._endoSplit = function _endoSplit(k) {
        var basis = this.endo.basis;
        var v1 = basis[0];
        var v2 = basis[1];
        var c1 = v2.b.mul(k).divRound(this.n);
        var c2 = v1.b.neg().mul(k).divRound(this.n);
        var p1 = c1.mul(v1.a);
        var p2 = c2.mul(v2.a);
        var q1 = c1.mul(v1.b);
        var q2 = c2.mul(v2.b);
        var k1 = k.sub(p1).sub(p2);
        var k2 = q1.add(q2).neg();
        return { k1, k2 };
      };
      ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      ShortCurve.prototype.validate = function validate(point) {
        if (point.inf)
          return true;
        var x = point.x;
        var y = point.y;
        var ax = this.a.redMul(x);
        var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
        return y.redSqr().redISub(rhs).cmpn(0) === 0;
      };
      ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
        var npoints = this._endoWnafT1;
        var ncoeffs = this._endoWnafT2;
        for (var i = 0; i < points.length; i++) {
          var split = this._endoSplit(coeffs[i]);
          var p = points[i];
          var beta = p._getBeta();
          if (split.k1.negative) {
            split.k1.ineg();
            p = p.neg(true);
          }
          if (split.k2.negative) {
            split.k2.ineg();
            beta = beta.neg(true);
          }
          npoints[i * 2] = p;
          npoints[i * 2 + 1] = beta;
          ncoeffs[i * 2] = split.k1;
          ncoeffs[i * 2 + 1] = split.k2;
        }
        var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
        for (var j = 0; j < i * 2; j++) {
          npoints[j] = null;
          ncoeffs[j] = null;
        }
        return res;
      };
      function Point(curve, x, y, isRed) {
        Base.BasePoint.call(this, curve, "affine");
        if (x === null && y === null) {
          this.x = null;
          this.y = null;
          this.inf = true;
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          if (isRed) {
            this.x.forceRed(this.curve.red);
            this.y.forceRed(this.curve.red);
          }
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          this.inf = false;
        }
      }
      inherits2(Point, Base.BasePoint);
      ShortCurve.prototype.point = function point(x, y, isRed) {
        return new Point(this, x, y, isRed);
      };
      ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
        return Point.fromJSON(this, obj, red);
      };
      Point.prototype._getBeta = function _getBeta() {
        if (!this.curve.endo)
          return;
        var pre = this.precomputed;
        if (pre && pre.beta)
          return pre.beta;
        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (pre) {
          var curve = this.curve;
          var endoMul = function(p) {
            return curve.point(p.x.redMul(curve.endo.beta), p.y);
          };
          pre.beta = beta;
          beta.precomputed = {
            beta: null,
            naf: pre.naf && {
              wnd: pre.naf.wnd,
              points: pre.naf.points.map(endoMul)
            },
            doubles: pre.doubles && {
              step: pre.doubles.step,
              points: pre.doubles.points.map(endoMul)
            }
          };
        }
        return beta;
      };
      Point.prototype.toJSON = function toJSON() {
        if (!this.precomputed)
          return [this.x, this.y];
        return [this.x, this.y, this.precomputed && {
          doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1)
          },
          naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1)
          }
        }];
      };
      Point.fromJSON = function fromJSON(curve, obj, red) {
        if (typeof obj === "string")
          obj = JSON.parse(obj);
        var res = curve.point(obj[0], obj[1], red);
        if (!obj[2])
          return res;
        function obj2point(obj2) {
          return curve.point(obj2[0], obj2[1], red);
        }
        var pre = obj[2];
        res.precomputed = {
          beta: null,
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: [res].concat(pre.doubles.points.map(obj2point))
          },
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: [res].concat(pre.naf.points.map(obj2point))
          }
        };
        return res;
      };
      Point.prototype.inspect = function inspect2() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.inf;
      };
      Point.prototype.add = function add(p) {
        if (this.inf)
          return p;
        if (p.inf)
          return this;
        if (this.eq(p))
          return this.dbl();
        if (this.neg().eq(p))
          return this.curve.point(null, null);
        if (this.x.cmp(p.x) === 0)
          return this.curve.point(null, null);
        var c = this.y.redSub(p.y);
        if (c.cmpn(0) !== 0)
          c = c.redMul(this.x.redSub(p.x).redInvm());
        var nx = c.redSqr().redISub(this.x).redISub(p.x);
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.dbl = function dbl() {
        if (this.inf)
          return this;
        var ys1 = this.y.redAdd(this.y);
        if (ys1.cmpn(0) === 0)
          return this.curve.point(null, null);
        var a = this.curve.a;
        var x2 = this.x.redSqr();
        var dyinv = ys1.redInvm();
        var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
        var nx = c.redSqr().redISub(this.x.redAdd(this.x));
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.getX = function getX() {
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        return this.y.fromRed();
      };
      Point.prototype.mul = function mul(k) {
        k = new BN(k, 16);
        if (this.isInfinity())
          return this;
        else if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else if (this.curve.endo)
          return this.curve._endoWnafMulAdd([this], [k]);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs, true);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
      };
      Point.prototype.eq = function eq(p) {
        return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
      };
      Point.prototype.neg = function neg(_precompute) {
        if (this.inf)
          return this;
        var res = this.curve.point(this.x, this.y.redNeg());
        if (_precompute && this.precomputed) {
          var pre = this.precomputed;
          var negate = function(p) {
            return p.neg();
          };
          res.precomputed = {
            naf: pre.naf && {
              wnd: pre.naf.wnd,
              points: pre.naf.points.map(negate)
            },
            doubles: pre.doubles && {
              step: pre.doubles.step,
              points: pre.doubles.points.map(negate)
            }
          };
        }
        return res;
      };
      Point.prototype.toJ = function toJ() {
        if (this.inf)
          return this.curve.jpoint(null, null, null);
        var res = this.curve.jpoint(this.x, this.y, this.curve.one);
        return res;
      };
      function JPoint(curve, x, y, z) {
        Base.BasePoint.call(this, curve, "jacobian");
        if (x === null && y === null && z === null) {
          this.x = this.curve.one;
          this.y = this.curve.one;
          this.z = new BN(0);
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          this.z = new BN(z, 16);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
      }
      inherits2(JPoint, Base.BasePoint);
      ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
        return new JPoint(this, x, y, z);
      };
      JPoint.prototype.toP = function toP() {
        if (this.isInfinity())
          return this.curve.point(null, null);
        var zinv = this.z.redInvm();
        var zinv2 = zinv.redSqr();
        var ax = this.x.redMul(zinv2);
        var ay = this.y.redMul(zinv2).redMul(zinv);
        return this.curve.point(ax, ay);
      };
      JPoint.prototype.neg = function neg() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
      };
      JPoint.prototype.add = function add(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        var pz2 = p.z.redSqr();
        var z2 = this.z.redSqr();
        var u1 = this.x.redMul(pz2);
        var u2 = p.x.redMul(z2);
        var s1 = this.y.redMul(pz2.redMul(p.z));
        var s2 = p.y.redMul(z2.redMul(this.z));
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(p.z).redMul(h);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mixedAdd = function mixedAdd(p) {
        if (this.isInfinity())
          return p.toJ();
        if (p.isInfinity())
          return this;
        var z2 = this.z.redSqr();
        var u1 = this.x;
        var u2 = p.x.redMul(z2);
        var s1 = this.y;
        var s2 = p.y.redMul(z2).redMul(this.z);
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(h);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.dblp = function dblp(pow) {
        if (pow === 0)
          return this;
        if (this.isInfinity())
          return this;
        if (!pow)
          return this.dbl();
        var i;
        if (this.curve.zeroA || this.curve.threeA) {
          var r = this;
          for (i = 0; i < pow; i++)
            r = r.dbl();
          return r;
        }
        var a = this.curve.a;
        var tinv = this.curve.tinv;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jyd = jy.redAdd(jy);
        for (i = 0; i < pow; i++) {
          var jx2 = jx.redSqr();
          var jyd2 = jyd.redSqr();
          var jyd4 = jyd2.redSqr();
          var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
          var t1 = jx.redMul(jyd2);
          var nx = c.redSqr().redISub(t1.redAdd(t1));
          var t2 = t1.redISub(nx);
          var dny = c.redMul(t2);
          dny = dny.redIAdd(dny).redISub(jyd4);
          var nz = jyd.redMul(jz);
          if (i + 1 < pow)
            jz4 = jz4.redMul(jyd4);
          jx = nx;
          jz = nz;
          jyd = dny;
        }
        return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
      };
      JPoint.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.zeroA)
          return this._zeroDbl();
        else if (this.curve.threeA)
          return this._threeDbl();
        else
          return this._dbl();
      };
      JPoint.prototype._zeroDbl = function _zeroDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx);
          var t = m.redSqr().redISub(s).redISub(s);
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          nx = t;
          ny = m.redMul(s.redISub(t)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var a = this.x.redSqr();
          var b = this.y.redSqr();
          var c = b.redSqr();
          var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
          d = d.redIAdd(d);
          var e = a.redAdd(a).redIAdd(a);
          var f = e.redSqr();
          var c8 = c.redIAdd(c);
          c8 = c8.redIAdd(c8);
          c8 = c8.redIAdd(c8);
          nx = f.redISub(d).redISub(d);
          ny = e.redMul(d.redISub(nx)).redISub(c8);
          nz = this.y.redMul(this.z);
          nz = nz.redIAdd(nz);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._threeDbl = function _threeDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
          var t = m.redSqr().redISub(s).redISub(s);
          nx = t;
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          ny = m.redMul(s.redISub(t)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var delta = this.z.redSqr();
          var gamma = this.y.redSqr();
          var beta = this.x.redMul(gamma);
          var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
          alpha = alpha.redAdd(alpha).redIAdd(alpha);
          var beta4 = beta.redIAdd(beta);
          beta4 = beta4.redIAdd(beta4);
          var beta8 = beta4.redAdd(beta4);
          nx = alpha.redSqr().redISub(beta8);
          nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
          var ggamma8 = gamma.redSqr();
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._dbl = function _dbl() {
        var a = this.curve.a;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jx2 = jx.redSqr();
        var jy2 = jy.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var jxd4 = jx.redAdd(jx);
        jxd4 = jxd4.redIAdd(jxd4);
        var t1 = jxd4.redMul(jy2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var jyd8 = jy2.redSqr();
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        var ny = c.redMul(t2).redISub(jyd8);
        var nz = jy.redAdd(jy).redMul(jz);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.trpl = function trpl() {
        if (!this.curve.zeroA)
          return this.dbl().add(this);
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var zz = this.z.redSqr();
        var yyyy = yy.redSqr();
        var m = xx.redAdd(xx).redIAdd(xx);
        var mm = m.redSqr();
        var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        e = e.redIAdd(e);
        e = e.redAdd(e).redIAdd(e);
        e = e.redISub(mm);
        var ee = e.redSqr();
        var t = yyyy.redIAdd(yyyy);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
        var yyu4 = yy.redMul(u);
        yyu4 = yyu4.redIAdd(yyu4);
        yyu4 = yyu4.redIAdd(yyu4);
        var nx = this.x.redMul(ee).redISub(yyu4);
        nx = nx.redIAdd(nx);
        nx = nx.redIAdd(nx);
        var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mul = function mul(k, kbase) {
        k = new BN(k, kbase);
        return this.curve._wnafMul(this, k);
      };
      JPoint.prototype.eq = function eq(p) {
        if (p.type === "affine")
          return this.eq(p.toJ());
        if (this === p)
          return true;
        var z2 = this.z.redSqr();
        var pz2 = p.z.redSqr();
        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
          return false;
        var z3 = z2.redMul(this.z);
        var pz3 = pz2.redMul(p.z);
        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
      };
      JPoint.prototype.eqXToP = function eqXToP(x) {
        var zs = this.z.redSqr();
        var rx = x.toRed(this.curve.red).redMul(zs);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(zs);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      JPoint.prototype.inspect = function inspect2() {
        if (this.isInfinity())
          return "<EC JPoint Infinity>";
        return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
      };
      JPoint.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/mont.js
  var require_mont = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var BN = require_bn2();
      var inherits2 = require_inherits_browser();
      var Base = require_base3();
      var utils = require_utils4();
      function MontCurve(conf) {
        Base.call(this, "mont", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.i4 = new BN(4).toRed(this.red).redInvm();
        this.two = new BN(2).toRed(this.red);
        this.a24 = this.i4.redMul(this.a.redAdd(this.two));
      }
      inherits2(MontCurve, Base);
      module.exports = MontCurve;
      MontCurve.prototype.validate = function validate(point) {
        var x = point.normalize().x;
        var x2 = x.redSqr();
        var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
        var y = rhs.redSqrt();
        return y.redSqr().cmp(rhs) === 0;
      };
      function Point(curve, x, z) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && z === null) {
          this.x = this.curve.one;
          this.z = this.curve.zero;
        } else {
          this.x = new BN(x, 16);
          this.z = new BN(z, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
        }
      }
      inherits2(Point, Base.BasePoint);
      MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        return this.point(utils.toArray(bytes, enc), 1);
      };
      MontCurve.prototype.point = function point(x, z) {
        return new Point(this, x, z);
      };
      MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      Point.prototype.precompute = function precompute() {
      };
      Point.prototype._encode = function _encode() {
        return this.getX().toArray("be", this.curve.p.byteLength());
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1] || curve.one);
      };
      Point.prototype.inspect = function inspect2() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
      Point.prototype.dbl = function dbl() {
        var a = this.x.redAdd(this.z);
        var aa = a.redSqr();
        var b = this.x.redSub(this.z);
        var bb = b.redSqr();
        var c = aa.redSub(bb);
        var nx = aa.redMul(bb);
        var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
        return this.curve.point(nx, nz);
      };
      Point.prototype.add = function add() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.diffAdd = function diffAdd(p, diff) {
        var a = this.x.redAdd(this.z);
        var b = this.x.redSub(this.z);
        var c = p.x.redAdd(p.z);
        var d = p.x.redSub(p.z);
        var da = d.redMul(a);
        var cb = c.redMul(b);
        var nx = diff.z.redMul(da.redAdd(cb).redSqr());
        var nz = diff.x.redMul(da.redISub(cb).redSqr());
        return this.curve.point(nx, nz);
      };
      Point.prototype.mul = function mul(k) {
        var t = k.clone();
        var a = this;
        var b = this.curve.point(null, null);
        var c = this;
        for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
          bits.push(t.andln(1));
        for (var i = bits.length - 1; i >= 0; i--) {
          if (bits[i] === 0) {
            a = a.diffAdd(b, c);
            b = b.dbl();
          } else {
            b = a.diffAdd(b, c);
            a = a.dbl();
          }
        }
        return b;
      };
      Point.prototype.mulAdd = function mulAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.jumlAdd = function jumlAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.eq = function eq(other) {
        return this.getX().cmp(other.getX()) === 0;
      };
      Point.prototype.normalize = function normalize() {
        this.x = this.x.redMul(this.z.redInvm());
        this.z = this.curve.one;
        return this;
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/edwards.js
  var require_edwards = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var utils = require_utils4();
      var BN = require_bn2();
      var inherits2 = require_inherits_browser();
      var Base = require_base3();
      var assert2 = utils.assert;
      function EdwardsCurve(conf) {
        this.twisted = (conf.a | 0) !== 1;
        this.mOneA = this.twisted && (conf.a | 0) === -1;
        this.extended = this.mOneA;
        Base.call(this, "edwards", conf);
        this.a = new BN(conf.a, 16).umod(this.red.m);
        this.a = this.a.toRed(this.red);
        this.c = new BN(conf.c, 16).toRed(this.red);
        this.c2 = this.c.redSqr();
        this.d = new BN(conf.d, 16).toRed(this.red);
        this.dd = this.d.redAdd(this.d);
        assert2(!this.twisted || this.c.fromRed().cmpn(1) === 0);
        this.oneC = (conf.c | 0) === 1;
      }
      inherits2(EdwardsCurve, Base);
      module.exports = EdwardsCurve;
      EdwardsCurve.prototype._mulA = function _mulA(num) {
        if (this.mOneA)
          return num.redNeg();
        else
          return this.a.redMul(num);
      };
      EdwardsCurve.prototype._mulC = function _mulC(num) {
        if (this.oneC)
          return num;
        else
          return this.c.redMul(num);
      };
      EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
        return this.point(x, y, z, t);
      };
      EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var x2 = x.redSqr();
        var rhs = this.c2.redSub(this.a.redMul(x2));
        var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
        var y2 = rhs.redMul(lhs.redInvm());
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
        y = new BN(y, 16);
        if (!y.red)
          y = y.toRed(this.red);
        var y2 = y.redSqr();
        var lhs = y2.redSub(this.c2);
        var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
        var x2 = lhs.redMul(rhs.redInvm());
        if (x2.cmp(this.zero) === 0) {
          if (odd)
            throw new Error("invalid point");
          else
            return this.point(this.zero, y);
        }
        var x = x2.redSqrt();
        if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        if (x.fromRed().isOdd() !== odd)
          x = x.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.validate = function validate(point) {
        if (point.isInfinity())
          return true;
        point.normalize();
        var x2 = point.x.redSqr();
        var y2 = point.y.redSqr();
        var lhs = x2.redMul(this.a).redAdd(y2);
        var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
        return lhs.cmp(rhs) === 0;
      };
      function Point(curve, x, y, z, t) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && y === null && z === null) {
          this.x = this.curve.zero;
          this.y = this.curve.one;
          this.z = this.curve.one;
          this.t = this.curve.zero;
          this.zOne = true;
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          this.z = z ? new BN(z, 16) : this.curve.one;
          this.t = t && new BN(t, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
          if (this.t && !this.t.red)
            this.t = this.t.toRed(this.curve.red);
          this.zOne = this.z === this.curve.one;
          if (this.curve.extended && !this.t) {
            this.t = this.x.redMul(this.y);
            if (!this.zOne)
              this.t = this.t.redMul(this.z.redInvm());
          }
        }
      }
      inherits2(Point, Base.BasePoint);
      EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      EdwardsCurve.prototype.point = function point(x, y, z, t) {
        return new Point(this, x, y, z, t);
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1], obj[2]);
      };
      Point.prototype.inspect = function inspect2() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
      };
      Point.prototype._extDbl = function _extDbl() {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = this.z.redSqr();
        c = c.redIAdd(c);
        var d = this.curve._mulA(a);
        var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
        var g = d.redAdd(b);
        var f = g.redSub(c);
        var h = d.redSub(b);
        var nx = e.redMul(f);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projDbl = function _projDbl() {
        var b = this.x.redAdd(this.y).redSqr();
        var c = this.x.redSqr();
        var d = this.y.redSqr();
        var nx;
        var ny;
        var nz;
        var e;
        var h;
        var j;
        if (this.curve.twisted) {
          e = this.curve._mulA(c);
          var f = e.redAdd(d);
          if (this.zOne) {
            nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
            ny = f.redMul(e.redSub(d));
            nz = f.redSqr().redSub(f).redSub(f);
          } else {
            h = this.z.redSqr();
            j = f.redSub(h).redISub(h);
            nx = b.redSub(c).redISub(d).redMul(j);
            ny = f.redMul(e.redSub(d));
            nz = f.redMul(j);
          }
        } else {
          e = c.redAdd(d);
          h = this.curve._mulC(this.z).redSqr();
          j = e.redSub(h).redSub(h);
          nx = this.curve._mulC(b.redISub(e)).redMul(j);
          ny = this.curve._mulC(e).redMul(c.redISub(d));
          nz = e.redMul(j);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extDbl();
        else
          return this._projDbl();
      };
      Point.prototype._extAdd = function _extAdd(p) {
        var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
        var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
        var c = this.t.redMul(this.curve.dd).redMul(p.t);
        var d = this.z.redMul(p.z.redAdd(p.z));
        var e = b.redSub(a);
        var f = d.redSub(c);
        var g = d.redAdd(c);
        var h = b.redAdd(a);
        var nx = e.redMul(f);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projAdd = function _projAdd(p) {
        var a = this.z.redMul(p.z);
        var b = a.redSqr();
        var c = this.x.redMul(p.x);
        var d = this.y.redMul(p.y);
        var e = this.curve.d.redMul(c).redMul(d);
        var f = b.redSub(e);
        var g = b.redAdd(e);
        var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
        var nx = a.redMul(f).redMul(tmp);
        var ny;
        var nz;
        if (this.curve.twisted) {
          ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
          nz = f.redMul(g);
        } else {
          ny = a.redMul(g).redMul(d.redSub(c));
          nz = this.curve._mulC(f).redMul(g);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.add = function add(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extAdd(p);
        else
          return this._projAdd(p);
      };
      Point.prototype.mul = function mul(k) {
        if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
      };
      Point.prototype.normalize = function normalize() {
        if (this.zOne)
          return this;
        var zi = this.z.redInvm();
        this.x = this.x.redMul(zi);
        this.y = this.y.redMul(zi);
        if (this.t)
          this.t = this.t.redMul(zi);
        this.z = this.curve.one;
        this.zOne = true;
        return this;
      };
      Point.prototype.neg = function neg() {
        return this.curve.point(
          this.x.redNeg(),
          this.y,
          this.z,
          this.t && this.t.redNeg()
        );
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        this.normalize();
        return this.y.fromRed();
      };
      Point.prototype.eq = function eq(other) {
        return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
      };
      Point.prototype.eqXToP = function eqXToP(x) {
        var rx = x.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(this.z);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      Point.prototype.toP = Point.prototype.normalize;
      Point.prototype.mixedAdd = Point.prototype.add;
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/index.js
  var require_curve = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/index.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var curve = exports9;
      curve.base = require_base3();
      curve.short = require_short();
      curve.mont = require_mont();
      curve.edwards = require_edwards();
    }
  });

  // node_modules/hash.js/lib/hash/utils.js
  var require_utils5 = __commonJS({
    "node_modules/hash.js/lib/hash/utils.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var assert2 = require_minimalistic_assert();
      var inherits2 = require_inherits_browser();
      exports9.inherits = inherits2;
      function isSurrogatePair(msg, i) {
        if ((msg.charCodeAt(i) & 64512) !== 55296) {
          return false;
        }
        if (i < 0 || i + 1 >= msg.length) {
          return false;
        }
        return (msg.charCodeAt(i + 1) & 64512) === 56320;
      }
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg === "string") {
          if (!enc) {
            var p = 0;
            for (var i = 0; i < msg.length; i++) {
              var c = msg.charCodeAt(i);
              if (c < 128) {
                res[p++] = c;
              } else if (c < 2048) {
                res[p++] = c >> 6 | 192;
                res[p++] = c & 63 | 128;
              } else if (isSurrogatePair(msg, i)) {
                c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
                res[p++] = c >> 18 | 240;
                res[p++] = c >> 12 & 63 | 128;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              } else {
                res[p++] = c >> 12 | 224;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              }
            }
          } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0)
              msg = "0" + msg;
            for (i = 0; i < msg.length; i += 2)
              res.push(parseInt(msg[i] + msg[i + 1], 16));
          }
        } else {
          for (i = 0; i < msg.length; i++)
            res[i] = msg[i] | 0;
        }
        return res;
      }
      exports9.toArray = toArray;
      function toHex2(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++)
          res += zero2(msg[i].toString(16));
        return res;
      }
      exports9.toHex = toHex2;
      function htonl(w) {
        var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
        return res >>> 0;
      }
      exports9.htonl = htonl;
      function toHex32(msg, endian) {
        var res = "";
        for (var i = 0; i < msg.length; i++) {
          var w = msg[i];
          if (endian === "little")
            w = htonl(w);
          res += zero8(w.toString(16));
        }
        return res;
      }
      exports9.toHex32 = toHex32;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      exports9.zero2 = zero2;
      function zero8(word) {
        if (word.length === 7)
          return "0" + word;
        else if (word.length === 6)
          return "00" + word;
        else if (word.length === 5)
          return "000" + word;
        else if (word.length === 4)
          return "0000" + word;
        else if (word.length === 3)
          return "00000" + word;
        else if (word.length === 2)
          return "000000" + word;
        else if (word.length === 1)
          return "0000000" + word;
        else
          return word;
      }
      exports9.zero8 = zero8;
      function join32(msg, start, end, endian) {
        var len = end - start;
        assert2(len % 4 === 0);
        var res = new Array(len / 4);
        for (var i = 0, k = start; i < res.length; i++, k += 4) {
          var w;
          if (endian === "big")
            w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
          else
            w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
          res[i] = w >>> 0;
        }
        return res;
      }
      exports9.join32 = join32;
      function split32(msg, endian) {
        var res = new Array(msg.length * 4);
        for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
          var m = msg[i];
          if (endian === "big") {
            res[k] = m >>> 24;
            res[k + 1] = m >>> 16 & 255;
            res[k + 2] = m >>> 8 & 255;
            res[k + 3] = m & 255;
          } else {
            res[k + 3] = m >>> 24;
            res[k + 2] = m >>> 16 & 255;
            res[k + 1] = m >>> 8 & 255;
            res[k] = m & 255;
          }
        }
        return res;
      }
      exports9.split32 = split32;
      function rotr32(w, b) {
        return w >>> b | w << 32 - b;
      }
      exports9.rotr32 = rotr32;
      function rotl32(w, b) {
        return w << b | w >>> 32 - b;
      }
      exports9.rotl32 = rotl32;
      function sum32(a, b) {
        return a + b >>> 0;
      }
      exports9.sum32 = sum32;
      function sum32_3(a, b, c) {
        return a + b + c >>> 0;
      }
      exports9.sum32_3 = sum32_3;
      function sum32_4(a, b, c, d) {
        return a + b + c + d >>> 0;
      }
      exports9.sum32_4 = sum32_4;
      function sum32_5(a, b, c, d, e) {
        return a + b + c + d + e >>> 0;
      }
      exports9.sum32_5 = sum32_5;
      function sum64(buf, pos, ah, al) {
        var bh = buf[pos];
        var bl = buf[pos + 1];
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        buf[pos] = hi >>> 0;
        buf[pos + 1] = lo;
      }
      exports9.sum64 = sum64;
      function sum64_hi(ah, al, bh, bl) {
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        return hi >>> 0;
      }
      exports9.sum64_hi = sum64_hi;
      function sum64_lo(ah, al, bh, bl) {
        var lo = al + bl;
        return lo >>> 0;
      }
      exports9.sum64_lo = sum64_lo;
      function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        var hi = ah + bh + ch + dh + carry;
        return hi >>> 0;
      }
      exports9.sum64_4_hi = sum64_4_hi;
      function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
        var lo = al + bl + cl + dl;
        return lo >>> 0;
      }
      exports9.sum64_4_lo = sum64_4_lo;
      function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        lo = lo + el >>> 0;
        carry += lo < el ? 1 : 0;
        var hi = ah + bh + ch + dh + eh + carry;
        return hi >>> 0;
      }
      exports9.sum64_5_hi = sum64_5_hi;
      function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var lo = al + bl + cl + dl + el;
        return lo >>> 0;
      }
      exports9.sum64_5_lo = sum64_5_lo;
      function rotr64_hi(ah, al, num) {
        var r = al << 32 - num | ah >>> num;
        return r >>> 0;
      }
      exports9.rotr64_hi = rotr64_hi;
      function rotr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports9.rotr64_lo = rotr64_lo;
      function shr64_hi(ah, al, num) {
        return ah >>> num;
      }
      exports9.shr64_hi = shr64_hi;
      function shr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports9.shr64_lo = shr64_lo;
    }
  });

  // node_modules/hash.js/lib/hash/common.js
  var require_common = __commonJS({
    "node_modules/hash.js/lib/hash/common.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var utils = require_utils5();
      var assert2 = require_minimalistic_assert();
      function BlockHash() {
        this.pending = null;
        this.pendingTotal = 0;
        this.blockSize = this.constructor.blockSize;
        this.outSize = this.constructor.outSize;
        this.hmacStrength = this.constructor.hmacStrength;
        this.padLength = this.constructor.padLength / 8;
        this.endian = "big";
        this._delta8 = this.blockSize / 8;
        this._delta32 = this.blockSize / 32;
      }
      exports9.BlockHash = BlockHash;
      BlockHash.prototype.update = function update(msg, enc) {
        msg = utils.toArray(msg, enc);
        if (!this.pending)
          this.pending = msg;
        else
          this.pending = this.pending.concat(msg);
        this.pendingTotal += msg.length;
        if (this.pending.length >= this._delta8) {
          msg = this.pending;
          var r = msg.length % this._delta8;
          this.pending = msg.slice(msg.length - r, msg.length);
          if (this.pending.length === 0)
            this.pending = null;
          msg = utils.join32(msg, 0, msg.length - r, this.endian);
          for (var i = 0; i < msg.length; i += this._delta32)
            this._update(msg, i, i + this._delta32);
        }
        return this;
      };
      BlockHash.prototype.digest = function digest(enc) {
        this.update(this._pad());
        assert2(this.pending === null);
        return this._digest(enc);
      };
      BlockHash.prototype._pad = function pad() {
        var len = this.pendingTotal;
        var bytes = this._delta8;
        var k = bytes - (len + this.padLength) % bytes;
        var res = new Array(k + this.padLength);
        res[0] = 128;
        for (var i = 1; i < k; i++)
          res[i] = 0;
        len <<= 3;
        if (this.endian === "big") {
          for (var t = 8; t < this.padLength; t++)
            res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = len >>> 24 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len & 255;
        } else {
          res[i++] = len & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 24 & 255;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          for (t = 8; t < this.padLength; t++)
            res[i++] = 0;
        }
        return res;
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/common.js
  var require_common2 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/common.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var utils = require_utils5();
      var rotr32 = utils.rotr32;
      function ft_1(s, x, y, z) {
        if (s === 0)
          return ch32(x, y, z);
        if (s === 1 || s === 3)
          return p32(x, y, z);
        if (s === 2)
          return maj32(x, y, z);
      }
      exports9.ft_1 = ft_1;
      function ch32(x, y, z) {
        return x & y ^ ~x & z;
      }
      exports9.ch32 = ch32;
      function maj32(x, y, z) {
        return x & y ^ x & z ^ y & z;
      }
      exports9.maj32 = maj32;
      function p32(x, y, z) {
        return x ^ y ^ z;
      }
      exports9.p32 = p32;
      function s0_256(x) {
        return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
      }
      exports9.s0_256 = s0_256;
      function s1_256(x) {
        return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
      }
      exports9.s1_256 = s1_256;
      function g0_256(x) {
        return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
      }
      exports9.g0_256 = g0_256;
      function g1_256(x) {
        return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
      }
      exports9.g1_256 = g1_256;
    }
  });

  // node_modules/hash.js/lib/hash/sha/1.js
  var require__ = __commonJS({
    "node_modules/hash.js/lib/hash/sha/1.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var utils = require_utils5();
      var common = require_common();
      var shaCommon = require_common2();
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_5 = utils.sum32_5;
      var ft_1 = shaCommon.ft_1;
      var BlockHash = common.BlockHash;
      var sha1_K = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
      ];
      function SHA1() {
        if (!(this instanceof SHA1))
          return new SHA1();
        BlockHash.call(this);
        this.h = [
          1732584193,
          4023233417,
          2562383102,
          271733878,
          3285377520
        ];
        this.W = new Array(80);
      }
      utils.inherits(SHA1, BlockHash);
      module.exports = SHA1;
      SHA1.blockSize = 512;
      SHA1.outSize = 160;
      SHA1.hmacStrength = 80;
      SHA1.padLength = 64;
      SHA1.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i++)
          W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        for (i = 0; i < W.length; i++) {
          var s = ~~(i / 20);
          var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
          e = d;
          d = c;
          c = rotl32(b, 30);
          b = a;
          a = t;
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
      };
      SHA1.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/256.js
  var require__2 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/256.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var utils = require_utils5();
      var common = require_common();
      var shaCommon = require_common2();
      var assert2 = require_minimalistic_assert();
      var sum32 = utils.sum32;
      var sum32_4 = utils.sum32_4;
      var sum32_5 = utils.sum32_5;
      var ch32 = shaCommon.ch32;
      var maj32 = shaCommon.maj32;
      var s0_256 = shaCommon.s0_256;
      var s1_256 = shaCommon.s1_256;
      var g0_256 = shaCommon.g0_256;
      var g1_256 = shaCommon.g1_256;
      var BlockHash = common.BlockHash;
      var sha256_K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      function SHA256() {
        if (!(this instanceof SHA256))
          return new SHA256();
        BlockHash.call(this);
        this.h = [
          1779033703,
          3144134277,
          1013904242,
          2773480762,
          1359893119,
          2600822924,
          528734635,
          1541459225
        ];
        this.k = sha256_K;
        this.W = new Array(64);
      }
      utils.inherits(SHA256, BlockHash);
      module.exports = SHA256;
      SHA256.blockSize = 512;
      SHA256.outSize = 256;
      SHA256.hmacStrength = 192;
      SHA256.padLength = 64;
      SHA256.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i++)
          W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        var f = this.h[5];
        var g = this.h[6];
        var h = this.h[7];
        assert2(this.k.length === W.length);
        for (i = 0; i < W.length; i++) {
          var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
          var T2 = sum32(s0_256(a), maj32(a, b, c));
          h = g;
          g = f;
          f = e;
          e = sum32(d, T1);
          d = c;
          c = b;
          b = a;
          a = sum32(T1, T2);
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
        this.h[5] = sum32(this.h[5], f);
        this.h[6] = sum32(this.h[6], g);
        this.h[7] = sum32(this.h[7], h);
      };
      SHA256.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/224.js
  var require__3 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/224.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var utils = require_utils5();
      var SHA256 = require__2();
      function SHA224() {
        if (!(this instanceof SHA224))
          return new SHA224();
        SHA256.call(this);
        this.h = [
          3238371032,
          914150663,
          812702999,
          4144912697,
          4290775857,
          1750603025,
          1694076839,
          3204075428
        ];
      }
      utils.inherits(SHA224, SHA256);
      module.exports = SHA224;
      SHA224.blockSize = 512;
      SHA224.outSize = 224;
      SHA224.hmacStrength = 192;
      SHA224.padLength = 64;
      SHA224.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 7), "big");
        else
          return utils.split32(this.h.slice(0, 7), "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/512.js
  var require__4 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/512.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var utils = require_utils5();
      var common = require_common();
      var assert2 = require_minimalistic_assert();
      var rotr64_hi = utils.rotr64_hi;
      var rotr64_lo = utils.rotr64_lo;
      var shr64_hi = utils.shr64_hi;
      var shr64_lo = utils.shr64_lo;
      var sum64 = utils.sum64;
      var sum64_hi = utils.sum64_hi;
      var sum64_lo = utils.sum64_lo;
      var sum64_4_hi = utils.sum64_4_hi;
      var sum64_4_lo = utils.sum64_4_lo;
      var sum64_5_hi = utils.sum64_5_hi;
      var sum64_5_lo = utils.sum64_5_lo;
      var BlockHash = common.BlockHash;
      var sha512_K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function SHA512() {
        if (!(this instanceof SHA512))
          return new SHA512();
        BlockHash.call(this);
        this.h = [
          1779033703,
          4089235720,
          3144134277,
          2227873595,
          1013904242,
          4271175723,
          2773480762,
          1595750129,
          1359893119,
          2917565137,
          2600822924,
          725511199,
          528734635,
          4215389547,
          1541459225,
          327033209
        ];
        this.k = sha512_K;
        this.W = new Array(160);
      }
      utils.inherits(SHA512, BlockHash);
      module.exports = SHA512;
      SHA512.blockSize = 1024;
      SHA512.outSize = 512;
      SHA512.hmacStrength = 192;
      SHA512.padLength = 128;
      SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
        var W = this.W;
        for (var i = 0; i < 32; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i += 2) {
          var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
          var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
          var c1_hi = W[i - 14];
          var c1_lo = W[i - 13];
          var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
          var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
          var c3_hi = W[i - 32];
          var c3_lo = W[i - 31];
          W[i] = sum64_4_hi(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo
          );
          W[i + 1] = sum64_4_lo(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo
          );
        }
      };
      SHA512.prototype._update = function _update(msg, start) {
        this._prepareBlock(msg, start);
        var W = this.W;
        var ah = this.h[0];
        var al = this.h[1];
        var bh = this.h[2];
        var bl = this.h[3];
        var ch = this.h[4];
        var cl = this.h[5];
        var dh = this.h[6];
        var dl = this.h[7];
        var eh = this.h[8];
        var el = this.h[9];
        var fh = this.h[10];
        var fl = this.h[11];
        var gh = this.h[12];
        var gl = this.h[13];
        var hh = this.h[14];
        var hl = this.h[15];
        assert2(this.k.length === W.length);
        for (var i = 0; i < W.length; i += 2) {
          var c0_hi = hh;
          var c0_lo = hl;
          var c1_hi = s1_512_hi(eh, el);
          var c1_lo = s1_512_lo(eh, el);
          var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
          var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
          var c3_hi = this.k[i];
          var c3_lo = this.k[i + 1];
          var c4_hi = W[i];
          var c4_lo = W[i + 1];
          var T1_hi = sum64_5_hi(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo,
            c4_hi,
            c4_lo
          );
          var T1_lo = sum64_5_lo(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo,
            c4_hi,
            c4_lo
          );
          c0_hi = s0_512_hi(ah, al);
          c0_lo = s0_512_lo(ah, al);
          c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
          c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
          var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
          var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          eh = sum64_hi(dh, dl, T1_hi, T1_lo);
          el = sum64_lo(dl, dl, T1_hi, T1_lo);
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
          al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
        }
        sum64(this.h, 0, ah, al);
        sum64(this.h, 2, bh, bl);
        sum64(this.h, 4, ch, cl);
        sum64(this.h, 6, dh, dl);
        sum64(this.h, 8, eh, el);
        sum64(this.h, 10, fh, fl);
        sum64(this.h, 12, gh, gl);
        sum64(this.h, 14, hh, hl);
      };
      SHA512.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
      function ch64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ ~xh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function ch64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ ~xl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ xh & zh ^ yh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ xl & zl ^ yl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 28);
        var c1_hi = rotr64_hi(xl, xh, 2);
        var c2_hi = rotr64_hi(xl, xh, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 28);
        var c1_lo = rotr64_lo(xl, xh, 2);
        var c2_lo = rotr64_lo(xl, xh, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 14);
        var c1_hi = rotr64_hi(xh, xl, 18);
        var c2_hi = rotr64_hi(xl, xh, 9);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 14);
        var c1_lo = rotr64_lo(xh, xl, 18);
        var c2_lo = rotr64_lo(xl, xh, 9);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 1);
        var c1_hi = rotr64_hi(xh, xl, 8);
        var c2_hi = shr64_hi(xh, xl, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 1);
        var c1_lo = rotr64_lo(xh, xl, 8);
        var c2_lo = shr64_lo(xh, xl, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 19);
        var c1_hi = rotr64_hi(xl, xh, 29);
        var c2_hi = shr64_hi(xh, xl, 6);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 19);
        var c1_lo = rotr64_lo(xl, xh, 29);
        var c2_lo = shr64_lo(xh, xl, 6);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
    }
  });

  // node_modules/hash.js/lib/hash/sha/384.js
  var require__5 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/384.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var utils = require_utils5();
      var SHA512 = require__4();
      function SHA384() {
        if (!(this instanceof SHA384))
          return new SHA384();
        SHA512.call(this);
        this.h = [
          3418070365,
          3238371032,
          1654270250,
          914150663,
          2438529370,
          812702999,
          355462360,
          4144912697,
          1731405415,
          4290775857,
          2394180231,
          1750603025,
          3675008525,
          1694076839,
          1203062813,
          3204075428
        ];
      }
      utils.inherits(SHA384, SHA512);
      module.exports = SHA384;
      SHA384.blockSize = 1024;
      SHA384.outSize = 384;
      SHA384.hmacStrength = 192;
      SHA384.padLength = 128;
      SHA384.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 12), "big");
        else
          return utils.split32(this.h.slice(0, 12), "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha.js
  var require_sha3 = __commonJS({
    "node_modules/hash.js/lib/hash/sha.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      exports9.sha1 = require__();
      exports9.sha224 = require__3();
      exports9.sha256 = require__2();
      exports9.sha384 = require__5();
      exports9.sha512 = require__4();
    }
  });

  // node_modules/hash.js/lib/hash/ripemd.js
  var require_ripemd = __commonJS({
    "node_modules/hash.js/lib/hash/ripemd.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var utils = require_utils5();
      var common = require_common();
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_3 = utils.sum32_3;
      var sum32_4 = utils.sum32_4;
      var BlockHash = common.BlockHash;
      function RIPEMD160() {
        if (!(this instanceof RIPEMD160))
          return new RIPEMD160();
        BlockHash.call(this);
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        this.endian = "little";
      }
      utils.inherits(RIPEMD160, BlockHash);
      exports9.ripemd160 = RIPEMD160;
      RIPEMD160.blockSize = 512;
      RIPEMD160.outSize = 160;
      RIPEMD160.hmacStrength = 192;
      RIPEMD160.padLength = 64;
      RIPEMD160.prototype._update = function update(msg, start) {
        var A = this.h[0];
        var B = this.h[1];
        var C = this.h[2];
        var D = this.h[3];
        var E = this.h[4];
        var Ah = A;
        var Bh = B;
        var Ch = C;
        var Dh = D;
        var Eh = E;
        for (var j = 0; j < 80; j++) {
          var T = sum32(
            rotl32(
              sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
              s[j]
            ),
            E
          );
          A = E;
          E = D;
          D = rotl32(C, 10);
          C = B;
          B = T;
          T = sum32(
            rotl32(
              sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
              sh[j]
            ),
            Eh
          );
          Ah = Eh;
          Eh = Dh;
          Dh = rotl32(Ch, 10);
          Ch = Bh;
          Bh = T;
        }
        T = sum32_3(this.h[1], C, Dh);
        this.h[1] = sum32_3(this.h[2], D, Eh);
        this.h[2] = sum32_3(this.h[3], E, Ah);
        this.h[3] = sum32_3(this.h[4], A, Bh);
        this.h[4] = sum32_3(this.h[0], B, Ch);
        this.h[0] = T;
      };
      RIPEMD160.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "little");
        else
          return utils.split32(this.h, "little");
      };
      function f(j, x, y, z) {
        if (j <= 15)
          return x ^ y ^ z;
        else if (j <= 31)
          return x & y | ~x & z;
        else if (j <= 47)
          return (x | ~y) ^ z;
        else if (j <= 63)
          return x & z | y & ~z;
        else
          return x ^ (y | ~z);
      }
      function K(j) {
        if (j <= 15)
          return 0;
        else if (j <= 31)
          return 1518500249;
        else if (j <= 47)
          return 1859775393;
        else if (j <= 63)
          return 2400959708;
        else
          return 2840853838;
      }
      function Kh(j) {
        if (j <= 15)
          return 1352829926;
        else if (j <= 31)
          return 1548603684;
        else if (j <= 47)
          return 1836072691;
        else if (j <= 63)
          return 2053994217;
        else
          return 0;
      }
      var r = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
      ];
      var rh = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
      ];
      var s = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
      ];
      var sh = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
      ];
    }
  });

  // node_modules/hash.js/lib/hash/hmac.js
  var require_hmac = __commonJS({
    "node_modules/hash.js/lib/hash/hmac.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var utils = require_utils5();
      var assert2 = require_minimalistic_assert();
      function Hmac(hash, key, enc) {
        if (!(this instanceof Hmac))
          return new Hmac(hash, key, enc);
        this.Hash = hash;
        this.blockSize = hash.blockSize / 8;
        this.outSize = hash.outSize / 8;
        this.inner = null;
        this.outer = null;
        this._init(utils.toArray(key, enc));
      }
      module.exports = Hmac;
      Hmac.prototype._init = function init2(key) {
        if (key.length > this.blockSize)
          key = new this.Hash().update(key).digest();
        assert2(key.length <= this.blockSize);
        for (var i = key.length; i < this.blockSize; i++)
          key.push(0);
        for (i = 0; i < key.length; i++)
          key[i] ^= 54;
        this.inner = new this.Hash().update(key);
        for (i = 0; i < key.length; i++)
          key[i] ^= 106;
        this.outer = new this.Hash().update(key);
      };
      Hmac.prototype.update = function update(msg, enc) {
        this.inner.update(msg, enc);
        return this;
      };
      Hmac.prototype.digest = function digest(enc) {
        this.outer.update(this.inner.digest());
        return this.outer.digest(enc);
      };
    }
  });

  // node_modules/hash.js/lib/hash.js
  var require_hash2 = __commonJS({
    "node_modules/hash.js/lib/hash.js"(exports9) {
      init_dirname();
      init_buffer2();
      init_process2();
      var hash = exports9;
      hash.utils = require_utils5();
      hash.common = require_common();
      hash.sha = require_sha3();
      hash.ripemd = require_ripemd();
      hash.hmac = require_hmac();
      hash.sha1 = hash.sha.sha1;
      hash.sha256 = hash.sha.sha256;
      hash.sha224 = hash.sha.sha224;
      hash.sha384 = hash.sha.sha384;
      hash.sha512 = hash.sha.sha512;
      hash.ripemd160 = hash.ripemd.ripemd160;
    }
  });

  // node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
  var require_secp256k1 = __commonJS({
    "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      module.exports = {
        doubles: {
          step: 4,
          points: [
            [
              "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
              "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
            ],
            [
              "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
              "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
            ],
            [
              "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
              "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
            ],
            [
              "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
              "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
            ],
            [
              "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
              "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
            ],
            [
              "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
              "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
            ],
            [
              "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
              "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
            ],
            [
              "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
              "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
            ],
            [
              "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
              "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
            ],
            [
              "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
              "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
            ],
            [
              "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
              "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
            ],
            [
              "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
              "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
            ],
            [
              "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
              "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
            ],
            [
              "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
              "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
            ],
            [
              "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
              "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
            ],
            [
              "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
              "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
            ],
            [
              "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
              "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
            ],
            [
              "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
              "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
            ],
            [
              "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
              "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
            ],
            [
              "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
              "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
            ],
            [
              "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
              "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
            ],
            [
              "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
              "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
            ],
            [
              "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
              "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
            ],
            [
              "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
              "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
            ],
            [
              "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
              "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
            ],
            [
              "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
              "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
            ],
            [
              "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
              "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
            ],
            [
              "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
              "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
            ],
            [
              "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
              "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
            ],
            [
              "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
              "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
            ],
            [
              "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
              "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
            ],
            [
              "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
              "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
            ],
            [
              "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
              "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
            ],
            [
              "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
              "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
            ],
            [
              "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
              "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
            ],
            [
              "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
              "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
            ],
            [
              "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
              "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
            ],
            [
              "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
              "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
            ],
            [
              "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
              "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
            ],
            [
              "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
              "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
            ],
            [
              "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
              "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
            ],
            [
              "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
              "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
            ],
            [
              "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
              "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
            ],
            [
              "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
              "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
            ],
            [
              "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
              "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
            ],
            [
              "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
              "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
            ],
            [
              "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
              "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
            ],
            [
              "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
              "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
            ],
            [
              "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
              "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
            ],
            [
              "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
              "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
            ],
            [
              "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
              "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
            ],
            [
              "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
              "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
            ],
            [
              "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
              "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
            ],
            [
              "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
              "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
            ],
            [
              "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
              "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
            ],
            [
              "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
              "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
            ],
            [
              "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
              "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
            ],
            [
              "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
              "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
            ],
            [
              "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
              "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
            ],
            [
              "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
              "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
            ],
            [
              "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
              "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
            ],
            [
              "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
              "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
            ],
            [
              "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
              "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
            ],
            [
              "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
              "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
            ],
            [
              "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
              "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
            ]
          ]
        },
        naf: {
          wnd: 7,
          points: [
            [
              "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
              "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
            ],
            [
              "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
              "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
            ],
            [
              "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
              "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
            ],
            [
              "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
              "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
            ],
            [
              "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
              "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
            ],
            [
              "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
              "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
            ],
            [
              "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
              "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
            ],
            [
              "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
              "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
            ],
            [
              "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
              "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
            ],
            [
              "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
              "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
            ],
            [
              "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
              "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
            ],
            [
              "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
              "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
            ],
            [
              "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
              "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
            ],
            [
              "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
              "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
            ],
            [
              "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
              "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
            ],
            [
              "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
              "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
            ],
            [
              "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
              "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
            ],
            [
              "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
              "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
            ],
            [
              "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
              "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
            ],
            [
              "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
              "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
            ],
            [
              "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
              "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
            ],
            [
              "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
              "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
            ],
            [
              "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
              "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
            ],
            [
              "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
              "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
            ],
            [
              "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
              "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
            ],
            [
              "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
              "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
            ],
            [
              "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
              "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
            ],
            [
              "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
              "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
            ],
            [
              "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
              "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
            ],
            [
              "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
              "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
            ],
            [
              "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
              "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
            ],
            [
              "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
              "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
            ],
            [
              "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
              "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
            ],
            [
              "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
              "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
            ],
            [
              "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
              "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
            ],
            [
              "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
              "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
            ],
            [
              "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
              "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
            ],
            [
              "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
              "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
            ],
            [
              "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
              "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
            ],
            [
              "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
              "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
            ],
            [
              "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
              "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
            ],
            [
              "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
              "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
            ],
            [
              "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
              "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
            ],
            [
              "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
              "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
            ],
            [
              "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
              "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
            ],
            [
              "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
              "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
            ],
            [
              "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
              "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
            ],
            [
              "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
              "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
            ],
            [
              "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
              "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
            ],
            [
              "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
              "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
            ],
            [
              "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
              "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
            ],
            [
              "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
              "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
            ],
            [
              "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
              "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
            ],
            [
              "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
              "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
            ],
            [
              "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
              "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
            ],
            [
              "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
              "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
            ],
            [
              "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
              "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
            ],
            [
              "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
              "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
            ],
            [
              "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
              "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
            ],
            [
              "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
              "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
            ],
            [
              "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
              "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
            ],
            [
              "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
              "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
            ],
            [
              "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
              "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
            ],
            [
              "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
              "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
            ],
            [
              "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
              "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
            ],
            [
              "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
              "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
            ],
            [
              "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
              "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
            ],
            [
              "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
              "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
            ],
            [
              "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
              "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
            ],
            [
              "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
              "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
            ],
            [
              "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
              "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
            ],
            [
              "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
              "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
            ],
            [
              "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
              "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
            ],
            [
              "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
              "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
            ],
            [
              "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
              "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
            ],
            [
              "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
              "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
            ],
            [
              "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
              "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
            ],
            [
              "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
              "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
            ],
            [
              "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
              "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
            ],
            [
              "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
              "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
            ],
            [
              "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
              "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
            ],
            [
              "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
              "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
            ],
            [
              "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
              "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
            ],
            [
              "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
              "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
            ],
            [
              "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
              "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
            ],
            [
              "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
              "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
            ],
            [
              "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
              "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
            ],
            [
              "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
              "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
            ],
            [
              "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
              "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
            ],
            [
              "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
              "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
            ],
            [
              "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
              "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
            ],
            [
              "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
              "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
            ],
            [
              "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
              "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
            ],
            [
              "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
              "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
            ],
            [
              "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
              "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
            ],
            [
              "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
              "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
            ],
            [
              "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
              "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
            ],
            [
              "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
              "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
            ],
            [
              "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
              "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
            ],
            [
              "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
              "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
            ],
            [
              "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
              "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
            ],
            [
              "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
              "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
            ],
            [
              "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
              "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
            ],
            [
              "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
              "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
            ],
            [
              "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
              "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
            ],
            [
              "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
              "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
            ],
            [
              "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
              "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
            ],
            [
              "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
              "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
            ],
            [
              "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
              "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
            ],
            [
              "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
              "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
            ],
            [
              "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
              "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
            ],
            [
              "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
              "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
            ],
            [
              "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
              "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
            ],
            [
              "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
              "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
            ],
            [
              "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
              "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
            ],
            [
              "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
              "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
            ],
            [
              "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
              "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
            ],
            [
              "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
              "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
            ],
            [
              "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
              "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
            ],
            [
              "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
              "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
            ],
            [
              "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
              "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
            ],
            [
              "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
              "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
            ],
            [
              "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
              "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
            ],
            [
              "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
              "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
            ],
            [
              "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
              "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
            ],
            [
              "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
              "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
            ],
            [
              "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
              "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
            ]
          ]
        }
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/curves.js
  var require_curves = __commonJS({
    "node_modules/elliptic/lib/elliptic/curves.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var curves = exports9;
      var hash = require_hash2();
      var curve = require_curve();
      var utils = require_utils4();
      var assert2 = utils.assert;
      function PresetCurve(options) {
        if (options.type === "short")
          this.curve = new curve.short(options);
        else if (options.type === "edwards")
          this.curve = new curve.edwards(options);
        else
          this.curve = new curve.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;
        assert2(this.g.validate(), "Invalid curve");
        assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      curves.PresetCurve = PresetCurve;
      function defineCurve(name2, options) {
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          get: function() {
            var curve2 = new PresetCurve(options);
            Object.defineProperty(curves, name2, {
              configurable: true,
              enumerable: true,
              value: curve2
            });
            return curve2;
          }
        });
      }
      defineCurve("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: hash.sha256,
        gRed: false,
        g: [
          "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
          "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
        ]
      });
      defineCurve("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: hash.sha256,
        gRed: false,
        g: [
          "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
          "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
        ]
      });
      defineCurve("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: hash.sha256,
        gRed: false,
        g: [
          "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
          "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
        ]
      });
      defineCurve("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: hash.sha384,
        gRed: false,
        g: [
          "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
          "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
        ]
      });
      defineCurve("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: hash.sha512,
        gRed: false,
        g: [
          "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
          "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
        ]
      });
      defineCurve("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash.sha256,
        gRed: false,
        g: [
          "9"
        ]
      });
      defineCurve("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        // -121665 * (121666^(-1)) (mod P)
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash.sha256,
        gRed: false,
        g: [
          "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
          // 4/5
          "6666666666666666666666666666666666666666666666666666666666666658"
        ]
      });
      var pre;
      try {
        pre = require_secp256k1();
      } catch (e) {
        pre = void 0;
      }
      defineCurve("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: hash.sha256,
        // Precomputed endomorphism
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [
          {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
          },
          {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
          }
        ],
        gRed: false,
        g: [
          "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
          "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
          pre
        ]
      });
    }
  });

  // node_modules/hmac-drbg/lib/hmac-drbg.js
  var require_hmac_drbg = __commonJS({
    "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var hash = require_hash2();
      var utils = require_utils3();
      var assert2 = require_minimalistic_assert();
      function HmacDRBG(options) {
        if (!(this instanceof HmacDRBG))
          return new HmacDRBG(options);
        this.hash = options.hash;
        this.predResist = !!options.predResist;
        this.outLen = this.hash.outSize;
        this.minEntropy = options.minEntropy || this.hash.hmacStrength;
        this._reseed = null;
        this.reseedInterval = null;
        this.K = null;
        this.V = null;
        var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
        var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
        var pers = utils.toArray(options.pers, options.persEnc || "hex");
        assert2(
          entropy.length >= this.minEntropy / 8,
          "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
        );
        this._init(entropy, nonce, pers);
      }
      module.exports = HmacDRBG;
      HmacDRBG.prototype._init = function init2(entropy, nonce, pers) {
        var seed = entropy.concat(nonce).concat(pers);
        this.K = new Array(this.outLen / 8);
        this.V = new Array(this.outLen / 8);
        for (var i = 0; i < this.V.length; i++) {
          this.K[i] = 0;
          this.V[i] = 1;
        }
        this._update(seed);
        this._reseed = 1;
        this.reseedInterval = 281474976710656;
      };
      HmacDRBG.prototype._hmac = function hmac() {
        return new hash.hmac(this.hash, this.K);
      };
      HmacDRBG.prototype._update = function update(seed) {
        var kmac = this._hmac().update(this.V).update([0]);
        if (seed)
          kmac = kmac.update(seed);
        this.K = kmac.digest();
        this.V = this._hmac().update(this.V).digest();
        if (!seed)
          return;
        this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
        this.V = this._hmac().update(this.V).digest();
      };
      HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
        if (typeof entropyEnc !== "string") {
          addEnc = add;
          add = entropyEnc;
          entropyEnc = null;
        }
        entropy = utils.toArray(entropy, entropyEnc);
        add = utils.toArray(add, addEnc);
        assert2(
          entropy.length >= this.minEntropy / 8,
          "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
        );
        this._update(entropy.concat(add || []));
        this._reseed = 1;
      };
      HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
        if (this._reseed > this.reseedInterval)
          throw new Error("Reseed is required");
        if (typeof enc !== "string") {
          addEnc = add;
          add = enc;
          enc = null;
        }
        if (add) {
          add = utils.toArray(add, addEnc || "hex");
          this._update(add);
        }
        var temp = [];
        while (temp.length < len) {
          this.V = this._hmac().update(this.V).digest();
          temp = temp.concat(this.V);
        }
        var res = temp.slice(0, len);
        this._update(add);
        this._reseed++;
        return utils.encode(res, enc);
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/ec/key.js
  var require_key = __commonJS({
    "node_modules/elliptic/lib/elliptic/ec/key.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var BN = require_bn2();
      var utils = require_utils4();
      var assert2 = utils.assert;
      function KeyPair(ec, options) {
        this.ec = ec;
        this.priv = null;
        this.pub = null;
        if (options.priv)
          this._importPrivate(options.priv, options.privEnc);
        if (options.pub)
          this._importPublic(options.pub, options.pubEnc);
      }
      module.exports = KeyPair;
      KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(ec, {
          pub,
          pubEnc: enc
        });
      };
      KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
        if (priv instanceof KeyPair)
          return priv;
        return new KeyPair(ec, {
          priv,
          privEnc: enc
        });
      };
      KeyPair.prototype.validate = function validate() {
        var pub = this.getPublic();
        if (pub.isInfinity())
          return { result: false, reason: "Invalid public key" };
        if (!pub.validate())
          return { result: false, reason: "Public key is not a point" };
        if (!pub.mul(this.ec.curve.n).isInfinity())
          return { result: false, reason: "Public key * N != O" };
        return { result: true, reason: null };
      };
      KeyPair.prototype.getPublic = function getPublic(compact, enc) {
        if (typeof compact === "string") {
          enc = compact;
          compact = null;
        }
        if (!this.pub)
          this.pub = this.ec.g.mul(this.priv);
        if (!enc)
          return this.pub;
        return this.pub.encode(enc, compact);
      };
      KeyPair.prototype.getPrivate = function getPrivate(enc) {
        if (enc === "hex")
          return this.priv.toString(16, 2);
        else
          return this.priv;
      };
      KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
        this.priv = new BN(key, enc || 16);
        this.priv = this.priv.umod(this.ec.curve.n);
      };
      KeyPair.prototype._importPublic = function _importPublic(key, enc) {
        if (key.x || key.y) {
          if (this.ec.curve.type === "mont") {
            assert2(key.x, "Need x coordinate");
          } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
            assert2(key.x && key.y, "Need both x and y coordinate");
          }
          this.pub = this.ec.curve.point(key.x, key.y);
          return;
        }
        this.pub = this.ec.curve.decodePoint(key, enc);
      };
      KeyPair.prototype.derive = function derive(pub) {
        if (!pub.validate()) {
          assert2(pub.validate(), "public point not validated");
        }
        return pub.mul(this.priv).getX();
      };
      KeyPair.prototype.sign = function sign3(msg, enc, options) {
        return this.ec.sign(msg, this, enc, options);
      };
      KeyPair.prototype.verify = function verify3(msg, signature) {
        return this.ec.verify(msg, signature, this);
      };
      KeyPair.prototype.inspect = function inspect2() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/ec/signature.js
  var require_signature = __commonJS({
    "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var BN = require_bn2();
      var utils = require_utils4();
      var assert2 = utils.assert;
      function Signature(options, enc) {
        if (options instanceof Signature)
          return options;
        if (this._importDER(options, enc))
          return;
        assert2(options.r && options.s, "Signature without r or s");
        this.r = new BN(options.r, 16);
        this.s = new BN(options.s, 16);
        if (options.recoveryParam === void 0)
          this.recoveryParam = null;
        else
          this.recoveryParam = options.recoveryParam;
      }
      module.exports = Signature;
      function Position() {
        this.place = 0;
      }
      function getLength(buf, p) {
        var initial = buf[p.place++];
        if (!(initial & 128)) {
          return initial;
        }
        var octetLen = initial & 15;
        if (octetLen === 0 || octetLen > 4) {
          return false;
        }
        if (buf[p.place] === 0) {
          return false;
        }
        var val = 0;
        for (var i = 0, off2 = p.place; i < octetLen; i++, off2++) {
          val <<= 8;
          val |= buf[off2];
          val >>>= 0;
        }
        if (val <= 127) {
          return false;
        }
        p.place = off2;
        return val;
      }
      function rmPadding(buf) {
        var i = 0;
        var len = buf.length - 1;
        while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
          i++;
        }
        if (i === 0) {
          return buf;
        }
        return buf.slice(i);
      }
      Signature.prototype._importDER = function _importDER(data, enc) {
        data = utils.toArray(data, enc);
        var p = new Position();
        if (data[p.place++] !== 48) {
          return false;
        }
        var len = getLength(data, p);
        if (len === false) {
          return false;
        }
        if (len + p.place !== data.length) {
          return false;
        }
        if (data[p.place++] !== 2) {
          return false;
        }
        var rlen = getLength(data, p);
        if (rlen === false) {
          return false;
        }
        if ((data[p.place] & 128) !== 0) {
          return false;
        }
        var r = data.slice(p.place, rlen + p.place);
        p.place += rlen;
        if (data[p.place++] !== 2) {
          return false;
        }
        var slen = getLength(data, p);
        if (slen === false) {
          return false;
        }
        if (data.length !== slen + p.place) {
          return false;
        }
        if ((data[p.place] & 128) !== 0) {
          return false;
        }
        var s = data.slice(p.place, slen + p.place);
        if (r[0] === 0) {
          if (r[1] & 128) {
            r = r.slice(1);
          } else {
            return false;
          }
        }
        if (s[0] === 0) {
          if (s[1] & 128) {
            s = s.slice(1);
          } else {
            return false;
          }
        }
        this.r = new BN(r);
        this.s = new BN(s);
        this.recoveryParam = null;
        return true;
      };
      function constructLength(arr, len) {
        if (len < 128) {
          arr.push(len);
          return;
        }
        var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
        arr.push(octets | 128);
        while (--octets) {
          arr.push(len >>> (octets << 3) & 255);
        }
        arr.push(len);
      }
      Signature.prototype.toDER = function toDER(enc) {
        var r = this.r.toArray();
        var s = this.s.toArray();
        if (r[0] & 128)
          r = [0].concat(r);
        if (s[0] & 128)
          s = [0].concat(s);
        r = rmPadding(r);
        s = rmPadding(s);
        while (!s[0] && !(s[1] & 128)) {
          s = s.slice(1);
        }
        var arr = [2];
        constructLength(arr, r.length);
        arr = arr.concat(r);
        arr.push(2);
        constructLength(arr, s.length);
        var backHalf = arr.concat(s);
        var res = [48];
        constructLength(res, backHalf.length);
        res = res.concat(backHalf);
        return utils.encode(res, enc);
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/ec/index.js
  var require_ec = __commonJS({
    "node_modules/elliptic/lib/elliptic/ec/index.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var BN = require_bn2();
      var HmacDRBG = require_hmac_drbg();
      var utils = require_utils4();
      var curves = require_curves();
      var rand = require_brorand();
      var assert2 = utils.assert;
      var KeyPair = require_key();
      var Signature = require_signature();
      function EC(options) {
        if (!(this instanceof EC))
          return new EC(options);
        if (typeof options === "string") {
          assert2(
            Object.prototype.hasOwnProperty.call(curves, options),
            "Unknown curve " + options
          );
          options = curves[options];
        }
        if (options instanceof curves.PresetCurve)
          options = { curve: options };
        this.curve = options.curve.curve;
        this.n = this.curve.n;
        this.nh = this.n.ushrn(1);
        this.g = this.curve.g;
        this.g = options.curve.g;
        this.g.precompute(options.curve.n.bitLength() + 1);
        this.hash = options.hash || options.curve.hash;
      }
      module.exports = EC;
      EC.prototype.keyPair = function keyPair(options) {
        return new KeyPair(this, options);
      };
      EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
        return KeyPair.fromPrivate(this, priv, enc);
      };
      EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
        return KeyPair.fromPublic(this, pub, enc);
      };
      EC.prototype.genKeyPair = function genKeyPair(options) {
        if (!options)
          options = {};
        var drbg = new HmacDRBG({
          hash: this.hash,
          pers: options.pers,
          persEnc: options.persEnc || "utf8",
          entropy: options.entropy || rand(this.hash.hmacStrength),
          entropyEnc: options.entropy && options.entropyEnc || "utf8",
          nonce: this.n.toArray()
        });
        var bytes = this.n.byteLength();
        var ns2 = this.n.sub(new BN(2));
        for (; ; ) {
          var priv = new BN(drbg.generate(bytes));
          if (priv.cmp(ns2) > 0)
            continue;
          priv.iaddn(1);
          return this.keyFromPrivate(priv);
        }
      };
      EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
        var delta = msg.byteLength() * 8 - this.n.bitLength();
        if (delta > 0)
          msg = msg.ushrn(delta);
        if (!truncOnly && msg.cmp(this.n) >= 0)
          return msg.sub(this.n);
        else
          return msg;
      };
      EC.prototype.sign = function sign3(msg, key, enc, options) {
        if (typeof enc === "object") {
          options = enc;
          enc = null;
        }
        if (!options)
          options = {};
        key = this.keyFromPrivate(key, enc);
        msg = this._truncateToN(new BN(msg, 16));
        var bytes = this.n.byteLength();
        var bkey = key.getPrivate().toArray("be", bytes);
        var nonce = msg.toArray("be", bytes);
        var drbg = new HmacDRBG({
          hash: this.hash,
          entropy: bkey,
          nonce,
          pers: options.pers,
          persEnc: options.persEnc || "utf8"
        });
        var ns1 = this.n.sub(new BN(1));
        for (var iter = 0; ; iter++) {
          var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
          k = this._truncateToN(k, true);
          if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
            continue;
          var kp = this.g.mul(k);
          if (kp.isInfinity())
            continue;
          var kpX = kp.getX();
          var r = kpX.umod(this.n);
          if (r.cmpn(0) === 0)
            continue;
          var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
          s = s.umod(this.n);
          if (s.cmpn(0) === 0)
            continue;
          var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
          if (options.canonical && s.cmp(this.nh) > 0) {
            s = this.n.sub(s);
            recoveryParam ^= 1;
          }
          return new Signature({ r, s, recoveryParam });
        }
      };
      EC.prototype.verify = function verify3(msg, signature, key, enc) {
        msg = this._truncateToN(new BN(msg, 16));
        key = this.keyFromPublic(key, enc);
        signature = new Signature(signature, "hex");
        var r = signature.r;
        var s = signature.s;
        if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
          return false;
        if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
          return false;
        var sinv = s.invm(this.n);
        var u1 = sinv.mul(msg).umod(this.n);
        var u2 = sinv.mul(r).umod(this.n);
        var p;
        if (!this.curve._maxwellTrick) {
          p = this.g.mulAdd(u1, key.getPublic(), u2);
          if (p.isInfinity())
            return false;
          return p.getX().umod(this.n).cmp(r) === 0;
        }
        p = this.g.jmulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.eqXToP(r);
      };
      EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
        assert2((3 & j) === j, "The recovery param is more than two bits");
        signature = new Signature(signature, enc);
        var n = this.n;
        var e = new BN(msg);
        var r = signature.r;
        var s = signature.s;
        var isYOdd = j & 1;
        var isSecondKey = j >> 1;
        if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
          throw new Error("Unable to find sencond key candinate");
        if (isSecondKey)
          r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
        else
          r = this.curve.pointFromX(r, isYOdd);
        var rInv = signature.r.invm(n);
        var s1 = n.sub(e).mul(rInv).umod(n);
        var s2 = s.mul(rInv).umod(n);
        return this.g.mulAdd(s1, r, s2);
      };
      EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
        signature = new Signature(signature, enc);
        if (signature.recoveryParam !== null)
          return signature.recoveryParam;
        for (var i = 0; i < 4; i++) {
          var Qprime;
          try {
            Qprime = this.recoverPubKey(e, signature, i);
          } catch (e2) {
            continue;
          }
          if (Qprime.eq(Q))
            return i;
        }
        throw new Error("Unable to find valid recovery factor");
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/eddsa/key.js
  var require_key2 = __commonJS({
    "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var utils = require_utils4();
      var assert2 = utils.assert;
      var parseBytes = utils.parseBytes;
      var cachedProperty = utils.cachedProperty;
      function KeyPair(eddsa, params) {
        this.eddsa = eddsa;
        this._secret = parseBytes(params.secret);
        if (eddsa.isPoint(params.pub))
          this._pub = params.pub;
        else
          this._pubBytes = parseBytes(params.pub);
      }
      KeyPair.fromPublic = function fromPublic(eddsa, pub) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(eddsa, { pub });
      };
      KeyPair.fromSecret = function fromSecret(eddsa, secret) {
        if (secret instanceof KeyPair)
          return secret;
        return new KeyPair(eddsa, { secret });
      };
      KeyPair.prototype.secret = function secret() {
        return this._secret;
      };
      cachedProperty(KeyPair, "pubBytes", function pubBytes() {
        return this.eddsa.encodePoint(this.pub());
      });
      cachedProperty(KeyPair, "pub", function pub() {
        if (this._pubBytes)
          return this.eddsa.decodePoint(this._pubBytes);
        return this.eddsa.g.mul(this.priv());
      });
      cachedProperty(KeyPair, "privBytes", function privBytes() {
        var eddsa = this.eddsa;
        var hash = this.hash();
        var lastIx = eddsa.encodingLength - 1;
        var a = hash.slice(0, eddsa.encodingLength);
        a[0] &= 248;
        a[lastIx] &= 127;
        a[lastIx] |= 64;
        return a;
      });
      cachedProperty(KeyPair, "priv", function priv() {
        return this.eddsa.decodeInt(this.privBytes());
      });
      cachedProperty(KeyPair, "hash", function hash() {
        return this.eddsa.hash().update(this.secret()).digest();
      });
      cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
        return this.hash().slice(this.eddsa.encodingLength);
      });
      KeyPair.prototype.sign = function sign3(message) {
        assert2(this._secret, "KeyPair can only verify");
        return this.eddsa.sign(message, this);
      };
      KeyPair.prototype.verify = function verify3(message, sig) {
        return this.eddsa.verify(message, sig, this);
      };
      KeyPair.prototype.getSecret = function getSecret(enc) {
        assert2(this._secret, "KeyPair is public only");
        return utils.encode(this.secret(), enc);
      };
      KeyPair.prototype.getPublic = function getPublic(enc) {
        return utils.encode(this.pubBytes(), enc);
      };
      module.exports = KeyPair;
    }
  });

  // node_modules/elliptic/lib/elliptic/eddsa/signature.js
  var require_signature2 = __commonJS({
    "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var BN = require_bn2();
      var utils = require_utils4();
      var assert2 = utils.assert;
      var cachedProperty = utils.cachedProperty;
      var parseBytes = utils.parseBytes;
      function Signature(eddsa, sig) {
        this.eddsa = eddsa;
        if (typeof sig !== "object")
          sig = parseBytes(sig);
        if (Array.isArray(sig)) {
          assert2(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
          sig = {
            R: sig.slice(0, eddsa.encodingLength),
            S: sig.slice(eddsa.encodingLength)
          };
        }
        assert2(sig.R && sig.S, "Signature without R or S");
        if (eddsa.isPoint(sig.R))
          this._R = sig.R;
        if (sig.S instanceof BN)
          this._S = sig.S;
        this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
        this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
      }
      cachedProperty(Signature, "S", function S() {
        return this.eddsa.decodeInt(this.Sencoded());
      });
      cachedProperty(Signature, "R", function R() {
        return this.eddsa.decodePoint(this.Rencoded());
      });
      cachedProperty(Signature, "Rencoded", function Rencoded() {
        return this.eddsa.encodePoint(this.R());
      });
      cachedProperty(Signature, "Sencoded", function Sencoded() {
        return this.eddsa.encodeInt(this.S());
      });
      Signature.prototype.toBytes = function toBytes() {
        return this.Rencoded().concat(this.Sencoded());
      };
      Signature.prototype.toHex = function toHex2() {
        return utils.encode(this.toBytes(), "hex").toUpperCase();
      };
      module.exports = Signature;
    }
  });

  // node_modules/elliptic/lib/elliptic/eddsa/index.js
  var require_eddsa = __commonJS({
    "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var hash = require_hash2();
      var curves = require_curves();
      var utils = require_utils4();
      var assert2 = utils.assert;
      var parseBytes = utils.parseBytes;
      var KeyPair = require_key2();
      var Signature = require_signature2();
      function EDDSA(curve) {
        assert2(curve === "ed25519", "only tested with ed25519 so far");
        if (!(this instanceof EDDSA))
          return new EDDSA(curve);
        curve = curves[curve].curve;
        this.curve = curve;
        this.g = curve.g;
        this.g.precompute(curve.n.bitLength() + 1);
        this.pointClass = curve.point().constructor;
        this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
        this.hash = hash.sha512;
      }
      module.exports = EDDSA;
      EDDSA.prototype.sign = function sign3(message, secret) {
        message = parseBytes(message);
        var key = this.keyFromSecret(secret);
        var r = this.hashInt(key.messagePrefix(), message);
        var R = this.g.mul(r);
        var Rencoded = this.encodePoint(R);
        var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
        var S = r.add(s_).umod(this.curve.n);
        return this.makeSignature({ R, S, Rencoded });
      };
      EDDSA.prototype.verify = function verify3(message, sig, pub) {
        message = parseBytes(message);
        sig = this.makeSignature(sig);
        if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
          return false;
        }
        var key = this.keyFromPublic(pub);
        var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
        var SG = this.g.mul(sig.S());
        var RplusAh = sig.R().add(key.pub().mul(h));
        return RplusAh.eq(SG);
      };
      EDDSA.prototype.hashInt = function hashInt() {
        var hash2 = this.hash();
        for (var i = 0; i < arguments.length; i++)
          hash2.update(arguments[i]);
        return utils.intFromLE(hash2.digest()).umod(this.curve.n);
      };
      EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
        return KeyPair.fromPublic(this, pub);
      };
      EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
        return KeyPair.fromSecret(this, secret);
      };
      EDDSA.prototype.makeSignature = function makeSignature(sig) {
        if (sig instanceof Signature)
          return sig;
        return new Signature(this, sig);
      };
      EDDSA.prototype.encodePoint = function encodePoint(point) {
        var enc = point.getY().toArray("le", this.encodingLength);
        enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
        return enc;
      };
      EDDSA.prototype.decodePoint = function decodePoint(bytes) {
        bytes = utils.parseBytes(bytes);
        var lastIx = bytes.length - 1;
        var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
        var xIsOdd = (bytes[lastIx] & 128) !== 0;
        var y = utils.intFromLE(normed);
        return this.curve.pointFromY(y, xIsOdd);
      };
      EDDSA.prototype.encodeInt = function encodeInt(num) {
        return num.toArray("le", this.encodingLength);
      };
      EDDSA.prototype.decodeInt = function decodeInt(bytes) {
        return utils.intFromLE(bytes);
      };
      EDDSA.prototype.isPoint = function isPoint4(val) {
        return val instanceof this.pointClass;
      };
    }
  });

  // node_modules/elliptic/lib/elliptic.js
  var require_elliptic = __commonJS({
    "node_modules/elliptic/lib/elliptic.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var elliptic = exports9;
      elliptic.version = require_package().version;
      elliptic.utils = require_utils4();
      elliptic.rand = require_brorand();
      elliptic.curve = require_curve();
      elliptic.curves = require_curves();
      elliptic.ec = require_ec();
      elliptic.eddsa = require_eddsa();
    }
  });

  // node_modules/secp256k1/lib/elliptic/index.js
  var require_elliptic2 = __commonJS({
    "node_modules/secp256k1/lib/elliptic/index.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var Buffer3 = require_safe_buffer().Buffer;
      var createHash = require_browser();
      var BN = require_bn();
      var EC = require_elliptic().ec;
      var messages = require_messages();
      var ec = new EC("secp256k1");
      var ecparams = ec.curve;
      function loadCompressedPublicKey(first, xBuffer) {
        var x = new BN(xBuffer);
        if (x.cmp(ecparams.p) >= 0) return null;
        x = x.toRed(ecparams.red);
        var y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
        if (first === 3 !== y.isOdd()) y = y.redNeg();
        const x3 = x.redSqr().redIMul(x);
        if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null;
        return ec.keyPair({ pub: { x, y } });
      }
      function loadUncompressedPublicKey(first, xBuffer, yBuffer) {
        var x = new BN(xBuffer);
        var y = new BN(yBuffer);
        if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null;
        x = x.toRed(ecparams.red);
        y = y.toRed(ecparams.red);
        if ((first === 6 || first === 7) && y.isOdd() !== (first === 7)) return null;
        var x3 = x.redSqr().redIMul(x);
        if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null;
        return ec.keyPair({ pub: { x, y } });
      }
      function loadPublicKey(publicKey) {
        var first = publicKey[0];
        switch (first) {
          case 2:
          case 3:
            if (publicKey.length !== 33) return null;
            return loadCompressedPublicKey(first, publicKey.slice(1, 33));
          case 4:
          case 6:
          case 7:
            if (publicKey.length !== 65) return null;
            return loadUncompressedPublicKey(first, publicKey.slice(1, 33), publicKey.slice(33, 65));
          default:
            return null;
        }
      }
      exports9.privateKeyVerify = function(privateKey) {
        var bn = new BN(privateKey);
        return bn.cmp(ecparams.n) < 0 && !bn.isZero();
      };
      exports9.privateKeyExport = function(privateKey, compressed) {
        var d = new BN(privateKey);
        if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PRIVATE_KEY_EXPORT_DER_FAIL);
        return Buffer3.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true));
      };
      exports9.privateKeyNegate = function(privateKey) {
        var bn = new BN(privateKey);
        return bn.isZero() ? Buffer3.alloc(32) : ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Buffer3, "be", 32);
      };
      exports9.privateKeyModInverse = function(privateKey) {
        var bn = new BN(privateKey);
        if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_RANGE_INVALID);
        return bn.invm(ecparams.n).toArrayLike(Buffer3, "be", 32);
      };
      exports9.privateKeyTweakAdd = function(privateKey, tweak) {
        var bn = new BN(tweak);
        if (bn.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);
        bn.iadd(new BN(privateKey));
        if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n);
        if (bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);
        return bn.toArrayLike(Buffer3, "be", 32);
      };
      exports9.privateKeyTweakMul = function(privateKey, tweak) {
        var bn = new BN(tweak);
        if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_MUL_FAIL);
        bn.imul(new BN(privateKey));
        if (bn.cmp(ecparams.n)) bn = bn.umod(ecparams.n);
        return bn.toArrayLike(Buffer3, "be", 32);
      };
      exports9.publicKeyCreate = function(privateKey, compressed) {
        var d = new BN(privateKey);
        if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PUBLIC_KEY_CREATE_FAIL);
        return Buffer3.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true));
      };
      exports9.publicKeyConvert = function(publicKey, compressed) {
        var pair = loadPublicKey(publicKey);
        if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
        return Buffer3.from(pair.getPublic(compressed, true));
      };
      exports9.publicKeyVerify = function(publicKey) {
        return loadPublicKey(publicKey) !== null;
      };
      exports9.publicKeyTweakAdd = function(publicKey, tweak, compressed) {
        var pair = loadPublicKey(publicKey);
        if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
        tweak = new BN(tweak);
        if (tweak.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL);
        var point = ecparams.g.mul(tweak).add(pair.pub);
        if (point.isInfinity()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL);
        return Buffer3.from(point.encode(true, compressed));
      };
      exports9.publicKeyTweakMul = function(publicKey, tweak, compressed) {
        var pair = loadPublicKey(publicKey);
        if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
        tweak = new BN(tweak);
        if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_MUL_FAIL);
        return Buffer3.from(pair.pub.mul(tweak).encode(true, compressed));
      };
      exports9.publicKeyCombine = function(publicKeys, compressed) {
        var pairs = new Array(publicKeys.length);
        for (var i = 0; i < publicKeys.length; ++i) {
          pairs[i] = loadPublicKey(publicKeys[i]);
          if (pairs[i] === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
        }
        var point = pairs[0].pub;
        for (var j = 1; j < pairs.length; ++j) point = point.add(pairs[j].pub);
        if (point.isInfinity()) throw new Error(messages.EC_PUBLIC_KEY_COMBINE_FAIL);
        return Buffer3.from(point.encode(true, compressed));
      };
      exports9.signatureNormalize = function(signature) {
        var r = new BN(signature.slice(0, 32));
        var s = new BN(signature.slice(32, 64));
        if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
        var result = Buffer3.from(signature);
        if (s.cmp(ec.nh) === 1) ecparams.n.sub(s).toArrayLike(Buffer3, "be", 32).copy(result, 32);
        return result;
      };
      exports9.signatureExport = function(signature) {
        var r = signature.slice(0, 32);
        var s = signature.slice(32, 64);
        if (new BN(r).cmp(ecparams.n) >= 0 || new BN(s).cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
        return { r, s };
      };
      exports9.signatureImport = function(sigObj) {
        var r = new BN(sigObj.r);
        if (r.cmp(ecparams.n) >= 0) r = new BN(0);
        var s = new BN(sigObj.s);
        if (s.cmp(ecparams.n) >= 0) s = new BN(0);
        return Buffer3.concat([
          r.toArrayLike(Buffer3, "be", 32),
          s.toArrayLike(Buffer3, "be", 32)
        ]);
      };
      exports9.sign = function(message, privateKey, noncefn, data) {
        if (typeof noncefn === "function") {
          var getNonce = noncefn;
          noncefn = function(counter) {
            var nonce = getNonce(message, privateKey, null, data, counter);
            if (!Buffer3.isBuffer(nonce) || nonce.length !== 32) throw new Error(messages.ECDSA_SIGN_FAIL);
            return new BN(nonce);
          };
        }
        var d = new BN(privateKey);
        if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.ECDSA_SIGN_FAIL);
        var result = ec.sign(message, privateKey, { canonical: true, k: noncefn, pers: data });
        return {
          signature: Buffer3.concat([
            result.r.toArrayLike(Buffer3, "be", 32),
            result.s.toArrayLike(Buffer3, "be", 32)
          ]),
          recovery: result.recoveryParam
        };
      };
      exports9.verify = function(message, signature, publicKey) {
        var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) };
        var sigr = new BN(sigObj.r);
        var sigs = new BN(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
        if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return false;
        var pair = loadPublicKey(publicKey);
        if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
        return ec.verify(message, sigObj, { x: pair.pub.x, y: pair.pub.y });
      };
      exports9.recover = function(message, signature, recovery, compressed) {
        var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) };
        var sigr = new BN(sigObj.r);
        var sigs = new BN(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
        try {
          if (sigr.isZero() || sigs.isZero()) throw new Error();
          var point = ec.recoverPubKey(message, sigObj, recovery);
          return Buffer3.from(point.encode(true, compressed));
        } catch (err) {
          throw new Error(messages.ECDSA_RECOVER_FAIL);
        }
      };
      exports9.ecdh = function(publicKey, privateKey) {
        var shared = exports9.ecdhUnsafe(publicKey, privateKey, true);
        return createHash("sha256").update(shared).digest();
      };
      exports9.ecdhUnsafe = function(publicKey, privateKey, compressed) {
        var pair = loadPublicKey(publicKey);
        if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
        var scalar = new BN(privateKey);
        if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) throw new Error(messages.ECDH_FAIL);
        return Buffer3.from(pair.pub.mul(scalar).encode(true, compressed));
      };
    }
  });

  // node_modules/secp256k1/elliptic.js
  var require_elliptic3 = __commonJS({
    "node_modules/secp256k1/elliptic.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module.exports = require_lib()(require_elliptic2());
    }
  });

  // node_modules/bitcoinjs-message/index.js
  var require_bitcoinjs_message = __commonJS({
    "node_modules/bitcoinjs-message/index.js"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var bs58check = require_bs58check2();
      var bech32 = require_bech32();
      var bufferEquals = require_buffer_equals();
      var createHash = require_browser();
      var secp256k1 = require_elliptic3();
      var varuint = require_varuint_bitcoin();
      var SEGWIT_TYPES = {
        P2WPKH: "p2wpkh",
        P2SH_P2WPKH: "p2sh(p2wpkh)"
      };
      function sha256(b) {
        return createHash("sha256").update(b).digest();
      }
      function hash256(buffer) {
        return sha256(sha256(buffer));
      }
      function hash160(buffer) {
        return createHash("ripemd160").update(sha256(buffer)).digest();
      }
      function encodeSignature(signature, recovery, compressed, segwitType) {
        if (segwitType !== void 0) {
          recovery += 8;
          if (segwitType === SEGWIT_TYPES.P2WPKH) recovery += 4;
        } else {
          if (compressed) recovery += 4;
        }
        return Buffer2.concat([Buffer2.alloc(1, recovery + 27), signature]);
      }
      function decodeSignature(buffer) {
        if (buffer.length !== 65) throw new Error("Invalid signature length");
        const flagByte = buffer.readUInt8(0) - 27;
        if (flagByte > 15 || flagByte < 0) {
          throw new Error("Invalid signature parameter");
        }
        return {
          compressed: !!(flagByte & 12),
          segwitType: !(flagByte & 8) ? null : !(flagByte & 4) ? SEGWIT_TYPES.P2SH_P2WPKH : SEGWIT_TYPES.P2WPKH,
          recovery: flagByte & 3,
          signature: buffer.slice(1)
        };
      }
      function magicHash(message, messagePrefix) {
        messagePrefix = messagePrefix || "Bitcoin Signed Message:\n";
        if (!Buffer2.isBuffer(messagePrefix)) {
          messagePrefix = Buffer2.from(messagePrefix, "utf8");
        }
        if (!Buffer2.isBuffer(message)) {
          message = Buffer2.from(message, "utf8");
        }
        const messageVISize = varuint.encodingLength(message.length);
        const buffer = Buffer2.allocUnsafe(
          messagePrefix.length + messageVISize + message.length
        );
        messagePrefix.copy(buffer, 0);
        varuint.encode(message.length, buffer, messagePrefix.length);
        message.copy(buffer, messagePrefix.length + messageVISize);
        return hash256(buffer);
      }
      function prepareSign(messagePrefixArg, sigOptions) {
        if (typeof messagePrefixArg === "object" && sigOptions === void 0) {
          sigOptions = messagePrefixArg;
          messagePrefixArg = void 0;
        }
        let { segwitType, extraEntropy } = sigOptions || {};
        if (segwitType && (typeof segwitType === "string" || segwitType instanceof String)) {
          segwitType = segwitType.toLowerCase();
        }
        if (segwitType && segwitType !== SEGWIT_TYPES.P2SH_P2WPKH && segwitType !== SEGWIT_TYPES.P2WPKH) {
          throw new Error(
            'Unrecognized segwitType: use "' + SEGWIT_TYPES.P2SH_P2WPKH + '" or "' + SEGWIT_TYPES.P2WPKH + '"'
          );
        }
        return {
          messagePrefixArg,
          segwitType,
          extraEntropy
        };
      }
      function isSigner(obj) {
        return obj && typeof obj.sign === "function";
      }
      function sign3(message, privateKey, compressed, messagePrefix, sigOptions) {
        const {
          messagePrefixArg,
          segwitType,
          extraEntropy
        } = prepareSign(messagePrefix, sigOptions);
        const hash = magicHash(message, messagePrefixArg);
        const sigObj = isSigner(privateKey) ? privateKey.sign(hash, extraEntropy) : secp256k1.sign(hash, privateKey, { data: extraEntropy });
        return encodeSignature(
          sigObj.signature,
          sigObj.recovery,
          compressed,
          segwitType
        );
      }
      function signAsync(message, privateKey, compressed, messagePrefix, sigOptions) {
        let messagePrefixArg, segwitType, extraEntropy;
        return Promise.resolve().then(() => {
          ({
            messagePrefixArg,
            segwitType,
            extraEntropy
          } = prepareSign(messagePrefix, sigOptions));
          const hash = magicHash(message, messagePrefixArg);
          return isSigner(privateKey) ? privateKey.sign(hash, extraEntropy) : secp256k1.sign(hash, privateKey, { data: extraEntropy });
        }).then((sigObj) => {
          return encodeSignature(
            sigObj.signature,
            sigObj.recovery,
            compressed,
            segwitType
          );
        });
      }
      function segwitRedeemHash(publicKeyHash) {
        const redeemScript = Buffer2.concat([
          Buffer2.from("0014", "hex"),
          publicKeyHash
        ]);
        return hash160(redeemScript);
      }
      function decodeBech32(address) {
        const result = bech32.decode(address);
        const data = bech32.fromWords(result.words.slice(1));
        return Buffer2.from(data);
      }
      function verify3(message, address, signature, messagePrefix, checkSegwitAlways) {
        if (!Buffer2.isBuffer(signature)) signature = Buffer2.from(signature, "base64");
        const parsed = decodeSignature(signature);
        if (checkSegwitAlways && !parsed.compressed) {
          throw new Error("checkSegwitAlways can only be used with a compressed pubkey signature flagbyte");
        }
        const hash = magicHash(message, messagePrefix);
        const publicKey = secp256k1.recover(
          hash,
          parsed.signature,
          parsed.recovery,
          parsed.compressed
        );
        const publicKeyHash = hash160(publicKey);
        let actual, expected;
        if (parsed.segwitType) {
          if (parsed.segwitType === SEGWIT_TYPES.P2SH_P2WPKH) {
            actual = segwitRedeemHash(publicKeyHash);
            expected = bs58check.decode(address).slice(1);
          } else {
            actual = publicKeyHash;
            expected = decodeBech32(address);
          }
        } else {
          if (checkSegwitAlways) {
            try {
              expected = decodeBech32(address);
              return bufferEquals(publicKeyHash, expected);
            } catch (e) {
              const redeemHash = segwitRedeemHash(publicKeyHash);
              expected = bs58check.decode(address).slice(1);
              return bufferEquals(publicKeyHash, expected) || bufferEquals(redeemHash, expected);
            }
          } else {
            actual = publicKeyHash;
            expected = bs58check.decode(address).slice(1);
          }
        }
        return bufferEquals(actual, expected);
      }
      module.exports = {
        magicHash,
        sign: sign3,
        signAsync,
        verify: verify3
      };
    }
  });

  // node_modules/@noble/hashes/hmac.js
  var require_hmac2 = __commonJS({
    "node_modules/@noble/hashes/hmac.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.hmac = exports9.HMAC = void 0;
      var _assert_js_1 = require_assert();
      var utils_js_1 = require_utils();
      var HMAC = class extends utils_js_1.Hash {
        constructor(hash, _key) {
          super();
          this.finished = false;
          this.destroyed = false;
          (0, _assert_js_1.hash)(hash);
          const key = (0, utils_js_1.toBytes)(_key);
          this.iHash = hash.create();
          if (typeof this.iHash.update !== "function")
            throw new Error("Expected instance of class which extends utils.Hash");
          this.blockLen = this.iHash.blockLen;
          this.outputLen = this.iHash.outputLen;
          const blockLen = this.blockLen;
          const pad = new Uint8Array(blockLen);
          pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
          for (let i = 0; i < pad.length; i++)
            pad[i] ^= 54;
          this.iHash.update(pad);
          this.oHash = hash.create();
          for (let i = 0; i < pad.length; i++)
            pad[i] ^= 54 ^ 92;
          this.oHash.update(pad);
          pad.fill(0);
        }
        update(buf) {
          (0, _assert_js_1.exists)(this);
          this.iHash.update(buf);
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.bytes)(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
        }
        digest() {
          const out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
        }
        _cloneInto(to) {
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          const { oHash, iHash, finished: finished2, destroyed, blockLen, outputLen } = this;
          to = to;
          to.finished = finished2;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
        }
        destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
        }
      };
      exports9.HMAC = HMAC;
      var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
      exports9.hmac = hmac;
      exports9.hmac.create = (hash, key) => new HMAC(hash, key);
    }
  });

  // node_modules/@noble/hashes/_u64.js
  var require_u64 = __commonJS({
    "node_modules/@noble/hashes/_u64.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.add5L = exports9.add5H = exports9.add4H = exports9.add4L = exports9.add3H = exports9.add3L = exports9.rotlBL = exports9.rotlBH = exports9.rotlSL = exports9.rotlSH = exports9.rotr32L = exports9.rotr32H = exports9.rotrBL = exports9.rotrBH = exports9.rotrSL = exports9.rotrSH = exports9.shrSL = exports9.shrSH = exports9.toBig = void 0;
      exports9.fromBig = fromBig;
      exports9.split = split;
      exports9.add = add;
      var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      var _32n = /* @__PURE__ */ BigInt(32);
      function fromBig(n, le = false) {
        if (le)
          return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
        return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
      }
      function split(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
          const { h, l } = fromBig(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
      }
      var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
      exports9.toBig = toBig;
      var shrSH = (h, _l, s) => h >>> s;
      exports9.shrSH = shrSH;
      var shrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports9.shrSL = shrSL;
      var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
      exports9.rotrSH = rotrSH;
      var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports9.rotrSL = rotrSL;
      var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
      exports9.rotrBH = rotrBH;
      var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
      exports9.rotrBL = rotrBL;
      var rotr32H = (_h, l) => l;
      exports9.rotr32H = rotr32H;
      var rotr32L = (h, _l) => h;
      exports9.rotr32L = rotr32L;
      var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
      exports9.rotlSH = rotlSH;
      var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
      exports9.rotlSL = rotlSL;
      var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
      exports9.rotlBH = rotlBH;
      var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
      exports9.rotlBL = rotlBL;
      function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
      }
      var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      exports9.add3L = add3L;
      var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      exports9.add3H = add3H;
      var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      exports9.add4L = add4L;
      var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      exports9.add4H = add4H;
      var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      exports9.add5L = add5L;
      var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      exports9.add5H = add5H;
      var u64 = {
        fromBig,
        split,
        toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      exports9.default = u64;
    }
  });

  // node_modules/@noble/hashes/sha512.js
  var require_sha5122 = __commonJS({
    "node_modules/@noble/hashes/sha512.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.sha384 = exports9.sha512_256 = exports9.sha512_224 = exports9.sha512 = exports9.SHA384 = exports9.SHA512_256 = exports9.SHA512_224 = exports9.SHA512 = void 0;
      var _md_js_1 = require_md();
      var _u64_js_1 = require_u64();
      var utils_js_1 = require_utils();
      var [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js_1.default.split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
      ].map((n) => BigInt(n))))();
      var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
      var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
      var SHA512 = class extends _md_js_1.HashMD {
        constructor() {
          super(128, 64, 16, false);
          this.Ah = 1779033703 | 0;
          this.Al = 4089235720 | 0;
          this.Bh = 3144134277 | 0;
          this.Bl = 2227873595 | 0;
          this.Ch = 1013904242 | 0;
          this.Cl = 4271175723 | 0;
          this.Dh = 2773480762 | 0;
          this.Dl = 1595750129 | 0;
          this.Eh = 1359893119 | 0;
          this.El = 2917565137 | 0;
          this.Fh = 2600822924 | 0;
          this.Fl = 725511199 | 0;
          this.Gh = 528734635 | 0;
          this.Gl = 4215389547 | 0;
          this.Hh = 1541459225 | 0;
          this.Hl = 327033209 | 0;
        }
        // prettier-ignore
        get() {
          const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
          }
          for (let i = 16; i < 80; i++) {
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
          }
          let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          for (let i = 0; i < 80; i++) {
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }
          ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
          ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
          ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
          ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
          ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
          ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
          ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
          ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
          SHA512_W_H.fill(0);
          SHA512_W_L.fill(0);
        }
        destroy() {
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      exports9.SHA512 = SHA512;
      var SHA512_224 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 2352822216 | 0;
          this.Al = 424955298 | 0;
          this.Bh = 1944164710 | 0;
          this.Bl = 2312950998 | 0;
          this.Ch = 502970286 | 0;
          this.Cl = 855612546 | 0;
          this.Dh = 1738396948 | 0;
          this.Dl = 1479516111 | 0;
          this.Eh = 258812777 | 0;
          this.El = 2077511080 | 0;
          this.Fh = 2011393907 | 0;
          this.Fl = 79989058 | 0;
          this.Gh = 1067287976 | 0;
          this.Gl = 1780299464 | 0;
          this.Hh = 286451373 | 0;
          this.Hl = 2446758561 | 0;
          this.outputLen = 28;
        }
      };
      exports9.SHA512_224 = SHA512_224;
      var SHA512_256 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 573645204 | 0;
          this.Al = 4230739756 | 0;
          this.Bh = 2673172387 | 0;
          this.Bl = 3360449730 | 0;
          this.Ch = 596883563 | 0;
          this.Cl = 1867755857 | 0;
          this.Dh = 2520282905 | 0;
          this.Dl = 1497426621 | 0;
          this.Eh = 2519219938 | 0;
          this.El = 2827943907 | 0;
          this.Fh = 3193839141 | 0;
          this.Fl = 1401305490 | 0;
          this.Gh = 721525244 | 0;
          this.Gl = 746961066 | 0;
          this.Hh = 246885852 | 0;
          this.Hl = 2177182882 | 0;
          this.outputLen = 32;
        }
      };
      exports9.SHA512_256 = SHA512_256;
      var SHA384 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 3418070365 | 0;
          this.Al = 3238371032 | 0;
          this.Bh = 1654270250 | 0;
          this.Bl = 914150663 | 0;
          this.Ch = 2438529370 | 0;
          this.Cl = 812702999 | 0;
          this.Dh = 355462360 | 0;
          this.Dl = 4144912697 | 0;
          this.Eh = 1731405415 | 0;
          this.El = 4290775857 | 0;
          this.Fh = 2394180231 | 0;
          this.Fl = 1750603025 | 0;
          this.Gh = 3675008525 | 0;
          this.Gl = 1694076839 | 0;
          this.Hh = 1203062813 | 0;
          this.Hl = 3204075428 | 0;
          this.outputLen = 48;
        }
      };
      exports9.SHA384 = SHA384;
      exports9.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
      exports9.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
      exports9.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
      exports9.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
    }
  });

  // node_modules/bip32/src/cjs/crypto.cjs
  var require_crypto3 = __commonJS({
    "node_modules/bip32/src/cjs/crypto.cjs"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.hash160 = hash160;
      exports9.hmacSHA512 = hmacSHA512;
      var hmac_1 = require_hmac2();
      var ripemd160_1 = require_ripemd160();
      var sha256_1 = require_sha256();
      var sha512_1 = require_sha5122();
      function hash160(buffer) {
        return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(buffer));
      }
      function hmacSHA512(key, data) {
        return (0, hmac_1.hmac)(sha512_1.sha512, key, data);
      }
    }
  });

  // node_modules/uint8array-tools/src/mjs/browser.js
  var browser_exports = {};
  __export(browser_exports, {
    compare: () => compare,
    concat: () => concat,
    fromBase64: () => fromBase64,
    fromHex: () => fromHex,
    fromUtf8: () => fromUtf8,
    readUInt16: () => readUInt16,
    readUInt32: () => readUInt32,
    readUInt64: () => readUInt64,
    readUInt8: () => readUInt8,
    toBase64: () => toBase64,
    toHex: () => toHex,
    toUtf8: () => toUtf8,
    writeUInt16: () => writeUInt16,
    writeUInt32: () => writeUInt32,
    writeUInt64: () => writeUInt64,
    writeUInt8: () => writeUInt8
  });
  function toUtf8(bytes) {
    return DECODER.decode(bytes);
  }
  function fromUtf8(s) {
    return ENCODER.encode(s);
  }
  function concat(arrays) {
    const totalLength = arrays.reduce((a, b) => a + b.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const array of arrays) {
      result.set(array, offset);
      offset += array.length;
    }
    return result;
  }
  function toHex(bytes) {
    const b = bytes || new Uint8Array();
    return b.length > 512 ? _toHexLengthPerf(b) : _toHexIterPerf(b);
  }
  function _toHexIterPerf(bytes) {
    let s = "";
    for (let i = 0; i < bytes.length; ++i) {
      s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] >> 4]]];
      s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] & 15]]];
    }
    return s;
  }
  function _toHexLengthPerf(bytes) {
    const hexBytes = new Uint8Array(bytes.length * 2);
    for (let i = 0; i < bytes.length; ++i) {
      hexBytes[i * 2] = HEX_CODES[bytes[i] >> 4];
      hexBytes[i * 2 + 1] = HEX_CODES[bytes[i] & 15];
    }
    return DECODER.decode(hexBytes);
  }
  function fromHex(hexString) {
    const hexBytes = ENCODER.encode(hexString || "");
    const resultBytes = new Uint8Array(Math.floor(hexBytes.length / 2));
    let i;
    for (i = 0; i < resultBytes.length; i++) {
      const a = HEX_CODEPOINTS[hexBytes[i * 2]];
      const b = HEX_CODEPOINTS[hexBytes[i * 2 + 1]];
      if (a === void 0 || b === void 0) {
        break;
      }
      resultBytes[i] = a << 4 | b;
    }
    return i === resultBytes.length ? resultBytes : resultBytes.slice(0, i);
  }
  function toBase64(bytes) {
    return btoa(String.fromCharCode(...bytes));
  }
  function fromBase64(base64) {
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  }
  function compare(v1, v2) {
    const minLength = Math.min(v1.length, v2.length);
    for (let i = 0; i < minLength; ++i) {
      if (v1[i] !== v2[i]) {
        return v1[i] < v2[i] ? -1 : 1;
      }
    }
    return v1.length === v2.length ? 0 : v1.length > v2.length ? 1 : -1;
  }
  function writeUInt8(buffer, offset, value) {
    if (offset + 1 > buffer.length) {
      throw new Error("Offset is outside the bounds of Uint8Array");
    }
    if (value > 255) {
      throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${255}. Received ${value}`);
    }
    buffer[offset] = value;
  }
  function writeUInt16(buffer, offset, value, littleEndian) {
    if (offset + 2 > buffer.length) {
      throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (value > 65535) {
      throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${65535}. Received ${value}`);
    }
    if (littleEndian === "LE") {
      buffer[offset] = value & 255;
      buffer[offset + 1] = value >> 8 & 255;
    } else {
      buffer[offset] = value >> 8 & 255;
      buffer[offset + 1] = value & 255;
    }
  }
  function writeUInt32(buffer, offset, value, littleEndian) {
    if (offset + 4 > buffer.length) {
      throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (value > 4294967295) {
      throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${value}`);
    }
    if (littleEndian === "LE") {
      buffer[offset] = value & 255;
      buffer[offset + 1] = value >> 8 & 255;
      buffer[offset + 2] = value >> 16 & 255;
      buffer[offset + 3] = value >> 24 & 255;
    } else {
      buffer[offset] = value >> 24 & 255;
      buffer[offset + 1] = value >> 16 & 255;
      buffer[offset + 2] = value >> 8 & 255;
      buffer[offset + 3] = value & 255;
    }
  }
  function writeUInt64(buffer, offset, value, littleEndian) {
    if (offset + 8 > buffer.length) {
      throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (value > 0xffffffffffffffffn) {
      throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${value}`);
    }
    if (littleEndian === "LE") {
      buffer[offset] = Number(value & 0xffn);
      buffer[offset + 1] = Number(value >> 8n & 0xffn);
      buffer[offset + 2] = Number(value >> 16n & 0xffn);
      buffer[offset + 3] = Number(value >> 24n & 0xffn);
      buffer[offset + 4] = Number(value >> 32n & 0xffn);
      buffer[offset + 5] = Number(value >> 40n & 0xffn);
      buffer[offset + 6] = Number(value >> 48n & 0xffn);
      buffer[offset + 7] = Number(value >> 56n & 0xffn);
    } else {
      buffer[offset] = Number(value >> 56n & 0xffn);
      buffer[offset + 1] = Number(value >> 48n & 0xffn);
      buffer[offset + 2] = Number(value >> 40n & 0xffn);
      buffer[offset + 3] = Number(value >> 32n & 0xffn);
      buffer[offset + 4] = Number(value >> 24n & 0xffn);
      buffer[offset + 5] = Number(value >> 16n & 0xffn);
      buffer[offset + 6] = Number(value >> 8n & 0xffn);
      buffer[offset + 7] = Number(value & 0xffn);
    }
  }
  function readUInt8(buffer, offset) {
    if (offset + 1 > buffer.length) {
      throw new Error("Offset is outside the bounds of Uint8Array");
    }
    return buffer[offset];
  }
  function readUInt16(buffer, offset, littleEndian) {
    if (offset + 2 > buffer.length) {
      throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
      let num = 0;
      num = (num << 8) + buffer[offset + 1];
      num = (num << 8) + buffer[offset];
      return num;
    } else {
      let num = 0;
      num = (num << 8) + buffer[offset];
      num = (num << 8) + buffer[offset + 1];
      return num;
    }
  }
  function readUInt32(buffer, offset, littleEndian) {
    if (offset + 4 > buffer.length) {
      throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
      let num = 0;
      num = (num << 8) + buffer[offset + 3] >>> 0;
      num = (num << 8) + buffer[offset + 2] >>> 0;
      num = (num << 8) + buffer[offset + 1] >>> 0;
      num = (num << 8) + buffer[offset] >>> 0;
      return num;
    } else {
      let num = 0;
      num = (num << 8) + buffer[offset] >>> 0;
      num = (num << 8) + buffer[offset + 1] >>> 0;
      num = (num << 8) + buffer[offset + 2] >>> 0;
      num = (num << 8) + buffer[offset + 3] >>> 0;
      return num;
    }
  }
  function readUInt64(buffer, offset, littleEndian) {
    if (offset + 8 > buffer.length) {
      throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
      let num = 0n;
      num = (num << 8n) + BigInt(buffer[offset + 7]);
      num = (num << 8n) + BigInt(buffer[offset + 6]);
      num = (num << 8n) + BigInt(buffer[offset + 5]);
      num = (num << 8n) + BigInt(buffer[offset + 4]);
      num = (num << 8n) + BigInt(buffer[offset + 3]);
      num = (num << 8n) + BigInt(buffer[offset + 2]);
      num = (num << 8n) + BigInt(buffer[offset + 1]);
      num = (num << 8n) + BigInt(buffer[offset]);
      return num;
    } else {
      let num = 0n;
      num = (num << 8n) + BigInt(buffer[offset]);
      num = (num << 8n) + BigInt(buffer[offset + 1]);
      num = (num << 8n) + BigInt(buffer[offset + 2]);
      num = (num << 8n) + BigInt(buffer[offset + 3]);
      num = (num << 8n) + BigInt(buffer[offset + 4]);
      num = (num << 8n) + BigInt(buffer[offset + 5]);
      num = (num << 8n) + BigInt(buffer[offset + 6]);
      num = (num << 8n) + BigInt(buffer[offset + 7]);
      return num;
    }
  }
  var HEX_STRINGS, HEX_CODES, HEX_CODEPOINTS, ENCODER, DECODER;
  var init_browser = __esm({
    "node_modules/uint8array-tools/src/mjs/browser.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      HEX_STRINGS = "0123456789abcdefABCDEF";
      HEX_CODES = HEX_STRINGS.split("").map((c) => c.codePointAt(0));
      HEX_CODEPOINTS = Array(256).fill(true).map((_, i) => {
        const s = String.fromCodePoint(i);
        const index = HEX_STRINGS.indexOf(s);
        return index < 0 ? void 0 : index < 16 ? index : index - 6;
      });
      ENCODER = new TextEncoder();
      DECODER = new TextDecoder();
    }
  });

  // node_modules/bip32/src/cjs/testecc.cjs
  var require_testecc = __commonJS({
    "node_modules/bip32/src/cjs/testecc.cjs"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var __createBinding = exports9 && exports9.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports9 && exports9.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports9 && exports9.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.testEcc = testEcc;
      var tools = __importStar((init_browser(), __toCommonJS(browser_exports)));
      var h = (hex) => tools.fromHex(hex);
      function testEcc(ecc) {
        assert2(ecc.isPoint(h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")));
        assert2(!ecc.isPoint(h("030000000000000000000000000000000000000000000000000000000000000005")));
        assert2(ecc.isPrivate(h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")));
        assert2(ecc.isPrivate(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")));
        assert2(!ecc.isPrivate(h("0000000000000000000000000000000000000000000000000000000000000000")));
        assert2(!ecc.isPrivate(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")));
        assert2(!ecc.isPrivate(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")));
        assert2(tools.compare(ecc.pointFromScalar(h("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), h("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")) === 0);
        if (ecc.xOnlyPointAddTweak) {
          assert2(ecc.xOnlyPointAddTweak(h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
          let xOnlyRes = ecc.xOnlyPointAddTweak(h("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), h("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
          assert2(tools.compare(xOnlyRes.xOnlyPubkey, h("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) === 0 && xOnlyRes.parity === 1);
          xOnlyRes = ecc.xOnlyPointAddTweak(h("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), h("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
        }
        assert2(tools.compare(ecc.pointAddScalar(h("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h("0000000000000000000000000000000000000000000000000000000000000003")), h("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5")) === 0);
        assert2(tools.compare(ecc.privateAdd(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), h("0000000000000000000000000000000000000000000000000000000000000002")), h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0);
        if (ecc.privateNegate) {
          assert2(tools.compare(ecc.privateNegate(h("0000000000000000000000000000000000000000000000000000000000000001")), h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0);
          assert2(tools.compare(ecc.privateNegate(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")), h("0000000000000000000000000000000000000000000000000000000000000003")) === 0);
          assert2(tools.compare(ecc.privateNegate(h("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), h("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")) === 0);
        }
        assert2(tools.compare(ecc.sign(h("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")), h("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")) === 0);
        assert2(ecc.verify(h("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), h("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")));
        if (ecc.signSchnorr) {
          assert2(tools.compare(ecc.signSchnorr(h("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), h("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), h("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")), h("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")) === 0);
        }
        if (ecc.verifySchnorr) {
          assert2(ecc.verifySchnorr(h("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), h("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), h("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
        }
      }
      function assert2(bool) {
        if (!bool)
          throw new Error("ecc library invalid");
      }
    }
  });

  // node_modules/@scure/base/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/@scure/base/lib/index.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.bytes = exports9.stringToBytes = exports9.str = exports9.bytesToString = exports9.hex = exports9.utf8 = exports9.bech32m = exports9.bech32 = exports9.base58check = exports9.createBase58check = exports9.base58xmr = exports9.base58xrp = exports9.base58flickr = exports9.base58 = exports9.base64urlnopad = exports9.base64url = exports9.base64nopad = exports9.base64 = exports9.base32crockford = exports9.base32hexnopad = exports9.base32hex = exports9.base32nopad = exports9.base32 = exports9.base16 = exports9.utils = exports9.assertNumber = void 0;
      function isBytes(a) {
        return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
      }
      function isArrayOf(isString2, arr) {
        if (!Array.isArray(arr))
          return false;
        if (arr.length === 0)
          return true;
        if (isString2) {
          return arr.every((item) => typeof item === "string");
        } else {
          return arr.every((item) => Number.isSafeInteger(item));
        }
      }
      function afn(input) {
        if (typeof input !== "function")
          throw new Error("function expected");
        return true;
      }
      function astr(label, input) {
        if (typeof input !== "string")
          throw new Error(`${label}: string expected`);
        return true;
      }
      function anumber(n) {
        if (!Number.isSafeInteger(n))
          throw new Error(`invalid integer: ${n}`);
      }
      exports9.assertNumber = anumber;
      function aArr(input) {
        if (!Array.isArray(input))
          throw new Error("array expected");
      }
      function astrArr(label, input) {
        if (!isArrayOf(true, input))
          throw new Error(`${label}: array of strings expected`);
      }
      function anumArr(label, input) {
        if (!isArrayOf(false, input))
          throw new Error(`${label}: array of numbers expected`);
      }
      // @__NO_SIDE_EFFECTS__
      function chain(...args) {
        const id = (a) => a;
        const wrap = (a, b) => (c) => a(b(c));
        const encode = args.map((x) => x.encode).reduceRight(wrap, id);
        const decode = args.map((x) => x.decode).reduce(wrap, id);
        return { encode, decode };
      }
      // @__NO_SIDE_EFFECTS__
      function alphabet(letters) {
        const lettersA = typeof letters === "string" ? letters.split("") : letters;
        const len = lettersA.length;
        astrArr("alphabet", lettersA);
        const indexes = new Map(lettersA.map((l, i) => [l, i]));
        return {
          encode: (digits) => {
            aArr(digits);
            return digits.map((i) => {
              if (!Number.isSafeInteger(i) || i < 0 || i >= len)
                throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
              return lettersA[i];
            });
          },
          decode: (input) => {
            aArr(input);
            return input.map((letter) => {
              astr("alphabet.decode", letter);
              const i = indexes.get(letter);
              if (i === void 0)
                throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
              return i;
            });
          }
        };
      }
      // @__NO_SIDE_EFFECTS__
      function join(separator = "") {
        astr("join", separator);
        return {
          encode: (from) => {
            astrArr("join.decode", from);
            return from.join(separator);
          },
          decode: (to) => {
            astr("join.decode", to);
            return to.split(separator);
          }
        };
      }
      // @__NO_SIDE_EFFECTS__
      function padding(bits, chr = "=") {
        anumber(bits);
        astr("padding", chr);
        return {
          encode(data) {
            astrArr("padding.encode", data);
            while (data.length * bits % 8)
              data.push(chr);
            return data;
          },
          decode(input) {
            astrArr("padding.decode", input);
            let end = input.length;
            if (end * bits % 8)
              throw new Error("padding: invalid, string should have whole number of bytes");
            for (; end > 0 && input[end - 1] === chr; end--) {
              const last = end - 1;
              const byte = last * bits;
              if (byte % 8 === 0)
                throw new Error("padding: invalid, string has too much padding");
            }
            return input.slice(0, end);
          }
        };
      }
      // @__NO_SIDE_EFFECTS__
      function normalize(fn) {
        afn(fn);
        return { encode: (from) => from, decode: (to) => fn(to) };
      }
      function convertRadix(data, from, to) {
        if (from < 2)
          throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
        if (to < 2)
          throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
        aArr(data);
        if (!data.length)
          return [];
        let pos = 0;
        const res = [];
        const digits = Array.from(data, (d) => {
          anumber(d);
          if (d < 0 || d >= from)
            throw new Error(`invalid integer: ${d}`);
          return d;
        });
        const dlen = digits.length;
        while (true) {
          let carry = 0;
          let done = true;
          for (let i = pos; i < dlen; i++) {
            const digit = digits[i];
            const fromCarry = from * carry;
            const digitBase = fromCarry + digit;
            if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
              throw new Error("convertRadix: carry overflow");
            }
            const div = digitBase / to;
            carry = digitBase % to;
            const rounded = Math.floor(div);
            digits[i] = rounded;
            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
              throw new Error("convertRadix: carry overflow");
            if (!done)
              continue;
            else if (!rounded)
              pos = i;
            else
              done = false;
          }
          res.push(carry);
          if (done)
            break;
        }
        for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
          res.push(0);
        return res.reverse();
      }
      var gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
      var radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));
      var powers = /* @__PURE__ */ (() => {
        let res = [];
        for (let i = 0; i < 40; i++)
          res.push(2 ** i);
        return res;
      })();
      function convertRadix2(data, from, to, padding2) {
        aArr(data);
        if (from <= 0 || from > 32)
          throw new Error(`convertRadix2: wrong from=${from}`);
        if (to <= 0 || to > 32)
          throw new Error(`convertRadix2: wrong to=${to}`);
        if (/* @__PURE__ */ radix2carry(from, to) > 32) {
          throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${/* @__PURE__ */ radix2carry(from, to)}`);
        }
        let carry = 0;
        let pos = 0;
        const max = powers[from];
        const mask = powers[to] - 1;
        const res = [];
        for (const n of data) {
          anumber(n);
          if (n >= max)
            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
          carry = carry << from | n;
          if (pos + from > 32)
            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
          pos += from;
          for (; pos >= to; pos -= to)
            res.push((carry >> pos - to & mask) >>> 0);
          const pow = powers[pos];
          if (pow === void 0)
            throw new Error("invalid carry");
          carry &= pow - 1;
        }
        carry = carry << to - pos & mask;
        if (!padding2 && pos >= from)
          throw new Error("Excess padding");
        if (!padding2 && carry > 0)
          throw new Error(`Non-zero padding: ${carry}`);
        if (padding2 && pos > 0)
          res.push(carry >>> 0);
        return res;
      }
      // @__NO_SIDE_EFFECTS__
      function radix(num) {
        anumber(num);
        const _256 = 2 ** 8;
        return {
          encode: (bytes) => {
            if (!isBytes(bytes))
              throw new Error("radix.encode input should be Uint8Array");
            return convertRadix(Array.from(bytes), _256, num);
          },
          decode: (digits) => {
            anumArr("radix.decode", digits);
            return Uint8Array.from(convertRadix(digits, num, _256));
          }
        };
      }
      // @__NO_SIDE_EFFECTS__
      function radix2(bits, revPadding = false) {
        anumber(bits);
        if (bits <= 0 || bits > 32)
          throw new Error("radix2: bits should be in (0..32]");
        if (/* @__PURE__ */ radix2carry(8, bits) > 32 || /* @__PURE__ */ radix2carry(bits, 8) > 32)
          throw new Error("radix2: carry overflow");
        return {
          encode: (bytes) => {
            if (!isBytes(bytes))
              throw new Error("radix2.encode input should be Uint8Array");
            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
          },
          decode: (digits) => {
            anumArr("radix2.decode", digits);
            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
          }
        };
      }
      function unsafeWrapper(fn) {
        afn(fn);
        return function(...args) {
          try {
            return fn.apply(null, args);
          } catch (e) {
          }
        };
      }
      function checksum(len, fn) {
        anumber(len);
        afn(fn);
        return {
          encode(data) {
            if (!isBytes(data))
              throw new Error("checksum.encode: input should be Uint8Array");
            const sum = fn(data).slice(0, len);
            const res = new Uint8Array(data.length + len);
            res.set(data);
            res.set(sum, data.length);
            return res;
          },
          decode(data) {
            if (!isBytes(data))
              throw new Error("checksum.decode: input should be Uint8Array");
            const payload = data.slice(0, -len);
            const oldChecksum = data.slice(-len);
            const newChecksum = fn(payload).slice(0, len);
            for (let i = 0; i < len; i++)
              if (newChecksum[i] !== oldChecksum[i])
                throw new Error("Invalid checksum");
            return payload;
          }
        };
      }
      exports9.utils = {
        alphabet,
        chain,
        checksum,
        convertRadix,
        convertRadix2,
        radix,
        radix2,
        join,
        padding
      };
      exports9.base16 = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(4), /* @__PURE__ */ alphabet("0123456789ABCDEF"), /* @__PURE__ */ join(""));
      exports9.base32 = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ padding(5), /* @__PURE__ */ join(""));
      exports9.base32nopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ join(""));
      exports9.base32hex = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ padding(5), /* @__PURE__ */ join(""));
      exports9.base32hexnopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ join(""));
      exports9.base32crockford = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), /* @__PURE__ */ join(""), /* @__PURE__ */ normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
      exports9.base64 = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ padding(6), /* @__PURE__ */ join(""));
      exports9.base64nopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ join(""));
      exports9.base64url = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ padding(6), /* @__PURE__ */ join(""));
      exports9.base64urlnopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ join(""));
      var genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => /* @__PURE__ */ chain(/* @__PURE__ */ radix(58), /* @__PURE__ */ alphabet(abc), /* @__PURE__ */ join(""));
      exports9.base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
      exports9.base58flickr = /* @__PURE__ */ genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
      exports9.base58xrp = /* @__PURE__ */ genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
      var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
      exports9.base58xmr = {
        encode(data) {
          let res = "";
          for (let i = 0; i < data.length; i += 8) {
            const block = data.subarray(i, i + 8);
            res += exports9.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
          }
          return res;
        },
        decode(str) {
          let res = [];
          for (let i = 0; i < str.length; i += 11) {
            const slice = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
            const block = exports9.base58.decode(slice);
            for (let j = 0; j < block.length - blockLen; j++) {
              if (block[j] !== 0)
                throw new Error("base58xmr: wrong padding");
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
          }
          return Uint8Array.from(res);
        }
      };
      var createBase58check = (sha256) => /* @__PURE__ */ chain(checksum(4, (data) => sha256(sha256(data))), exports9.base58);
      exports9.createBase58check = createBase58check;
      exports9.base58check = exports9.createBase58check;
      var BECH_ALPHABET = /* @__PURE__ */ chain(/* @__PURE__ */ alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ join(""));
      var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
      function bech32Polymod(pre) {
        const b = pre >> 25;
        let chk = (pre & 33554431) << 5;
        for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
          if ((b >> i & 1) === 1)
            chk ^= POLYMOD_GENERATORS[i];
        }
        return chk;
      }
      function bechChecksum(prefix, words, encodingConst = 1) {
        const len = prefix.length;
        let chk = 1;
        for (let i = 0; i < len; i++) {
          const c = prefix.charCodeAt(i);
          if (c < 33 || c > 126)
            throw new Error(`Invalid prefix (${prefix})`);
          chk = bech32Polymod(chk) ^ c >> 5;
        }
        chk = bech32Polymod(chk);
        for (let i = 0; i < len; i++)
          chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 31;
        for (let v of words)
          chk = bech32Polymod(chk) ^ v;
        for (let i = 0; i < 6; i++)
          chk = bech32Polymod(chk);
        chk ^= encodingConst;
        return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
      }
      // @__NO_SIDE_EFFECTS__
      function genBech32(encoding) {
        const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
        const _words = /* @__PURE__ */ radix2(5);
        const fromWords = _words.decode;
        const toWords = _words.encode;
        const fromWordsUnsafe = unsafeWrapper(fromWords);
        function encode(prefix, words, limit = 90) {
          astr("bech32.encode prefix", prefix);
          if (isBytes(words))
            words = Array.from(words);
          anumArr("bech32.encode", words);
          const plen = prefix.length;
          if (plen === 0)
            throw new TypeError(`Invalid prefix length ${plen}`);
          const actualLength = plen + 7 + words.length;
          if (limit !== false && actualLength > limit)
            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
          const lowered = prefix.toLowerCase();
          const sum = bechChecksum(lowered, words, ENCODING_CONST);
          return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
        }
        function decode(str, limit = 90) {
          astr("bech32.decode input", str);
          const slen = str.length;
          if (slen < 8 || limit !== false && slen > limit)
            throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
          const lowered = str.toLowerCase();
          if (str !== lowered && str !== str.toUpperCase())
            throw new Error(`String must be lowercase or uppercase`);
          const sepIndex = lowered.lastIndexOf("1");
          if (sepIndex === 0 || sepIndex === -1)
            throw new Error(`Letter "1" must be present between prefix and data only`);
          const prefix = lowered.slice(0, sepIndex);
          const data = lowered.slice(sepIndex + 1);
          if (data.length < 6)
            throw new Error("Data must be at least 6 characters long");
          const words = BECH_ALPHABET.decode(data).slice(0, -6);
          const sum = bechChecksum(prefix, words, ENCODING_CONST);
          if (!data.endsWith(sum))
            throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
          return { prefix, words };
        }
        const decodeUnsafe = unsafeWrapper(decode);
        function decodeToBytes(str) {
          const { prefix, words } = decode(str, false);
          return { prefix, words, bytes: fromWords(words) };
        }
        function encodeFromBytes(prefix, bytes) {
          return encode(prefix, toWords(bytes));
        }
        return {
          encode,
          decode,
          encodeFromBytes,
          decodeToBytes,
          decodeUnsafe,
          fromWords,
          fromWordsUnsafe,
          toWords
        };
      }
      exports9.bech32 = /* @__PURE__ */ genBech32("bech32");
      exports9.bech32m = /* @__PURE__ */ genBech32("bech32m");
      exports9.utf8 = {
        encode: (data) => new TextDecoder().decode(data),
        decode: (str) => new TextEncoder().encode(str)
      };
      exports9.hex = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(4), /* @__PURE__ */ alphabet("0123456789abcdef"), /* @__PURE__ */ join(""), /* @__PURE__ */ normalize((s) => {
        if (typeof s !== "string" || s.length % 2 !== 0)
          throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
        return s.toLowerCase();
      }));
      var CODERS = {
        utf8: exports9.utf8,
        hex: exports9.hex,
        base16: exports9.base16,
        base32: exports9.base32,
        base64: exports9.base64,
        base64url: exports9.base64url,
        base58: exports9.base58,
        base58xmr: exports9.base58xmr
      };
      var coderTypeError = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
      var bytesToString = (type, bytes) => {
        if (typeof type !== "string" || !CODERS.hasOwnProperty(type))
          throw new TypeError(coderTypeError);
        if (!isBytes(bytes))
          throw new TypeError("bytesToString() expects Uint8Array");
        return CODERS[type].encode(bytes);
      };
      exports9.bytesToString = bytesToString;
      exports9.str = exports9.bytesToString;
      var stringToBytes = (type, str) => {
        if (!CODERS.hasOwnProperty(type))
          throw new TypeError(coderTypeError);
        if (typeof str !== "string")
          throw new TypeError("stringToBytes() expects string");
        return CODERS[type].decode(str);
      };
      exports9.stringToBytes = stringToBytes;
      exports9.bytes = exports9.stringToBytes;
    }
  });

  // node_modules/valibot/dist/index.cjs
  var require_dist2 = __commonJS({
    "node_modules/valibot/dist/index.cjs"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all) => {
        for (var name2 in all)
          __defProp2(target, name2, { get: all[name2], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var src_exports = {};
      __export2(src_exports, {
        BASE64_REGEX: () => BASE64_REGEX,
        BIC_REGEX: () => BIC_REGEX,
        CUID2_REGEX: () => CUID2_REGEX,
        DECIMAL_REGEX: () => DECIMAL_REGEX,
        EMAIL_REGEX: () => EMAIL_REGEX,
        EMOJI_REGEX: () => EMOJI_REGEX,
        HEXADECIMAL_REGEX: () => HEXADECIMAL_REGEX,
        HEX_COLOR_REGEX: () => HEX_COLOR_REGEX,
        IMEI_REGEX: () => IMEI_REGEX,
        IPV4_REGEX: () => IPV4_REGEX,
        IPV6_REGEX: () => IPV6_REGEX,
        IP_REGEX: () => IP_REGEX,
        ISO_DATE_REGEX: () => ISO_DATE_REGEX,
        ISO_DATE_TIME_REGEX: () => ISO_DATE_TIME_REGEX,
        ISO_TIMESTAMP_REGEX: () => ISO_TIMESTAMP_REGEX,
        ISO_TIME_REGEX: () => ISO_TIME_REGEX,
        ISO_TIME_SECOND_REGEX: () => ISO_TIME_SECOND_REGEX,
        ISO_WEEK_REGEX: () => ISO_WEEK_REGEX,
        MAC48_REGEX: () => MAC48_REGEX,
        MAC64_REGEX: () => MAC64_REGEX,
        MAC_REGEX: () => MAC_REGEX,
        OCTAL_REGEX: () => OCTAL_REGEX,
        ULID_REGEX: () => ULID_REGEX,
        UUID_REGEX: () => UUID_REGEX,
        ValiError: () => ValiError,
        _addIssue: () => _addIssue,
        _isLuhnAlgo: () => _isLuhnAlgo,
        _isValidObjectKey: () => _isValidObjectKey,
        _stringify: () => _stringify,
        any: () => any,
        array: () => array,
        arrayAsync: () => arrayAsync,
        awaitAsync: () => awaitAsync,
        base64: () => base64,
        bic: () => bic,
        bigint: () => bigint,
        blob: () => blob,
        boolean: () => boolean,
        brand: () => brand,
        bytes: () => bytes,
        check: () => check,
        checkAsync: () => checkAsync,
        checkItems: () => checkItems,
        config: () => config2,
        creditCard: () => creditCard,
        cuid2: () => cuid2,
        custom: () => custom,
        customAsync: () => customAsync,
        date: () => date,
        decimal: () => decimal,
        deleteGlobalConfig: () => deleteGlobalConfig,
        deleteGlobalMessage: () => deleteGlobalMessage,
        deleteSchemaMessage: () => deleteSchemaMessage,
        deleteSpecificMessage: () => deleteSpecificMessage,
        description: () => description,
        email: () => email,
        emoji: () => emoji,
        empty: () => empty,
        endsWith: () => endsWith,
        entriesFromList: () => entriesFromList,
        enum: () => enum_,
        enum_: () => enum_,
        everyItem: () => everyItem,
        excludes: () => excludes,
        fallback: () => fallback,
        fallbackAsync: () => fallbackAsync,
        file: () => file,
        filterItems: () => filterItems,
        findItem: () => findItem,
        finite: () => finite,
        flatten: () => flatten,
        forward: () => forward,
        forwardAsync: () => forwardAsync,
        function: () => function_,
        function_: () => function_,
        getDefault: () => getDefault,
        getDefaults: () => getDefaults,
        getDefaultsAsync: () => getDefaultsAsync,
        getDotPath: () => getDotPath,
        getFallback: () => getFallback,
        getFallbacks: () => getFallbacks,
        getFallbacksAsync: () => getFallbacksAsync,
        getGlobalConfig: () => getGlobalConfig,
        getGlobalMessage: () => getGlobalMessage,
        getSchemaMessage: () => getSchemaMessage,
        getSpecificMessage: () => getSpecificMessage,
        hash: () => hash,
        hexColor: () => hexColor,
        hexadecimal: () => hexadecimal,
        imei: () => imei,
        includes: () => includes,
        instance: () => instance,
        integer: () => integer,
        intersect: () => intersect,
        intersectAsync: () => intersectAsync,
        ip: () => ip,
        ipv4: () => ipv4,
        ipv6: () => ipv6,
        is: () => is,
        isOfKind: () => isOfKind,
        isOfType: () => isOfType,
        isValiError: () => isValiError,
        isoDate: () => isoDate,
        isoDateTime: () => isoDateTime,
        isoTime: () => isoTime,
        isoTimeSecond: () => isoTimeSecond,
        isoTimestamp: () => isoTimestamp,
        isoWeek: () => isoWeek,
        keyof: () => keyof,
        lazy: () => lazy,
        lazyAsync: () => lazyAsync,
        length: () => length,
        literal: () => literal,
        looseObject: () => looseObject,
        looseObjectAsync: () => looseObjectAsync,
        looseTuple: () => looseTuple,
        looseTupleAsync: () => looseTupleAsync,
        mac: () => mac,
        mac48: () => mac48,
        mac64: () => mac64,
        map: () => map,
        mapAsync: () => mapAsync,
        mapItems: () => mapItems,
        maxBytes: () => maxBytes,
        maxLength: () => maxLength,
        maxSize: () => maxSize,
        maxValue: () => maxValue,
        mimeType: () => mimeType,
        minBytes: () => minBytes,
        minLength: () => minLength,
        minSize: () => minSize,
        minValue: () => minValue,
        multipleOf: () => multipleOf,
        nan: () => nan,
        never: () => never,
        nonEmpty: () => nonEmpty,
        nonNullable: () => nonNullable,
        nonNullableAsync: () => nonNullableAsync,
        nonNullish: () => nonNullish,
        nonNullishAsync: () => nonNullishAsync,
        nonOptional: () => nonOptional,
        nonOptionalAsync: () => nonOptionalAsync,
        normalize: () => normalize,
        notBytes: () => notBytes,
        notLength: () => notLength,
        notSize: () => notSize,
        notValue: () => notValue,
        null: () => null_,
        null_: () => null_,
        nullable: () => nullable,
        nullableAsync: () => nullableAsync,
        nullish: () => nullish,
        nullishAsync: () => nullishAsync,
        number: () => number,
        object: () => object,
        objectAsync: () => objectAsync,
        objectWithRest: () => objectWithRest,
        objectWithRestAsync: () => objectWithRestAsync,
        octal: () => octal,
        omit: () => omit,
        optional: () => optional,
        optionalAsync: () => optionalAsync,
        parse: () => parse,
        parseAsync: () => parseAsync,
        parser: () => parser,
        parserAsync: () => parserAsync,
        partial: () => partial,
        partialAsync: () => partialAsync,
        partialCheck: () => partialCheck,
        partialCheckAsync: () => partialCheckAsync,
        pick: () => pick,
        picklist: () => picklist,
        pipe: () => pipe,
        pipeAsync: () => pipeAsync,
        promise: () => promise,
        rawCheck: () => rawCheck,
        rawCheckAsync: () => rawCheckAsync,
        rawTransform: () => rawTransform,
        rawTransformAsync: () => rawTransformAsync,
        readonly: () => readonly,
        record: () => record,
        recordAsync: () => recordAsync,
        reduceItems: () => reduceItems,
        regex: () => regex,
        required: () => required,
        requiredAsync: () => requiredAsync,
        safeInteger: () => safeInteger,
        safeParse: () => safeParse,
        safeParseAsync: () => safeParseAsync,
        safeParser: () => safeParser,
        safeParserAsync: () => safeParserAsync,
        set: () => set,
        setAsync: () => setAsync,
        setGlobalConfig: () => setGlobalConfig,
        setGlobalMessage: () => setGlobalMessage,
        setSchemaMessage: () => setSchemaMessage,
        setSpecificMessage: () => setSpecificMessage,
        size: () => size,
        someItem: () => someItem,
        sortItems: () => sortItems,
        startsWith: () => startsWith,
        strictObject: () => strictObject,
        strictObjectAsync: () => strictObjectAsync,
        strictTuple: () => strictTuple,
        strictTupleAsync: () => strictTupleAsync,
        string: () => string,
        symbol: () => symbol,
        toLowerCase: () => toLowerCase,
        toMaxValue: () => toMaxValue,
        toMinValue: () => toMinValue,
        toUpperCase: () => toUpperCase,
        transform: () => transform,
        transformAsync: () => transformAsync,
        trim: () => trim,
        trimEnd: () => trimEnd,
        trimStart: () => trimStart,
        tuple: () => tuple,
        tupleAsync: () => tupleAsync,
        tupleWithRest: () => tupleWithRest,
        tupleWithRestAsync: () => tupleWithRestAsync,
        ulid: () => ulid,
        undefined: () => undefined_,
        undefined_: () => undefined_,
        union: () => union,
        unionAsync: () => unionAsync,
        unknown: () => unknown,
        unwrap: () => unwrap,
        url: () => url,
        uuid: () => uuid,
        value: () => value,
        variant: () => variant,
        variantAsync: () => variantAsync,
        void: () => void_,
        void_: () => void_
      });
      module.exports = __toCommonJS2(src_exports);
      function awaitAsync() {
        return {
          kind: "transformation",
          type: "await",
          reference: awaitAsync,
          async: true,
          async _run(dataset) {
            dataset.value = await dataset.value;
            return dataset;
          }
        };
      }
      var BASE64_REGEX = /^(?:[\da-z+/]{4})*(?:[\da-z+/]{2}==|[\da-z+/]{3}=)?$/iu;
      var BIC_REGEX = /^[A-Z]{6}(?!00)[\dA-Z]{2}(?:[\dA-Z]{3})?$/u;
      var CUID2_REGEX = /^[a-z][\da-z]*$/u;
      var DECIMAL_REGEX = /^\d+$/u;
      var EMAIL_REGEX = /^[\w+-]+(?:\.[\w+-]+)*@[\da-z]+(?:[.-][\da-z]+)*\.[a-z]{2,}$/iu;
      var EMOJI_REGEX = (
        // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives
        /^(?:[\u{1F1E6}-\u{1F1FF}]{2}|\u{1F3F4}[\u{E0061}-\u{E007A}]{2}[\u{E0030}-\u{E0039}\u{E0061}-\u{E007A}]{1,3}\u{E007F}|(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation})(?:\u200D(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation}))*)+$/u
      );
      var HEXADECIMAL_REGEX = /^(?:0[hx])?[\da-f]+$/iu;
      var HEX_COLOR_REGEX = /^#(?:[\da-f]{3,4}|[\da-f]{6}|[\da-f]{8})$/iu;
      var IMEI_REGEX = /^\d{15}$|^\d{2}-\d{6}-\d{6}-\d$/u;
      var IPV4_REGEX = (
        // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive
        /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$/u
      );
      var IPV6_REGEX = /^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
      var IP_REGEX = /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$|^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
      var ISO_DATE_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])$/u;
      var ISO_DATE_TIME_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])T(?:0\d|1\d|2[0-3]):[0-5]\d$/u;
      var ISO_TIME_REGEX = /^(?:0\d|1\d|2[0-3]):[0-5]\d$/u;
      var ISO_TIME_SECOND_REGEX = /^(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}$/u;
      var ISO_TIMESTAMP_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])T(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}(?:\.\d{1,9})?(?:Z|[+-](?:0\d|1\d|2[0-3])(?::?[0-5]\d)?)$/u;
      var ISO_WEEK_REGEX = /^\d{4}-W(?:0[1-9]|[1-4]\d|5[0-3])$/u;
      var MAC48_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$/iu;
      var MAC64_REGEX = /^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
      var MAC_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$|^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
      var OCTAL_REGEX = /^(?:0o)?[0-7]+$/iu;
      var ULID_REGEX = /^[\da-hjkmnp-tv-z]{26}$/iu;
      var UUID_REGEX = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu;
      var store;
      function setGlobalConfig(config22) {
        store = { ...store, ...config22 };
      }
      function getGlobalConfig(config22) {
        return {
          lang: config22?.lang ?? store?.lang,
          message: config22?.message,
          abortEarly: config22?.abortEarly ?? store?.abortEarly,
          abortPipeEarly: config22?.abortPipeEarly ?? store?.abortPipeEarly
        };
      }
      function deleteGlobalConfig() {
        store = void 0;
      }
      var store2;
      function setGlobalMessage(message, lang) {
        if (!store2) store2 = /* @__PURE__ */ new Map();
        store2.set(lang, message);
      }
      function getGlobalMessage(lang) {
        return store2?.get(lang);
      }
      function deleteGlobalMessage(lang) {
        store2?.delete(lang);
      }
      var store3;
      function setSchemaMessage(message, lang) {
        if (!store3) store3 = /* @__PURE__ */ new Map();
        store3.set(lang, message);
      }
      function getSchemaMessage(lang) {
        return store3?.get(lang);
      }
      function deleteSchemaMessage(lang) {
        store3?.delete(lang);
      }
      var store4;
      function setSpecificMessage(reference, message, lang) {
        if (!store4) store4 = /* @__PURE__ */ new Map();
        if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());
        store4.get(reference).set(lang, message);
      }
      function getSpecificMessage(reference, lang) {
        return store4?.get(reference)?.get(lang);
      }
      function deleteSpecificMessage(reference, lang) {
        store4?.get(reference)?.delete(lang);
      }
      function _stringify(input) {
        const type = typeof input;
        if (type === "string") {
          return `"${input}"`;
        }
        if (type === "number" || type === "bigint" || type === "boolean") {
          return `${input}`;
        }
        if (type === "object" || type === "function") {
          return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
        }
        return type;
      }
      function _addIssue(context, label, dataset, config22, other) {
        const input = other && "input" in other ? other.input : dataset.value;
        const expected = other?.expected ?? context.expects ?? null;
        const received = other?.received ?? _stringify(input);
        const issue = {
          kind: context.kind,
          type: context.type,
          input,
          expected,
          received,
          message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
          // @ts-expect-error
          requirement: context.requirement,
          path: other?.path,
          issues: other?.issues,
          lang: config22.lang,
          abortEarly: config22.abortEarly,
          abortPipeEarly: config22.abortPipeEarly
        };
        const isSchema = context.kind === "schema";
        const message = other?.message ?? // @ts-expect-error
        context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config22.message ?? getGlobalMessage(issue.lang);
        if (message) {
          issue.message = typeof message === "function" ? message(issue) : message;
        }
        if (isSchema) {
          dataset.typed = false;
        }
        if (dataset.issues) {
          dataset.issues.push(issue);
        } else {
          dataset.issues = [issue];
        }
      }
      var NON_DIGIT_REGEX = /\D/gu;
      function _isLuhnAlgo(input) {
        const number2 = input.replace(NON_DIGIT_REGEX, "");
        let length2 = number2.length;
        let bit = 1;
        let sum = 0;
        while (length2) {
          const value2 = +number2[--length2];
          bit ^= 1;
          sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;
        }
        return sum % 10 === 0;
      }
      function _isValidObjectKey(object2, key) {
        return Object.hasOwn(object2, key) && key !== "__proto__" && key !== "prototype" && key !== "constructor";
      }
      function entriesFromList(list, schema) {
        const entries = {};
        for (const key of list) {
          entries[key] = schema;
        }
        return entries;
      }
      function getDotPath(issue) {
        if (issue.path) {
          let key = "";
          for (const item of issue.path) {
            if (typeof item.key === "string" || typeof item.key === "number") {
              if (key) {
                key += `.${item.key}`;
              } else {
                key += item.key;
              }
            } else {
              return null;
            }
          }
          return key;
        }
        return null;
      }
      function isOfKind(kind, object2) {
        return object2.kind === kind;
      }
      function isOfType(type, object2) {
        return object2.type === type;
      }
      function isValiError(error) {
        return error instanceof ValiError;
      }
      var ValiError = class extends Error {
        /**
         * The error issues.
         */
        issues;
        /**
         * Creates a Valibot error with useful information.
         *
         * @param issues The error issues.
         */
        constructor(issues) {
          super(issues[0].message);
          this.name = "ValiError";
          this.issues = issues;
        }
      };
      function base64(message) {
        return {
          kind: "validation",
          type: "base64",
          reference: base64,
          async: false,
          expects: null,
          requirement: BASE64_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "Base64", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function bic(message) {
        return {
          kind: "validation",
          type: "bic",
          reference: bic,
          async: false,
          expects: null,
          requirement: BIC_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "BIC", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function brand(name2) {
        return {
          kind: "transformation",
          type: "brand",
          reference: brand,
          async: false,
          name: name2,
          _run(dataset) {
            return dataset;
          }
        };
      }
      function bytes(requirement, message) {
        return {
          kind: "validation",
          type: "bytes",
          reference: bytes,
          async: false,
          expects: `${requirement}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed) {
              const length2 = new TextEncoder().encode(dataset.value).length;
              if (length2 !== this.requirement) {
                _addIssue(this, "bytes", dataset, config22, {
                  received: `${length2}`
                });
              }
            }
            return dataset;
          }
        };
      }
      function check(requirement, message) {
        return {
          kind: "validation",
          type: "check",
          reference: check,
          async: false,
          expects: null,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement(dataset.value)) {
              _addIssue(this, "input", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function checkAsync(requirement, message) {
        return {
          kind: "validation",
          type: "check",
          reference: checkAsync,
          async: true,
          expects: null,
          requirement,
          message,
          async _run(dataset, config22) {
            if (dataset.typed && !await this.requirement(dataset.value)) {
              _addIssue(this, "input", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function checkItems(requirement, message) {
        return {
          kind: "validation",
          type: "check_items",
          reference: checkItems,
          async: false,
          expects: null,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed) {
              for (let index = 0; index < dataset.value.length; index++) {
                const item = dataset.value[index];
                if (!this.requirement(item, index, dataset.value)) {
                  _addIssue(this, "item", dataset, config22, {
                    input: item,
                    path: [
                      {
                        type: "array",
                        origin: "value",
                        input: dataset.value,
                        key: index,
                        value: item
                      }
                    ]
                  });
                }
              }
            }
            return dataset;
          }
        };
      }
      var CREDIT_CARD_REGEX = /^(?:\d{14,19}|\d{4}(?: \d{3,6}){2,4}|\d{4}(?:-\d{3,6}){2,4})$/u;
      var SANITIZE_REGEX = /[- ]/gu;
      var PROVIDER_REGEX_LIST = [
        // American Express
        /^3[47]\d{13}$/u,
        // Diners Club
        /^3(?:0[0-5]|[68]\d)\d{11,13}$/u,
        // Discover
        /^6(?:011|5\d{2})\d{12,15}$/u,
        // JCB
        /^(?:2131|1800|35\d{3})\d{11}$/u,
        // Mastercard
        /^5[1-5]\d{2}|(?:222\d|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}$/u,
        // UnionPay
        /^(?:6[27]\d{14,17}|81\d{14,17})$/u,
        // Visa
        /^4\d{12}(?:\d{3,6})?$/u
      ];
      function creditCard(message) {
        return {
          kind: "validation",
          type: "credit_card",
          reference: creditCard,
          async: false,
          expects: null,
          requirement(input) {
            let sanitized;
            return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks
            (sanitized = input.replace(SANITIZE_REGEX, "")) && // Check if it matches a provider
            PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm
            _isLuhnAlgo(sanitized);
          },
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement(dataset.value)) {
              _addIssue(this, "credit card", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function cuid2(message) {
        return {
          kind: "validation",
          type: "cuid2",
          reference: cuid2,
          async: false,
          expects: null,
          requirement: CUID2_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "Cuid2", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function decimal(message) {
        return {
          kind: "validation",
          type: "decimal",
          reference: decimal,
          async: false,
          expects: null,
          requirement: DECIMAL_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "decimal", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function description(description_) {
        return {
          kind: "metadata",
          type: "description",
          reference: description,
          description: description_
        };
      }
      function email(message) {
        return {
          kind: "validation",
          type: "email",
          reference: email,
          expects: null,
          async: false,
          requirement: EMAIL_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "email", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function emoji(message) {
        return {
          kind: "validation",
          type: "emoji",
          reference: emoji,
          async: false,
          expects: null,
          requirement: EMOJI_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "emoji", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function empty(message) {
        return {
          kind: "validation",
          type: "empty",
          reference: empty,
          async: false,
          expects: "0",
          message,
          _run(dataset, config22) {
            if (dataset.typed && dataset.value.length > 0) {
              _addIssue(this, "length", dataset, config22, {
                received: `${dataset.value.length}`
              });
            }
            return dataset;
          }
        };
      }
      function endsWith(requirement, message) {
        return {
          kind: "validation",
          type: "ends_with",
          reference: endsWith,
          async: false,
          expects: `"${requirement}"`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !dataset.value.endsWith(this.requirement)) {
              _addIssue(this, "end", dataset, config22, {
                received: `"${dataset.value.slice(-this.requirement.length)}"`
              });
            }
            return dataset;
          }
        };
      }
      function everyItem(requirement, message) {
        return {
          kind: "validation",
          type: "every_item",
          reference: everyItem,
          async: false,
          expects: null,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !dataset.value.every(this.requirement)) {
              _addIssue(this, "item", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function excludes(requirement, message) {
        const received = _stringify(requirement);
        return {
          kind: "validation",
          type: "excludes",
          reference: excludes,
          async: false,
          expects: `!${received}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && dataset.value.includes(this.requirement)) {
              _addIssue(this, "content", dataset, config22, { received });
            }
            return dataset;
          }
        };
      }
      function filterItems(operation) {
        return {
          kind: "transformation",
          type: "filter_items",
          reference: filterItems,
          async: false,
          operation,
          _run(dataset) {
            dataset.value = dataset.value.filter(this.operation);
            return dataset;
          }
        };
      }
      function findItem(operation) {
        return {
          kind: "transformation",
          type: "find_item",
          reference: findItem,
          async: false,
          operation,
          _run(dataset) {
            dataset.value = dataset.value.find(this.operation);
            return dataset;
          }
        };
      }
      function finite(message) {
        return {
          kind: "validation",
          type: "finite",
          reference: finite,
          async: false,
          expects: null,
          requirement: Number.isFinite,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement(dataset.value)) {
              _addIssue(this, "finite", dataset, config22);
            }
            return dataset;
          }
        };
      }
      var HASH_LENGTHS = {
        md4: 32,
        md5: 32,
        sha1: 40,
        sha256: 64,
        sha384: 96,
        sha512: 128,
        ripemd128: 32,
        ripemd160: 40,
        tiger128: 32,
        tiger160: 40,
        tiger192: 48,
        crc32: 8,
        crc32b: 8,
        adler32: 8
      };
      function hash(types2, message) {
        return {
          kind: "validation",
          type: "hash",
          reference: hash,
          expects: null,
          async: false,
          requirement: RegExp(
            types2.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join("|"),
            "iu"
          ),
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "hash", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function hexadecimal(message) {
        return {
          kind: "validation",
          type: "hexadecimal",
          reference: hexadecimal,
          async: false,
          expects: null,
          requirement: HEXADECIMAL_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "hexadecimal", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function hexColor(message) {
        return {
          kind: "validation",
          type: "hex_color",
          reference: hexColor,
          async: false,
          expects: null,
          requirement: HEX_COLOR_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "hex color", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function imei(message) {
        return {
          kind: "validation",
          type: "imei",
          reference: imei,
          async: false,
          expects: null,
          requirement(input) {
            return IMEI_REGEX.test(input) && _isLuhnAlgo(input);
          },
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement(dataset.value)) {
              _addIssue(this, "IMEI", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function includes(requirement, message) {
        const expects = _stringify(requirement);
        return {
          kind: "validation",
          type: "includes",
          reference: includes,
          async: false,
          expects,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !dataset.value.includes(this.requirement)) {
              _addIssue(this, "content", dataset, config22, {
                received: `!${expects}`
              });
            }
            return dataset;
          }
        };
      }
      function integer(message) {
        return {
          kind: "validation",
          type: "integer",
          reference: integer,
          async: false,
          expects: null,
          requirement: Number.isInteger,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement(dataset.value)) {
              _addIssue(this, "integer", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function ip(message) {
        return {
          kind: "validation",
          type: "ip",
          reference: ip,
          async: false,
          expects: null,
          requirement: IP_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "IP", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function ipv4(message) {
        return {
          kind: "validation",
          type: "ipv4",
          reference: ipv4,
          async: false,
          expects: null,
          requirement: IPV4_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "IPv4", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function ipv6(message) {
        return {
          kind: "validation",
          type: "ipv6",
          reference: ipv6,
          async: false,
          expects: null,
          requirement: IPV6_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "IPv6", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function isoDate(message) {
        return {
          kind: "validation",
          type: "iso_date",
          reference: isoDate,
          async: false,
          expects: null,
          requirement: ISO_DATE_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "date", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function isoDateTime(message) {
        return {
          kind: "validation",
          type: "iso_date_time",
          reference: isoDateTime,
          async: false,
          expects: null,
          requirement: ISO_DATE_TIME_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "date-time", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function isoTime(message) {
        return {
          kind: "validation",
          type: "iso_time",
          reference: isoTime,
          async: false,
          expects: null,
          requirement: ISO_TIME_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "time", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function isoTimeSecond(message) {
        return {
          kind: "validation",
          type: "iso_time_second",
          reference: isoTimeSecond,
          async: false,
          expects: null,
          requirement: ISO_TIME_SECOND_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "time-second", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function isoTimestamp(message) {
        return {
          kind: "validation",
          type: "iso_timestamp",
          reference: isoTimestamp,
          async: false,
          expects: null,
          requirement: ISO_TIMESTAMP_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "timestamp", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function isoWeek(message) {
        return {
          kind: "validation",
          type: "iso_week",
          reference: isoWeek,
          async: false,
          expects: null,
          requirement: ISO_WEEK_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "week", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function length(requirement, message) {
        return {
          kind: "validation",
          type: "length",
          reference: length,
          async: false,
          expects: `${requirement}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && dataset.value.length !== this.requirement) {
              _addIssue(this, "length", dataset, config22, {
                received: `${dataset.value.length}`
              });
            }
            return dataset;
          }
        };
      }
      function mac(message) {
        return {
          kind: "validation",
          type: "mac",
          reference: mac,
          async: false,
          expects: null,
          requirement: MAC_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "MAC", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function mac48(message) {
        return {
          kind: "validation",
          type: "mac48",
          reference: mac48,
          async: false,
          expects: null,
          requirement: MAC48_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "48-bit MAC", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function mac64(message) {
        return {
          kind: "validation",
          type: "mac64",
          reference: mac64,
          async: false,
          expects: null,
          requirement: MAC64_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "64-bit MAC", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function mapItems(operation) {
        return {
          kind: "transformation",
          type: "map_items",
          reference: mapItems,
          async: false,
          operation,
          _run(dataset) {
            dataset.value = dataset.value.map(this.operation);
            return dataset;
          }
        };
      }
      function maxBytes(requirement, message) {
        return {
          kind: "validation",
          type: "max_bytes",
          reference: maxBytes,
          async: false,
          expects: `<=${requirement}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed) {
              const length2 = new TextEncoder().encode(dataset.value).length;
              if (length2 > this.requirement) {
                _addIssue(this, "bytes", dataset, config22, {
                  received: `${length2}`
                });
              }
            }
            return dataset;
          }
        };
      }
      function maxLength(requirement, message) {
        return {
          kind: "validation",
          type: "max_length",
          reference: maxLength,
          async: false,
          expects: `<=${requirement}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && dataset.value.length > this.requirement) {
              _addIssue(this, "length", dataset, config22, {
                received: `${dataset.value.length}`
              });
            }
            return dataset;
          }
        };
      }
      function maxSize(requirement, message) {
        return {
          kind: "validation",
          type: "max_size",
          reference: maxSize,
          async: false,
          expects: `<=${requirement}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && dataset.value.size > this.requirement) {
              _addIssue(this, "size", dataset, config22, {
                received: `${dataset.value.size}`
              });
            }
            return dataset;
          }
        };
      }
      function maxValue(requirement, message) {
        return {
          kind: "validation",
          type: "max_value",
          reference: maxValue,
          async: false,
          expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && dataset.value > this.requirement) {
              _addIssue(this, "value", dataset, config22, {
                received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
              });
            }
            return dataset;
          }
        };
      }
      function mimeType(requirement, message) {
        return {
          kind: "validation",
          type: "mime_type",
          reference: mimeType,
          async: false,
          expects: requirement.map((option) => `"${option}"`).join(" | ") || "never",
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.includes(dataset.value.type)) {
              _addIssue(this, "MIME type", dataset, config22, {
                received: `"${dataset.value.type}"`
              });
            }
            return dataset;
          }
        };
      }
      function minBytes(requirement, message) {
        return {
          kind: "validation",
          type: "min_bytes",
          reference: minBytes,
          async: false,
          expects: `>=${requirement}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed) {
              const length2 = new TextEncoder().encode(dataset.value).length;
              if (length2 < this.requirement) {
                _addIssue(this, "bytes", dataset, config22, {
                  received: `${length2}`
                });
              }
            }
            return dataset;
          }
        };
      }
      function minLength(requirement, message) {
        return {
          kind: "validation",
          type: "min_length",
          reference: minLength,
          async: false,
          expects: `>=${requirement}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && dataset.value.length < this.requirement) {
              _addIssue(this, "length", dataset, config22, {
                received: `${dataset.value.length}`
              });
            }
            return dataset;
          }
        };
      }
      function minSize(requirement, message) {
        return {
          kind: "validation",
          type: "min_size",
          reference: minSize,
          async: false,
          expects: `>=${requirement}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && dataset.value.size < this.requirement) {
              _addIssue(this, "size", dataset, config22, {
                received: `${dataset.value.size}`
              });
            }
            return dataset;
          }
        };
      }
      function minValue(requirement, message) {
        return {
          kind: "validation",
          type: "min_value",
          reference: minValue,
          async: false,
          expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && dataset.value < this.requirement) {
              _addIssue(this, "value", dataset, config22, {
                received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
              });
            }
            return dataset;
          }
        };
      }
      function multipleOf(requirement, message) {
        return {
          kind: "validation",
          type: "multiple_of",
          reference: multipleOf,
          async: false,
          expects: `%${requirement}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && dataset.value % this.requirement !== 0) {
              _addIssue(this, "multiple", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function nonEmpty(message) {
        return {
          kind: "validation",
          type: "non_empty",
          reference: nonEmpty,
          async: false,
          expects: "!0",
          message,
          _run(dataset, config22) {
            if (dataset.typed && dataset.value.length === 0) {
              _addIssue(this, "length", dataset, config22, {
                received: "0"
              });
            }
            return dataset;
          }
        };
      }
      function normalize(form) {
        return {
          kind: "transformation",
          type: "normalize",
          reference: normalize,
          async: false,
          form,
          _run(dataset) {
            dataset.value = dataset.value.normalize(this.form);
            return dataset;
          }
        };
      }
      function notBytes(requirement, message) {
        return {
          kind: "validation",
          type: "not_bytes",
          reference: notBytes,
          async: false,
          expects: `!${requirement}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed) {
              const length2 = new TextEncoder().encode(dataset.value).length;
              if (length2 === this.requirement) {
                _addIssue(this, "bytes", dataset, config22, {
                  received: `${length2}`
                });
              }
            }
            return dataset;
          }
        };
      }
      function notLength(requirement, message) {
        return {
          kind: "validation",
          type: "not_length",
          reference: notLength,
          async: false,
          expects: `!${requirement}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && dataset.value.length === this.requirement) {
              _addIssue(this, "length", dataset, config22, {
                received: `${dataset.value.length}`
              });
            }
            return dataset;
          }
        };
      }
      function notSize(requirement, message) {
        return {
          kind: "validation",
          type: "not_size",
          reference: notSize,
          async: false,
          expects: `!${requirement}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && dataset.value.size === this.requirement) {
              _addIssue(this, "size", dataset, config22, {
                received: `${dataset.value.size}`
              });
            }
            return dataset;
          }
        };
      }
      function notValue(requirement, message) {
        return {
          kind: "validation",
          type: "not_value",
          reference: notValue,
          async: false,
          expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {
              _addIssue(this, "value", dataset, config22, {
                received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
              });
            }
            return dataset;
          }
        };
      }
      function octal(message) {
        return {
          kind: "validation",
          type: "octal",
          reference: octal,
          async: false,
          expects: null,
          requirement: OCTAL_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "octal", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function _isPartiallyTyped(dataset, pathList) {
        if (dataset.issues) {
          for (const path of pathList) {
            for (const issue of dataset.issues) {
              let typed = false;
              const bound = Math.min(path.length, issue.path?.length ?? 0);
              for (let index = 0; index < bound; index++) {
                if (path[index] !== issue.path[index].key) {
                  typed = true;
                  break;
                }
              }
              if (!typed) {
                return false;
              }
            }
          }
        }
        return true;
      }
      function partialCheck(pathList, requirement, message) {
        return {
          kind: "validation",
          type: "partial_check",
          reference: partialCheck,
          async: false,
          expects: null,
          requirement,
          message,
          _run(dataset, config22) {
            if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error
            !this.requirement(dataset.value)) {
              _addIssue(this, "input", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function partialCheckAsync(pathList, requirement, message) {
        return {
          kind: "validation",
          type: "partial_check",
          reference: partialCheckAsync,
          async: true,
          expects: null,
          requirement,
          message,
          async _run(dataset, config22) {
            if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error
            !await this.requirement(dataset.value)) {
              _addIssue(this, "input", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function rawCheck(action) {
        return {
          kind: "validation",
          type: "raw_check",
          reference: rawCheck,
          async: false,
          expects: null,
          _run(dataset, config22) {
            action({
              dataset,
              config: config22,
              addIssue: (info) => _addIssue(this, info?.label ?? "input", dataset, config22, info)
            });
            return dataset;
          }
        };
      }
      function rawCheckAsync(action) {
        return {
          kind: "validation",
          type: "raw_check",
          reference: rawCheckAsync,
          async: true,
          expects: null,
          async _run(dataset, config22) {
            await action({
              dataset,
              config: config22,
              addIssue: (info) => _addIssue(this, info?.label ?? "input", dataset, config22, info)
            });
            return dataset;
          }
        };
      }
      function rawTransform(action) {
        return {
          kind: "transformation",
          type: "raw_transform",
          reference: rawTransform,
          async: false,
          _run(dataset, config22) {
            const output = action({
              dataset,
              config: config22,
              addIssue: (info) => _addIssue(this, info?.label ?? "input", dataset, config22, info),
              NEVER: null
            });
            if (dataset.issues) {
              dataset.typed = false;
            } else {
              dataset.value = output;
            }
            return dataset;
          }
        };
      }
      function rawTransformAsync(action) {
        return {
          kind: "transformation",
          type: "raw_transform",
          reference: rawTransformAsync,
          async: true,
          async _run(dataset, config22) {
            const output = await action({
              dataset,
              config: config22,
              addIssue: (info) => _addIssue(this, info?.label ?? "input", dataset, config22, info),
              NEVER: null
            });
            if (dataset.issues) {
              dataset.typed = false;
            } else {
              dataset.value = output;
            }
            return dataset;
          }
        };
      }
      function readonly() {
        return {
          kind: "transformation",
          type: "readonly",
          reference: readonly,
          async: false,
          _run(dataset) {
            return dataset;
          }
        };
      }
      function reduceItems(operation, initial) {
        return {
          kind: "transformation",
          type: "reduce_items",
          reference: reduceItems,
          async: false,
          operation,
          initial,
          _run(dataset) {
            dataset.value = dataset.value.reduce(this.operation, this.initial);
            return dataset;
          }
        };
      }
      function regex(requirement, message) {
        return {
          kind: "validation",
          type: "regex",
          reference: regex,
          async: false,
          expects: `${requirement}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "format", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function safeInteger(message) {
        return {
          kind: "validation",
          type: "safe_integer",
          reference: safeInteger,
          async: false,
          expects: null,
          requirement: Number.isSafeInteger,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement(dataset.value)) {
              _addIssue(this, "safe integer", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function size(requirement, message) {
        return {
          kind: "validation",
          type: "size",
          reference: size,
          async: false,
          expects: `${requirement}`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && dataset.value.size !== this.requirement) {
              _addIssue(this, "size", dataset, config22, {
                received: `${dataset.value.size}`
              });
            }
            return dataset;
          }
        };
      }
      function someItem(requirement, message) {
        return {
          kind: "validation",
          type: "some_item",
          reference: someItem,
          async: false,
          expects: null,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !dataset.value.some(this.requirement)) {
              _addIssue(this, "item", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function sortItems(operation) {
        return {
          kind: "transformation",
          type: "sort_items",
          reference: sortItems,
          async: false,
          operation,
          _run(dataset) {
            dataset.value = dataset.value.sort(this.operation);
            return dataset;
          }
        };
      }
      function startsWith(requirement, message) {
        return {
          kind: "validation",
          type: "starts_with",
          reference: startsWith,
          async: false,
          expects: `"${requirement}"`,
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !dataset.value.startsWith(this.requirement)) {
              _addIssue(this, "start", dataset, config22, {
                received: `"${dataset.value.slice(0, this.requirement.length)}"`
              });
            }
            return dataset;
          }
        };
      }
      function toLowerCase() {
        return {
          kind: "transformation",
          type: "to_lower_case",
          reference: toLowerCase,
          async: false,
          _run(dataset) {
            dataset.value = dataset.value.toLowerCase();
            return dataset;
          }
        };
      }
      function toMaxValue(requirement) {
        return {
          kind: "transformation",
          type: "to_max_value",
          reference: toMaxValue,
          async: false,
          requirement,
          _run(dataset) {
            dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;
            return dataset;
          }
        };
      }
      function toMinValue(requirement) {
        return {
          kind: "transformation",
          type: "to_min_value",
          reference: toMinValue,
          async: false,
          requirement,
          _run(dataset) {
            dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;
            return dataset;
          }
        };
      }
      function toUpperCase() {
        return {
          kind: "transformation",
          type: "to_upper_case",
          reference: toUpperCase,
          async: false,
          _run(dataset) {
            dataset.value = dataset.value.toUpperCase();
            return dataset;
          }
        };
      }
      function transform(operation) {
        return {
          kind: "transformation",
          type: "transform",
          reference: transform,
          async: false,
          operation,
          _run(dataset) {
            dataset.value = this.operation(dataset.value);
            return dataset;
          }
        };
      }
      function transformAsync(operation) {
        return {
          kind: "transformation",
          type: "transform",
          reference: transformAsync,
          async: true,
          operation,
          async _run(dataset) {
            dataset.value = await this.operation(dataset.value);
            return dataset;
          }
        };
      }
      function trim() {
        return {
          kind: "transformation",
          type: "trim",
          reference: trim,
          async: false,
          _run(dataset) {
            dataset.value = dataset.value.trim();
            return dataset;
          }
        };
      }
      function trimEnd() {
        return {
          kind: "transformation",
          type: "trim_end",
          reference: trimEnd,
          async: false,
          _run(dataset) {
            dataset.value = dataset.value.trimEnd();
            return dataset;
          }
        };
      }
      function trimStart() {
        return {
          kind: "transformation",
          type: "trim_start",
          reference: trimStart,
          async: false,
          _run(dataset) {
            dataset.value = dataset.value.trimStart();
            return dataset;
          }
        };
      }
      function ulid(message) {
        return {
          kind: "validation",
          type: "ulid",
          reference: ulid,
          async: false,
          expects: null,
          requirement: ULID_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "ULID", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function url(message) {
        return {
          kind: "validation",
          type: "url",
          reference: url,
          async: false,
          expects: null,
          requirement(input) {
            try {
              new URL(input);
              return true;
            } catch {
              return false;
            }
          },
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement(dataset.value)) {
              _addIssue(this, "URL", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function uuid(message) {
        return {
          kind: "validation",
          type: "uuid",
          reference: uuid,
          async: false,
          expects: null,
          requirement: UUID_REGEX,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
              _addIssue(this, "UUID", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function value(requirement, message) {
        return {
          kind: "validation",
          type: "value",
          reference: value,
          async: false,
          expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),
          requirement,
          message,
          _run(dataset, config22) {
            if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {
              _addIssue(this, "value", dataset, config22, {
                received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
              });
            }
            return dataset;
          }
        };
      }
      function config2(schema, config22) {
        return {
          ...schema,
          _run(dataset, config_) {
            return schema._run(dataset, { ...config_, ...config22 });
          }
        };
      }
      function getFallback(schema, dataset, config22) {
        return typeof schema.fallback === "function" ? (
          // @ts-expect-error
          schema.fallback(dataset, config22)
        ) : (
          // @ts-expect-error
          schema.fallback
        );
      }
      function fallback(schema, fallback2) {
        return {
          ...schema,
          fallback: fallback2,
          _run(dataset, config22) {
            const outputDataset = schema._run(dataset, config22);
            return outputDataset.issues ? { typed: true, value: getFallback(this, outputDataset, config22) } : outputDataset;
          }
        };
      }
      function fallbackAsync(schema, fallback2) {
        return {
          ...schema,
          fallback: fallback2,
          async: true,
          async _run(dataset, config22) {
            const outputDataset = await schema._run(dataset, config22);
            return outputDataset.issues ? (
              // @ts-expect-error
              { typed: true, value: await getFallback(this, outputDataset, config22) }
            ) : outputDataset;
          }
        };
      }
      function flatten(issues) {
        const flatErrors = {};
        for (const issue of issues) {
          if (issue.path) {
            const dotPath = getDotPath(issue);
            if (dotPath) {
              if (!flatErrors.nested) {
                flatErrors.nested = {};
              }
              if (flatErrors.nested[dotPath]) {
                flatErrors.nested[dotPath].push(issue.message);
              } else {
                flatErrors.nested[dotPath] = [issue.message];
              }
            } else {
              if (flatErrors.other) {
                flatErrors.other.push(issue.message);
              } else {
                flatErrors.other = [issue.message];
              }
            }
          } else {
            if (flatErrors.root) {
              flatErrors.root.push(issue.message);
            } else {
              flatErrors.root = [issue.message];
            }
          }
        }
        return flatErrors;
      }
      function forward(action, pathKeys) {
        return {
          ...action,
          _run(dataset, config22) {
            const prevIssues = dataset.issues && [...dataset.issues];
            action._run(dataset, config22);
            if (dataset.issues) {
              for (const issue of dataset.issues) {
                if (!prevIssues?.includes(issue)) {
                  let pathInput = dataset.value;
                  for (const key of pathKeys) {
                    const pathValue = pathInput[key];
                    const pathItem = {
                      type: "unknown",
                      origin: "value",
                      input: pathInput,
                      key,
                      value: pathValue
                    };
                    if (issue.path) {
                      issue.path.push(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    if (!pathValue) {
                      break;
                    }
                    pathInput = pathValue;
                  }
                }
              }
            }
            return dataset;
          }
        };
      }
      function forwardAsync(action, pathKeys) {
        return {
          ...action,
          async: true,
          async _run(dataset, config22) {
            const prevIssues = dataset.issues && [...dataset.issues];
            await action._run(dataset, config22);
            if (dataset.issues) {
              for (const issue of dataset.issues) {
                if (!prevIssues?.includes(issue)) {
                  let pathInput = dataset.value;
                  for (const key of pathKeys) {
                    const pathValue = pathInput[key];
                    const pathItem = {
                      type: "unknown",
                      origin: "value",
                      input: pathInput,
                      key,
                      value: pathValue
                    };
                    if (issue.path) {
                      issue.path.push(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    if (!pathValue) {
                      break;
                    }
                    pathInput = pathValue;
                  }
                }
              }
            }
            return dataset;
          }
        };
      }
      function getDefault(schema, dataset, config22) {
        return typeof schema.default === "function" ? (
          // @ts-expect-error
          schema.default(dataset, config22)
        ) : (
          // @ts-expect-error
          schema.default
        );
      }
      function getDefaults(schema) {
        if ("entries" in schema) {
          const object2 = {};
          for (const key in schema.entries) {
            object2[key] = getDefaults(schema.entries[key]);
          }
          return object2;
        }
        if ("items" in schema) {
          return schema.items.map(getDefaults);
        }
        return getDefault(schema);
      }
      async function getDefaultsAsync(schema) {
        if ("entries" in schema) {
          return Object.fromEntries(
            await Promise.all(
              Object.entries(schema.entries).map(async ([key, value2]) => [
                key,
                await getDefaultsAsync(value2)
              ])
            )
          );
        }
        if ("items" in schema) {
          return Promise.all(schema.items.map(getDefaultsAsync));
        }
        return getDefault(schema);
      }
      function getFallbacks(schema) {
        if ("entries" in schema) {
          const object2 = {};
          for (const key in schema.entries) {
            object2[key] = getFallbacks(schema.entries[key]);
          }
          return object2;
        }
        if ("items" in schema) {
          return schema.items.map(getFallbacks);
        }
        return getFallback(schema);
      }
      async function getFallbacksAsync(schema) {
        if ("entries" in schema) {
          return Object.fromEntries(
            await Promise.all(
              Object.entries(schema.entries).map(async ([key, value2]) => [
                key,
                await getFallbacksAsync(value2)
              ])
            )
          );
        }
        if ("items" in schema) {
          return Promise.all(schema.items.map(getFallbacksAsync));
        }
        return getFallback(schema);
      }
      function is(schema, input) {
        return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;
      }
      function any() {
        return {
          kind: "schema",
          type: "any",
          reference: any,
          expects: "any",
          async: false,
          _run(dataset) {
            dataset.typed = true;
            return dataset;
          }
        };
      }
      function array(item, message) {
        return {
          kind: "schema",
          type: "array",
          reference: array,
          expects: "Array",
          async: false,
          item,
          message,
          _run(dataset, config22) {
            const input = dataset.value;
            if (Array.isArray(input)) {
              dataset.typed = true;
              dataset.value = [];
              for (let key = 0; key < input.length; key++) {
                const value2 = input[key];
                const itemDataset = this.item._run({ typed: false, value: value2 }, config22);
                if (itemDataset.issues) {
                  const pathItem = {
                    type: "array",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of itemDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = itemDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!itemDataset.typed) {
                  dataset.typed = false;
                }
                dataset.value.push(itemDataset.value);
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function arrayAsync(item, message) {
        return {
          kind: "schema",
          type: "array",
          reference: arrayAsync,
          expects: "Array",
          async: true,
          item,
          message,
          async _run(dataset, config22) {
            const input = dataset.value;
            if (Array.isArray(input)) {
              dataset.typed = true;
              dataset.value = [];
              const itemDatasets = await Promise.all(
                input.map((value2) => this.item._run({ typed: false, value: value2 }, config22))
              );
              for (let key = 0; key < itemDatasets.length; key++) {
                const itemDataset = itemDatasets[key];
                if (itemDataset.issues) {
                  const pathItem = {
                    type: "array",
                    origin: "value",
                    input,
                    key,
                    value: input[key]
                  };
                  for (const issue of itemDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = itemDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!itemDataset.typed) {
                  dataset.typed = false;
                }
                dataset.value.push(itemDataset.value);
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function bigint(message) {
        return {
          kind: "schema",
          type: "bigint",
          reference: bigint,
          expects: "bigint",
          async: false,
          message,
          _run(dataset, config22) {
            if (typeof dataset.value === "bigint") {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function blob(message) {
        return {
          kind: "schema",
          type: "blob",
          reference: blob,
          expects: "Blob",
          async: false,
          message,
          _run(dataset, config22) {
            if (dataset.value instanceof Blob) {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function boolean(message) {
        return {
          kind: "schema",
          type: "boolean",
          reference: boolean,
          expects: "boolean",
          async: false,
          message,
          _run(dataset, config22) {
            if (typeof dataset.value === "boolean") {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function custom(check2, message) {
        return {
          kind: "schema",
          type: "custom",
          reference: custom,
          expects: "unknown",
          async: false,
          check: check2,
          message,
          _run(dataset, config22) {
            if (this.check(dataset.value)) {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function customAsync(check2, message) {
        return {
          kind: "schema",
          type: "custom",
          reference: customAsync,
          expects: "unknown",
          async: true,
          check: check2,
          message,
          async _run(dataset, config22) {
            if (await this.check(dataset.value)) {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function date(message) {
        return {
          kind: "schema",
          type: "date",
          reference: date,
          expects: "Date",
          async: false,
          message,
          _run(dataset, config22) {
            if (dataset.value instanceof Date) {
              if (!isNaN(dataset.value)) {
                dataset.typed = true;
              } else {
                _addIssue(this, "type", dataset, config22, {
                  received: '"Invalid Date"'
                });
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function enum_(enum__, message) {
        const options = Object.entries(enum__).filter(([key]) => isNaN(+key)).map(([, value2]) => value2);
        return {
          kind: "schema",
          type: "enum",
          reference: enum_,
          expects: options.map(_stringify).join(" | ") || "never",
          async: false,
          enum: enum__,
          options,
          message,
          _run(dataset, config22) {
            if (this.options.includes(dataset.value)) {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function file(message) {
        return {
          kind: "schema",
          type: "file",
          reference: file,
          expects: "File",
          async: false,
          message,
          _run(dataset, config22) {
            if (dataset.value instanceof File) {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function function_(message) {
        return {
          kind: "schema",
          type: "function",
          reference: function_,
          expects: "Function",
          async: false,
          message,
          _run(dataset, config22) {
            if (typeof dataset.value === "function") {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function instance(class_, message) {
        return {
          kind: "schema",
          type: "instance",
          reference: instance,
          expects: class_.name,
          async: false,
          class: class_,
          message,
          _run(dataset, config22) {
            if (dataset.value instanceof this.class) {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function _merge(value1, value2) {
        if (typeof value1 === typeof value2) {
          if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {
            return { value: value1 };
          }
          if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {
            for (const key in value2) {
              if (key in value1) {
                const dataset = _merge(value1[key], value2[key]);
                if (dataset.issue) {
                  return dataset;
                }
                value1[key] = dataset.value;
              } else {
                value1[key] = value2[key];
              }
            }
            return { value: value1 };
          }
          if (Array.isArray(value1) && Array.isArray(value2)) {
            if (value1.length === value2.length) {
              for (let index = 0; index < value1.length; index++) {
                const dataset = _merge(value1[index], value2[index]);
                if (dataset.issue) {
                  return dataset;
                }
                value1[index] = dataset.value;
              }
              return { value: value1 };
            }
          }
        }
        return { issue: true };
      }
      function intersect(options, message) {
        return {
          kind: "schema",
          type: "intersect",
          reference: intersect,
          expects: [...new Set(options.map((option) => option.expects))].join(" & ") || "never",
          async: false,
          options,
          message,
          _run(dataset, config22) {
            if (this.options.length) {
              const input = dataset.value;
              let outputs;
              dataset.typed = true;
              for (const schema of this.options) {
                const optionDataset = schema._run(
                  { typed: false, value: input },
                  config22
                );
                if (optionDataset.issues) {
                  if (dataset.issues) {
                    dataset.issues.push(...optionDataset.issues);
                  } else {
                    dataset.issues = optionDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!optionDataset.typed) {
                  dataset.typed = false;
                }
                if (dataset.typed) {
                  if (outputs) {
                    outputs.push(optionDataset.value);
                  } else {
                    outputs = [optionDataset.value];
                  }
                }
              }
              if (dataset.typed) {
                dataset.value = outputs[0];
                for (let index = 1; index < outputs.length; index++) {
                  const mergeDataset = _merge(dataset.value, outputs[index]);
                  if (mergeDataset.issue) {
                    _addIssue(this, "type", dataset, config22, {
                      received: "unknown"
                    });
                    break;
                  }
                  dataset.value = mergeDataset.value;
                }
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function intersectAsync(options, message) {
        return {
          kind: "schema",
          type: "intersect",
          reference: intersectAsync,
          expects: [...new Set(options.map((option) => option.expects))].join(" & ") || "never",
          async: true,
          options,
          message,
          async _run(dataset, config22) {
            if (this.options.length) {
              const input = dataset.value;
              let outputs;
              dataset.typed = true;
              const optionDatasets = await Promise.all(
                this.options.map(
                  (schema) => schema._run({ typed: false, value: input }, config22)
                )
              );
              for (const optionDataset of optionDatasets) {
                if (optionDataset.issues) {
                  if (dataset.issues) {
                    dataset.issues.push(...optionDataset.issues);
                  } else {
                    dataset.issues = optionDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!optionDataset.typed) {
                  dataset.typed = false;
                }
                if (dataset.typed) {
                  if (outputs) {
                    outputs.push(optionDataset.value);
                  } else {
                    outputs = [optionDataset.value];
                  }
                }
              }
              if (dataset.typed) {
                dataset.value = outputs[0];
                for (let index = 1; index < outputs.length; index++) {
                  const mergeDataset = _merge(dataset.value, outputs[index]);
                  if (mergeDataset.issue) {
                    _addIssue(this, "type", dataset, config22, {
                      received: "unknown"
                    });
                    break;
                  }
                  dataset.value = mergeDataset.value;
                }
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function lazy(getter) {
        return {
          kind: "schema",
          type: "lazy",
          reference: lazy,
          expects: "unknown",
          async: false,
          getter,
          _run(dataset, config22) {
            return this.getter(dataset.value)._run(dataset, config22);
          }
        };
      }
      function lazyAsync(getter) {
        return {
          kind: "schema",
          type: "lazy",
          reference: lazyAsync,
          expects: "unknown",
          async: true,
          getter,
          async _run(dataset, config22) {
            return (await this.getter(dataset.value))._run(dataset, config22);
          }
        };
      }
      function literal(literal_, message) {
        return {
          kind: "schema",
          type: "literal",
          reference: literal,
          expects: _stringify(literal_),
          async: false,
          literal: literal_,
          message,
          _run(dataset, config22) {
            if (dataset.value === this.literal) {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function looseObject(entries, message) {
        return {
          kind: "schema",
          type: "loose_object",
          reference: looseObject,
          expects: "Object",
          async: false,
          entries,
          message,
          _run(dataset, config22) {
            const input = dataset.value;
            if (input && typeof input === "object") {
              dataset.typed = true;
              dataset.value = {};
              for (const key in this.entries) {
                const value2 = input[key];
                const valueDataset = this.entries[key]._run(
                  { typed: false, value: value2 },
                  config22
                );
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "object",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = valueDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!valueDataset.typed) {
                  dataset.typed = false;
                }
                if (valueDataset.value !== void 0 || key in input) {
                  dataset.value[key] = valueDataset.value;
                }
              }
              if (!dataset.issues || !config22.abortEarly) {
                for (const key in input) {
                  if (_isValidObjectKey(input, key) && !(key in this.entries)) {
                    dataset.value[key] = input[key];
                  }
                }
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function looseObjectAsync(entries, message) {
        return {
          kind: "schema",
          type: "loose_object",
          reference: looseObjectAsync,
          expects: "Object",
          async: true,
          entries,
          message,
          async _run(dataset, config22) {
            const input = dataset.value;
            if (input && typeof input === "object") {
              dataset.typed = true;
              dataset.value = {};
              const valueDatasets = await Promise.all(
                Object.entries(this.entries).map(async ([key, schema]) => {
                  const value2 = input[key];
                  return [
                    key,
                    value2,
                    await schema._run({ typed: false, value: value2 }, config22)
                  ];
                })
              );
              for (const [key, value2, valueDataset] of valueDatasets) {
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "object",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = valueDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!valueDataset.typed) {
                  dataset.typed = false;
                }
                if (valueDataset.value !== void 0 || key in input) {
                  dataset.value[key] = valueDataset.value;
                }
              }
              if (!dataset.issues || !config22.abortEarly) {
                for (const key in input) {
                  if (_isValidObjectKey(input, key) && !(key in this.entries)) {
                    dataset.value[key] = input[key];
                  }
                }
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function looseTuple(items, message) {
        return {
          kind: "schema",
          type: "loose_tuple",
          reference: looseTuple,
          expects: "Array",
          async: false,
          items,
          message,
          _run(dataset, config22) {
            const input = dataset.value;
            if (Array.isArray(input)) {
              dataset.typed = true;
              dataset.value = [];
              for (let key = 0; key < this.items.length; key++) {
                const value2 = input[key];
                const itemDataset = this.items[key]._run(
                  { typed: false, value: value2 },
                  config22
                );
                if (itemDataset.issues) {
                  const pathItem = {
                    type: "array",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of itemDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = itemDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!itemDataset.typed) {
                  dataset.typed = false;
                }
                dataset.value.push(itemDataset.value);
              }
              if (!dataset.issues || !config22.abortEarly) {
                for (let key = this.items.length; key < input.length; key++) {
                  dataset.value.push(input[key]);
                }
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function looseTupleAsync(items, message) {
        return {
          kind: "schema",
          type: "loose_tuple",
          reference: looseTupleAsync,
          expects: "Array",
          async: true,
          items,
          message,
          async _run(dataset, config22) {
            const input = dataset.value;
            if (Array.isArray(input)) {
              dataset.typed = true;
              dataset.value = [];
              const itemDatasets = await Promise.all(
                this.items.map(async (item, key) => {
                  const value2 = input[key];
                  return [
                    key,
                    value2,
                    await item._run({ typed: false, value: value2 }, config22)
                  ];
                })
              );
              for (const [key, value2, itemDataset] of itemDatasets) {
                if (itemDataset.issues) {
                  const pathItem = {
                    type: "array",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of itemDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = itemDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!itemDataset.typed) {
                  dataset.typed = false;
                }
                dataset.value.push(itemDataset.value);
              }
              if (!dataset.issues || !config22.abortEarly) {
                for (let key = this.items.length; key < input.length; key++) {
                  dataset.value.push(input[key]);
                }
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function map(key, value2, message) {
        return {
          kind: "schema",
          type: "map",
          reference: map,
          expects: "Map",
          async: false,
          key,
          value: value2,
          message,
          _run(dataset, config22) {
            const input = dataset.value;
            if (input instanceof Map) {
              dataset.typed = true;
              dataset.value = /* @__PURE__ */ new Map();
              for (const [inputKey, inputValue] of input) {
                const keyDataset = this.key._run(
                  { typed: false, value: inputKey },
                  config22
                );
                if (keyDataset.issues) {
                  const pathItem = {
                    type: "map",
                    origin: "key",
                    input,
                    key: inputKey,
                    value: inputValue
                  };
                  for (const issue of keyDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = keyDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                const valueDataset = this.value._run(
                  { typed: false, value: inputValue },
                  config22
                );
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "map",
                    origin: "value",
                    input,
                    key: inputKey,
                    value: inputValue
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = valueDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!keyDataset.typed || !valueDataset.typed) {
                  dataset.typed = false;
                }
                dataset.value.set(keyDataset.value, valueDataset.value);
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function mapAsync(key, value2, message) {
        return {
          kind: "schema",
          type: "map",
          reference: mapAsync,
          expects: "Map",
          async: true,
          key,
          value: value2,
          message,
          async _run(dataset, config22) {
            const input = dataset.value;
            if (input instanceof Map) {
              dataset.typed = true;
              dataset.value = /* @__PURE__ */ new Map();
              const datasets = await Promise.all(
                [...input].map(
                  ([inputKey, inputValue]) => Promise.all([
                    inputKey,
                    inputValue,
                    this.key._run({ typed: false, value: inputKey }, config22),
                    this.value._run({ typed: false, value: inputValue }, config22)
                  ])
                )
              );
              for (const [
                inputKey,
                inputValue,
                keyDataset,
                valueDataset
              ] of datasets) {
                if (keyDataset.issues) {
                  const pathItem = {
                    type: "map",
                    origin: "key",
                    input,
                    key: inputKey,
                    value: inputValue
                  };
                  for (const issue of keyDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = keyDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "map",
                    origin: "value",
                    input,
                    key: inputKey,
                    value: inputValue
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = valueDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!keyDataset.typed || !valueDataset.typed) {
                  dataset.typed = false;
                }
                dataset.value.set(keyDataset.value, valueDataset.value);
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function nan(message) {
        return {
          kind: "schema",
          type: "nan",
          reference: nan,
          expects: "NaN",
          async: false,
          message,
          _run(dataset, config22) {
            if (Number.isNaN(dataset.value)) {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function never(message) {
        return {
          kind: "schema",
          type: "never",
          reference: never,
          expects: "never",
          async: false,
          message,
          _run(dataset, config22) {
            _addIssue(this, "type", dataset, config22);
            return dataset;
          }
        };
      }
      function nonNullable(wrapped, message) {
        return {
          kind: "schema",
          type: "non_nullable",
          reference: nonNullable,
          expects: "!null",
          async: false,
          wrapped,
          message,
          _run(dataset, config22) {
            if (dataset.value === null) {
              _addIssue(this, "type", dataset, config22);
              return dataset;
            }
            return this.wrapped._run(dataset, config22);
          }
        };
      }
      function nonNullableAsync(wrapped, message) {
        return {
          kind: "schema",
          type: "non_nullable",
          reference: nonNullableAsync,
          expects: "!null",
          async: true,
          wrapped,
          message,
          async _run(dataset, config22) {
            if (dataset.value === null) {
              _addIssue(this, "type", dataset, config22);
              return dataset;
            }
            return this.wrapped._run(dataset, config22);
          }
        };
      }
      function nonNullish(wrapped, message) {
        return {
          kind: "schema",
          type: "non_nullish",
          reference: nonNullish,
          expects: "!null & !undefined",
          async: false,
          wrapped,
          message,
          _run(dataset, config22) {
            if (dataset.value === null || dataset.value === void 0) {
              _addIssue(this, "type", dataset, config22);
              return dataset;
            }
            return this.wrapped._run(dataset, config22);
          }
        };
      }
      function nonNullishAsync(wrapped, message) {
        return {
          kind: "schema",
          type: "non_nullish",
          reference: nonNullishAsync,
          expects: "!null & !undefined",
          async: true,
          wrapped,
          message,
          async _run(dataset, config22) {
            if (dataset.value === null || dataset.value === void 0) {
              _addIssue(this, "type", dataset, config22);
              return dataset;
            }
            return this.wrapped._run(dataset, config22);
          }
        };
      }
      function nonOptional(wrapped, message) {
        return {
          kind: "schema",
          type: "non_optional",
          reference: nonOptional,
          expects: "!undefined",
          async: false,
          wrapped,
          message,
          _run(dataset, config22) {
            if (dataset.value === void 0) {
              _addIssue(this, "type", dataset, config22);
              return dataset;
            }
            return this.wrapped._run(dataset, config22);
          }
        };
      }
      function nonOptionalAsync(wrapped, message) {
        return {
          kind: "schema",
          type: "non_optional",
          reference: nonOptionalAsync,
          expects: "!undefined",
          async: true,
          wrapped,
          message,
          async _run(dataset, config22) {
            if (dataset.value === void 0) {
              _addIssue(this, "type", dataset, config22);
              return dataset;
            }
            return this.wrapped._run(dataset, config22);
          }
        };
      }
      function null_(message) {
        return {
          kind: "schema",
          type: "null",
          reference: null_,
          expects: "null",
          async: false,
          message,
          _run(dataset, config22) {
            if (dataset.value === null) {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function nullable(wrapped, ...args) {
        const schema = {
          kind: "schema",
          type: "nullable",
          reference: nullable,
          expects: `${wrapped.expects} | null`,
          async: false,
          wrapped,
          _run(dataset, config22) {
            if (dataset.value === null) {
              if ("default" in this) {
                dataset.value = getDefault(
                  this,
                  dataset,
                  config22
                );
              }
              if (dataset.value === null) {
                dataset.typed = true;
                return dataset;
              }
            }
            return this.wrapped._run(dataset, config22);
          }
        };
        if (0 in args) {
          schema.default = args[0];
        }
        return schema;
      }
      function nullableAsync(wrapped, ...args) {
        const schema = {
          kind: "schema",
          type: "nullable",
          reference: nullableAsync,
          expects: `${wrapped.expects} | null`,
          async: true,
          wrapped,
          async _run(dataset, config22) {
            if (dataset.value === null) {
              if ("default" in this) {
                dataset.value = await getDefault(
                  this,
                  dataset,
                  config22
                );
              }
              if (dataset.value === null) {
                dataset.typed = true;
                return dataset;
              }
            }
            return this.wrapped._run(dataset, config22);
          }
        };
        if (0 in args) {
          schema.default = args[0];
        }
        return schema;
      }
      function nullish(wrapped, ...args) {
        const schema = {
          kind: "schema",
          type: "nullish",
          reference: nullish,
          expects: `${wrapped.expects} | null | undefined`,
          async: false,
          wrapped,
          _run(dataset, config22) {
            if (dataset.value === null || dataset.value === void 0) {
              if ("default" in this) {
                dataset.value = getDefault(
                  this,
                  dataset,
                  config22
                );
              }
              if (dataset.value === null || dataset.value === void 0) {
                dataset.typed = true;
                return dataset;
              }
            }
            return this.wrapped._run(dataset, config22);
          }
        };
        if (0 in args) {
          schema.default = args[0];
        }
        return schema;
      }
      function nullishAsync(wrapped, ...args) {
        const schema = {
          kind: "schema",
          type: "nullish",
          reference: nullishAsync,
          expects: `${wrapped.expects} | null | undefined`,
          async: true,
          wrapped,
          async _run(dataset, config22) {
            if (dataset.value === null || dataset.value === void 0) {
              if ("default" in this) {
                dataset.value = await getDefault(
                  this,
                  dataset,
                  config22
                );
              }
              if (dataset.value === null || dataset.value === void 0) {
                dataset.typed = true;
                return dataset;
              }
            }
            return this.wrapped._run(dataset, config22);
          }
        };
        if (0 in args) {
          schema.default = args[0];
        }
        return schema;
      }
      function number(message) {
        return {
          kind: "schema",
          type: "number",
          reference: number,
          expects: "number",
          async: false,
          message,
          _run(dataset, config22) {
            if (typeof dataset.value === "number" && !isNaN(dataset.value)) {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function object(entries, message) {
        return {
          kind: "schema",
          type: "object",
          reference: object,
          expects: "Object",
          async: false,
          entries,
          message,
          _run(dataset, config22) {
            const input = dataset.value;
            if (input && typeof input === "object") {
              dataset.typed = true;
              dataset.value = {};
              for (const key in this.entries) {
                const value2 = input[key];
                const valueDataset = this.entries[key]._run(
                  { typed: false, value: value2 },
                  config22
                );
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "object",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = valueDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!valueDataset.typed) {
                  dataset.typed = false;
                }
                if (valueDataset.value !== void 0 || key in input) {
                  dataset.value[key] = valueDataset.value;
                }
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function objectAsync(entries, message) {
        return {
          kind: "schema",
          type: "object",
          reference: objectAsync,
          expects: "Object",
          async: true,
          entries,
          message,
          async _run(dataset, config22) {
            const input = dataset.value;
            if (input && typeof input === "object") {
              dataset.typed = true;
              dataset.value = {};
              const valueDatasets = await Promise.all(
                Object.entries(this.entries).map(async ([key, schema]) => {
                  const value2 = input[key];
                  return [
                    key,
                    value2,
                    await schema._run({ typed: false, value: value2 }, config22)
                  ];
                })
              );
              for (const [key, value2, valueDataset] of valueDatasets) {
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "object",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = valueDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!valueDataset.typed) {
                  dataset.typed = false;
                }
                if (valueDataset.value !== void 0 || key in input) {
                  dataset.value[key] = valueDataset.value;
                }
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function objectWithRest(entries, rest, message) {
        return {
          kind: "schema",
          type: "object_with_rest",
          reference: objectWithRest,
          expects: "Object",
          async: false,
          entries,
          rest,
          message,
          _run(dataset, config22) {
            const input = dataset.value;
            if (input && typeof input === "object") {
              dataset.typed = true;
              dataset.value = {};
              for (const key in this.entries) {
                const value2 = input[key];
                const valueDataset = this.entries[key]._run(
                  { typed: false, value: value2 },
                  config22
                );
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "object",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = valueDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!valueDataset.typed) {
                  dataset.typed = false;
                }
                if (valueDataset.value !== void 0 || key in input) {
                  dataset.value[key] = valueDataset.value;
                }
              }
              if (!dataset.issues || !config22.abortEarly) {
                for (const key in input) {
                  if (_isValidObjectKey(input, key) && !(key in this.entries)) {
                    const value2 = input[key];
                    const valueDataset = this.rest._run(
                      { typed: false, value: value2 },
                      config22
                    );
                    if (valueDataset.issues) {
                      const pathItem = {
                        type: "object",
                        origin: "value",
                        input,
                        key,
                        value: value2
                      };
                      for (const issue of valueDataset.issues) {
                        if (issue.path) {
                          issue.path.unshift(pathItem);
                        } else {
                          issue.path = [pathItem];
                        }
                        dataset.issues?.push(issue);
                      }
                      if (!dataset.issues) {
                        dataset.issues = valueDataset.issues;
                      }
                      if (config22.abortEarly) {
                        dataset.typed = false;
                        break;
                      }
                    }
                    if (!valueDataset.typed) {
                      dataset.typed = false;
                    }
                    dataset.value[key] = valueDataset.value;
                  }
                }
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function objectWithRestAsync(entries, rest, message) {
        return {
          kind: "schema",
          type: "object_with_rest",
          reference: objectWithRestAsync,
          expects: "Object",
          async: true,
          entries,
          rest,
          message,
          async _run(dataset, config22) {
            const input = dataset.value;
            if (input && typeof input === "object") {
              dataset.typed = true;
              dataset.value = {};
              const [normalDatasets, restDatasets] = await Promise.all([
                // Parse schema of each normal entry
                // Hint: We do not distinguish between missing and `undefined` entries.
                // The reason for this decision is that it reduces the bundle size, and
                // we also expect that most users will expect this behavior.
                Promise.all(
                  Object.entries(this.entries).map(async ([key, schema]) => {
                    const value2 = input[key];
                    return [
                      key,
                      value2,
                      await schema._run({ typed: false, value: value2 }, config22)
                    ];
                  })
                ),
                // Parse other entries with rest schema
                // Hint: We exclude specific keys for security reasons
                Promise.all(
                  Object.entries(input).filter(
                    ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)
                  ).map(
                    async ([key, value2]) => [
                      key,
                      value2,
                      await this.rest._run({ typed: false, value: value2 }, config22)
                    ]
                  )
                )
              ]);
              for (const [key, value2, valueDataset] of normalDatasets) {
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "object",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = valueDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!valueDataset.typed) {
                  dataset.typed = false;
                }
                if (valueDataset.value !== void 0 || key in input) {
                  dataset.value[key] = valueDataset.value;
                }
              }
              if (!dataset.issues || !config22.abortEarly) {
                for (const [key, value2, valueDataset] of restDatasets) {
                  if (valueDataset.issues) {
                    const pathItem = {
                      type: "object",
                      origin: "value",
                      input,
                      key,
                      value: value2
                    };
                    for (const issue of valueDataset.issues) {
                      if (issue.path) {
                        issue.path.unshift(pathItem);
                      } else {
                        issue.path = [pathItem];
                      }
                      dataset.issues?.push(issue);
                    }
                    if (!dataset.issues) {
                      dataset.issues = valueDataset.issues;
                    }
                    if (config22.abortEarly) {
                      dataset.typed = false;
                      break;
                    }
                  }
                  if (!valueDataset.typed) {
                    dataset.typed = false;
                  }
                  dataset.value[key] = valueDataset.value;
                }
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function optional(wrapped, ...args) {
        const schema = {
          kind: "schema",
          type: "optional",
          reference: optional,
          expects: `${wrapped.expects} | undefined`,
          async: false,
          wrapped,
          _run(dataset, config22) {
            if (dataset.value === void 0) {
              if ("default" in this) {
                dataset.value = getDefault(
                  this,
                  dataset,
                  config22
                );
              }
              if (dataset.value === void 0) {
                dataset.typed = true;
                return dataset;
              }
            }
            return this.wrapped._run(dataset, config22);
          }
        };
        if (0 in args) {
          schema.default = args[0];
        }
        return schema;
      }
      function optionalAsync(wrapped, ...args) {
        const schema = {
          kind: "schema",
          type: "optional",
          reference: optionalAsync,
          expects: `${wrapped.expects} | undefined`,
          async: true,
          wrapped,
          async _run(dataset, config22) {
            if (dataset.value === void 0) {
              if ("default" in this) {
                dataset.value = await getDefault(
                  this,
                  dataset,
                  config22
                );
              }
              if (dataset.value === void 0) {
                dataset.typed = true;
                return dataset;
              }
            }
            return this.wrapped._run(dataset, config22);
          }
        };
        if (0 in args) {
          schema.default = args[0];
        }
        return schema;
      }
      function picklist(options, message) {
        return {
          kind: "schema",
          type: "picklist",
          reference: picklist,
          expects: options.map(_stringify).join(" | ") || "never",
          async: false,
          options,
          message,
          _run(dataset, config22) {
            if (this.options.includes(dataset.value)) {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function promise(message) {
        return {
          kind: "schema",
          type: "promise",
          reference: promise,
          expects: "Promise",
          async: false,
          message,
          _run(dataset, config22) {
            if (dataset.value instanceof Promise) {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function record(key, value2, message) {
        return {
          kind: "schema",
          type: "record",
          reference: record,
          expects: "Object",
          async: false,
          key,
          value: value2,
          message,
          _run(dataset, config22) {
            const input = dataset.value;
            if (input && typeof input === "object") {
              dataset.typed = true;
              dataset.value = {};
              for (const entryKey in input) {
                if (_isValidObjectKey(input, entryKey)) {
                  const entryValue = input[entryKey];
                  const keyDataset = this.key._run(
                    { typed: false, value: entryKey },
                    config22
                  );
                  if (keyDataset.issues) {
                    const pathItem = {
                      type: "object",
                      origin: "key",
                      input,
                      key: entryKey,
                      value: entryValue
                    };
                    for (const issue of keyDataset.issues) {
                      issue.path = [pathItem];
                      dataset.issues?.push(issue);
                    }
                    if (!dataset.issues) {
                      dataset.issues = keyDataset.issues;
                    }
                    if (config22.abortEarly) {
                      dataset.typed = false;
                      break;
                    }
                  }
                  const valueDataset = this.value._run(
                    { typed: false, value: entryValue },
                    config22
                  );
                  if (valueDataset.issues) {
                    const pathItem = {
                      type: "object",
                      origin: "value",
                      input,
                      key: entryKey,
                      value: entryValue
                    };
                    for (const issue of valueDataset.issues) {
                      if (issue.path) {
                        issue.path.unshift(pathItem);
                      } else {
                        issue.path = [pathItem];
                      }
                      dataset.issues?.push(issue);
                    }
                    if (!dataset.issues) {
                      dataset.issues = valueDataset.issues;
                    }
                    if (config22.abortEarly) {
                      dataset.typed = false;
                      break;
                    }
                  }
                  if (!keyDataset.typed || !valueDataset.typed) {
                    dataset.typed = false;
                  }
                  if (keyDataset.typed) {
                    dataset.value[keyDataset.value] = valueDataset.value;
                  }
                }
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function recordAsync(key, value2, message) {
        return {
          kind: "schema",
          type: "record",
          reference: recordAsync,
          expects: "Object",
          async: true,
          key,
          value: value2,
          message,
          async _run(dataset, config22) {
            const input = dataset.value;
            if (input && typeof input === "object") {
              dataset.typed = true;
              dataset.value = {};
              const datasets = await Promise.all(
                Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(
                  ([entryKey, entryValue]) => Promise.all([
                    entryKey,
                    entryValue,
                    this.key._run({ typed: false, value: entryKey }, config22),
                    this.value._run({ typed: false, value: entryValue }, config22)
                  ])
                )
              );
              for (const [
                entryKey,
                entryValue,
                keyDataset,
                valueDataset
              ] of datasets) {
                if (keyDataset.issues) {
                  const pathItem = {
                    type: "object",
                    origin: "key",
                    input,
                    key: entryKey,
                    value: entryValue
                  };
                  for (const issue of keyDataset.issues) {
                    issue.path = [pathItem];
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = keyDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "object",
                    origin: "value",
                    input,
                    key: entryKey,
                    value: entryValue
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = valueDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!keyDataset.typed || !valueDataset.typed) {
                  dataset.typed = false;
                }
                if (keyDataset.typed) {
                  dataset.value[keyDataset.value] = valueDataset.value;
                }
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function set(value2, message) {
        return {
          kind: "schema",
          type: "set",
          reference: set,
          expects: "Set",
          async: false,
          value: value2,
          message,
          _run(dataset, config22) {
            const input = dataset.value;
            if (input instanceof Set) {
              dataset.typed = true;
              dataset.value = /* @__PURE__ */ new Set();
              for (const inputValue of input) {
                const valueDataset = this.value._run(
                  { typed: false, value: inputValue },
                  config22
                );
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "set",
                    origin: "value",
                    input,
                    key: null,
                    value: inputValue
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = valueDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!valueDataset.typed) {
                  dataset.typed = false;
                }
                dataset.value.add(valueDataset.value);
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function setAsync(value2, message) {
        return {
          kind: "schema",
          type: "set",
          reference: setAsync,
          expects: "Set",
          async: true,
          value: value2,
          message,
          async _run(dataset, config22) {
            const input = dataset.value;
            if (input instanceof Set) {
              dataset.typed = true;
              dataset.value = /* @__PURE__ */ new Set();
              const valueDatasets = await Promise.all(
                [...input].map(
                  async (inputValue) => [
                    inputValue,
                    await this.value._run(
                      { typed: false, value: inputValue },
                      config22
                    )
                  ]
                )
              );
              for (const [inputValue, valueDataset] of valueDatasets) {
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "set",
                    origin: "value",
                    input,
                    key: null,
                    value: inputValue
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = valueDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!valueDataset.typed) {
                  dataset.typed = false;
                }
                dataset.value.add(valueDataset.value);
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function strictObject(entries, message) {
        return {
          kind: "schema",
          type: "strict_object",
          reference: strictObject,
          expects: "Object",
          async: false,
          entries,
          message,
          _run(dataset, config22) {
            const input = dataset.value;
            if (input && typeof input === "object") {
              dataset.typed = true;
              dataset.value = {};
              for (const key in this.entries) {
                const value2 = input[key];
                const valueDataset = this.entries[key]._run(
                  { typed: false, value: value2 },
                  config22
                );
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "object",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = valueDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!valueDataset.typed) {
                  dataset.typed = false;
                }
                if (valueDataset.value !== void 0 || key in input) {
                  dataset.value[key] = valueDataset.value;
                }
              }
              if (!dataset.issues || !config22.abortEarly) {
                for (const key in input) {
                  if (!(key in this.entries)) {
                    const value2 = input[key];
                    _addIssue(this, "type", dataset, config22, {
                      input: value2,
                      expected: "never",
                      path: [
                        {
                          type: "object",
                          origin: "value",
                          input,
                          key,
                          value: value2
                        }
                      ]
                    });
                    break;
                  }
                }
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function strictObjectAsync(entries, message) {
        return {
          kind: "schema",
          type: "strict_object",
          reference: strictObjectAsync,
          expects: "Object",
          async: true,
          entries,
          message,
          async _run(dataset, config22) {
            const input = dataset.value;
            if (input && typeof input === "object") {
              dataset.typed = true;
              dataset.value = {};
              const valueDatasets = await Promise.all(
                Object.entries(this.entries).map(async ([key, schema]) => {
                  const value2 = input[key];
                  return [
                    key,
                    value2,
                    await schema._run({ typed: false, value: value2 }, config22)
                  ];
                })
              );
              for (const [key, value2, valueDataset] of valueDatasets) {
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "object",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = valueDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!valueDataset.typed) {
                  dataset.typed = false;
                }
                if (valueDataset.value !== void 0 || key in input) {
                  dataset.value[key] = valueDataset.value;
                }
              }
              if (!dataset.issues || !config22.abortEarly) {
                for (const key in input) {
                  if (!(key in this.entries)) {
                    const value2 = input[key];
                    _addIssue(this, "type", dataset, config22, {
                      input: value2,
                      expected: "never",
                      path: [
                        {
                          type: "object",
                          origin: "value",
                          input,
                          key,
                          value: value2
                        }
                      ]
                    });
                    break;
                  }
                }
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function strictTuple(items, message) {
        return {
          kind: "schema",
          type: "strict_tuple",
          reference: strictTuple,
          expects: "Array",
          async: false,
          items,
          message,
          _run(dataset, config22) {
            const input = dataset.value;
            if (Array.isArray(input)) {
              dataset.typed = true;
              dataset.value = [];
              for (let key = 0; key < this.items.length; key++) {
                const value2 = input[key];
                const itemDataset = this.items[key]._run(
                  { typed: false, value: value2 },
                  config22
                );
                if (itemDataset.issues) {
                  const pathItem = {
                    type: "array",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of itemDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = itemDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!itemDataset.typed) {
                  dataset.typed = false;
                }
                dataset.value.push(itemDataset.value);
              }
              if (!(dataset.issues && config22.abortEarly) && this.items.length < input.length) {
                const value2 = input[items.length];
                _addIssue(this, "type", dataset, config22, {
                  input: value2,
                  expected: "never",
                  path: [
                    {
                      type: "array",
                      origin: "value",
                      input,
                      key: this.items.length,
                      value: value2
                    }
                  ]
                });
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function strictTupleAsync(items, message) {
        return {
          kind: "schema",
          type: "strict_tuple",
          reference: strictTupleAsync,
          expects: "Array",
          async: true,
          items,
          message,
          async _run(dataset, config22) {
            const input = dataset.value;
            if (Array.isArray(input)) {
              dataset.typed = true;
              dataset.value = [];
              const itemDatasets = await Promise.all(
                this.items.map(async (item, key) => {
                  const value2 = input[key];
                  return [
                    key,
                    value2,
                    await item._run({ typed: false, value: value2 }, config22)
                  ];
                })
              );
              for (const [key, value2, itemDataset] of itemDatasets) {
                if (itemDataset.issues) {
                  const pathItem = {
                    type: "array",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of itemDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = itemDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!itemDataset.typed) {
                  dataset.typed = false;
                }
                dataset.value.push(itemDataset.value);
              }
              if (!(dataset.issues && config22.abortEarly) && this.items.length < input.length) {
                const value2 = input[items.length];
                _addIssue(this, "type", dataset, config22, {
                  input: value2,
                  expected: "never",
                  path: [
                    {
                      type: "array",
                      origin: "value",
                      input,
                      key: this.items.length,
                      value: value2
                    }
                  ]
                });
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function string(message) {
        return {
          kind: "schema",
          type: "string",
          reference: string,
          expects: "string",
          async: false,
          message,
          _run(dataset, config22) {
            if (typeof dataset.value === "string") {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function symbol(message) {
        return {
          kind: "schema",
          type: "symbol",
          reference: symbol,
          expects: "symbol",
          async: false,
          message,
          _run(dataset, config22) {
            if (typeof dataset.value === "symbol") {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function tuple(items, message) {
        return {
          kind: "schema",
          type: "tuple",
          reference: tuple,
          expects: "Array",
          async: false,
          items,
          message,
          _run(dataset, config22) {
            const input = dataset.value;
            if (Array.isArray(input)) {
              dataset.typed = true;
              dataset.value = [];
              for (let key = 0; key < this.items.length; key++) {
                const value2 = input[key];
                const itemDataset = this.items[key]._run(
                  { typed: false, value: value2 },
                  config22
                );
                if (itemDataset.issues) {
                  const pathItem = {
                    type: "array",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of itemDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = itemDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!itemDataset.typed) {
                  dataset.typed = false;
                }
                dataset.value.push(itemDataset.value);
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function tupleAsync(items, message) {
        return {
          kind: "schema",
          type: "tuple",
          reference: tupleAsync,
          expects: "Array",
          async: true,
          items,
          message,
          async _run(dataset, config22) {
            const input = dataset.value;
            if (Array.isArray(input)) {
              dataset.typed = true;
              dataset.value = [];
              const itemDatasets = await Promise.all(
                this.items.map(async (item, key) => {
                  const value2 = input[key];
                  return [
                    key,
                    value2,
                    await item._run({ typed: false, value: value2 }, config22)
                  ];
                })
              );
              for (const [key, value2, itemDataset] of itemDatasets) {
                if (itemDataset.issues) {
                  const pathItem = {
                    type: "array",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of itemDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = itemDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!itemDataset.typed) {
                  dataset.typed = false;
                }
                dataset.value.push(itemDataset.value);
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function tupleWithRest(items, rest, message) {
        return {
          kind: "schema",
          type: "tuple_with_rest",
          reference: tupleWithRest,
          expects: "Array",
          async: false,
          items,
          rest,
          message,
          _run(dataset, config22) {
            const input = dataset.value;
            if (Array.isArray(input)) {
              dataset.typed = true;
              dataset.value = [];
              for (let key = 0; key < this.items.length; key++) {
                const value2 = input[key];
                const itemDataset = this.items[key]._run(
                  { typed: false, value: value2 },
                  config22
                );
                if (itemDataset.issues) {
                  const pathItem = {
                    type: "array",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of itemDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = itemDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!itemDataset.typed) {
                  dataset.typed = false;
                }
                dataset.value.push(itemDataset.value);
              }
              if (!dataset.issues || !config22.abortEarly) {
                for (let key = this.items.length; key < input.length; key++) {
                  const value2 = input[key];
                  const itemDataset = this.rest._run({ typed: false, value: value2 }, config22);
                  if (itemDataset.issues) {
                    const pathItem = {
                      type: "array",
                      origin: "value",
                      input,
                      key,
                      value: value2
                    };
                    for (const issue of itemDataset.issues) {
                      if (issue.path) {
                        issue.path.unshift(pathItem);
                      } else {
                        issue.path = [pathItem];
                      }
                      dataset.issues?.push(issue);
                    }
                    if (!dataset.issues) {
                      dataset.issues = itemDataset.issues;
                    }
                    if (config22.abortEarly) {
                      dataset.typed = false;
                      break;
                    }
                  }
                  if (!itemDataset.typed) {
                    dataset.typed = false;
                  }
                  dataset.value.push(itemDataset.value);
                }
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function tupleWithRestAsync(items, rest, message) {
        return {
          kind: "schema",
          type: "tuple_with_rest",
          reference: tupleWithRestAsync,
          expects: "Array",
          async: true,
          items,
          rest,
          message,
          async _run(dataset, config22) {
            const input = dataset.value;
            if (Array.isArray(input)) {
              dataset.typed = true;
              dataset.value = [];
              const [normalDatasets, restDatasets] = await Promise.all([
                // Parse schema of each normal item
                Promise.all(
                  this.items.map(async (item, key) => {
                    const value2 = input[key];
                    return [
                      key,
                      value2,
                      await item._run({ typed: false, value: value2 }, config22)
                    ];
                  })
                ),
                // Parse other items with rest schema
                Promise.all(
                  input.slice(this.items.length).map(async (value2, key) => {
                    return [
                      key + this.items.length,
                      value2,
                      await this.rest._run({ typed: false, value: value2 }, config22)
                    ];
                  })
                )
              ]);
              for (const [key, value2, itemDataset] of normalDatasets) {
                if (itemDataset.issues) {
                  const pathItem = {
                    type: "array",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of itemDataset.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    dataset.issues?.push(issue);
                  }
                  if (!dataset.issues) {
                    dataset.issues = itemDataset.issues;
                  }
                  if (config22.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!itemDataset.typed) {
                  dataset.typed = false;
                }
                dataset.value.push(itemDataset.value);
              }
              if (!dataset.issues || !config22.abortEarly) {
                for (const [key, value2, itemDataset] of restDatasets) {
                  if (itemDataset.issues) {
                    const pathItem = {
                      type: "array",
                      origin: "value",
                      input,
                      key,
                      value: value2
                    };
                    for (const issue of itemDataset.issues) {
                      if (issue.path) {
                        issue.path.unshift(pathItem);
                      } else {
                        issue.path = [pathItem];
                      }
                      dataset.issues?.push(issue);
                    }
                    if (!dataset.issues) {
                      dataset.issues = itemDataset.issues;
                    }
                    if (config22.abortEarly) {
                      dataset.typed = false;
                      break;
                    }
                  }
                  if (!itemDataset.typed) {
                    dataset.typed = false;
                  }
                  dataset.value.push(itemDataset.value);
                }
              }
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function undefined_(message) {
        return {
          kind: "schema",
          type: "undefined",
          reference: undefined_,
          expects: "undefined",
          async: false,
          message,
          _run(dataset, config22) {
            if (dataset.value === void 0) {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function _subIssues(datasets) {
        let issues;
        if (datasets) {
          for (const dataset of datasets) {
            if (issues) {
              issues.push(...dataset.issues);
            } else {
              issues = dataset.issues;
            }
          }
        }
        return issues;
      }
      function union(options, message) {
        return {
          kind: "schema",
          type: "union",
          reference: union,
          expects: [...new Set(options.map((option) => option.expects))].join(" | ") || "never",
          async: false,
          options,
          message,
          _run(dataset, config22) {
            let validDataset;
            let typedDatasets;
            let untypedDatasets;
            for (const schema of this.options) {
              const optionDataset = schema._run(
                { typed: false, value: dataset.value },
                config22
              );
              if (optionDataset.typed) {
                if (optionDataset.issues) {
                  if (typedDatasets) {
                    typedDatasets.push(optionDataset);
                  } else {
                    typedDatasets = [optionDataset];
                  }
                } else {
                  validDataset = optionDataset;
                  break;
                }
              } else {
                if (untypedDatasets) {
                  untypedDatasets.push(optionDataset);
                } else {
                  untypedDatasets = [optionDataset];
                }
              }
            }
            if (validDataset) {
              return validDataset;
            }
            if (typedDatasets) {
              if (typedDatasets.length === 1) {
                return typedDatasets[0];
              }
              _addIssue(this, "type", dataset, config22, {
                issues: _subIssues(typedDatasets)
              });
              dataset.typed = true;
            } else if (untypedDatasets?.length === 1) {
              return untypedDatasets[0];
            } else {
              _addIssue(this, "type", dataset, config22, {
                issues: _subIssues(untypedDatasets)
              });
            }
            return dataset;
          }
        };
      }
      function unionAsync(options, message) {
        return {
          kind: "schema",
          type: "union",
          reference: unionAsync,
          expects: [...new Set(options.map((option) => option.expects))].join(" | ") || "never",
          async: true,
          options,
          message,
          async _run(dataset, config22) {
            let validDataset;
            let typedDatasets;
            let untypedDatasets;
            for (const schema of this.options) {
              const optionDataset = await schema._run(
                { typed: false, value: dataset.value },
                config22
              );
              if (optionDataset.typed) {
                if (optionDataset.issues) {
                  if (typedDatasets) {
                    typedDatasets.push(optionDataset);
                  } else {
                    typedDatasets = [optionDataset];
                  }
                } else {
                  validDataset = optionDataset;
                  break;
                }
              } else {
                if (untypedDatasets) {
                  untypedDatasets.push(optionDataset);
                } else {
                  untypedDatasets = [optionDataset];
                }
              }
            }
            if (validDataset) {
              return validDataset;
            }
            if (typedDatasets) {
              if (typedDatasets.length === 1) {
                return typedDatasets[0];
              }
              _addIssue(this, "type", dataset, config22, {
                issues: _subIssues(typedDatasets)
              });
              dataset.typed = true;
            } else if (untypedDatasets?.length === 1) {
              return untypedDatasets[0];
            } else {
              _addIssue(this, "type", dataset, config22, {
                issues: _subIssues(untypedDatasets)
              });
            }
            return dataset;
          }
        };
      }
      function unknown() {
        return {
          kind: "schema",
          type: "unknown",
          reference: unknown,
          expects: "unknown",
          async: false,
          _run(dataset) {
            dataset.typed = true;
            return dataset;
          }
        };
      }
      function _discriminators(key, options, set2 = /* @__PURE__ */ new Set()) {
        for (const schema of options) {
          if (schema.type === "variant") {
            _discriminators(key, schema.options, set2);
          } else {
            set2.add(schema.entries[key].expects);
          }
        }
        return set2;
      }
      function variant(key, options, message) {
        let expectedDiscriminators;
        return {
          kind: "schema",
          type: "variant",
          reference: variant,
          expects: "Object",
          async: false,
          key,
          options,
          message,
          _run(dataset, config22) {
            const input = dataset.value;
            if (input && typeof input === "object") {
              const discriminator = input[this.key];
              if (this.key in input) {
                let outputDataset;
                for (const schema of this.options) {
                  if (schema.type === "variant" || !schema.entries[this.key]._run(
                    { typed: false, value: discriminator },
                    config22
                  ).issues) {
                    const optionDataset = schema._run(
                      { typed: false, value: input },
                      config22
                    );
                    if (!optionDataset.issues) {
                      return optionDataset;
                    }
                    if (!outputDataset || !outputDataset.typed && optionDataset.typed) {
                      outputDataset = optionDataset;
                    }
                  }
                }
                if (outputDataset) {
                  return outputDataset;
                }
              }
              if (!expectedDiscriminators) {
                expectedDiscriminators = [..._discriminators(this.key, this.options)].join(" | ") || "never";
              }
              _addIssue(this, "type", dataset, config22, {
                input: discriminator,
                expected: expectedDiscriminators,
                path: [
                  {
                    type: "object",
                    origin: "value",
                    input,
                    key: this.key,
                    value: discriminator
                  }
                ]
              });
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function variantAsync(key, options, message) {
        let expectedDiscriminators;
        return {
          kind: "schema",
          type: "variant",
          reference: variantAsync,
          expects: "Object",
          async: true,
          key,
          options,
          message,
          async _run(dataset, config22) {
            const input = dataset.value;
            if (input && typeof input === "object") {
              const discriminator = input[this.key];
              if (this.key in input) {
                let outputDataset;
                for (const schema of this.options) {
                  if (schema.type === "variant" || !(await schema.entries[this.key]._run(
                    { typed: false, value: discriminator },
                    config22
                  )).issues) {
                    const optionDataset = await schema._run(
                      { typed: false, value: input },
                      config22
                    );
                    if (!optionDataset.issues) {
                      return optionDataset;
                    }
                    if (!outputDataset || !outputDataset.typed && optionDataset.typed) {
                      outputDataset = optionDataset;
                    }
                  }
                }
                if (outputDataset) {
                  return outputDataset;
                }
              }
              if (!expectedDiscriminators) {
                expectedDiscriminators = [..._discriminators(this.key, this.options)].join(" | ") || "never";
              }
              _addIssue(this, "type", dataset, config22, {
                input: discriminator,
                expected: expectedDiscriminators,
                path: [
                  {
                    type: "object",
                    origin: "value",
                    input,
                    key: this.key,
                    value: discriminator
                  }
                ]
              });
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function void_(message) {
        return {
          kind: "schema",
          type: "void",
          reference: void_,
          expects: "void",
          async: false,
          message,
          _run(dataset, config22) {
            if (dataset.value === void 0) {
              dataset.typed = true;
            } else {
              _addIssue(this, "type", dataset, config22);
            }
            return dataset;
          }
        };
      }
      function keyof(schema, message) {
        return picklist(Object.keys(schema.entries), message);
      }
      function omit(schema, keys) {
        const entries = {
          ...schema.entries
        };
        for (const key of keys) {
          delete entries[key];
        }
        return { ...schema, entries };
      }
      function parse(schema, input, config22) {
        const dataset = schema._run(
          { typed: false, value: input },
          getGlobalConfig(config22)
        );
        if (dataset.issues) {
          throw new ValiError(dataset.issues);
        }
        return dataset.value;
      }
      async function parseAsync(schema, input, config22) {
        const dataset = await schema._run(
          { typed: false, value: input },
          getGlobalConfig(config22)
        );
        if (dataset.issues) {
          throw new ValiError(dataset.issues);
        }
        return dataset.value;
      }
      function parser(schema, config22) {
        const func = (input) => parse(schema, input, config22);
        func.schema = schema;
        func.config = config22;
        return func;
      }
      function parserAsync(schema, config22) {
        const func = (input) => parseAsync(schema, input, config22);
        func.schema = schema;
        func.config = config22;
        return func;
      }
      function partial(schema, keys) {
        const entries = {};
        for (const key in schema.entries) {
          entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];
        }
        return { ...schema, entries };
      }
      function partialAsync(schema, keys) {
        const entries = {};
        for (const key in schema.entries) {
          entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];
        }
        return { ...schema, entries };
      }
      function pick(schema, keys) {
        const entries = {};
        for (const key of keys) {
          entries[key] = schema.entries[key];
        }
        return { ...schema, entries };
      }
      function pipe(...pipe2) {
        return {
          ...pipe2[0],
          pipe: pipe2,
          _run(dataset, config22) {
            for (const item of pipe2) {
              if (item.kind !== "metadata") {
                if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
                  dataset.typed = false;
                  break;
                }
                if (!dataset.issues || !config22.abortEarly && !config22.abortPipeEarly) {
                  dataset = item._run(dataset, config22);
                }
              }
            }
            return dataset;
          }
        };
      }
      function pipeAsync(...pipe2) {
        return {
          ...pipe2[0],
          pipe: pipe2,
          async: true,
          async _run(dataset, config22) {
            for (const item of pipe2) {
              if (item.kind !== "metadata") {
                if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
                  dataset.typed = false;
                  break;
                }
                if (!dataset.issues || !config22.abortEarly && !config22.abortPipeEarly) {
                  dataset = await item._run(dataset, config22);
                }
              }
            }
            return dataset;
          }
        };
      }
      function required(schema, arg2, arg3) {
        const keys = Array.isArray(arg2) ? arg2 : void 0;
        const message = Array.isArray(arg2) ? arg3 : arg2;
        const entries = {};
        for (const key in schema.entries) {
          entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];
        }
        return { ...schema, entries };
      }
      function requiredAsync(schema, arg2, arg3) {
        const keys = Array.isArray(arg2) ? arg2 : void 0;
        const message = Array.isArray(arg2) ? arg3 : arg2;
        const entries = {};
        for (const key in schema.entries) {
          entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];
        }
        return { ...schema, entries };
      }
      function safeParse(schema, input, config22) {
        const dataset = schema._run(
          { typed: false, value: input },
          getGlobalConfig(config22)
        );
        return {
          typed: dataset.typed,
          success: !dataset.issues,
          output: dataset.value,
          issues: dataset.issues
        };
      }
      async function safeParseAsync(schema, input, config22) {
        const dataset = await schema._run(
          { typed: false, value: input },
          getGlobalConfig(config22)
        );
        return {
          typed: dataset.typed,
          success: !dataset.issues,
          output: dataset.value,
          issues: dataset.issues
        };
      }
      function safeParser(schema, config22) {
        const func = (input) => safeParse(schema, input, config22);
        func.schema = schema;
        func.config = config22;
        return func;
      }
      function safeParserAsync(schema, config22) {
        const func = (input) => safeParseAsync(schema, input, config22);
        func.schema = schema;
        func.config = config22;
        return func;
      }
      function unwrap(schema) {
        return schema.wrapped;
      }
    }
  });

  // node_modules/bip32/src/cjs/types.cjs
  var require_types2 = __commonJS({
    "node_modules/bip32/src/cjs/types.cjs"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var __createBinding = exports9 && exports9.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports9 && exports9.__setModuleDefault || (Object.create ? function(o, v2) {
        Object.defineProperty(o, "default", { enumerable: true, value: v2 });
      } : function(o, v2) {
        o["default"] = v2;
      });
      var __importStar = exports9 && exports9.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.Bip32PathSchema = exports9.NetworkSchema = exports9.Buffer33Bytes = exports9.Buffer256Bit = exports9.Uint31Schema = exports9.Uint32Schema = void 0;
      var v = __importStar(require_dist2());
      exports9.Uint32Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(4294967295));
      exports9.Uint31Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(2147483647));
      var Uint8Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(255));
      exports9.Buffer256Bit = v.pipe(v.instance(Uint8Array), v.length(32));
      exports9.Buffer33Bytes = v.pipe(v.instance(Uint8Array), v.length(33));
      exports9.NetworkSchema = v.object({
        wif: Uint8Schema,
        bip32: v.object({
          public: exports9.Uint32Schema,
          private: exports9.Uint32Schema
        })
      });
      exports9.Bip32PathSchema = v.pipe(v.string(), v.regex(/^(m\/)?(\d+'?\/)*\d+'?$/));
    }
  });

  // node_modules/base-x/src/cjs/index.cjs
  var require_cjs = __commonJS({
    "node_modules/base-x/src/cjs/index.cjs"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      function base(ALPHABET) {
        if (ALPHABET.length >= 255) {
          throw new TypeError("Alphabet too long");
        }
        const BASE_MAP = new Uint8Array(256);
        for (let j = 0; j < BASE_MAP.length; j++) {
          BASE_MAP[j] = 255;
        }
        for (let i = 0; i < ALPHABET.length; i++) {
          const x = ALPHABET.charAt(i);
          const xc = x.charCodeAt(0);
          if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + " is ambiguous");
          }
          BASE_MAP[xc] = i;
        }
        const BASE = ALPHABET.length;
        const LEADER = ALPHABET.charAt(0);
        const FACTOR = Math.log(BASE) / Math.log(256);
        const iFACTOR = Math.log(256) / Math.log(BASE);
        function encode(source) {
          if (source instanceof Uint8Array) {
          } else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
          } else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
          }
          if (!(source instanceof Uint8Array)) {
            throw new TypeError("Expected Uint8Array");
          }
          if (source.length === 0) {
            return "";
          }
          let zeroes = 0;
          let length = 0;
          let pbegin = 0;
          const pend = source.length;
          while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
          }
          const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
          const b58 = new Uint8Array(size);
          while (pbegin !== pend) {
            let carry = source[pbegin];
            let i = 0;
            for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
              carry += 256 * b58[it1] >>> 0;
              b58[it1] = carry % BASE >>> 0;
              carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i;
            pbegin++;
          }
          let it2 = size - length;
          while (it2 !== size && b58[it2] === 0) {
            it2++;
          }
          let str = LEADER.repeat(zeroes);
          for (; it2 < size; ++it2) {
            str += ALPHABET.charAt(b58[it2]);
          }
          return str;
        }
        function decodeUnsafe(source) {
          if (typeof source !== "string") {
            throw new TypeError("Expected String");
          }
          if (source.length === 0) {
            return new Uint8Array();
          }
          let psz = 0;
          let zeroes = 0;
          let length = 0;
          while (source[psz] === LEADER) {
            zeroes++;
            psz++;
          }
          const size = (source.length - psz) * FACTOR + 1 >>> 0;
          const b256 = new Uint8Array(size);
          while (source[psz]) {
            let carry = BASE_MAP[source.charCodeAt(psz)];
            if (carry === 255) {
              return;
            }
            let i = 0;
            for (let it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
              carry += BASE * b256[it3] >>> 0;
              b256[it3] = carry % 256 >>> 0;
              carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i;
            psz++;
          }
          let it4 = size - length;
          while (it4 !== size && b256[it4] === 0) {
            it4++;
          }
          const vch = new Uint8Array(zeroes + (size - it4));
          let j = zeroes;
          while (it4 !== size) {
            vch[j++] = b256[it4++];
          }
          return vch;
        }
        function decode(string) {
          const buffer = decodeUnsafe(string);
          if (buffer) {
            return buffer;
          }
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode,
          decodeUnsafe,
          decode
        };
      }
      exports9.default = base;
    }
  });

  // node_modules/bs58/src/cjs/index.cjs
  var require_cjs2 = __commonJS({
    "node_modules/bs58/src/cjs/index.cjs"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var __importDefault = exports9 && exports9.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports9, "__esModule", { value: true });
      var base_x_1 = __importDefault(require_cjs());
      var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      exports9.default = (0, base_x_1.default)(ALPHABET);
    }
  });

  // node_modules/bs58check/src/cjs/base.cjs
  var require_base4 = __commonJS({
    "node_modules/bs58check/src/cjs/base.cjs"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var __importDefault = exports9 && exports9.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.default = default_1;
      var bs58_1 = __importDefault(require_cjs2());
      function default_1(checksumFn) {
        function encode(payload) {
          var payloadU8 = Uint8Array.from(payload);
          var checksum = checksumFn(payloadU8);
          var length = payloadU8.length + 4;
          var both = new Uint8Array(length);
          both.set(payloadU8, 0);
          both.set(checksum.subarray(0, 4), payloadU8.length);
          return bs58_1.default.encode(both);
        }
        function decodeRaw(buffer) {
          var payload = buffer.slice(0, -4);
          var checksum = buffer.slice(-4);
          var newChecksum = checksumFn(payload);
          if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3])
            return;
          return payload;
        }
        function decodeUnsafe(str) {
          var buffer = bs58_1.default.decodeUnsafe(str);
          if (buffer == null)
            return;
          return decodeRaw(buffer);
        }
        function decode(str) {
          var buffer = bs58_1.default.decode(str);
          var payload = decodeRaw(buffer);
          if (payload == null)
            throw new Error("Invalid checksum");
          return payload;
        }
        return {
          encode,
          decode,
          decodeUnsafe
        };
      }
    }
  });

  // node_modules/bs58check/src/cjs/index.cjs
  var require_cjs3 = __commonJS({
    "node_modules/bs58check/src/cjs/index.cjs"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var __importDefault = exports9 && exports9.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports9, "__esModule", { value: true });
      var sha256_1 = require_sha256();
      var base_js_1 = __importDefault(require_base4());
      function sha256x2(buffer) {
        return (0, sha256_1.sha256)((0, sha256_1.sha256)(buffer));
      }
      exports9.default = (0, base_js_1.default)(sha256x2);
    }
  });

  // node_modules/wif/src/cjs/index.cjs
  var require_cjs4 = __commonJS({
    "node_modules/wif/src/cjs/index.cjs"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var __importDefault = exports9 && exports9.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.encode = exports9.decode = exports9.encodeRaw = exports9.decodeRaw = void 0;
      var bs58check_1 = __importDefault(require_cjs3());
      function decodeRaw(buffer, version2) {
        if (version2 !== void 0 && buffer[0] !== version2)
          throw new Error("Invalid network version");
        if (buffer.length === 33) {
          return {
            version: buffer[0],
            privateKey: buffer.slice(1, 33),
            compressed: false
          };
        }
        if (buffer.length !== 34)
          throw new Error("Invalid WIF length");
        if (buffer[33] !== 1)
          throw new Error("Invalid compression flag");
        return {
          version: buffer[0],
          privateKey: buffer.slice(1, 33),
          compressed: true
        };
      }
      exports9.decodeRaw = decodeRaw;
      function encodeRaw(version2, privateKey, compressed) {
        if (privateKey.length !== 32)
          throw new TypeError("Invalid privateKey length");
        var result = new Uint8Array(compressed ? 34 : 33);
        var view = new DataView(result.buffer);
        view.setUint8(0, version2);
        result.set(privateKey, 1);
        if (compressed) {
          result[33] = 1;
        }
        return result;
      }
      exports9.encodeRaw = encodeRaw;
      function decode(str, version2) {
        return decodeRaw(bs58check_1.default.decode(str), version2);
      }
      exports9.decode = decode;
      function encode(wif) {
        return bs58check_1.default.encode(encodeRaw(wif.version, wif.privateKey, wif.compressed));
      }
      exports9.encode = encode;
    }
  });

  // node_modules/bip32/src/cjs/bip32.cjs
  var require_bip32 = __commonJS({
    "node_modules/bip32/src/cjs/bip32.cjs"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var __createBinding = exports9 && exports9.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports9 && exports9.__setModuleDefault || (Object.create ? function(o, v2) {
        Object.defineProperty(o, "default", { enumerable: true, value: v2 });
      } : function(o, v2) {
        o["default"] = v2;
      });
      var __importStar = exports9 && exports9.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.BIP32Factory = BIP32Factory;
      var crypto2 = __importStar(require_crypto3());
      var testecc_js_1 = require_testecc();
      var base_1 = require_lib2();
      var sha256_1 = require_sha256();
      var v = __importStar(require_dist2());
      var types_js_1 = require_types2();
      var wif = __importStar(require_cjs4());
      var tools = __importStar((init_browser(), __toCommonJS(browser_exports)));
      var _bs58check = (0, base_1.base58check)(sha256_1.sha256);
      var bs58check = {
        encode: (data) => _bs58check.encode(data),
        decode: (str) => _bs58check.decode(str)
      };
      function BIP32Factory(ecc) {
        (0, testecc_js_1.testEcc)(ecc);
        const BITCOIN = {
          messagePrefix: "Bitcoin Signed Message:\n",
          bech32: "bc",
          bip32: {
            public: 76067358,
            private: 76066276
          },
          pubKeyHash: 0,
          scriptHash: 5,
          wif: 128
        };
        const HIGHEST_BIT = 2147483648;
        function toXOnly(pubKey) {
          return pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
        }
        class Bip32Signer {
          __D;
          __Q;
          lowR = false;
          constructor(__D, __Q) {
            this.__D = __D;
            this.__Q = __Q;
          }
          get publicKey() {
            if (this.__Q === void 0)
              this.__Q = ecc.pointFromScalar(this.__D, true);
            return this.__Q;
          }
          get privateKey() {
            return this.__D;
          }
          sign(hash, lowR) {
            if (!this.privateKey)
              throw new Error("Missing private key");
            if (lowR === void 0)
              lowR = this.lowR;
            if (lowR === false) {
              return ecc.sign(hash, this.privateKey);
            } else {
              let sig = ecc.sign(hash, this.privateKey);
              const extraData = new Uint8Array(32);
              let counter = 0;
              while (sig[0] > 127) {
                counter++;
                tools.writeUInt32(extraData, 0, counter, "LE");
                sig = ecc.sign(hash, this.privateKey, extraData);
              }
              return sig;
            }
          }
          signSchnorr(hash) {
            if (!this.privateKey)
              throw new Error("Missing private key");
            if (!ecc.signSchnorr)
              throw new Error("signSchnorr not supported by ecc library");
            return ecc.signSchnorr(hash, this.privateKey);
          }
          verify(hash, signature) {
            return ecc.verify(hash, this.publicKey, signature);
          }
          verifySchnorr(hash, signature) {
            if (!ecc.verifySchnorr)
              throw new Error("verifySchnorr not supported by ecc library");
            return ecc.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature);
          }
        }
        class BIP32 extends Bip32Signer {
          chainCode;
          network;
          __DEPTH;
          __INDEX;
          __PARENT_FINGERPRINT;
          constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0) {
            super(__D, __Q);
            this.chainCode = chainCode;
            this.network = network;
            this.__DEPTH = __DEPTH;
            this.__INDEX = __INDEX;
            this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
            v.parse(types_js_1.NetworkSchema, network);
          }
          get depth() {
            return this.__DEPTH;
          }
          get index() {
            return this.__INDEX;
          }
          get parentFingerprint() {
            return this.__PARENT_FINGERPRINT;
          }
          get identifier() {
            return crypto2.hash160(this.publicKey);
          }
          get fingerprint() {
            return this.identifier.slice(0, 4);
          }
          get compressed() {
            return true;
          }
          // Private === not neutered
          // Public === neutered
          isNeutered() {
            return this.__D === void 0;
          }
          neutered() {
            return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
          }
          toBase58() {
            const network = this.network;
            const version2 = !this.isNeutered() ? network.bip32.private : network.bip32.public;
            const buffer = new Uint8Array(78);
            tools.writeUInt32(buffer, 0, version2, "BE");
            tools.writeUInt8(buffer, 4, this.depth);
            tools.writeUInt32(buffer, 5, this.parentFingerprint, "BE");
            tools.writeUInt32(buffer, 9, this.index, "BE");
            buffer.set(this.chainCode, 13);
            if (!this.isNeutered()) {
              tools.writeUInt8(buffer, 45, 0);
              buffer.set(this.privateKey, 46);
            } else {
              buffer.set(this.publicKey, 45);
            }
            return bs58check.encode(buffer);
          }
          toWIF() {
            if (!this.privateKey)
              throw new TypeError("Missing private key");
            return wif.encode({
              version: this.network.wif,
              privateKey: this.privateKey,
              compressed: true
            });
          }
          // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
          derive(index) {
            v.parse(types_js_1.Uint32Schema, index);
            const isHardened = index >= HIGHEST_BIT;
            const data = new Uint8Array(37);
            if (isHardened) {
              if (this.isNeutered())
                throw new TypeError("Missing private key for hardened child key");
              data[0] = 0;
              data.set(this.privateKey, 1);
              tools.writeUInt32(data, 33, index, "BE");
            } else {
              data.set(this.publicKey, 0);
              tools.writeUInt32(data, 33, index, "BE");
            }
            const I = crypto2.hmacSHA512(this.chainCode, data);
            const IL = I.slice(0, 32);
            const IR = I.slice(32);
            if (!ecc.isPrivate(IL))
              return this.derive(index + 1);
            let hd;
            if (!this.isNeutered()) {
              const ki = ecc.privateAdd(this.privateKey, IL);
              if (ki == null)
                return this.derive(index + 1);
              hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, tools.readUInt32(this.fingerprint, 0, "BE"));
            } else {
              const Ki = ecc.pointAddScalar(this.publicKey, IL, true);
              if (Ki === null)
                return this.derive(index + 1);
              hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, tools.readUInt32(this.fingerprint, 0, "BE"));
            }
            return hd;
          }
          deriveHardened(index) {
            if (typeof v.parse(types_js_1.Uint31Schema, index) === "number")
              return this.derive(index + HIGHEST_BIT);
            throw new TypeError("Expected UInt31, got " + index);
          }
          derivePath(path) {
            v.parse(types_js_1.Bip32PathSchema, path);
            let splitPath = path.split("/");
            if (splitPath[0] === "m") {
              if (this.parentFingerprint)
                throw new TypeError("Expected master, got child");
              splitPath = splitPath.slice(1);
            }
            return splitPath.reduce((prevHd, indexStr) => {
              let index;
              if (indexStr.slice(-1) === `'`) {
                index = parseInt(indexStr.slice(0, -1), 10);
                return prevHd.deriveHardened(index);
              } else {
                index = parseInt(indexStr, 10);
                return prevHd.derive(index);
              }
            }, this);
          }
          tweak(t) {
            if (this.privateKey)
              return this.tweakFromPrivateKey(t);
            return this.tweakFromPublicKey(t);
          }
          tweakFromPublicKey(t) {
            const xOnlyPubKey = toXOnly(this.publicKey);
            if (!ecc.xOnlyPointAddTweak)
              throw new Error("xOnlyPointAddTweak not supported by ecc library");
            const tweakedPublicKey = ecc.xOnlyPointAddTweak(xOnlyPubKey, t);
            if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null)
              throw new Error("Cannot tweak public key!");
            const parityByte = Uint8Array.from([
              tweakedPublicKey.parity === 0 ? 2 : 3
            ]);
            const tweakedPublicKeyCompresed = tools.concat([
              parityByte,
              tweakedPublicKey.xOnlyPubkey
            ]);
            return new Bip32Signer(void 0, tweakedPublicKeyCompresed);
          }
          tweakFromPrivateKey(t) {
            const hasOddY = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1;
            const privateKey = (() => {
              if (!hasOddY)
                return this.privateKey;
              else if (!ecc.privateNegate)
                throw new Error("privateNegate not supported by ecc library");
              else
                return ecc.privateNegate(this.privateKey);
            })();
            const tweakedPrivateKey = ecc.privateAdd(privateKey, t);
            if (!tweakedPrivateKey)
              throw new Error("Invalid tweaked private key!");
            return new Bip32Signer(tweakedPrivateKey, void 0);
          }
        }
        function fromBase58(inString, network) {
          const buffer = bs58check.decode(inString);
          if (buffer.length !== 78)
            throw new TypeError("Invalid buffer length");
          network = network || BITCOIN;
          const version2 = tools.readUInt32(buffer, 0, "BE");
          if (version2 !== network.bip32.private && version2 !== network.bip32.public)
            throw new TypeError("Invalid network version");
          const depth = buffer[4];
          const parentFingerprint = tools.readUInt32(buffer, 5, "BE");
          if (depth === 0) {
            if (parentFingerprint !== 0)
              throw new TypeError("Invalid parent fingerprint");
          }
          const index = tools.readUInt32(buffer, 9, "BE");
          if (depth === 0 && index !== 0)
            throw new TypeError("Invalid index");
          const chainCode = buffer.slice(13, 45);
          let hd;
          if (version2 === network.bip32.private) {
            if (buffer[45] !== 0)
              throw new TypeError("Invalid private key");
            const k = buffer.slice(46, 78);
            hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);
          } else {
            const X = buffer.slice(45, 78);
            hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);
          }
          return hd;
        }
        function fromPrivateKey(privateKey, chainCode, network) {
          return fromPrivateKeyLocal(privateKey, chainCode, network);
        }
        function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
          v.parse(types_js_1.Buffer256Bit, privateKey);
          v.parse(types_js_1.Buffer256Bit, chainCode);
          network = network || BITCOIN;
          if (!ecc.isPrivate(privateKey))
            throw new TypeError("Private key not in range [1, n)");
          return new BIP32(privateKey, void 0, chainCode, network, depth, index, parentFingerprint);
        }
        function fromPublicKey(publicKey, chainCode, network) {
          return fromPublicKeyLocal(publicKey, chainCode, network);
        }
        function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
          v.parse(types_js_1.Buffer33Bytes, publicKey);
          v.parse(types_js_1.Buffer256Bit, chainCode);
          network = network || BITCOIN;
          if (!ecc.isPoint(publicKey))
            throw new TypeError("Point is not on the curve");
          return new BIP32(void 0, publicKey, chainCode, network, depth, index, parentFingerprint);
        }
        function fromSeed(seed, network) {
          v.parse(v.instance(Uint8Array), seed);
          if (seed.length < 16)
            throw new TypeError("Seed should be at least 128 bits");
          if (seed.length > 64)
            throw new TypeError("Seed should be at most 512 bits");
          network = network || BITCOIN;
          const I = crypto2.hmacSHA512(tools.fromUtf8("Bitcoin seed"), seed);
          const IL = I.slice(0, 32);
          const IR = I.slice(32);
          return fromPrivateKey(IL, IR, network);
        }
        return {
          fromSeed,
          fromBase58,
          fromPublicKey,
          fromPrivateKey
        };
      }
    }
  });

  // node_modules/bip32/src/cjs/index.cjs
  var require_cjs5 = __commonJS({
    "node_modules/bip32/src/cjs/index.cjs"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.BIP32Factory = exports9.default = void 0;
      var bip32_js_1 = require_bip32();
      Object.defineProperty(exports9, "default", { enumerable: true, get: function() {
        return bip32_js_1.BIP32Factory;
      } });
      Object.defineProperty(exports9, "BIP32Factory", { enumerable: true, get: function() {
        return bip32_js_1.BIP32Factory;
      } });
    }
  });

  // node_modules/@noble/hashes/pbkdf2.js
  var require_pbkdf2 = __commonJS({
    "node_modules/@noble/hashes/pbkdf2.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.pbkdf2 = pbkdf2;
      exports9.pbkdf2Async = pbkdf2Async;
      var _assert_js_1 = require_assert();
      var hmac_js_1 = require_hmac2();
      var utils_js_1 = require_utils();
      function pbkdf2Init(hash, _password, _salt, _opts) {
        (0, _assert_js_1.hash)(hash);
        const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
        const { c, dkLen, asyncTick } = opts;
        (0, _assert_js_1.number)(c);
        (0, _assert_js_1.number)(dkLen);
        (0, _assert_js_1.number)(asyncTick);
        if (c < 1)
          throw new Error("PBKDF2: iterations (c) should be >= 1");
        const password = (0, utils_js_1.toBytes)(_password);
        const salt = (0, utils_js_1.toBytes)(_salt);
        const DK = new Uint8Array(dkLen);
        const PRF = hmac_js_1.hmac.create(hash, password);
        const PRFSalt = PRF._cloneInto().update(salt);
        return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
      }
      function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
        PRF.destroy();
        PRFSalt.destroy();
        if (prfW)
          prfW.destroy();
        u.fill(0);
        return DK;
      }
      function pbkdf2(hash, password, salt, opts) {
        const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
        let prfW;
        const arr = new Uint8Array(4);
        const view = (0, utils_js_1.createView)(arr);
        const u = new Uint8Array(PRF.outputLen);
        for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
          const Ti = DK.subarray(pos, pos + PRF.outputLen);
          view.setInt32(0, ti, false);
          (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
          Ti.set(u.subarray(0, Ti.length));
          for (let ui = 1; ui < c; ui++) {
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
              Ti[i] ^= u[i];
          }
        }
        return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
      }
      async function pbkdf2Async(hash, password, salt, opts) {
        const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
        let prfW;
        const arr = new Uint8Array(4);
        const view = (0, utils_js_1.createView)(arr);
        const u = new Uint8Array(PRF.outputLen);
        for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
          const Ti = DK.subarray(pos, pos + PRF.outputLen);
          view.setInt32(0, ti, false);
          (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
          Ti.set(u.subarray(0, Ti.length));
          await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, () => {
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
              Ti[i] ^= u[i];
          });
        }
        return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
      }
    }
  });

  // node_modules/bip39/src/wordlists/czech.json
  var require_czech = __commonJS({
    "node_modules/bip39/src/wordlists/czech.json"(exports9, module) {
      module.exports = [
        "abdikace",
        "abeceda",
        "adresa",
        "agrese",
        "akce",
        "aktovka",
        "alej",
        "alkohol",
        "amputace",
        "ananas",
        "andulka",
        "anekdota",
        "anketa",
        "antika",
        "anulovat",
        "archa",
        "arogance",
        "asfalt",
        "asistent",
        "aspirace",
        "astma",
        "astronom",
        "atlas",
        "atletika",
        "atol",
        "autobus",
        "azyl",
        "babka",
        "bachor",
        "bacil",
        "baculka",
        "badatel",
        "bageta",
        "bagr",
        "bahno",
        "bakterie",
        "balada",
        "baletka",
        "balkon",
        "balonek",
        "balvan",
        "balza",
        "bambus",
        "bankomat",
        "barbar",
        "baret",
        "barman",
        "baroko",
        "barva",
        "baterka",
        "batoh",
        "bavlna",
        "bazalka",
        "bazilika",
        "bazuka",
        "bedna",
        "beran",
        "beseda",
        "bestie",
        "beton",
        "bezinka",
        "bezmoc",
        "beztak",
        "bicykl",
        "bidlo",
        "biftek",
        "bikiny",
        "bilance",
        "biograf",
        "biolog",
        "bitva",
        "bizon",
        "blahobyt",
        "blatouch",
        "blecha",
        "bledule",
        "blesk",
        "blikat",
        "blizna",
        "blokovat",
        "bloudit",
        "blud",
        "bobek",
        "bobr",
        "bodlina",
        "bodnout",
        "bohatost",
        "bojkot",
        "bojovat",
        "bokorys",
        "bolest",
        "borec",
        "borovice",
        "bota",
        "boubel",
        "bouchat",
        "bouda",
        "boule",
        "bourat",
        "boxer",
        "bradavka",
        "brambora",
        "branka",
        "bratr",
        "brepta",
        "briketa",
        "brko",
        "brloh",
        "bronz",
        "broskev",
        "brunetka",
        "brusinka",
        "brzda",
        "brzy",
        "bublina",
        "bubnovat",
        "buchta",
        "buditel",
        "budka",
        "budova",
        "bufet",
        "bujarost",
        "bukvice",
        "buldok",
        "bulva",
        "bunda",
        "bunkr",
        "burza",
        "butik",
        "buvol",
        "buzola",
        "bydlet",
        "bylina",
        "bytovka",
        "bzukot",
        "capart",
        "carevna",
        "cedr",
        "cedule",
        "cejch",
        "cejn",
        "cela",
        "celer",
        "celkem",
        "celnice",
        "cenina",
        "cennost",
        "cenovka",
        "centrum",
        "cenzor",
        "cestopis",
        "cetka",
        "chalupa",
        "chapadlo",
        "charita",
        "chata",
        "chechtat",
        "chemie",
        "chichot",
        "chirurg",
        "chlad",
        "chleba",
        "chlubit",
        "chmel",
        "chmura",
        "chobot",
        "chochol",
        "chodba",
        "cholera",
        "chomout",
        "chopit",
        "choroba",
        "chov",
        "chrapot",
        "chrlit",
        "chrt",
        "chrup",
        "chtivost",
        "chudina",
        "chutnat",
        "chvat",
        "chvilka",
        "chvost",
        "chyba",
        "chystat",
        "chytit",
        "cibule",
        "cigareta",
        "cihelna",
        "cihla",
        "cinkot",
        "cirkus",
        "cisterna",
        "citace",
        "citrus",
        "cizinec",
        "cizost",
        "clona",
        "cokoliv",
        "couvat",
        "ctitel",
        "ctnost",
        "cudnost",
        "cuketa",
        "cukr",
        "cupot",
        "cvaknout",
        "cval",
        "cvik",
        "cvrkot",
        "cyklista",
        "daleko",
        "dareba",
        "datel",
        "datum",
        "dcera",
        "debata",
        "dechovka",
        "decibel",
        "deficit",
        "deflace",
        "dekl",
        "dekret",
        "demokrat",
        "deprese",
        "derby",
        "deska",
        "detektiv",
        "dikobraz",
        "diktovat",
        "dioda",
        "diplom",
        "disk",
        "displej",
        "divadlo",
        "divoch",
        "dlaha",
        "dlouho",
        "dluhopis",
        "dnes",
        "dobro",
        "dobytek",
        "docent",
        "dochutit",
        "dodnes",
        "dohled",
        "dohoda",
        "dohra",
        "dojem",
        "dojnice",
        "doklad",
        "dokola",
        "doktor",
        "dokument",
        "dolar",
        "doleva",
        "dolina",
        "doma",
        "dominant",
        "domluvit",
        "domov",
        "donutit",
        "dopad",
        "dopis",
        "doplnit",
        "doposud",
        "doprovod",
        "dopustit",
        "dorazit",
        "dorost",
        "dort",
        "dosah",
        "doslov",
        "dostatek",
        "dosud",
        "dosyta",
        "dotaz",
        "dotek",
        "dotknout",
        "doufat",
        "doutnat",
        "dovozce",
        "dozadu",
        "doznat",
        "dozorce",
        "drahota",
        "drak",
        "dramatik",
        "dravec",
        "draze",
        "drdol",
        "drobnost",
        "drogerie",
        "drozd",
        "drsnost",
        "drtit",
        "drzost",
        "duben",
        "duchovno",
        "dudek",
        "duha",
        "duhovka",
        "dusit",
        "dusno",
        "dutost",
        "dvojice",
        "dvorec",
        "dynamit",
        "ekolog",
        "ekonomie",
        "elektron",
        "elipsa",
        "email",
        "emise",
        "emoce",
        "empatie",
        "epizoda",
        "epocha",
        "epopej",
        "epos",
        "esej",
        "esence",
        "eskorta",
        "eskymo",
        "etiketa",
        "euforie",
        "evoluce",
        "exekuce",
        "exkurze",
        "expedice",
        "exploze",
        "export",
        "extrakt",
        "facka",
        "fajfka",
        "fakulta",
        "fanatik",
        "fantazie",
        "farmacie",
        "favorit",
        "fazole",
        "federace",
        "fejeton",
        "fenka",
        "fialka",
        "figurant",
        "filozof",
        "filtr",
        "finance",
        "finta",
        "fixace",
        "fjord",
        "flanel",
        "flirt",
        "flotila",
        "fond",
        "fosfor",
        "fotbal",
        "fotka",
        "foton",
        "frakce",
        "freska",
        "fronta",
        "fukar",
        "funkce",
        "fyzika",
        "galeje",
        "garant",
        "genetika",
        "geolog",
        "gilotina",
        "glazura",
        "glejt",
        "golem",
        "golfista",
        "gotika",
        "graf",
        "gramofon",
        "granule",
        "grep",
        "gril",
        "grog",
        "groteska",
        "guma",
        "hadice",
        "hadr",
        "hala",
        "halenka",
        "hanba",
        "hanopis",
        "harfa",
        "harpuna",
        "havran",
        "hebkost",
        "hejkal",
        "hejno",
        "hejtman",
        "hektar",
        "helma",
        "hematom",
        "herec",
        "herna",
        "heslo",
        "hezky",
        "historik",
        "hladovka",
        "hlasivky",
        "hlava",
        "hledat",
        "hlen",
        "hlodavec",
        "hloh",
        "hloupost",
        "hltat",
        "hlubina",
        "hluchota",
        "hmat",
        "hmota",
        "hmyz",
        "hnis",
        "hnojivo",
        "hnout",
        "hoblina",
        "hoboj",
        "hoch",
        "hodiny",
        "hodlat",
        "hodnota",
        "hodovat",
        "hojnost",
        "hokej",
        "holinka",
        "holka",
        "holub",
        "homole",
        "honitba",
        "honorace",
        "horal",
        "horda",
        "horizont",
        "horko",
        "horlivec",
        "hormon",
        "hornina",
        "horoskop",
        "horstvo",
        "hospoda",
        "hostina",
        "hotovost",
        "houba",
        "houf",
        "houpat",
        "houska",
        "hovor",
        "hradba",
        "hranice",
        "hravost",
        "hrazda",
        "hrbolek",
        "hrdina",
        "hrdlo",
        "hrdost",
        "hrnek",
        "hrobka",
        "hromada",
        "hrot",
        "hrouda",
        "hrozen",
        "hrstka",
        "hrubost",
        "hryzat",
        "hubenost",
        "hubnout",
        "hudba",
        "hukot",
        "humr",
        "husita",
        "hustota",
        "hvozd",
        "hybnost",
        "hydrant",
        "hygiena",
        "hymna",
        "hysterik",
        "idylka",
        "ihned",
        "ikona",
        "iluze",
        "imunita",
        "infekce",
        "inflace",
        "inkaso",
        "inovace",
        "inspekce",
        "internet",
        "invalida",
        "investor",
        "inzerce",
        "ironie",
        "jablko",
        "jachta",
        "jahoda",
        "jakmile",
        "jakost",
        "jalovec",
        "jantar",
        "jarmark",
        "jaro",
        "jasan",
        "jasno",
        "jatka",
        "javor",
        "jazyk",
        "jedinec",
        "jedle",
        "jednatel",
        "jehlan",
        "jekot",
        "jelen",
        "jelito",
        "jemnost",
        "jenom",
        "jepice",
        "jeseter",
        "jevit",
        "jezdec",
        "jezero",
        "jinak",
        "jindy",
        "jinoch",
        "jiskra",
        "jistota",
        "jitrnice",
        "jizva",
        "jmenovat",
        "jogurt",
        "jurta",
        "kabaret",
        "kabel",
        "kabinet",
        "kachna",
        "kadet",
        "kadidlo",
        "kahan",
        "kajak",
        "kajuta",
        "kakao",
        "kaktus",
        "kalamita",
        "kalhoty",
        "kalibr",
        "kalnost",
        "kamera",
        "kamkoliv",
        "kamna",
        "kanibal",
        "kanoe",
        "kantor",
        "kapalina",
        "kapela",
        "kapitola",
        "kapka",
        "kaple",
        "kapota",
        "kapr",
        "kapusta",
        "kapybara",
        "karamel",
        "karotka",
        "karton",
        "kasa",
        "katalog",
        "katedra",
        "kauce",
        "kauza",
        "kavalec",
        "kazajka",
        "kazeta",
        "kazivost",
        "kdekoliv",
        "kdesi",
        "kedluben",
        "kemp",
        "keramika",
        "kino",
        "klacek",
        "kladivo",
        "klam",
        "klapot",
        "klasika",
        "klaun",
        "klec",
        "klenba",
        "klepat",
        "klesnout",
        "klid",
        "klima",
        "klisna",
        "klobouk",
        "klokan",
        "klopa",
        "kloub",
        "klubovna",
        "klusat",
        "kluzkost",
        "kmen",
        "kmitat",
        "kmotr",
        "kniha",
        "knot",
        "koalice",
        "koberec",
        "kobka",
        "kobliha",
        "kobyla",
        "kocour",
        "kohout",
        "kojenec",
        "kokos",
        "koktejl",
        "kolaps",
        "koleda",
        "kolize",
        "kolo",
        "komando",
        "kometa",
        "komik",
        "komnata",
        "komora",
        "kompas",
        "komunita",
        "konat",
        "koncept",
        "kondice",
        "konec",
        "konfese",
        "kongres",
        "konina",
        "konkurs",
        "kontakt",
        "konzerva",
        "kopanec",
        "kopie",
        "kopnout",
        "koprovka",
        "korbel",
        "korektor",
        "kormidlo",
        "koroptev",
        "korpus",
        "koruna",
        "koryto",
        "korzet",
        "kosatec",
        "kostka",
        "kotel",
        "kotleta",
        "kotoul",
        "koukat",
        "koupelna",
        "kousek",
        "kouzlo",
        "kovboj",
        "koza",
        "kozoroh",
        "krabice",
        "krach",
        "krajina",
        "kralovat",
        "krasopis",
        "kravata",
        "kredit",
        "krejcar",
        "kresba",
        "kreveta",
        "kriket",
        "kritik",
        "krize",
        "krkavec",
        "krmelec",
        "krmivo",
        "krocan",
        "krok",
        "kronika",
        "kropit",
        "kroupa",
        "krovka",
        "krtek",
        "kruhadlo",
        "krupice",
        "krutost",
        "krvinka",
        "krychle",
        "krypta",
        "krystal",
        "kryt",
        "kudlanka",
        "kufr",
        "kujnost",
        "kukla",
        "kulajda",
        "kulich",
        "kulka",
        "kulomet",
        "kultura",
        "kuna",
        "kupodivu",
        "kurt",
        "kurzor",
        "kutil",
        "kvalita",
        "kvasinka",
        "kvestor",
        "kynolog",
        "kyselina",
        "kytara",
        "kytice",
        "kytka",
        "kytovec",
        "kyvadlo",
        "labrador",
        "lachtan",
        "ladnost",
        "laik",
        "lakomec",
        "lamela",
        "lampa",
        "lanovka",
        "lasice",
        "laso",
        "lastura",
        "latinka",
        "lavina",
        "lebka",
        "leckdy",
        "leden",
        "lednice",
        "ledovka",
        "ledvina",
        "legenda",
        "legie",
        "legrace",
        "lehce",
        "lehkost",
        "lehnout",
        "lektvar",
        "lenochod",
        "lentilka",
        "lepenka",
        "lepidlo",
        "letadlo",
        "letec",
        "letmo",
        "letokruh",
        "levhart",
        "levitace",
        "levobok",
        "libra",
        "lichotka",
        "lidojed",
        "lidskost",
        "lihovina",
        "lijavec",
        "lilek",
        "limetka",
        "linie",
        "linka",
        "linoleum",
        "listopad",
        "litina",
        "litovat",
        "lobista",
        "lodivod",
        "logika",
        "logoped",
        "lokalita",
        "loket",
        "lomcovat",
        "lopata",
        "lopuch",
        "lord",
        "losos",
        "lotr",
        "loudal",
        "louh",
        "louka",
        "louskat",
        "lovec",
        "lstivost",
        "lucerna",
        "lucifer",
        "lump",
        "lusk",
        "lustrace",
        "lvice",
        "lyra",
        "lyrika",
        "lysina",
        "madam",
        "madlo",
        "magistr",
        "mahagon",
        "majetek",
        "majitel",
        "majorita",
        "makak",
        "makovice",
        "makrela",
        "malba",
        "malina",
        "malovat",
        "malvice",
        "maminka",
        "mandle",
        "manko",
        "marnost",
        "masakr",
        "maskot",
        "masopust",
        "matice",
        "matrika",
        "maturita",
        "mazanec",
        "mazivo",
        "mazlit",
        "mazurka",
        "mdloba",
        "mechanik",
        "meditace",
        "medovina",
        "melasa",
        "meloun",
        "mentolka",
        "metla",
        "metoda",
        "metr",
        "mezera",
        "migrace",
        "mihnout",
        "mihule",
        "mikina",
        "mikrofon",
        "milenec",
        "milimetr",
        "milost",
        "mimika",
        "mincovna",
        "minibar",
        "minomet",
        "minulost",
        "miska",
        "mistr",
        "mixovat",
        "mladost",
        "mlha",
        "mlhovina",
        "mlok",
        "mlsat",
        "mluvit",
        "mnich",
        "mnohem",
        "mobil",
        "mocnost",
        "modelka",
        "modlitba",
        "mohyla",
        "mokro",
        "molekula",
        "momentka",
        "monarcha",
        "monokl",
        "monstrum",
        "montovat",
        "monzun",
        "mosaz",
        "moskyt",
        "most",
        "motivace",
        "motorka",
        "motyka",
        "moucha",
        "moudrost",
        "mozaika",
        "mozek",
        "mozol",
        "mramor",
        "mravenec",
        "mrkev",
        "mrtvola",
        "mrzet",
        "mrzutost",
        "mstitel",
        "mudrc",
        "muflon",
        "mulat",
        "mumie",
        "munice",
        "muset",
        "mutace",
        "muzeum",
        "muzikant",
        "myslivec",
        "mzda",
        "nabourat",
        "nachytat",
        "nadace",
        "nadbytek",
        "nadhoz",
        "nadobro",
        "nadpis",
        "nahlas",
        "nahnat",
        "nahodile",
        "nahradit",
        "naivita",
        "najednou",
        "najisto",
        "najmout",
        "naklonit",
        "nakonec",
        "nakrmit",
        "nalevo",
        "namazat",
        "namluvit",
        "nanometr",
        "naoko",
        "naopak",
        "naostro",
        "napadat",
        "napevno",
        "naplnit",
        "napnout",
        "naposled",
        "naprosto",
        "narodit",
        "naruby",
        "narychlo",
        "nasadit",
        "nasekat",
        "naslepo",
        "nastat",
        "natolik",
        "navenek",
        "navrch",
        "navzdory",
        "nazvat",
        "nebe",
        "nechat",
        "necky",
        "nedaleko",
        "nedbat",
        "neduh",
        "negace",
        "nehet",
        "nehoda",
        "nejen",
        "nejprve",
        "neklid",
        "nelibost",
        "nemilost",
        "nemoc",
        "neochota",
        "neonka",
        "nepokoj",
        "nerost",
        "nerv",
        "nesmysl",
        "nesoulad",
        "netvor",
        "neuron",
        "nevina",
        "nezvykle",
        "nicota",
        "nijak",
        "nikam",
        "nikdy",
        "nikl",
        "nikterak",
        "nitro",
        "nocleh",
        "nohavice",
        "nominace",
        "nora",
        "norek",
        "nositel",
        "nosnost",
        "nouze",
        "noviny",
        "novota",
        "nozdra",
        "nuda",
        "nudle",
        "nuget",
        "nutit",
        "nutnost",
        "nutrie",
        "nymfa",
        "obal",
        "obarvit",
        "obava",
        "obdiv",
        "obec",
        "obehnat",
        "obejmout",
        "obezita",
        "obhajoba",
        "obilnice",
        "objasnit",
        "objekt",
        "obklopit",
        "oblast",
        "oblek",
        "obliba",
        "obloha",
        "obluda",
        "obnos",
        "obohatit",
        "obojek",
        "obout",
        "obrazec",
        "obrna",
        "obruba",
        "obrys",
        "obsah",
        "obsluha",
        "obstarat",
        "obuv",
        "obvaz",
        "obvinit",
        "obvod",
        "obvykle",
        "obyvatel",
        "obzor",
        "ocas",
        "ocel",
        "ocenit",
        "ochladit",
        "ochota",
        "ochrana",
        "ocitnout",
        "odboj",
        "odbyt",
        "odchod",
        "odcizit",
        "odebrat",
        "odeslat",
        "odevzdat",
        "odezva",
        "odhadce",
        "odhodit",
        "odjet",
        "odjinud",
        "odkaz",
        "odkoupit",
        "odliv",
        "odluka",
        "odmlka",
        "odolnost",
        "odpad",
        "odpis",
        "odplout",
        "odpor",
        "odpustit",
        "odpykat",
        "odrazka",
        "odsoudit",
        "odstup",
        "odsun",
        "odtok",
        "odtud",
        "odvaha",
        "odveta",
        "odvolat",
        "odvracet",
        "odznak",
        "ofina",
        "ofsajd",
        "ohlas",
        "ohnisko",
        "ohrada",
        "ohrozit",
        "ohryzek",
        "okap",
        "okenice",
        "oklika",
        "okno",
        "okouzlit",
        "okovy",
        "okrasa",
        "okres",
        "okrsek",
        "okruh",
        "okupant",
        "okurka",
        "okusit",
        "olejnina",
        "olizovat",
        "omak",
        "omeleta",
        "omezit",
        "omladina",
        "omlouvat",
        "omluva",
        "omyl",
        "onehdy",
        "opakovat",
        "opasek",
        "operace",
        "opice",
        "opilost",
        "opisovat",
        "opora",
        "opozice",
        "opravdu",
        "oproti",
        "orbital",
        "orchestr",
        "orgie",
        "orlice",
        "orloj",
        "ortel",
        "osada",
        "oschnout",
        "osika",
        "osivo",
        "oslava",
        "oslepit",
        "oslnit",
        "oslovit",
        "osnova",
        "osoba",
        "osolit",
        "ospalec",
        "osten",
        "ostraha",
        "ostuda",
        "ostych",
        "osvojit",
        "oteplit",
        "otisk",
        "otop",
        "otrhat",
        "otrlost",
        "otrok",
        "otruby",
        "otvor",
        "ovanout",
        "ovar",
        "oves",
        "ovlivnit",
        "ovoce",
        "oxid",
        "ozdoba",
        "pachatel",
        "pacient",
        "padouch",
        "pahorek",
        "pakt",
        "palanda",
        "palec",
        "palivo",
        "paluba",
        "pamflet",
        "pamlsek",
        "panenka",
        "panika",
        "panna",
        "panovat",
        "panstvo",
        "pantofle",
        "paprika",
        "parketa",
        "parodie",
        "parta",
        "paruka",
        "paryba",
        "paseka",
        "pasivita",
        "pastelka",
        "patent",
        "patrona",
        "pavouk",
        "pazneht",
        "pazourek",
        "pecka",
        "pedagog",
        "pejsek",
        "peklo",
        "peloton",
        "penalta",
        "pendrek",
        "penze",
        "periskop",
        "pero",
        "pestrost",
        "petarda",
        "petice",
        "petrolej",
        "pevnina",
        "pexeso",
        "pianista",
        "piha",
        "pijavice",
        "pikle",
        "piknik",
        "pilina",
        "pilnost",
        "pilulka",
        "pinzeta",
        "pipeta",
        "pisatel",
        "pistole",
        "pitevna",
        "pivnice",
        "pivovar",
        "placenta",
        "plakat",
        "plamen",
        "planeta",
        "plastika",
        "platit",
        "plavidlo",
        "plaz",
        "plech",
        "plemeno",
        "plenta",
        "ples",
        "pletivo",
        "plevel",
        "plivat",
        "plnit",
        "plno",
        "plocha",
        "plodina",
        "plomba",
        "plout",
        "pluk",
        "plyn",
        "pobavit",
        "pobyt",
        "pochod",
        "pocit",
        "poctivec",
        "podat",
        "podcenit",
        "podepsat",
        "podhled",
        "podivit",
        "podklad",
        "podmanit",
        "podnik",
        "podoba",
        "podpora",
        "podraz",
        "podstata",
        "podvod",
        "podzim",
        "poezie",
        "pohanka",
        "pohnutka",
        "pohovor",
        "pohroma",
        "pohyb",
        "pointa",
        "pojistka",
        "pojmout",
        "pokazit",
        "pokles",
        "pokoj",
        "pokrok",
        "pokuta",
        "pokyn",
        "poledne",
        "polibek",
        "polknout",
        "poloha",
        "polynom",
        "pomalu",
        "pominout",
        "pomlka",
        "pomoc",
        "pomsta",
        "pomyslet",
        "ponechat",
        "ponorka",
        "ponurost",
        "popadat",
        "popel",
        "popisek",
        "poplach",
        "poprosit",
        "popsat",
        "popud",
        "poradce",
        "porce",
        "porod",
        "porucha",
        "poryv",
        "posadit",
        "posed",
        "posila",
        "poskok",
        "poslanec",
        "posoudit",
        "pospolu",
        "postava",
        "posudek",
        "posyp",
        "potah",
        "potkan",
        "potlesk",
        "potomek",
        "potrava",
        "potupa",
        "potvora",
        "poukaz",
        "pouto",
        "pouzdro",
        "povaha",
        "povidla",
        "povlak",
        "povoz",
        "povrch",
        "povstat",
        "povyk",
        "povzdech",
        "pozdrav",
        "pozemek",
        "poznatek",
        "pozor",
        "pozvat",
        "pracovat",
        "prahory",
        "praktika",
        "prales",
        "praotec",
        "praporek",
        "prase",
        "pravda",
        "princip",
        "prkno",
        "probudit",
        "procento",
        "prodej",
        "profese",
        "prohra",
        "projekt",
        "prolomit",
        "promile",
        "pronikat",
        "propad",
        "prorok",
        "prosba",
        "proton",
        "proutek",
        "provaz",
        "prskavka",
        "prsten",
        "prudkost",
        "prut",
        "prvek",
        "prvohory",
        "psanec",
        "psovod",
        "pstruh",
        "ptactvo",
        "puberta",
        "puch",
        "pudl",
        "pukavec",
        "puklina",
        "pukrle",
        "pult",
        "pumpa",
        "punc",
        "pupen",
        "pusa",
        "pusinka",
        "pustina",
        "putovat",
        "putyka",
        "pyramida",
        "pysk",
        "pytel",
        "racek",
        "rachot",
        "radiace",
        "radnice",
        "radon",
        "raft",
        "ragby",
        "raketa",
        "rakovina",
        "rameno",
        "rampouch",
        "rande",
        "rarach",
        "rarita",
        "rasovna",
        "rastr",
        "ratolest",
        "razance",
        "razidlo",
        "reagovat",
        "reakce",
        "recept",
        "redaktor",
        "referent",
        "reflex",
        "rejnok",
        "reklama",
        "rekord",
        "rekrut",
        "rektor",
        "reputace",
        "revize",
        "revma",
        "revolver",
        "rezerva",
        "riskovat",
        "riziko",
        "robotika",
        "rodokmen",
        "rohovka",
        "rokle",
        "rokoko",
        "romaneto",
        "ropovod",
        "ropucha",
        "rorejs",
        "rosol",
        "rostlina",
        "rotmistr",
        "rotoped",
        "rotunda",
        "roubenka",
        "roucho",
        "roup",
        "roura",
        "rovina",
        "rovnice",
        "rozbor",
        "rozchod",
        "rozdat",
        "rozeznat",
        "rozhodce",
        "rozinka",
        "rozjezd",
        "rozkaz",
        "rozloha",
        "rozmar",
        "rozpad",
        "rozruch",
        "rozsah",
        "roztok",
        "rozum",
        "rozvod",
        "rubrika",
        "ruchadlo",
        "rukavice",
        "rukopis",
        "ryba",
        "rybolov",
        "rychlost",
        "rydlo",
        "rypadlo",
        "rytina",
        "ryzost",
        "sadista",
        "sahat",
        "sako",
        "samec",
        "samizdat",
        "samota",
        "sanitka",
        "sardinka",
        "sasanka",
        "satelit",
        "sazba",
        "sazenice",
        "sbor",
        "schovat",
        "sebranka",
        "secese",
        "sedadlo",
        "sediment",
        "sedlo",
        "sehnat",
        "sejmout",
        "sekera",
        "sekta",
        "sekunda",
        "sekvoje",
        "semeno",
        "seno",
        "servis",
        "sesadit",
        "seshora",
        "seskok",
        "seslat",
        "sestra",
        "sesuv",
        "sesypat",
        "setba",
        "setina",
        "setkat",
        "setnout",
        "setrvat",
        "sever",
        "seznam",
        "shoda",
        "shrnout",
        "sifon",
        "silnice",
        "sirka",
        "sirotek",
        "sirup",
        "situace",
        "skafandr",
        "skalisko",
        "skanzen",
        "skaut",
        "skeptik",
        "skica",
        "skladba",
        "sklenice",
        "sklo",
        "skluz",
        "skoba",
        "skokan",
        "skoro",
        "skripta",
        "skrz",
        "skupina",
        "skvost",
        "skvrna",
        "slabika",
        "sladidlo",
        "slanina",
        "slast",
        "slavnost",
        "sledovat",
        "slepec",
        "sleva",
        "slezina",
        "slib",
        "slina",
        "sliznice",
        "slon",
        "sloupek",
        "slovo",
        "sluch",
        "sluha",
        "slunce",
        "slupka",
        "slza",
        "smaragd",
        "smetana",
        "smilstvo",
        "smlouva",
        "smog",
        "smrad",
        "smrk",
        "smrtka",
        "smutek",
        "smysl",
        "snad",
        "snaha",
        "snob",
        "sobota",
        "socha",
        "sodovka",
        "sokol",
        "sopka",
        "sotva",
        "souboj",
        "soucit",
        "soudce",
        "souhlas",
        "soulad",
        "soumrak",
        "souprava",
        "soused",
        "soutok",
        "souviset",
        "spalovna",
        "spasitel",
        "spis",
        "splav",
        "spodek",
        "spojenec",
        "spolu",
        "sponzor",
        "spornost",
        "spousta",
        "sprcha",
        "spustit",
        "sranda",
        "sraz",
        "srdce",
        "srna",
        "srnec",
        "srovnat",
        "srpen",
        "srst",
        "srub",
        "stanice",
        "starosta",
        "statika",
        "stavba",
        "stehno",
        "stezka",
        "stodola",
        "stolek",
        "stopa",
        "storno",
        "stoupat",
        "strach",
        "stres",
        "strhnout",
        "strom",
        "struna",
        "studna",
        "stupnice",
        "stvol",
        "styk",
        "subjekt",
        "subtropy",
        "suchar",
        "sudost",
        "sukno",
        "sundat",
        "sunout",
        "surikata",
        "surovina",
        "svah",
        "svalstvo",
        "svetr",
        "svatba",
        "svazek",
        "svisle",
        "svitek",
        "svoboda",
        "svodidlo",
        "svorka",
        "svrab",
        "sykavka",
        "sykot",
        "synek",
        "synovec",
        "sypat",
        "sypkost",
        "syrovost",
        "sysel",
        "sytost",
        "tabletka",
        "tabule",
        "tahoun",
        "tajemno",
        "tajfun",
        "tajga",
        "tajit",
        "tajnost",
        "taktika",
        "tamhle",
        "tampon",
        "tancovat",
        "tanec",
        "tanker",
        "tapeta",
        "tavenina",
        "tazatel",
        "technika",
        "tehdy",
        "tekutina",
        "telefon",
        "temnota",
        "tendence",
        "tenista",
        "tenor",
        "teplota",
        "tepna",
        "teprve",
        "terapie",
        "termoska",
        "textil",
        "ticho",
        "tiskopis",
        "titulek",
        "tkadlec",
        "tkanina",
        "tlapka",
        "tleskat",
        "tlukot",
        "tlupa",
        "tmel",
        "toaleta",
        "topinka",
        "topol",
        "torzo",
        "touha",
        "toulec",
        "tradice",
        "traktor",
        "tramp",
        "trasa",
        "traverza",
        "trefit",
        "trest",
        "trezor",
        "trhavina",
        "trhlina",
        "trochu",
        "trojice",
        "troska",
        "trouba",
        "trpce",
        "trpitel",
        "trpkost",
        "trubec",
        "truchlit",
        "truhlice",
        "trus",
        "trvat",
        "tudy",
        "tuhnout",
        "tuhost",
        "tundra",
        "turista",
        "turnaj",
        "tuzemsko",
        "tvaroh",
        "tvorba",
        "tvrdost",
        "tvrz",
        "tygr",
        "tykev",
        "ubohost",
        "uboze",
        "ubrat",
        "ubrousek",
        "ubrus",
        "ubytovna",
        "ucho",
        "uctivost",
        "udivit",
        "uhradit",
        "ujednat",
        "ujistit",
        "ujmout",
        "ukazatel",
        "uklidnit",
        "uklonit",
        "ukotvit",
        "ukrojit",
        "ulice",
        "ulita",
        "ulovit",
        "umyvadlo",
        "unavit",
        "uniforma",
        "uniknout",
        "upadnout",
        "uplatnit",
        "uplynout",
        "upoutat",
        "upravit",
        "uran",
        "urazit",
        "usednout",
        "usilovat",
        "usmrtit",
        "usnadnit",
        "usnout",
        "usoudit",
        "ustlat",
        "ustrnout",
        "utahovat",
        "utkat",
        "utlumit",
        "utonout",
        "utopenec",
        "utrousit",
        "uvalit",
        "uvolnit",
        "uvozovka",
        "uzdravit",
        "uzel",
        "uzenina",
        "uzlina",
        "uznat",
        "vagon",
        "valcha",
        "valoun",
        "vana",
        "vandal",
        "vanilka",
        "varan",
        "varhany",
        "varovat",
        "vcelku",
        "vchod",
        "vdova",
        "vedro",
        "vegetace",
        "vejce",
        "velbloud",
        "veletrh",
        "velitel",
        "velmoc",
        "velryba",
        "venkov",
        "veranda",
        "verze",
        "veselka",
        "veskrze",
        "vesnice",
        "vespodu",
        "vesta",
        "veterina",
        "veverka",
        "vibrace",
        "vichr",
        "videohra",
        "vidina",
        "vidle",
        "vila",
        "vinice",
        "viset",
        "vitalita",
        "vize",
        "vizitka",
        "vjezd",
        "vklad",
        "vkus",
        "vlajka",
        "vlak",
        "vlasec",
        "vlevo",
        "vlhkost",
        "vliv",
        "vlnovka",
        "vloupat",
        "vnucovat",
        "vnuk",
        "voda",
        "vodivost",
        "vodoznak",
        "vodstvo",
        "vojensky",
        "vojna",
        "vojsko",
        "volant",
        "volba",
        "volit",
        "volno",
        "voskovka",
        "vozidlo",
        "vozovna",
        "vpravo",
        "vrabec",
        "vracet",
        "vrah",
        "vrata",
        "vrba",
        "vrcholek",
        "vrhat",
        "vrstva",
        "vrtule",
        "vsadit",
        "vstoupit",
        "vstup",
        "vtip",
        "vybavit",
        "vybrat",
        "vychovat",
        "vydat",
        "vydra",
        "vyfotit",
        "vyhledat",
        "vyhnout",
        "vyhodit",
        "vyhradit",
        "vyhubit",
        "vyjasnit",
        "vyjet",
        "vyjmout",
        "vyklopit",
        "vykonat",
        "vylekat",
        "vymazat",
        "vymezit",
        "vymizet",
        "vymyslet",
        "vynechat",
        "vynikat",
        "vynutit",
        "vypadat",
        "vyplatit",
        "vypravit",
        "vypustit",
        "vyrazit",
        "vyrovnat",
        "vyrvat",
        "vyslovit",
        "vysoko",
        "vystavit",
        "vysunout",
        "vysypat",
        "vytasit",
        "vytesat",
        "vytratit",
        "vyvinout",
        "vyvolat",
        "vyvrhel",
        "vyzdobit",
        "vyznat",
        "vzadu",
        "vzbudit",
        "vzchopit",
        "vzdor",
        "vzduch",
        "vzdychat",
        "vzestup",
        "vzhledem",
        "vzkaz",
        "vzlykat",
        "vznik",
        "vzorek",
        "vzpoura",
        "vztah",
        "vztek",
        "xylofon",
        "zabrat",
        "zabydlet",
        "zachovat",
        "zadarmo",
        "zadusit",
        "zafoukat",
        "zahltit",
        "zahodit",
        "zahrada",
        "zahynout",
        "zajatec",
        "zajet",
        "zajistit",
        "zaklepat",
        "zakoupit",
        "zalepit",
        "zamezit",
        "zamotat",
        "zamyslet",
        "zanechat",
        "zanikat",
        "zaplatit",
        "zapojit",
        "zapsat",
        "zarazit",
        "zastavit",
        "zasunout",
        "zatajit",
        "zatemnit",
        "zatknout",
        "zaujmout",
        "zavalit",
        "zavelet",
        "zavinit",
        "zavolat",
        "zavrtat",
        "zazvonit",
        "zbavit",
        "zbrusu",
        "zbudovat",
        "zbytek",
        "zdaleka",
        "zdarma",
        "zdatnost",
        "zdivo",
        "zdobit",
        "zdroj",
        "zdvih",
        "zdymadlo",
        "zelenina",
        "zeman",
        "zemina",
        "zeptat",
        "zezadu",
        "zezdola",
        "zhatit",
        "zhltnout",
        "zhluboka",
        "zhotovit",
        "zhruba",
        "zima",
        "zimnice",
        "zjemnit",
        "zklamat",
        "zkoumat",
        "zkratka",
        "zkumavka",
        "zlato",
        "zlehka",
        "zloba",
        "zlom",
        "zlost",
        "zlozvyk",
        "zmapovat",
        "zmar",
        "zmatek",
        "zmije",
        "zmizet",
        "zmocnit",
        "zmodrat",
        "zmrzlina",
        "zmutovat",
        "znak",
        "znalost",
        "znamenat",
        "znovu",
        "zobrazit",
        "zotavit",
        "zoubek",
        "zoufale",
        "zplodit",
        "zpomalit",
        "zprava",
        "zprostit",
        "zprudka",
        "zprvu",
        "zrada",
        "zranit",
        "zrcadlo",
        "zrnitost",
        "zrno",
        "zrovna",
        "zrychlit",
        "zrzavost",
        "zticha",
        "ztratit",
        "zubovina",
        "zubr",
        "zvednout",
        "zvenku",
        "zvesela",
        "zvon",
        "zvrat",
        "zvukovod",
        "zvyk"
      ];
    }
  });

  // node_modules/bip39/src/wordlists/chinese_simplified.json
  var require_chinese_simplified = __commonJS({
    "node_modules/bip39/src/wordlists/chinese_simplified.json"(exports9, module) {
      module.exports = [
        "\u7684",
        "\u4E00",
        "\u662F",
        "\u5728",
        "\u4E0D",
        "\u4E86",
        "\u6709",
        "\u548C",
        "\u4EBA",
        "\u8FD9",
        "\u4E2D",
        "\u5927",
        "\u4E3A",
        "\u4E0A",
        "\u4E2A",
        "\u56FD",
        "\u6211",
        "\u4EE5",
        "\u8981",
        "\u4ED6",
        "\u65F6",
        "\u6765",
        "\u7528",
        "\u4EEC",
        "\u751F",
        "\u5230",
        "\u4F5C",
        "\u5730",
        "\u4E8E",
        "\u51FA",
        "\u5C31",
        "\u5206",
        "\u5BF9",
        "\u6210",
        "\u4F1A",
        "\u53EF",
        "\u4E3B",
        "\u53D1",
        "\u5E74",
        "\u52A8",
        "\u540C",
        "\u5DE5",
        "\u4E5F",
        "\u80FD",
        "\u4E0B",
        "\u8FC7",
        "\u5B50",
        "\u8BF4",
        "\u4EA7",
        "\u79CD",
        "\u9762",
        "\u800C",
        "\u65B9",
        "\u540E",
        "\u591A",
        "\u5B9A",
        "\u884C",
        "\u5B66",
        "\u6CD5",
        "\u6240",
        "\u6C11",
        "\u5F97",
        "\u7ECF",
        "\u5341",
        "\u4E09",
        "\u4E4B",
        "\u8FDB",
        "\u7740",
        "\u7B49",
        "\u90E8",
        "\u5EA6",
        "\u5BB6",
        "\u7535",
        "\u529B",
        "\u91CC",
        "\u5982",
        "\u6C34",
        "\u5316",
        "\u9AD8",
        "\u81EA",
        "\u4E8C",
        "\u7406",
        "\u8D77",
        "\u5C0F",
        "\u7269",
        "\u73B0",
        "\u5B9E",
        "\u52A0",
        "\u91CF",
        "\u90FD",
        "\u4E24",
        "\u4F53",
        "\u5236",
        "\u673A",
        "\u5F53",
        "\u4F7F",
        "\u70B9",
        "\u4ECE",
        "\u4E1A",
        "\u672C",
        "\u53BB",
        "\u628A",
        "\u6027",
        "\u597D",
        "\u5E94",
        "\u5F00",
        "\u5B83",
        "\u5408",
        "\u8FD8",
        "\u56E0",
        "\u7531",
        "\u5176",
        "\u4E9B",
        "\u7136",
        "\u524D",
        "\u5916",
        "\u5929",
        "\u653F",
        "\u56DB",
        "\u65E5",
        "\u90A3",
        "\u793E",
        "\u4E49",
        "\u4E8B",
        "\u5E73",
        "\u5F62",
        "\u76F8",
        "\u5168",
        "\u8868",
        "\u95F4",
        "\u6837",
        "\u4E0E",
        "\u5173",
        "\u5404",
        "\u91CD",
        "\u65B0",
        "\u7EBF",
        "\u5185",
        "\u6570",
        "\u6B63",
        "\u5FC3",
        "\u53CD",
        "\u4F60",
        "\u660E",
        "\u770B",
        "\u539F",
        "\u53C8",
        "\u4E48",
        "\u5229",
        "\u6BD4",
        "\u6216",
        "\u4F46",
        "\u8D28",
        "\u6C14",
        "\u7B2C",
        "\u5411",
        "\u9053",
        "\u547D",
        "\u6B64",
        "\u53D8",
        "\u6761",
        "\u53EA",
        "\u6CA1",
        "\u7ED3",
        "\u89E3",
        "\u95EE",
        "\u610F",
        "\u5EFA",
        "\u6708",
        "\u516C",
        "\u65E0",
        "\u7CFB",
        "\u519B",
        "\u5F88",
        "\u60C5",
        "\u8005",
        "\u6700",
        "\u7ACB",
        "\u4EE3",
        "\u60F3",
        "\u5DF2",
        "\u901A",
        "\u5E76",
        "\u63D0",
        "\u76F4",
        "\u9898",
        "\u515A",
        "\u7A0B",
        "\u5C55",
        "\u4E94",
        "\u679C",
        "\u6599",
        "\u8C61",
        "\u5458",
        "\u9769",
        "\u4F4D",
        "\u5165",
        "\u5E38",
        "\u6587",
        "\u603B",
        "\u6B21",
        "\u54C1",
        "\u5F0F",
        "\u6D3B",
        "\u8BBE",
        "\u53CA",
        "\u7BA1",
        "\u7279",
        "\u4EF6",
        "\u957F",
        "\u6C42",
        "\u8001",
        "\u5934",
        "\u57FA",
        "\u8D44",
        "\u8FB9",
        "\u6D41",
        "\u8DEF",
        "\u7EA7",
        "\u5C11",
        "\u56FE",
        "\u5C71",
        "\u7EDF",
        "\u63A5",
        "\u77E5",
        "\u8F83",
        "\u5C06",
        "\u7EC4",
        "\u89C1",
        "\u8BA1",
        "\u522B",
        "\u5979",
        "\u624B",
        "\u89D2",
        "\u671F",
        "\u6839",
        "\u8BBA",
        "\u8FD0",
        "\u519C",
        "\u6307",
        "\u51E0",
        "\u4E5D",
        "\u533A",
        "\u5F3A",
        "\u653E",
        "\u51B3",
        "\u897F",
        "\u88AB",
        "\u5E72",
        "\u505A",
        "\u5FC5",
        "\u6218",
        "\u5148",
        "\u56DE",
        "\u5219",
        "\u4EFB",
        "\u53D6",
        "\u636E",
        "\u5904",
        "\u961F",
        "\u5357",
        "\u7ED9",
        "\u8272",
        "\u5149",
        "\u95E8",
        "\u5373",
        "\u4FDD",
        "\u6CBB",
        "\u5317",
        "\u9020",
        "\u767E",
        "\u89C4",
        "\u70ED",
        "\u9886",
        "\u4E03",
        "\u6D77",
        "\u53E3",
        "\u4E1C",
        "\u5BFC",
        "\u5668",
        "\u538B",
        "\u5FD7",
        "\u4E16",
        "\u91D1",
        "\u589E",
        "\u4E89",
        "\u6D4E",
        "\u9636",
        "\u6CB9",
        "\u601D",
        "\u672F",
        "\u6781",
        "\u4EA4",
        "\u53D7",
        "\u8054",
        "\u4EC0",
        "\u8BA4",
        "\u516D",
        "\u5171",
        "\u6743",
        "\u6536",
        "\u8BC1",
        "\u6539",
        "\u6E05",
        "\u7F8E",
        "\u518D",
        "\u91C7",
        "\u8F6C",
        "\u66F4",
        "\u5355",
        "\u98CE",
        "\u5207",
        "\u6253",
        "\u767D",
        "\u6559",
        "\u901F",
        "\u82B1",
        "\u5E26",
        "\u5B89",
        "\u573A",
        "\u8EAB",
        "\u8F66",
        "\u4F8B",
        "\u771F",
        "\u52A1",
        "\u5177",
        "\u4E07",
        "\u6BCF",
        "\u76EE",
        "\u81F3",
        "\u8FBE",
        "\u8D70",
        "\u79EF",
        "\u793A",
        "\u8BAE",
        "\u58F0",
        "\u62A5",
        "\u6597",
        "\u5B8C",
        "\u7C7B",
        "\u516B",
        "\u79BB",
        "\u534E",
        "\u540D",
        "\u786E",
        "\u624D",
        "\u79D1",
        "\u5F20",
        "\u4FE1",
        "\u9A6C",
        "\u8282",
        "\u8BDD",
        "\u7C73",
        "\u6574",
        "\u7A7A",
        "\u5143",
        "\u51B5",
        "\u4ECA",
        "\u96C6",
        "\u6E29",
        "\u4F20",
        "\u571F",
        "\u8BB8",
        "\u6B65",
        "\u7FA4",
        "\u5E7F",
        "\u77F3",
        "\u8BB0",
        "\u9700",
        "\u6BB5",
        "\u7814",
        "\u754C",
        "\u62C9",
        "\u6797",
        "\u5F8B",
        "\u53EB",
        "\u4E14",
        "\u7A76",
        "\u89C2",
        "\u8D8A",
        "\u7EC7",
        "\u88C5",
        "\u5F71",
        "\u7B97",
        "\u4F4E",
        "\u6301",
        "\u97F3",
        "\u4F17",
        "\u4E66",
        "\u5E03",
        "\u590D",
        "\u5BB9",
        "\u513F",
        "\u987B",
        "\u9645",
        "\u5546",
        "\u975E",
        "\u9A8C",
        "\u8FDE",
        "\u65AD",
        "\u6DF1",
        "\u96BE",
        "\u8FD1",
        "\u77FF",
        "\u5343",
        "\u5468",
        "\u59D4",
        "\u7D20",
        "\u6280",
        "\u5907",
        "\u534A",
        "\u529E",
        "\u9752",
        "\u7701",
        "\u5217",
        "\u4E60",
        "\u54CD",
        "\u7EA6",
        "\u652F",
        "\u822C",
        "\u53F2",
        "\u611F",
        "\u52B3",
        "\u4FBF",
        "\u56E2",
        "\u5F80",
        "\u9178",
        "\u5386",
        "\u5E02",
        "\u514B",
        "\u4F55",
        "\u9664",
        "\u6D88",
        "\u6784",
        "\u5E9C",
        "\u79F0",
        "\u592A",
        "\u51C6",
        "\u7CBE",
        "\u503C",
        "\u53F7",
        "\u7387",
        "\u65CF",
        "\u7EF4",
        "\u5212",
        "\u9009",
        "\u6807",
        "\u5199",
        "\u5B58",
        "\u5019",
        "\u6BDB",
        "\u4EB2",
        "\u5FEB",
        "\u6548",
        "\u65AF",
        "\u9662",
        "\u67E5",
        "\u6C5F",
        "\u578B",
        "\u773C",
        "\u738B",
        "\u6309",
        "\u683C",
        "\u517B",
        "\u6613",
        "\u7F6E",
        "\u6D3E",
        "\u5C42",
        "\u7247",
        "\u59CB",
        "\u5374",
        "\u4E13",
        "\u72B6",
        "\u80B2",
        "\u5382",
        "\u4EAC",
        "\u8BC6",
        "\u9002",
        "\u5C5E",
        "\u5706",
        "\u5305",
        "\u706B",
        "\u4F4F",
        "\u8C03",
        "\u6EE1",
        "\u53BF",
        "\u5C40",
        "\u7167",
        "\u53C2",
        "\u7EA2",
        "\u7EC6",
        "\u5F15",
        "\u542C",
        "\u8BE5",
        "\u94C1",
        "\u4EF7",
        "\u4E25",
        "\u9996",
        "\u5E95",
        "\u6DB2",
        "\u5B98",
        "\u5FB7",
        "\u968F",
        "\u75C5",
        "\u82CF",
        "\u5931",
        "\u5C14",
        "\u6B7B",
        "\u8BB2",
        "\u914D",
        "\u5973",
        "\u9EC4",
        "\u63A8",
        "\u663E",
        "\u8C08",
        "\u7F6A",
        "\u795E",
        "\u827A",
        "\u5462",
        "\u5E2D",
        "\u542B",
        "\u4F01",
        "\u671B",
        "\u5BC6",
        "\u6279",
        "\u8425",
        "\u9879",
        "\u9632",
        "\u4E3E",
        "\u7403",
        "\u82F1",
        "\u6C27",
        "\u52BF",
        "\u544A",
        "\u674E",
        "\u53F0",
        "\u843D",
        "\u6728",
        "\u5E2E",
        "\u8F6E",
        "\u7834",
        "\u4E9A",
        "\u5E08",
        "\u56F4",
        "\u6CE8",
        "\u8FDC",
        "\u5B57",
        "\u6750",
        "\u6392",
        "\u4F9B",
        "\u6CB3",
        "\u6001",
        "\u5C01",
        "\u53E6",
        "\u65BD",
        "\u51CF",
        "\u6811",
        "\u6EB6",
        "\u600E",
        "\u6B62",
        "\u6848",
        "\u8A00",
        "\u58EB",
        "\u5747",
        "\u6B66",
        "\u56FA",
        "\u53F6",
        "\u9C7C",
        "\u6CE2",
        "\u89C6",
        "\u4EC5",
        "\u8D39",
        "\u7D27",
        "\u7231",
        "\u5DE6",
        "\u7AE0",
        "\u65E9",
        "\u671D",
        "\u5BB3",
        "\u7EED",
        "\u8F7B",
        "\u670D",
        "\u8BD5",
        "\u98DF",
        "\u5145",
        "\u5175",
        "\u6E90",
        "\u5224",
        "\u62A4",
        "\u53F8",
        "\u8DB3",
        "\u67D0",
        "\u7EC3",
        "\u5DEE",
        "\u81F4",
        "\u677F",
        "\u7530",
        "\u964D",
        "\u9ED1",
        "\u72AF",
        "\u8D1F",
        "\u51FB",
        "\u8303",
        "\u7EE7",
        "\u5174",
        "\u4F3C",
        "\u4F59",
        "\u575A",
        "\u66F2",
        "\u8F93",
        "\u4FEE",
        "\u6545",
        "\u57CE",
        "\u592B",
        "\u591F",
        "\u9001",
        "\u7B14",
        "\u8239",
        "\u5360",
        "\u53F3",
        "\u8D22",
        "\u5403",
        "\u5BCC",
        "\u6625",
        "\u804C",
        "\u89C9",
        "\u6C49",
        "\u753B",
        "\u529F",
        "\u5DF4",
        "\u8DDF",
        "\u867D",
        "\u6742",
        "\u98DE",
        "\u68C0",
        "\u5438",
        "\u52A9",
        "\u5347",
        "\u9633",
        "\u4E92",
        "\u521D",
        "\u521B",
        "\u6297",
        "\u8003",
        "\u6295",
        "\u574F",
        "\u7B56",
        "\u53E4",
        "\u5F84",
        "\u6362",
        "\u672A",
        "\u8DD1",
        "\u7559",
        "\u94A2",
        "\u66FE",
        "\u7AEF",
        "\u8D23",
        "\u7AD9",
        "\u7B80",
        "\u8FF0",
        "\u94B1",
        "\u526F",
        "\u5C3D",
        "\u5E1D",
        "\u5C04",
        "\u8349",
        "\u51B2",
        "\u627F",
        "\u72EC",
        "\u4EE4",
        "\u9650",
        "\u963F",
        "\u5BA3",
        "\u73AF",
        "\u53CC",
        "\u8BF7",
        "\u8D85",
        "\u5FAE",
        "\u8BA9",
        "\u63A7",
        "\u5DDE",
        "\u826F",
        "\u8F74",
        "\u627E",
        "\u5426",
        "\u7EAA",
        "\u76CA",
        "\u4F9D",
        "\u4F18",
        "\u9876",
        "\u7840",
        "\u8F7D",
        "\u5012",
        "\u623F",
        "\u7A81",
        "\u5750",
        "\u7C89",
        "\u654C",
        "\u7565",
        "\u5BA2",
        "\u8881",
        "\u51B7",
        "\u80DC",
        "\u7EDD",
        "\u6790",
        "\u5757",
        "\u5242",
        "\u6D4B",
        "\u4E1D",
        "\u534F",
        "\u8BC9",
        "\u5FF5",
        "\u9648",
        "\u4ECD",
        "\u7F57",
        "\u76D0",
        "\u53CB",
        "\u6D0B",
        "\u9519",
        "\u82E6",
        "\u591C",
        "\u5211",
        "\u79FB",
        "\u9891",
        "\u9010",
        "\u9760",
        "\u6DF7",
        "\u6BCD",
        "\u77ED",
        "\u76AE",
        "\u7EC8",
        "\u805A",
        "\u6C7D",
        "\u6751",
        "\u4E91",
        "\u54EA",
        "\u65E2",
        "\u8DDD",
        "\u536B",
        "\u505C",
        "\u70C8",
        "\u592E",
        "\u5BDF",
        "\u70E7",
        "\u8FC5",
        "\u5883",
        "\u82E5",
        "\u5370",
        "\u6D32",
        "\u523B",
        "\u62EC",
        "\u6FC0",
        "\u5B54",
        "\u641E",
        "\u751A",
        "\u5BA4",
        "\u5F85",
        "\u6838",
        "\u6821",
        "\u6563",
        "\u4FB5",
        "\u5427",
        "\u7532",
        "\u6E38",
        "\u4E45",
        "\u83DC",
        "\u5473",
        "\u65E7",
        "\u6A21",
        "\u6E56",
        "\u8D27",
        "\u635F",
        "\u9884",
        "\u963B",
        "\u6BEB",
        "\u666E",
        "\u7A33",
        "\u4E59",
        "\u5988",
        "\u690D",
        "\u606F",
        "\u6269",
        "\u94F6",
        "\u8BED",
        "\u6325",
        "\u9152",
        "\u5B88",
        "\u62FF",
        "\u5E8F",
        "\u7EB8",
        "\u533B",
        "\u7F3A",
        "\u96E8",
        "\u5417",
        "\u9488",
        "\u5218",
        "\u554A",
        "\u6025",
        "\u5531",
        "\u8BEF",
        "\u8BAD",
        "\u613F",
        "\u5BA1",
        "\u9644",
        "\u83B7",
        "\u8336",
        "\u9C9C",
        "\u7CAE",
        "\u65A4",
        "\u5B69",
        "\u8131",
        "\u786B",
        "\u80A5",
        "\u5584",
        "\u9F99",
        "\u6F14",
        "\u7236",
        "\u6E10",
        "\u8840",
        "\u6B22",
        "\u68B0",
        "\u638C",
        "\u6B4C",
        "\u6C99",
        "\u521A",
        "\u653B",
        "\u8C13",
        "\u76FE",
        "\u8BA8",
        "\u665A",
        "\u7C92",
        "\u4E71",
        "\u71C3",
        "\u77DB",
        "\u4E4E",
        "\u6740",
        "\u836F",
        "\u5B81",
        "\u9C81",
        "\u8D35",
        "\u949F",
        "\u7164",
        "\u8BFB",
        "\u73ED",
        "\u4F2F",
        "\u9999",
        "\u4ECB",
        "\u8FEB",
        "\u53E5",
        "\u4E30",
        "\u57F9",
        "\u63E1",
        "\u5170",
        "\u62C5",
        "\u5F26",
        "\u86CB",
        "\u6C89",
        "\u5047",
        "\u7A7F",
        "\u6267",
        "\u7B54",
        "\u4E50",
        "\u8C01",
        "\u987A",
        "\u70DF",
        "\u7F29",
        "\u5F81",
        "\u8138",
        "\u559C",
        "\u677E",
        "\u811A",
        "\u56F0",
        "\u5F02",
        "\u514D",
        "\u80CC",
        "\u661F",
        "\u798F",
        "\u4E70",
        "\u67D3",
        "\u4E95",
        "\u6982",
        "\u6162",
        "\u6015",
        "\u78C1",
        "\u500D",
        "\u7956",
        "\u7687",
        "\u4FC3",
        "\u9759",
        "\u8865",
        "\u8BC4",
        "\u7FFB",
        "\u8089",
        "\u8DF5",
        "\u5C3C",
        "\u8863",
        "\u5BBD",
        "\u626C",
        "\u68C9",
        "\u5E0C",
        "\u4F24",
        "\u64CD",
        "\u5782",
        "\u79CB",
        "\u5B9C",
        "\u6C22",
        "\u5957",
        "\u7763",
        "\u632F",
        "\u67B6",
        "\u4EAE",
        "\u672B",
        "\u5BAA",
        "\u5E86",
        "\u7F16",
        "\u725B",
        "\u89E6",
        "\u6620",
        "\u96F7",
        "\u9500",
        "\u8BD7",
        "\u5EA7",
        "\u5C45",
        "\u6293",
        "\u88C2",
        "\u80DE",
        "\u547C",
        "\u5A18",
        "\u666F",
        "\u5A01",
        "\u7EFF",
        "\u6676",
        "\u539A",
        "\u76DF",
        "\u8861",
        "\u9E21",
        "\u5B59",
        "\u5EF6",
        "\u5371",
        "\u80F6",
        "\u5C4B",
        "\u4E61",
        "\u4E34",
        "\u9646",
        "\u987E",
        "\u6389",
        "\u5440",
        "\u706F",
        "\u5C81",
        "\u63AA",
        "\u675F",
        "\u8010",
        "\u5267",
        "\u7389",
        "\u8D75",
        "\u8DF3",
        "\u54E5",
        "\u5B63",
        "\u8BFE",
        "\u51EF",
        "\u80E1",
        "\u989D",
        "\u6B3E",
        "\u7ECD",
        "\u5377",
        "\u9F50",
        "\u4F1F",
        "\u84B8",
        "\u6B96",
        "\u6C38",
        "\u5B97",
        "\u82D7",
        "\u5DDD",
        "\u7089",
        "\u5CA9",
        "\u5F31",
        "\u96F6",
        "\u6768",
        "\u594F",
        "\u6CBF",
        "\u9732",
        "\u6746",
        "\u63A2",
        "\u6ED1",
        "\u9547",
        "\u996D",
        "\u6D53",
        "\u822A",
        "\u6000",
        "\u8D76",
        "\u5E93",
        "\u593A",
        "\u4F0A",
        "\u7075",
        "\u7A0E",
        "\u9014",
        "\u706D",
        "\u8D5B",
        "\u5F52",
        "\u53EC",
        "\u9F13",
        "\u64AD",
        "\u76D8",
        "\u88C1",
        "\u9669",
        "\u5EB7",
        "\u552F",
        "\u5F55",
        "\u83CC",
        "\u7EAF",
        "\u501F",
        "\u7CD6",
        "\u76D6",
        "\u6A2A",
        "\u7B26",
        "\u79C1",
        "\u52AA",
        "\u5802",
        "\u57DF",
        "\u67AA",
        "\u6DA6",
        "\u5E45",
        "\u54C8",
        "\u7ADF",
        "\u719F",
        "\u866B",
        "\u6CFD",
        "\u8111",
        "\u58E4",
        "\u78B3",
        "\u6B27",
        "\u904D",
        "\u4FA7",
        "\u5BE8",
        "\u6562",
        "\u5F7B",
        "\u8651",
        "\u659C",
        "\u8584",
        "\u5EAD",
        "\u7EB3",
        "\u5F39",
        "\u9972",
        "\u4F38",
        "\u6298",
        "\u9EA6",
        "\u6E7F",
        "\u6697",
        "\u8377",
        "\u74E6",
        "\u585E",
        "\u5E8A",
        "\u7B51",
        "\u6076",
        "\u6237",
        "\u8BBF",
        "\u5854",
        "\u5947",
        "\u900F",
        "\u6881",
        "\u5200",
        "\u65CB",
        "\u8FF9",
        "\u5361",
        "\u6C2F",
        "\u9047",
        "\u4EFD",
        "\u6BD2",
        "\u6CE5",
        "\u9000",
        "\u6D17",
        "\u6446",
        "\u7070",
        "\u5F69",
        "\u5356",
        "\u8017",
        "\u590F",
        "\u62E9",
        "\u5FD9",
        "\u94DC",
        "\u732E",
        "\u786C",
        "\u4E88",
        "\u7E41",
        "\u5708",
        "\u96EA",
        "\u51FD",
        "\u4EA6",
        "\u62BD",
        "\u7BC7",
        "\u9635",
        "\u9634",
        "\u4E01",
        "\u5C3A",
        "\u8FFD",
        "\u5806",
        "\u96C4",
        "\u8FCE",
        "\u6CDB",
        "\u7238",
        "\u697C",
        "\u907F",
        "\u8C0B",
        "\u5428",
        "\u91CE",
        "\u732A",
        "\u65D7",
        "\u7D2F",
        "\u504F",
        "\u5178",
        "\u9986",
        "\u7D22",
        "\u79E6",
        "\u8102",
        "\u6F6E",
        "\u7237",
        "\u8C46",
        "\u5FFD",
        "\u6258",
        "\u60CA",
        "\u5851",
        "\u9057",
        "\u6108",
        "\u6731",
        "\u66FF",
        "\u7EA4",
        "\u7C97",
        "\u503E",
        "\u5C1A",
        "\u75DB",
        "\u695A",
        "\u8C22",
        "\u594B",
        "\u8D2D",
        "\u78E8",
        "\u541B",
        "\u6C60",
        "\u65C1",
        "\u788E",
        "\u9AA8",
        "\u76D1",
        "\u6355",
        "\u5F1F",
        "\u66B4",
        "\u5272",
        "\u8D2F",
        "\u6B8A",
        "\u91CA",
        "\u8BCD",
        "\u4EA1",
        "\u58C1",
        "\u987F",
        "\u5B9D",
        "\u5348",
        "\u5C18",
        "\u95FB",
        "\u63ED",
        "\u70AE",
        "\u6B8B",
        "\u51AC",
        "\u6865",
        "\u5987",
        "\u8B66",
        "\u7EFC",
        "\u62DB",
        "\u5434",
        "\u4ED8",
        "\u6D6E",
        "\u906D",
        "\u5F90",
        "\u60A8",
        "\u6447",
        "\u8C37",
        "\u8D5E",
        "\u7BB1",
        "\u9694",
        "\u8BA2",
        "\u7537",
        "\u5439",
        "\u56ED",
        "\u7EB7",
        "\u5510",
        "\u8D25",
        "\u5B8B",
        "\u73BB",
        "\u5DE8",
        "\u8015",
        "\u5766",
        "\u8363",
        "\u95ED",
        "\u6E7E",
        "\u952E",
        "\u51E1",
        "\u9A7B",
        "\u9505",
        "\u6551",
        "\u6069",
        "\u5265",
        "\u51DD",
        "\u78B1",
        "\u9F7F",
        "\u622A",
        "\u70BC",
        "\u9EBB",
        "\u7EBA",
        "\u7981",
        "\u5E9F",
        "\u76DB",
        "\u7248",
        "\u7F13",
        "\u51C0",
        "\u775B",
        "\u660C",
        "\u5A5A",
        "\u6D89",
        "\u7B52",
        "\u5634",
        "\u63D2",
        "\u5CB8",
        "\u6717",
        "\u5E84",
        "\u8857",
        "\u85CF",
        "\u59D1",
        "\u8D38",
        "\u8150",
        "\u5974",
        "\u5566",
        "\u60EF",
        "\u4E58",
        "\u4F19",
        "\u6062",
        "\u5300",
        "\u7EB1",
        "\u624E",
        "\u8FA9",
        "\u8033",
        "\u5F6A",
        "\u81E3",
        "\u4EBF",
        "\u7483",
        "\u62B5",
        "\u8109",
        "\u79C0",
        "\u8428",
        "\u4FC4",
        "\u7F51",
        "\u821E",
        "\u5E97",
        "\u55B7",
        "\u7EB5",
        "\u5BF8",
        "\u6C57",
        "\u6302",
        "\u6D2A",
        "\u8D3A",
        "\u95EA",
        "\u67EC",
        "\u7206",
        "\u70EF",
        "\u6D25",
        "\u7A3B",
        "\u5899",
        "\u8F6F",
        "\u52C7",
        "\u50CF",
        "\u6EDA",
        "\u5398",
        "\u8499",
        "\u82B3",
        "\u80AF",
        "\u5761",
        "\u67F1",
        "\u8361",
        "\u817F",
        "\u4EEA",
        "\u65C5",
        "\u5C3E",
        "\u8F67",
        "\u51B0",
        "\u8D21",
        "\u767B",
        "\u9ECE",
        "\u524A",
        "\u94BB",
        "\u52D2",
        "\u9003",
        "\u969C",
        "\u6C28",
        "\u90ED",
        "\u5CF0",
        "\u5E01",
        "\u6E2F",
        "\u4F0F",
        "\u8F68",
        "\u4EA9",
        "\u6BD5",
        "\u64E6",
        "\u83AB",
        "\u523A",
        "\u6D6A",
        "\u79D8",
        "\u63F4",
        "\u682A",
        "\u5065",
        "\u552E",
        "\u80A1",
        "\u5C9B",
        "\u7518",
        "\u6CE1",
        "\u7761",
        "\u7AE5",
        "\u94F8",
        "\u6C64",
        "\u9600",
        "\u4F11",
        "\u6C47",
        "\u820D",
        "\u7267",
        "\u7ED5",
        "\u70B8",
        "\u54F2",
        "\u78F7",
        "\u7EE9",
        "\u670B",
        "\u6DE1",
        "\u5C16",
        "\u542F",
        "\u9677",
        "\u67F4",
        "\u5448",
        "\u5F92",
        "\u989C",
        "\u6CEA",
        "\u7A0D",
        "\u5FD8",
        "\u6CF5",
        "\u84DD",
        "\u62D6",
        "\u6D1E",
        "\u6388",
        "\u955C",
        "\u8F9B",
        "\u58EE",
        "\u950B",
        "\u8D2B",
        "\u865A",
        "\u5F2F",
        "\u6469",
        "\u6CF0",
        "\u5E7C",
        "\u5EF7",
        "\u5C0A",
        "\u7A97",
        "\u7EB2",
        "\u5F04",
        "\u96B6",
        "\u7591",
        "\u6C0F",
        "\u5BAB",
        "\u59D0",
        "\u9707",
        "\u745E",
        "\u602A",
        "\u5C24",
        "\u7434",
        "\u5FAA",
        "\u63CF",
        "\u819C",
        "\u8FDD",
        "\u5939",
        "\u8170",
        "\u7F18",
        "\u73E0",
        "\u7A77",
        "\u68EE",
        "\u679D",
        "\u7AF9",
        "\u6C9F",
        "\u50AC",
        "\u7EF3",
        "\u5FC6",
        "\u90A6",
        "\u5269",
        "\u5E78",
        "\u6D46",
        "\u680F",
        "\u62E5",
        "\u7259",
        "\u8D2E",
        "\u793C",
        "\u6EE4",
        "\u94A0",
        "\u7EB9",
        "\u7F62",
        "\u62CD",
        "\u54B1",
        "\u558A",
        "\u8896",
        "\u57C3",
        "\u52E4",
        "\u7F5A",
        "\u7126",
        "\u6F5C",
        "\u4F0D",
        "\u58A8",
        "\u6B32",
        "\u7F1D",
        "\u59D3",
        "\u520A",
        "\u9971",
        "\u4EFF",
        "\u5956",
        "\u94DD",
        "\u9B3C",
        "\u4E3D",
        "\u8DE8",
        "\u9ED8",
        "\u6316",
        "\u94FE",
        "\u626B",
        "\u559D",
        "\u888B",
        "\u70AD",
        "\u6C61",
        "\u5E55",
        "\u8BF8",
        "\u5F27",
        "\u52B1",
        "\u6885",
        "\u5976",
        "\u6D01",
        "\u707E",
        "\u821F",
        "\u9274",
        "\u82EF",
        "\u8BBC",
        "\u62B1",
        "\u6BC1",
        "\u61C2",
        "\u5BD2",
        "\u667A",
        "\u57D4",
        "\u5BC4",
        "\u5C4A",
        "\u8DC3",
        "\u6E21",
        "\u6311",
        "\u4E39",
        "\u8270",
        "\u8D1D",
        "\u78B0",
        "\u62D4",
        "\u7239",
        "\u6234",
        "\u7801",
        "\u68A6",
        "\u82BD",
        "\u7194",
        "\u8D64",
        "\u6E14",
        "\u54ED",
        "\u656C",
        "\u9897",
        "\u5954",
        "\u94C5",
        "\u4EF2",
        "\u864E",
        "\u7A00",
        "\u59B9",
        "\u4E4F",
        "\u73CD",
        "\u7533",
        "\u684C",
        "\u9075",
        "\u5141",
        "\u9686",
        "\u87BA",
        "\u4ED3",
        "\u9B4F",
        "\u9510",
        "\u6653",
        "\u6C2E",
        "\u517C",
        "\u9690",
        "\u788D",
        "\u8D6B",
        "\u62E8",
        "\u5FE0",
        "\u8083",
        "\u7F38",
        "\u7275",
        "\u62A2",
        "\u535A",
        "\u5DE7",
        "\u58F3",
        "\u5144",
        "\u675C",
        "\u8BAF",
        "\u8BDA",
        "\u78A7",
        "\u7965",
        "\u67EF",
        "\u9875",
        "\u5DE1",
        "\u77E9",
        "\u60B2",
        "\u704C",
        "\u9F84",
        "\u4F26",
        "\u7968",
        "\u5BFB",
        "\u6842",
        "\u94FA",
        "\u5723",
        "\u6050",
        "\u6070",
        "\u90D1",
        "\u8DA3",
        "\u62AC",
        "\u8352",
        "\u817E",
        "\u8D34",
        "\u67D4",
        "\u6EF4",
        "\u731B",
        "\u9614",
        "\u8F86",
        "\u59BB",
        "\u586B",
        "\u64A4",
        "\u50A8",
        "\u7B7E",
        "\u95F9",
        "\u6270",
        "\u7D2B",
        "\u7802",
        "\u9012",
        "\u620F",
        "\u540A",
        "\u9676",
        "\u4F10",
        "\u5582",
        "\u7597",
        "\u74F6",
        "\u5A46",
        "\u629A",
        "\u81C2",
        "\u6478",
        "\u5FCD",
        "\u867E",
        "\u8721",
        "\u90BB",
        "\u80F8",
        "\u5DE9",
        "\u6324",
        "\u5076",
        "\u5F03",
        "\u69FD",
        "\u52B2",
        "\u4E73",
        "\u9093",
        "\u5409",
        "\u4EC1",
        "\u70C2",
        "\u7816",
        "\u79DF",
        "\u4E4C",
        "\u8230",
        "\u4F34",
        "\u74DC",
        "\u6D45",
        "\u4E19",
        "\u6682",
        "\u71E5",
        "\u6A61",
        "\u67F3",
        "\u8FF7",
        "\u6696",
        "\u724C",
        "\u79E7",
        "\u80C6",
        "\u8BE6",
        "\u7C27",
        "\u8E0F",
        "\u74F7",
        "\u8C31",
        "\u5446",
        "\u5BBE",
        "\u7CCA",
        "\u6D1B",
        "\u8F89",
        "\u6124",
        "\u7ADE",
        "\u9699",
        "\u6012",
        "\u7C98",
        "\u4E43",
        "\u7EEA",
        "\u80A9",
        "\u7C4D",
        "\u654F",
        "\u6D82",
        "\u7199",
        "\u7686",
        "\u4FA6",
        "\u60AC",
        "\u6398",
        "\u4EAB",
        "\u7EA0",
        "\u9192",
        "\u72C2",
        "\u9501",
        "\u6DC0",
        "\u6068",
        "\u7272",
        "\u9738",
        "\u722C",
        "\u8D4F",
        "\u9006",
        "\u73A9",
        "\u9675",
        "\u795D",
        "\u79D2",
        "\u6D59",
        "\u8C8C",
        "\u5F79",
        "\u5F7C",
        "\u6089",
        "\u9E2D",
        "\u8D8B",
        "\u51E4",
        "\u6668",
        "\u755C",
        "\u8F88",
        "\u79E9",
        "\u5375",
        "\u7F72",
        "\u68AF",
        "\u708E",
        "\u6EE9",
        "\u68CB",
        "\u9A71",
        "\u7B5B",
        "\u5CE1",
        "\u5192",
        "\u5565",
        "\u5BFF",
        "\u8BD1",
        "\u6D78",
        "\u6CC9",
        "\u5E3D",
        "\u8FDF",
        "\u7845",
        "\u7586",
        "\u8D37",
        "\u6F0F",
        "\u7A3F",
        "\u51A0",
        "\u5AE9",
        "\u80C1",
        "\u82AF",
        "\u7262",
        "\u53DB",
        "\u8680",
        "\u5965",
        "\u9E23",
        "\u5CAD",
        "\u7F8A",
        "\u51ED",
        "\u4E32",
        "\u5858",
        "\u7ED8",
        "\u9175",
        "\u878D",
        "\u76C6",
        "\u9521",
        "\u5E99",
        "\u7B79",
        "\u51BB",
        "\u8F85",
        "\u6444",
        "\u88AD",
        "\u7B4B",
        "\u62D2",
        "\u50DA",
        "\u65F1",
        "\u94BE",
        "\u9E1F",
        "\u6F06",
        "\u6C88",
        "\u7709",
        "\u758F",
        "\u6DFB",
        "\u68D2",
        "\u7A57",
        "\u785D",
        "\u97E9",
        "\u903C",
        "\u626D",
        "\u4FA8",
        "\u51C9",
        "\u633A",
        "\u7897",
        "\u683D",
        "\u7092",
        "\u676F",
        "\u60A3",
        "\u998F",
        "\u529D",
        "\u8C6A",
        "\u8FBD",
        "\u52C3",
        "\u9E3F",
        "\u65E6",
        "\u540F",
        "\u62DC",
        "\u72D7",
        "\u57CB",
        "\u8F8A",
        "\u63A9",
        "\u996E",
        "\u642C",
        "\u9A82",
        "\u8F9E",
        "\u52FE",
        "\u6263",
        "\u4F30",
        "\u848B",
        "\u7ED2",
        "\u96FE",
        "\u4E08",
        "\u6735",
        "\u59C6",
        "\u62DF",
        "\u5B87",
        "\u8F91",
        "\u9655",
        "\u96D5",
        "\u507F",
        "\u84C4",
        "\u5D07",
        "\u526A",
        "\u5021",
        "\u5385",
        "\u54AC",
        "\u9A76",
        "\u85AF",
        "\u5237",
        "\u65A5",
        "\u756A",
        "\u8D4B",
        "\u5949",
        "\u4F5B",
        "\u6D47",
        "\u6F2B",
        "\u66FC",
        "\u6247",
        "\u9499",
        "\u6843",
        "\u6276",
        "\u4ED4",
        "\u8FD4",
        "\u4FD7",
        "\u4E8F",
        "\u8154",
        "\u978B",
        "\u68F1",
        "\u8986",
        "\u6846",
        "\u6084",
        "\u53D4",
        "\u649E",
        "\u9A97",
        "\u52D8",
        "\u65FA",
        "\u6CB8",
        "\u5B64",
        "\u5410",
        "\u5B5F",
        "\u6E20",
        "\u5C48",
        "\u75BE",
        "\u5999",
        "\u60DC",
        "\u4EF0",
        "\u72E0",
        "\u80C0",
        "\u8C10",
        "\u629B",
        "\u9709",
        "\u6851",
        "\u5C97",
        "\u561B",
        "\u8870",
        "\u76D7",
        "\u6E17",
        "\u810F",
        "\u8D56",
        "\u6D8C",
        "\u751C",
        "\u66F9",
        "\u9605",
        "\u808C",
        "\u54E9",
        "\u5389",
        "\u70C3",
        "\u7EAC",
        "\u6BC5",
        "\u6628",
        "\u4F2A",
        "\u75C7",
        "\u716E",
        "\u53F9",
        "\u9489",
        "\u642D",
        "\u830E",
        "\u7B3C",
        "\u9177",
        "\u5077",
        "\u5F13",
        "\u9525",
        "\u6052",
        "\u6770",
        "\u5751",
        "\u9F3B",
        "\u7FFC",
        "\u7EB6",
        "\u53D9",
        "\u72F1",
        "\u902E",
        "\u7F50",
        "\u7EDC",
        "\u68DA",
        "\u6291",
        "\u81A8",
        "\u852C",
        "\u5BFA",
        "\u9AA4",
        "\u7A46",
        "\u51B6",
        "\u67AF",
        "\u518C",
        "\u5C38",
        "\u51F8",
        "\u7EC5",
        "\u576F",
        "\u727A",
        "\u7130",
        "\u8F70",
        "\u6B23",
        "\u664B",
        "\u7626",
        "\u5FA1",
        "\u952D",
        "\u9526",
        "\u4E27",
        "\u65EC",
        "\u953B",
        "\u5784",
        "\u641C",
        "\u6251",
        "\u9080",
        "\u4EAD",
        "\u916F",
        "\u8FC8",
        "\u8212",
        "\u8106",
        "\u9176",
        "\u95F2",
        "\u5FE7",
        "\u915A",
        "\u987D",
        "\u7FBD",
        "\u6DA8",
        "\u5378",
        "\u4ED7",
        "\u966A",
        "\u8F9F",
        "\u60E9",
        "\u676D",
        "\u59DA",
        "\u809A",
        "\u6349",
        "\u98D8",
        "\u6F02",
        "\u6606",
        "\u6B3A",
        "\u543E",
        "\u90CE",
        "\u70F7",
        "\u6C41",
        "\u5475",
        "\u9970",
        "\u8427",
        "\u96C5",
        "\u90AE",
        "\u8FC1",
        "\u71D5",
        "\u6492",
        "\u59FB",
        "\u8D74",
        "\u5BB4",
        "\u70E6",
        "\u503A",
        "\u5E10",
        "\u6591",
        "\u94C3",
        "\u65E8",
        "\u9187",
        "\u8463",
        "\u997C",
        "\u96CF",
        "\u59FF",
        "\u62CC",
        "\u5085",
        "\u8179",
        "\u59A5",
        "\u63C9",
        "\u8D24",
        "\u62C6",
        "\u6B6A",
        "\u8461",
        "\u80FA",
        "\u4E22",
        "\u6D69",
        "\u5FBD",
        "\u6602",
        "\u57AB",
        "\u6321",
        "\u89C8",
        "\u8D2A",
        "\u6170",
        "\u7F34",
        "\u6C6A",
        "\u614C",
        "\u51AF",
        "\u8BFA",
        "\u59DC",
        "\u8C0A",
        "\u51F6",
        "\u52A3",
        "\u8BEC",
        "\u8000",
        "\u660F",
        "\u8EBA",
        "\u76C8",
        "\u9A91",
        "\u4E54",
        "\u6EAA",
        "\u4E1B",
        "\u5362",
        "\u62B9",
        "\u95F7",
        "\u54A8",
        "\u522E",
        "\u9A7E",
        "\u7F06",
        "\u609F",
        "\u6458",
        "\u94D2",
        "\u63B7",
        "\u9887",
        "\u5E7B",
        "\u67C4",
        "\u60E0",
        "\u60E8",
        "\u4F73",
        "\u4EC7",
        "\u814A",
        "\u7A9D",
        "\u6DA4",
        "\u5251",
        "\u77A7",
        "\u5821",
        "\u6CFC",
        "\u8471",
        "\u7F69",
        "\u970D",
        "\u635E",
        "\u80CE",
        "\u82CD",
        "\u6EE8",
        "\u4FE9",
        "\u6345",
        "\u6E58",
        "\u780D",
        "\u971E",
        "\u90B5",
        "\u8404",
        "\u75AF",
        "\u6DEE",
        "\u9042",
        "\u718A",
        "\u7CAA",
        "\u70D8",
        "\u5BBF",
        "\u6863",
        "\u6208",
        "\u9A73",
        "\u5AC2",
        "\u88D5",
        "\u5F99",
        "\u7BAD",
        "\u6350",
        "\u80A0",
        "\u6491",
        "\u6652",
        "\u8FA8",
        "\u6BBF",
        "\u83B2",
        "\u644A",
        "\u6405",
        "\u9171",
        "\u5C4F",
        "\u75AB",
        "\u54C0",
        "\u8521",
        "\u5835",
        "\u6CAB",
        "\u76B1",
        "\u7545",
        "\u53E0",
        "\u9601",
        "\u83B1",
        "\u6572",
        "\u8F96",
        "\u94A9",
        "\u75D5",
        "\u575D",
        "\u5DF7",
        "\u997F",
        "\u7978",
        "\u4E18",
        "\u7384",
        "\u6E9C",
        "\u66F0",
        "\u903B",
        "\u5F6D",
        "\u5C1D",
        "\u537F",
        "\u59A8",
        "\u8247",
        "\u541E",
        "\u97E6",
        "\u6028",
        "\u77EE",
        "\u6B47"
      ];
    }
  });

  // node_modules/bip39/src/wordlists/chinese_traditional.json
  var require_chinese_traditional = __commonJS({
    "node_modules/bip39/src/wordlists/chinese_traditional.json"(exports9, module) {
      module.exports = [
        "\u7684",
        "\u4E00",
        "\u662F",
        "\u5728",
        "\u4E0D",
        "\u4E86",
        "\u6709",
        "\u548C",
        "\u4EBA",
        "\u9019",
        "\u4E2D",
        "\u5927",
        "\u70BA",
        "\u4E0A",
        "\u500B",
        "\u570B",
        "\u6211",
        "\u4EE5",
        "\u8981",
        "\u4ED6",
        "\u6642",
        "\u4F86",
        "\u7528",
        "\u5011",
        "\u751F",
        "\u5230",
        "\u4F5C",
        "\u5730",
        "\u65BC",
        "\u51FA",
        "\u5C31",
        "\u5206",
        "\u5C0D",
        "\u6210",
        "\u6703",
        "\u53EF",
        "\u4E3B",
        "\u767C",
        "\u5E74",
        "\u52D5",
        "\u540C",
        "\u5DE5",
        "\u4E5F",
        "\u80FD",
        "\u4E0B",
        "\u904E",
        "\u5B50",
        "\u8AAA",
        "\u7522",
        "\u7A2E",
        "\u9762",
        "\u800C",
        "\u65B9",
        "\u5F8C",
        "\u591A",
        "\u5B9A",
        "\u884C",
        "\u5B78",
        "\u6CD5",
        "\u6240",
        "\u6C11",
        "\u5F97",
        "\u7D93",
        "\u5341",
        "\u4E09",
        "\u4E4B",
        "\u9032",
        "\u8457",
        "\u7B49",
        "\u90E8",
        "\u5EA6",
        "\u5BB6",
        "\u96FB",
        "\u529B",
        "\u88E1",
        "\u5982",
        "\u6C34",
        "\u5316",
        "\u9AD8",
        "\u81EA",
        "\u4E8C",
        "\u7406",
        "\u8D77",
        "\u5C0F",
        "\u7269",
        "\u73FE",
        "\u5BE6",
        "\u52A0",
        "\u91CF",
        "\u90FD",
        "\u5169",
        "\u9AD4",
        "\u5236",
        "\u6A5F",
        "\u7576",
        "\u4F7F",
        "\u9EDE",
        "\u5F9E",
        "\u696D",
        "\u672C",
        "\u53BB",
        "\u628A",
        "\u6027",
        "\u597D",
        "\u61C9",
        "\u958B",
        "\u5B83",
        "\u5408",
        "\u9084",
        "\u56E0",
        "\u7531",
        "\u5176",
        "\u4E9B",
        "\u7136",
        "\u524D",
        "\u5916",
        "\u5929",
        "\u653F",
        "\u56DB",
        "\u65E5",
        "\u90A3",
        "\u793E",
        "\u7FA9",
        "\u4E8B",
        "\u5E73",
        "\u5F62",
        "\u76F8",
        "\u5168",
        "\u8868",
        "\u9593",
        "\u6A23",
        "\u8207",
        "\u95DC",
        "\u5404",
        "\u91CD",
        "\u65B0",
        "\u7DDA",
        "\u5167",
        "\u6578",
        "\u6B63",
        "\u5FC3",
        "\u53CD",
        "\u4F60",
        "\u660E",
        "\u770B",
        "\u539F",
        "\u53C8",
        "\u9EBC",
        "\u5229",
        "\u6BD4",
        "\u6216",
        "\u4F46",
        "\u8CEA",
        "\u6C23",
        "\u7B2C",
        "\u5411",
        "\u9053",
        "\u547D",
        "\u6B64",
        "\u8B8A",
        "\u689D",
        "\u53EA",
        "\u6C92",
        "\u7D50",
        "\u89E3",
        "\u554F",
        "\u610F",
        "\u5EFA",
        "\u6708",
        "\u516C",
        "\u7121",
        "\u7CFB",
        "\u8ECD",
        "\u5F88",
        "\u60C5",
        "\u8005",
        "\u6700",
        "\u7ACB",
        "\u4EE3",
        "\u60F3",
        "\u5DF2",
        "\u901A",
        "\u4E26",
        "\u63D0",
        "\u76F4",
        "\u984C",
        "\u9EE8",
        "\u7A0B",
        "\u5C55",
        "\u4E94",
        "\u679C",
        "\u6599",
        "\u8C61",
        "\u54E1",
        "\u9769",
        "\u4F4D",
        "\u5165",
        "\u5E38",
        "\u6587",
        "\u7E3D",
        "\u6B21",
        "\u54C1",
        "\u5F0F",
        "\u6D3B",
        "\u8A2D",
        "\u53CA",
        "\u7BA1",
        "\u7279",
        "\u4EF6",
        "\u9577",
        "\u6C42",
        "\u8001",
        "\u982D",
        "\u57FA",
        "\u8CC7",
        "\u908A",
        "\u6D41",
        "\u8DEF",
        "\u7D1A",
        "\u5C11",
        "\u5716",
        "\u5C71",
        "\u7D71",
        "\u63A5",
        "\u77E5",
        "\u8F03",
        "\u5C07",
        "\u7D44",
        "\u898B",
        "\u8A08",
        "\u5225",
        "\u5979",
        "\u624B",
        "\u89D2",
        "\u671F",
        "\u6839",
        "\u8AD6",
        "\u904B",
        "\u8FB2",
        "\u6307",
        "\u5E7E",
        "\u4E5D",
        "\u5340",
        "\u5F37",
        "\u653E",
        "\u6C7A",
        "\u897F",
        "\u88AB",
        "\u5E79",
        "\u505A",
        "\u5FC5",
        "\u6230",
        "\u5148",
        "\u56DE",
        "\u5247",
        "\u4EFB",
        "\u53D6",
        "\u64DA",
        "\u8655",
        "\u968A",
        "\u5357",
        "\u7D66",
        "\u8272",
        "\u5149",
        "\u9580",
        "\u5373",
        "\u4FDD",
        "\u6CBB",
        "\u5317",
        "\u9020",
        "\u767E",
        "\u898F",
        "\u71B1",
        "\u9818",
        "\u4E03",
        "\u6D77",
        "\u53E3",
        "\u6771",
        "\u5C0E",
        "\u5668",
        "\u58D3",
        "\u5FD7",
        "\u4E16",
        "\u91D1",
        "\u589E",
        "\u722D",
        "\u6FDF",
        "\u968E",
        "\u6CB9",
        "\u601D",
        "\u8853",
        "\u6975",
        "\u4EA4",
        "\u53D7",
        "\u806F",
        "\u4EC0",
        "\u8A8D",
        "\u516D",
        "\u5171",
        "\u6B0A",
        "\u6536",
        "\u8B49",
        "\u6539",
        "\u6E05",
        "\u7F8E",
        "\u518D",
        "\u63A1",
        "\u8F49",
        "\u66F4",
        "\u55AE",
        "\u98A8",
        "\u5207",
        "\u6253",
        "\u767D",
        "\u6559",
        "\u901F",
        "\u82B1",
        "\u5E36",
        "\u5B89",
        "\u5834",
        "\u8EAB",
        "\u8ECA",
        "\u4F8B",
        "\u771F",
        "\u52D9",
        "\u5177",
        "\u842C",
        "\u6BCF",
        "\u76EE",
        "\u81F3",
        "\u9054",
        "\u8D70",
        "\u7A4D",
        "\u793A",
        "\u8B70",
        "\u8072",
        "\u5831",
        "\u9B25",
        "\u5B8C",
        "\u985E",
        "\u516B",
        "\u96E2",
        "\u83EF",
        "\u540D",
        "\u78BA",
        "\u624D",
        "\u79D1",
        "\u5F35",
        "\u4FE1",
        "\u99AC",
        "\u7BC0",
        "\u8A71",
        "\u7C73",
        "\u6574",
        "\u7A7A",
        "\u5143",
        "\u6CC1",
        "\u4ECA",
        "\u96C6",
        "\u6EAB",
        "\u50B3",
        "\u571F",
        "\u8A31",
        "\u6B65",
        "\u7FA4",
        "\u5EE3",
        "\u77F3",
        "\u8A18",
        "\u9700",
        "\u6BB5",
        "\u7814",
        "\u754C",
        "\u62C9",
        "\u6797",
        "\u5F8B",
        "\u53EB",
        "\u4E14",
        "\u7A76",
        "\u89C0",
        "\u8D8A",
        "\u7E54",
        "\u88DD",
        "\u5F71",
        "\u7B97",
        "\u4F4E",
        "\u6301",
        "\u97F3",
        "\u773E",
        "\u66F8",
        "\u5E03",
        "\u590D",
        "\u5BB9",
        "\u5152",
        "\u9808",
        "\u969B",
        "\u5546",
        "\u975E",
        "\u9A57",
        "\u9023",
        "\u65B7",
        "\u6DF1",
        "\u96E3",
        "\u8FD1",
        "\u7926",
        "\u5343",
        "\u9031",
        "\u59D4",
        "\u7D20",
        "\u6280",
        "\u5099",
        "\u534A",
        "\u8FA6",
        "\u9752",
        "\u7701",
        "\u5217",
        "\u7FD2",
        "\u97FF",
        "\u7D04",
        "\u652F",
        "\u822C",
        "\u53F2",
        "\u611F",
        "\u52DE",
        "\u4FBF",
        "\u5718",
        "\u5F80",
        "\u9178",
        "\u6B77",
        "\u5E02",
        "\u514B",
        "\u4F55",
        "\u9664",
        "\u6D88",
        "\u69CB",
        "\u5E9C",
        "\u7A31",
        "\u592A",
        "\u6E96",
        "\u7CBE",
        "\u503C",
        "\u865F",
        "\u7387",
        "\u65CF",
        "\u7DAD",
        "\u5283",
        "\u9078",
        "\u6A19",
        "\u5BEB",
        "\u5B58",
        "\u5019",
        "\u6BDB",
        "\u89AA",
        "\u5FEB",
        "\u6548",
        "\u65AF",
        "\u9662",
        "\u67E5",
        "\u6C5F",
        "\u578B",
        "\u773C",
        "\u738B",
        "\u6309",
        "\u683C",
        "\u990A",
        "\u6613",
        "\u7F6E",
        "\u6D3E",
        "\u5C64",
        "\u7247",
        "\u59CB",
        "\u537B",
        "\u5C08",
        "\u72C0",
        "\u80B2",
        "\u5EE0",
        "\u4EAC",
        "\u8B58",
        "\u9069",
        "\u5C6C",
        "\u5713",
        "\u5305",
        "\u706B",
        "\u4F4F",
        "\u8ABF",
        "\u6EFF",
        "\u7E23",
        "\u5C40",
        "\u7167",
        "\u53C3",
        "\u7D05",
        "\u7D30",
        "\u5F15",
        "\u807D",
        "\u8A72",
        "\u9435",
        "\u50F9",
        "\u56B4",
        "\u9996",
        "\u5E95",
        "\u6DB2",
        "\u5B98",
        "\u5FB7",
        "\u96A8",
        "\u75C5",
        "\u8607",
        "\u5931",
        "\u723E",
        "\u6B7B",
        "\u8B1B",
        "\u914D",
        "\u5973",
        "\u9EC3",
        "\u63A8",
        "\u986F",
        "\u8AC7",
        "\u7F6A",
        "\u795E",
        "\u85DD",
        "\u5462",
        "\u5E2D",
        "\u542B",
        "\u4F01",
        "\u671B",
        "\u5BC6",
        "\u6279",
        "\u71DF",
        "\u9805",
        "\u9632",
        "\u8209",
        "\u7403",
        "\u82F1",
        "\u6C27",
        "\u52E2",
        "\u544A",
        "\u674E",
        "\u53F0",
        "\u843D",
        "\u6728",
        "\u5E6B",
        "\u8F2A",
        "\u7834",
        "\u4E9E",
        "\u5E2B",
        "\u570D",
        "\u6CE8",
        "\u9060",
        "\u5B57",
        "\u6750",
        "\u6392",
        "\u4F9B",
        "\u6CB3",
        "\u614B",
        "\u5C01",
        "\u53E6",
        "\u65BD",
        "\u6E1B",
        "\u6A39",
        "\u6EB6",
        "\u600E",
        "\u6B62",
        "\u6848",
        "\u8A00",
        "\u58EB",
        "\u5747",
        "\u6B66",
        "\u56FA",
        "\u8449",
        "\u9B5A",
        "\u6CE2",
        "\u8996",
        "\u50C5",
        "\u8CBB",
        "\u7DCA",
        "\u611B",
        "\u5DE6",
        "\u7AE0",
        "\u65E9",
        "\u671D",
        "\u5BB3",
        "\u7E8C",
        "\u8F15",
        "\u670D",
        "\u8A66",
        "\u98DF",
        "\u5145",
        "\u5175",
        "\u6E90",
        "\u5224",
        "\u8B77",
        "\u53F8",
        "\u8DB3",
        "\u67D0",
        "\u7DF4",
        "\u5DEE",
        "\u81F4",
        "\u677F",
        "\u7530",
        "\u964D",
        "\u9ED1",
        "\u72AF",
        "\u8CA0",
        "\u64CA",
        "\u8303",
        "\u7E7C",
        "\u8208",
        "\u4F3C",
        "\u9918",
        "\u5805",
        "\u66F2",
        "\u8F38",
        "\u4FEE",
        "\u6545",
        "\u57CE",
        "\u592B",
        "\u5920",
        "\u9001",
        "\u7B46",
        "\u8239",
        "\u4F54",
        "\u53F3",
        "\u8CA1",
        "\u5403",
        "\u5BCC",
        "\u6625",
        "\u8077",
        "\u89BA",
        "\u6F22",
        "\u756B",
        "\u529F",
        "\u5DF4",
        "\u8DDF",
        "\u96D6",
        "\u96DC",
        "\u98DB",
        "\u6AA2",
        "\u5438",
        "\u52A9",
        "\u6607",
        "\u967D",
        "\u4E92",
        "\u521D",
        "\u5275",
        "\u6297",
        "\u8003",
        "\u6295",
        "\u58DE",
        "\u7B56",
        "\u53E4",
        "\u5F91",
        "\u63DB",
        "\u672A",
        "\u8DD1",
        "\u7559",
        "\u92FC",
        "\u66FE",
        "\u7AEF",
        "\u8CAC",
        "\u7AD9",
        "\u7C21",
        "\u8FF0",
        "\u9322",
        "\u526F",
        "\u76E1",
        "\u5E1D",
        "\u5C04",
        "\u8349",
        "\u885D",
        "\u627F",
        "\u7368",
        "\u4EE4",
        "\u9650",
        "\u963F",
        "\u5BA3",
        "\u74B0",
        "\u96D9",
        "\u8ACB",
        "\u8D85",
        "\u5FAE",
        "\u8B93",
        "\u63A7",
        "\u5DDE",
        "\u826F",
        "\u8EF8",
        "\u627E",
        "\u5426",
        "\u7D00",
        "\u76CA",
        "\u4F9D",
        "\u512A",
        "\u9802",
        "\u790E",
        "\u8F09",
        "\u5012",
        "\u623F",
        "\u7A81",
        "\u5750",
        "\u7C89",
        "\u6575",
        "\u7565",
        "\u5BA2",
        "\u8881",
        "\u51B7",
        "\u52DD",
        "\u7D55",
        "\u6790",
        "\u584A",
        "\u5291",
        "\u6E2C",
        "\u7D72",
        "\u5354",
        "\u8A34",
        "\u5FF5",
        "\u9673",
        "\u4ECD",
        "\u7F85",
        "\u9E7D",
        "\u53CB",
        "\u6D0B",
        "\u932F",
        "\u82E6",
        "\u591C",
        "\u5211",
        "\u79FB",
        "\u983B",
        "\u9010",
        "\u9760",
        "\u6DF7",
        "\u6BCD",
        "\u77ED",
        "\u76AE",
        "\u7D42",
        "\u805A",
        "\u6C7D",
        "\u6751",
        "\u96F2",
        "\u54EA",
        "\u65E2",
        "\u8DDD",
        "\u885B",
        "\u505C",
        "\u70C8",
        "\u592E",
        "\u5BDF",
        "\u71D2",
        "\u8FC5",
        "\u5883",
        "\u82E5",
        "\u5370",
        "\u6D32",
        "\u523B",
        "\u62EC",
        "\u6FC0",
        "\u5B54",
        "\u641E",
        "\u751A",
        "\u5BA4",
        "\u5F85",
        "\u6838",
        "\u6821",
        "\u6563",
        "\u4FB5",
        "\u5427",
        "\u7532",
        "\u904A",
        "\u4E45",
        "\u83DC",
        "\u5473",
        "\u820A",
        "\u6A21",
        "\u6E56",
        "\u8CA8",
        "\u640D",
        "\u9810",
        "\u963B",
        "\u6BEB",
        "\u666E",
        "\u7A69",
        "\u4E59",
        "\u5ABD",
        "\u690D",
        "\u606F",
        "\u64F4",
        "\u9280",
        "\u8A9E",
        "\u63EE",
        "\u9152",
        "\u5B88",
        "\u62FF",
        "\u5E8F",
        "\u7D19",
        "\u91AB",
        "\u7F3A",
        "\u96E8",
        "\u55CE",
        "\u91DD",
        "\u5289",
        "\u554A",
        "\u6025",
        "\u5531",
        "\u8AA4",
        "\u8A13",
        "\u9858",
        "\u5BE9",
        "\u9644",
        "\u7372",
        "\u8336",
        "\u9BAE",
        "\u7CE7",
        "\u65A4",
        "\u5B69",
        "\u812B",
        "\u786B",
        "\u80A5",
        "\u5584",
        "\u9F8D",
        "\u6F14",
        "\u7236",
        "\u6F38",
        "\u8840",
        "\u6B61",
        "\u68B0",
        "\u638C",
        "\u6B4C",
        "\u6C99",
        "\u525B",
        "\u653B",
        "\u8B02",
        "\u76FE",
        "\u8A0E",
        "\u665A",
        "\u7C92",
        "\u4E82",
        "\u71C3",
        "\u77DB",
        "\u4E4E",
        "\u6BBA",
        "\u85E5",
        "\u5BE7",
        "\u9B6F",
        "\u8CB4",
        "\u9418",
        "\u7164",
        "\u8B80",
        "\u73ED",
        "\u4F2F",
        "\u9999",
        "\u4ECB",
        "\u8FEB",
        "\u53E5",
        "\u8C50",
        "\u57F9",
        "\u63E1",
        "\u862D",
        "\u64D4",
        "\u5F26",
        "\u86CB",
        "\u6C89",
        "\u5047",
        "\u7A7F",
        "\u57F7",
        "\u7B54",
        "\u6A02",
        "\u8AB0",
        "\u9806",
        "\u7159",
        "\u7E2E",
        "\u5FB5",
        "\u81C9",
        "\u559C",
        "\u677E",
        "\u8173",
        "\u56F0",
        "\u7570",
        "\u514D",
        "\u80CC",
        "\u661F",
        "\u798F",
        "\u8CB7",
        "\u67D3",
        "\u4E95",
        "\u6982",
        "\u6162",
        "\u6015",
        "\u78C1",
        "\u500D",
        "\u7956",
        "\u7687",
        "\u4FC3",
        "\u975C",
        "\u88DC",
        "\u8A55",
        "\u7FFB",
        "\u8089",
        "\u8E10",
        "\u5C3C",
        "\u8863",
        "\u5BEC",
        "\u63DA",
        "\u68C9",
        "\u5E0C",
        "\u50B7",
        "\u64CD",
        "\u5782",
        "\u79CB",
        "\u5B9C",
        "\u6C2B",
        "\u5957",
        "\u7763",
        "\u632F",
        "\u67B6",
        "\u4EAE",
        "\u672B",
        "\u61B2",
        "\u6176",
        "\u7DE8",
        "\u725B",
        "\u89F8",
        "\u6620",
        "\u96F7",
        "\u92B7",
        "\u8A69",
        "\u5EA7",
        "\u5C45",
        "\u6293",
        "\u88C2",
        "\u80DE",
        "\u547C",
        "\u5A18",
        "\u666F",
        "\u5A01",
        "\u7DA0",
        "\u6676",
        "\u539A",
        "\u76DF",
        "\u8861",
        "\u96DE",
        "\u5B6B",
        "\u5EF6",
        "\u5371",
        "\u81A0",
        "\u5C4B",
        "\u9109",
        "\u81E8",
        "\u9678",
        "\u9867",
        "\u6389",
        "\u5440",
        "\u71C8",
        "\u6B72",
        "\u63AA",
        "\u675F",
        "\u8010",
        "\u5287",
        "\u7389",
        "\u8D99",
        "\u8DF3",
        "\u54E5",
        "\u5B63",
        "\u8AB2",
        "\u51F1",
        "\u80E1",
        "\u984D",
        "\u6B3E",
        "\u7D39",
        "\u5377",
        "\u9F4A",
        "\u5049",
        "\u84B8",
        "\u6B96",
        "\u6C38",
        "\u5B97",
        "\u82D7",
        "\u5DDD",
        "\u7210",
        "\u5CA9",
        "\u5F31",
        "\u96F6",
        "\u694A",
        "\u594F",
        "\u6CBF",
        "\u9732",
        "\u687F",
        "\u63A2",
        "\u6ED1",
        "\u93AE",
        "\u98EF",
        "\u6FC3",
        "\u822A",
        "\u61F7",
        "\u8D95",
        "\u5EAB",
        "\u596A",
        "\u4F0A",
        "\u9748",
        "\u7A05",
        "\u9014",
        "\u6EC5",
        "\u8CFD",
        "\u6B78",
        "\u53EC",
        "\u9F13",
        "\u64AD",
        "\u76E4",
        "\u88C1",
        "\u96AA",
        "\u5EB7",
        "\u552F",
        "\u9304",
        "\u83CC",
        "\u7D14",
        "\u501F",
        "\u7CD6",
        "\u84CB",
        "\u6A6B",
        "\u7B26",
        "\u79C1",
        "\u52AA",
        "\u5802",
        "\u57DF",
        "\u69CD",
        "\u6F64",
        "\u5E45",
        "\u54C8",
        "\u7ADF",
        "\u719F",
        "\u87F2",
        "\u6FA4",
        "\u8166",
        "\u58E4",
        "\u78B3",
        "\u6B50",
        "\u904D",
        "\u5074",
        "\u5BE8",
        "\u6562",
        "\u5FB9",
        "\u616E",
        "\u659C",
        "\u8584",
        "\u5EAD",
        "\u7D0D",
        "\u5F48",
        "\u98FC",
        "\u4F38",
        "\u6298",
        "\u9EA5",
        "\u6FD5",
        "\u6697",
        "\u8377",
        "\u74E6",
        "\u585E",
        "\u5E8A",
        "\u7BC9",
        "\u60E1",
        "\u6236",
        "\u8A2A",
        "\u5854",
        "\u5947",
        "\u900F",
        "\u6881",
        "\u5200",
        "\u65CB",
        "\u8DE1",
        "\u5361",
        "\u6C2F",
        "\u9047",
        "\u4EFD",
        "\u6BD2",
        "\u6CE5",
        "\u9000",
        "\u6D17",
        "\u64FA",
        "\u7070",
        "\u5F69",
        "\u8CE3",
        "\u8017",
        "\u590F",
        "\u64C7",
        "\u5FD9",
        "\u9285",
        "\u737B",
        "\u786C",
        "\u4E88",
        "\u7E41",
        "\u5708",
        "\u96EA",
        "\u51FD",
        "\u4EA6",
        "\u62BD",
        "\u7BC7",
        "\u9663",
        "\u9670",
        "\u4E01",
        "\u5C3A",
        "\u8FFD",
        "\u5806",
        "\u96C4",
        "\u8FCE",
        "\u6CDB",
        "\u7238",
        "\u6A13",
        "\u907F",
        "\u8B00",
        "\u5678",
        "\u91CE",
        "\u8C6C",
        "\u65D7",
        "\u7D2F",
        "\u504F",
        "\u5178",
        "\u9928",
        "\u7D22",
        "\u79E6",
        "\u8102",
        "\u6F6E",
        "\u723A",
        "\u8C46",
        "\u5FFD",
        "\u6258",
        "\u9A5A",
        "\u5851",
        "\u907A",
        "\u6108",
        "\u6731",
        "\u66FF",
        "\u7E96",
        "\u7C97",
        "\u50BE",
        "\u5C1A",
        "\u75DB",
        "\u695A",
        "\u8B1D",
        "\u596E",
        "\u8CFC",
        "\u78E8",
        "\u541B",
        "\u6C60",
        "\u65C1",
        "\u788E",
        "\u9AA8",
        "\u76E3",
        "\u6355",
        "\u5F1F",
        "\u66B4",
        "\u5272",
        "\u8CAB",
        "\u6B8A",
        "\u91CB",
        "\u8A5E",
        "\u4EA1",
        "\u58C1",
        "\u9813",
        "\u5BF6",
        "\u5348",
        "\u5875",
        "\u805E",
        "\u63ED",
        "\u70AE",
        "\u6B98",
        "\u51AC",
        "\u6A4B",
        "\u5A66",
        "\u8B66",
        "\u7D9C",
        "\u62DB",
        "\u5433",
        "\u4ED8",
        "\u6D6E",
        "\u906D",
        "\u5F90",
        "\u60A8",
        "\u6416",
        "\u8C37",
        "\u8D0A",
        "\u7BB1",
        "\u9694",
        "\u8A02",
        "\u7537",
        "\u5439",
        "\u5712",
        "\u7D1B",
        "\u5510",
        "\u6557",
        "\u5B8B",
        "\u73BB",
        "\u5DE8",
        "\u8015",
        "\u5766",
        "\u69AE",
        "\u9589",
        "\u7063",
        "\u9375",
        "\u51E1",
        "\u99D0",
        "\u934B",
        "\u6551",
        "\u6069",
        "\u525D",
        "\u51DD",
        "\u9E7C",
        "\u9F52",
        "\u622A",
        "\u7149",
        "\u9EBB",
        "\u7D21",
        "\u7981",
        "\u5EE2",
        "\u76DB",
        "\u7248",
        "\u7DE9",
        "\u6DE8",
        "\u775B",
        "\u660C",
        "\u5A5A",
        "\u6D89",
        "\u7B52",
        "\u5634",
        "\u63D2",
        "\u5CB8",
        "\u6717",
        "\u838A",
        "\u8857",
        "\u85CF",
        "\u59D1",
        "\u8CBF",
        "\u8150",
        "\u5974",
        "\u5566",
        "\u6163",
        "\u4E58",
        "\u5925",
        "\u6062",
        "\u52FB",
        "\u7D17",
        "\u624E",
        "\u8FAF",
        "\u8033",
        "\u5F6A",
        "\u81E3",
        "\u5104",
        "\u7483",
        "\u62B5",
        "\u8108",
        "\u79C0",
        "\u85A9",
        "\u4FC4",
        "\u7DB2",
        "\u821E",
        "\u5E97",
        "\u5674",
        "\u7E31",
        "\u5BF8",
        "\u6C57",
        "\u639B",
        "\u6D2A",
        "\u8CC0",
        "\u9583",
        "\u67EC",
        "\u7206",
        "\u70EF",
        "\u6D25",
        "\u7A3B",
        "\u7246",
        "\u8EDF",
        "\u52C7",
        "\u50CF",
        "\u6EFE",
        "\u5398",
        "\u8499",
        "\u82B3",
        "\u80AF",
        "\u5761",
        "\u67F1",
        "\u76EA",
        "\u817F",
        "\u5100",
        "\u65C5",
        "\u5C3E",
        "\u8ECB",
        "\u51B0",
        "\u8CA2",
        "\u767B",
        "\u9ECE",
        "\u524A",
        "\u947D",
        "\u52D2",
        "\u9003",
        "\u969C",
        "\u6C28",
        "\u90ED",
        "\u5CF0",
        "\u5E63",
        "\u6E2F",
        "\u4F0F",
        "\u8ECC",
        "\u755D",
        "\u7562",
        "\u64E6",
        "\u83AB",
        "\u523A",
        "\u6D6A",
        "\u79D8",
        "\u63F4",
        "\u682A",
        "\u5065",
        "\u552E",
        "\u80A1",
        "\u5CF6",
        "\u7518",
        "\u6CE1",
        "\u7761",
        "\u7AE5",
        "\u9444",
        "\u6E6F",
        "\u95A5",
        "\u4F11",
        "\u532F",
        "\u820D",
        "\u7267",
        "\u7E5E",
        "\u70B8",
        "\u54F2",
        "\u78F7",
        "\u7E3E",
        "\u670B",
        "\u6DE1",
        "\u5C16",
        "\u555F",
        "\u9677",
        "\u67F4",
        "\u5448",
        "\u5F92",
        "\u984F",
        "\u6DDA",
        "\u7A0D",
        "\u5FD8",
        "\u6CF5",
        "\u85CD",
        "\u62D6",
        "\u6D1E",
        "\u6388",
        "\u93E1",
        "\u8F9B",
        "\u58EF",
        "\u92D2",
        "\u8CA7",
        "\u865B",
        "\u5F4E",
        "\u6469",
        "\u6CF0",
        "\u5E7C",
        "\u5EF7",
        "\u5C0A",
        "\u7A97",
        "\u7DB1",
        "\u5F04",
        "\u96B8",
        "\u7591",
        "\u6C0F",
        "\u5BAE",
        "\u59D0",
        "\u9707",
        "\u745E",
        "\u602A",
        "\u5C24",
        "\u7434",
        "\u5FAA",
        "\u63CF",
        "\u819C",
        "\u9055",
        "\u593E",
        "\u8170",
        "\u7DE3",
        "\u73E0",
        "\u7AAE",
        "\u68EE",
        "\u679D",
        "\u7AF9",
        "\u6E9D",
        "\u50AC",
        "\u7E69",
        "\u61B6",
        "\u90A6",
        "\u5269",
        "\u5E78",
        "\u6F3F",
        "\u6B04",
        "\u64C1",
        "\u7259",
        "\u8CAF",
        "\u79AE",
        "\u6FFE",
        "\u9209",
        "\u7D0B",
        "\u7F77",
        "\u62CD",
        "\u54B1",
        "\u558A",
        "\u8896",
        "\u57C3",
        "\u52E4",
        "\u7F70",
        "\u7126",
        "\u6F5B",
        "\u4F0D",
        "\u58A8",
        "\u6B32",
        "\u7E2B",
        "\u59D3",
        "\u520A",
        "\u98FD",
        "\u4EFF",
        "\u734E",
        "\u92C1",
        "\u9B3C",
        "\u9E97",
        "\u8DE8",
        "\u9ED8",
        "\u6316",
        "\u93C8",
        "\u6383",
        "\u559D",
        "\u888B",
        "\u70AD",
        "\u6C61",
        "\u5E55",
        "\u8AF8",
        "\u5F27",
        "\u52F5",
        "\u6885",
        "\u5976",
        "\u6F54",
        "\u707D",
        "\u821F",
        "\u9451",
        "\u82EF",
        "\u8A1F",
        "\u62B1",
        "\u6BC0",
        "\u61C2",
        "\u5BD2",
        "\u667A",
        "\u57D4",
        "\u5BC4",
        "\u5C46",
        "\u8E8D",
        "\u6E21",
        "\u6311",
        "\u4E39",
        "\u8271",
        "\u8C9D",
        "\u78B0",
        "\u62D4",
        "\u7239",
        "\u6234",
        "\u78BC",
        "\u5922",
        "\u82BD",
        "\u7194",
        "\u8D64",
        "\u6F01",
        "\u54ED",
        "\u656C",
        "\u9846",
        "\u5954",
        "\u925B",
        "\u4EF2",
        "\u864E",
        "\u7A00",
        "\u59B9",
        "\u4E4F",
        "\u73CD",
        "\u7533",
        "\u684C",
        "\u9075",
        "\u5141",
        "\u9686",
        "\u87BA",
        "\u5009",
        "\u9B4F",
        "\u92B3",
        "\u66C9",
        "\u6C2E",
        "\u517C",
        "\u96B1",
        "\u7919",
        "\u8D6B",
        "\u64A5",
        "\u5FE0",
        "\u8085",
        "\u7F38",
        "\u727D",
        "\u6436",
        "\u535A",
        "\u5DE7",
        "\u6BBC",
        "\u5144",
        "\u675C",
        "\u8A0A",
        "\u8AA0",
        "\u78A7",
        "\u7965",
        "\u67EF",
        "\u9801",
        "\u5DE1",
        "\u77E9",
        "\u60B2",
        "\u704C",
        "\u9F61",
        "\u502B",
        "\u7968",
        "\u5C0B",
        "\u6842",
        "\u92EA",
        "\u8056",
        "\u6050",
        "\u6070",
        "\u912D",
        "\u8DA3",
        "\u62AC",
        "\u8352",
        "\u9A30",
        "\u8CBC",
        "\u67D4",
        "\u6EF4",
        "\u731B",
        "\u95CA",
        "\u8F1B",
        "\u59BB",
        "\u586B",
        "\u64A4",
        "\u5132",
        "\u7C3D",
        "\u9B27",
        "\u64FE",
        "\u7D2B",
        "\u7802",
        "\u905E",
        "\u6232",
        "\u540A",
        "\u9676",
        "\u4F10",
        "\u9935",
        "\u7642",
        "\u74F6",
        "\u5A46",
        "\u64AB",
        "\u81C2",
        "\u6478",
        "\u5FCD",
        "\u8766",
        "\u881F",
        "\u9130",
        "\u80F8",
        "\u978F",
        "\u64E0",
        "\u5076",
        "\u68C4",
        "\u69FD",
        "\u52C1",
        "\u4E73",
        "\u9127",
        "\u5409",
        "\u4EC1",
        "\u721B",
        "\u78DA",
        "\u79DF",
        "\u70CF",
        "\u8266",
        "\u4F34",
        "\u74DC",
        "\u6DFA",
        "\u4E19",
        "\u66AB",
        "\u71E5",
        "\u6A61",
        "\u67F3",
        "\u8FF7",
        "\u6696",
        "\u724C",
        "\u79E7",
        "\u81BD",
        "\u8A73",
        "\u7C27",
        "\u8E0F",
        "\u74F7",
        "\u8B5C",
        "\u5446",
        "\u8CD3",
        "\u7CCA",
        "\u6D1B",
        "\u8F1D",
        "\u61A4",
        "\u7AF6",
        "\u9699",
        "\u6012",
        "\u7C98",
        "\u4E43",
        "\u7DD2",
        "\u80A9",
        "\u7C4D",
        "\u654F",
        "\u5857",
        "\u7199",
        "\u7686",
        "\u5075",
        "\u61F8",
        "\u6398",
        "\u4EAB",
        "\u7CFE",
        "\u9192",
        "\u72C2",
        "\u9396",
        "\u6DC0",
        "\u6068",
        "\u7272",
        "\u9738",
        "\u722C",
        "\u8CDE",
        "\u9006",
        "\u73A9",
        "\u9675",
        "\u795D",
        "\u79D2",
        "\u6D59",
        "\u8C8C",
        "\u5F79",
        "\u5F7C",
        "\u6089",
        "\u9D28",
        "\u8DA8",
        "\u9CF3",
        "\u6668",
        "\u755C",
        "\u8F29",
        "\u79E9",
        "\u5375",
        "\u7F72",
        "\u68AF",
        "\u708E",
        "\u7058",
        "\u68CB",
        "\u9A45",
        "\u7BE9",
        "\u5CFD",
        "\u5192",
        "\u5565",
        "\u58FD",
        "\u8B6F",
        "\u6D78",
        "\u6CC9",
        "\u5E3D",
        "\u9072",
        "\u77FD",
        "\u7586",
        "\u8CB8",
        "\u6F0F",
        "\u7A3F",
        "\u51A0",
        "\u5AE9",
        "\u8105",
        "\u82AF",
        "\u7262",
        "\u53DB",
        "\u8755",
        "\u5967",
        "\u9CF4",
        "\u5DBA",
        "\u7F8A",
        "\u6191",
        "\u4E32",
        "\u5858",
        "\u7E6A",
        "\u9175",
        "\u878D",
        "\u76C6",
        "\u932B",
        "\u5EDF",
        "\u7C4C",
        "\u51CD",
        "\u8F14",
        "\u651D",
        "\u8972",
        "\u7B4B",
        "\u62D2",
        "\u50DA",
        "\u65F1",
        "\u9240",
        "\u9CE5",
        "\u6F06",
        "\u6C88",
        "\u7709",
        "\u758F",
        "\u6DFB",
        "\u68D2",
        "\u7A57",
        "\u785D",
        "\u97D3",
        "\u903C",
        "\u626D",
        "\u50D1",
        "\u6DBC",
        "\u633A",
        "\u7897",
        "\u683D",
        "\u7092",
        "\u676F",
        "\u60A3",
        "\u993E",
        "\u52F8",
        "\u8C6A",
        "\u907C",
        "\u52C3",
        "\u9D3B",
        "\u65E6",
        "\u540F",
        "\u62DC",
        "\u72D7",
        "\u57CB",
        "\u8F25",
        "\u63A9",
        "\u98F2",
        "\u642C",
        "\u7F75",
        "\u8FAD",
        "\u52FE",
        "\u6263",
        "\u4F30",
        "\u8523",
        "\u7D68",
        "\u9727",
        "\u4E08",
        "\u6735",
        "\u59C6",
        "\u64EC",
        "\u5B87",
        "\u8F2F",
        "\u965D",
        "\u96D5",
        "\u511F",
        "\u84C4",
        "\u5D07",
        "\u526A",
        "\u5021",
        "\u5EF3",
        "\u54AC",
        "\u99DB",
        "\u85AF",
        "\u5237",
        "\u65A5",
        "\u756A",
        "\u8CE6",
        "\u5949",
        "\u4F5B",
        "\u6F86",
        "\u6F2B",
        "\u66FC",
        "\u6247",
        "\u9223",
        "\u6843",
        "\u6276",
        "\u4ED4",
        "\u8FD4",
        "\u4FD7",
        "\u8667",
        "\u8154",
        "\u978B",
        "\u68F1",
        "\u8986",
        "\u6846",
        "\u6084",
        "\u53D4",
        "\u649E",
        "\u9A19",
        "\u52D8",
        "\u65FA",
        "\u6CB8",
        "\u5B64",
        "\u5410",
        "\u5B5F",
        "\u6E20",
        "\u5C48",
        "\u75BE",
        "\u5999",
        "\u60DC",
        "\u4EF0",
        "\u72E0",
        "\u8139",
        "\u8AE7",
        "\u62CB",
        "\u9EF4",
        "\u6851",
        "\u5D17",
        "\u561B",
        "\u8870",
        "\u76DC",
        "\u6EF2",
        "\u81DF",
        "\u8CF4",
        "\u6E67",
        "\u751C",
        "\u66F9",
        "\u95B1",
        "\u808C",
        "\u54E9",
        "\u53B2",
        "\u70F4",
        "\u7DEF",
        "\u6BC5",
        "\u6628",
        "\u507D",
        "\u75C7",
        "\u716E",
        "\u5606",
        "\u91D8",
        "\u642D",
        "\u8396",
        "\u7C60",
        "\u9177",
        "\u5077",
        "\u5F13",
        "\u9310",
        "\u6046",
        "\u5091",
        "\u5751",
        "\u9F3B",
        "\u7FFC",
        "\u7DB8",
        "\u6558",
        "\u7344",
        "\u902E",
        "\u7F50",
        "\u7D61",
        "\u68DA",
        "\u6291",
        "\u81A8",
        "\u852C",
        "\u5BFA",
        "\u9A5F",
        "\u7A46",
        "\u51B6",
        "\u67AF",
        "\u518A",
        "\u5C4D",
        "\u51F8",
        "\u7D33",
        "\u576F",
        "\u72A7",
        "\u7130",
        "\u8F5F",
        "\u6B23",
        "\u6649",
        "\u7626",
        "\u79A6",
        "\u9320",
        "\u9326",
        "\u55AA",
        "\u65EC",
        "\u935B",
        "\u58DF",
        "\u641C",
        "\u64B2",
        "\u9080",
        "\u4EAD",
        "\u916F",
        "\u9081",
        "\u8212",
        "\u8106",
        "\u9176",
        "\u9592",
        "\u6182",
        "\u915A",
        "\u9811",
        "\u7FBD",
        "\u6F32",
        "\u5378",
        "\u4ED7",
        "\u966A",
        "\u95E2",
        "\u61F2",
        "\u676D",
        "\u59DA",
        "\u809A",
        "\u6349",
        "\u98C4",
        "\u6F02",
        "\u6606",
        "\u6B3A",
        "\u543E",
        "\u90CE",
        "\u70F7",
        "\u6C41",
        "\u5475",
        "\u98FE",
        "\u856D",
        "\u96C5",
        "\u90F5",
        "\u9077",
        "\u71D5",
        "\u6492",
        "\u59FB",
        "\u8D74",
        "\u5BB4",
        "\u7169",
        "\u50B5",
        "\u5E33",
        "\u6591",
        "\u9234",
        "\u65E8",
        "\u9187",
        "\u8463",
        "\u9905",
        "\u96DB",
        "\u59FF",
        "\u62CC",
        "\u5085",
        "\u8179",
        "\u59A5",
        "\u63C9",
        "\u8CE2",
        "\u62C6",
        "\u6B6A",
        "\u8461",
        "\u80FA",
        "\u4E1F",
        "\u6D69",
        "\u5FBD",
        "\u6602",
        "\u588A",
        "\u64CB",
        "\u89BD",
        "\u8CAA",
        "\u6170",
        "\u7E73",
        "\u6C6A",
        "\u614C",
        "\u99AE",
        "\u8AFE",
        "\u59DC",
        "\u8ABC",
        "\u5147",
        "\u52A3",
        "\u8AA3",
        "\u8000",
        "\u660F",
        "\u8EBA",
        "\u76C8",
        "\u9A0E",
        "\u55AC",
        "\u6EAA",
        "\u53E2",
        "\u76E7",
        "\u62B9",
        "\u60B6",
        "\u8AEE",
        "\u522E",
        "\u99D5",
        "\u7E9C",
        "\u609F",
        "\u6458",
        "\u927A",
        "\u64F2",
        "\u9817",
        "\u5E7B",
        "\u67C4",
        "\u60E0",
        "\u6158",
        "\u4F73",
        "\u4EC7",
        "\u81D8",
        "\u7AA9",
        "\u6ECC",
        "\u528D",
        "\u77A7",
        "\u5821",
        "\u6F51",
        "\u8525",
        "\u7F69",
        "\u970D",
        "\u6488",
        "\u80CE",
        "\u84BC",
        "\u6FF1",
        "\u5006",
        "\u6345",
        "\u6E58",
        "\u780D",
        "\u971E",
        "\u90B5",
        "\u8404",
        "\u760B",
        "\u6DEE",
        "\u9042",
        "\u718A",
        "\u7CDE",
        "\u70D8",
        "\u5BBF",
        "\u6A94",
        "\u6208",
        "\u99C1",
        "\u5AC2",
        "\u88D5",
        "\u5F99",
        "\u7BAD",
        "\u6350",
        "\u8178",
        "\u6490",
        "\u66EC",
        "\u8FA8",
        "\u6BBF",
        "\u84EE",
        "\u6524",
        "\u652A",
        "\u91AC",
        "\u5C4F",
        "\u75AB",
        "\u54C0",
        "\u8521",
        "\u5835",
        "\u6CAB",
        "\u76BA",
        "\u66A2",
        "\u758A",
        "\u95A3",
        "\u840A",
        "\u6572",
        "\u8F44",
        "\u9264",
        "\u75D5",
        "\u58E9",
        "\u5DF7",
        "\u9913",
        "\u798D",
        "\u4E18",
        "\u7384",
        "\u6E9C",
        "\u66F0",
        "\u908F",
        "\u5F6D",
        "\u5617",
        "\u537F",
        "\u59A8",
        "\u8247",
        "\u541E",
        "\u97CB",
        "\u6028",
        "\u77EE",
        "\u6B47"
      ];
    }
  });

  // node_modules/bip39/src/wordlists/korean.json
  var require_korean = __commonJS({
    "node_modules/bip39/src/wordlists/korean.json"(exports9, module) {
      module.exports = [
        "\u1100\u1161\u1100\u1167\u11A8",
        "\u1100\u1161\u1101\u1173\u11B7",
        "\u1100\u1161\u1102\u1161\u11AB",
        "\u1100\u1161\u1102\u1173\u11BC",
        "\u1100\u1161\u1103\u1173\u11A8",
        "\u1100\u1161\u1105\u1173\u110E\u1175\u11B7",
        "\u1100\u1161\u1106\u116E\u11B7",
        "\u1100\u1161\u1107\u1161\u11BC",
        "\u1100\u1161\u1109\u1161\u11BC",
        "\u1100\u1161\u1109\u1173\u11B7",
        "\u1100\u1161\u110B\u116E\u11AB\u1103\u1166",
        "\u1100\u1161\u110B\u1173\u11AF",
        "\u1100\u1161\u110B\u1175\u1103\u1173",
        "\u1100\u1161\u110B\u1175\u11B8",
        "\u1100\u1161\u110C\u1161\u11BC",
        "\u1100\u1161\u110C\u1165\u11BC",
        "\u1100\u1161\u110C\u1169\u11A8",
        "\u1100\u1161\u110C\u116E\u11A8",
        "\u1100\u1161\u11A8\u110B\u1169",
        "\u1100\u1161\u11A8\u110C\u1161",
        "\u1100\u1161\u11AB\u1100\u1167\u11A8",
        "\u1100\u1161\u11AB\u1107\u116E",
        "\u1100\u1161\u11AB\u1109\u1165\u11B8",
        "\u1100\u1161\u11AB\u110C\u1161\u11BC",
        "\u1100\u1161\u11AB\u110C\u1165\u11B8",
        "\u1100\u1161\u11AB\u1111\u1161\u11AB",
        "\u1100\u1161\u11AF\u1103\u1173\u11BC",
        "\u1100\u1161\u11AF\u1107\u1175",
        "\u1100\u1161\u11AF\u1109\u1162\u11A8",
        "\u1100\u1161\u11AF\u110C\u1173\u11BC",
        "\u1100\u1161\u11B7\u1100\u1161\u11A8",
        "\u1100\u1161\u11B7\u1100\u1175",
        "\u1100\u1161\u11B7\u1109\u1169",
        "\u1100\u1161\u11B7\u1109\u116E\u1109\u1165\u11BC",
        "\u1100\u1161\u11B7\u110C\u1161",
        "\u1100\u1161\u11B7\u110C\u1165\u11BC",
        "\u1100\u1161\u11B8\u110C\u1161\u1100\u1175",
        "\u1100\u1161\u11BC\u1102\u1161\u11B7",
        "\u1100\u1161\u11BC\u1103\u1161\u11BC",
        "\u1100\u1161\u11BC\u1103\u1169",
        "\u1100\u1161\u11BC\u1105\u1167\u11A8\u1112\u1175",
        "\u1100\u1161\u11BC\u1107\u1167\u11AB",
        "\u1100\u1161\u11BC\u1107\u116E\u11A8",
        "\u1100\u1161\u11BC\u1109\u1161",
        "\u1100\u1161\u11BC\u1109\u116E\u1105\u1163\u11BC",
        "\u1100\u1161\u11BC\u110B\u1161\u110C\u1175",
        "\u1100\u1161\u11BC\u110B\u116F\u11AB\u1103\u1169",
        "\u1100\u1161\u11BC\u110B\u1174",
        "\u1100\u1161\u11BC\u110C\u1166",
        "\u1100\u1161\u11BC\u110C\u1169",
        "\u1100\u1161\u11C0\u110B\u1175",
        "\u1100\u1162\u1100\u116E\u1105\u1175",
        "\u1100\u1162\u1102\u1161\u1105\u1175",
        "\u1100\u1162\u1107\u1161\u11BC",
        "\u1100\u1162\u1107\u1167\u11AF",
        "\u1100\u1162\u1109\u1165\u11AB",
        "\u1100\u1162\u1109\u1165\u11BC",
        "\u1100\u1162\u110B\u1175\u11AB",
        "\u1100\u1162\u11A8\u1100\u116A\u11AB\u110C\u1165\u11A8",
        "\u1100\u1165\u1109\u1175\u11AF",
        "\u1100\u1165\u110B\u1162\u11A8",
        "\u1100\u1165\u110B\u116E\u11AF",
        "\u1100\u1165\u110C\u1175\u11BA",
        "\u1100\u1165\u1111\u116E\u11B7",
        "\u1100\u1165\u11A8\u110C\u1165\u11BC",
        "\u1100\u1165\u11AB\u1100\u1161\u11BC",
        "\u1100\u1165\u11AB\u1106\u116E\u11AF",
        "\u1100\u1165\u11AB\u1109\u1165\u11AF",
        "\u1100\u1165\u11AB\u110C\u1169",
        "\u1100\u1165\u11AB\u110E\u116E\u11A8",
        "\u1100\u1165\u11AF\u110B\u1173\u11B7",
        "\u1100\u1165\u11B7\u1109\u1161",
        "\u1100\u1165\u11B7\u1110\u1169",
        "\u1100\u1166\u1109\u1175\u1111\u1161\u11AB",
        "\u1100\u1166\u110B\u1175\u11B7",
        "\u1100\u1167\u110B\u116E\u11AF",
        "\u1100\u1167\u11AB\u1112\u1162",
        "\u1100\u1167\u11AF\u1100\u116A",
        "\u1100\u1167\u11AF\u1100\u116E\u11A8",
        "\u1100\u1167\u11AF\u1105\u1169\u11AB",
        "\u1100\u1167\u11AF\u1109\u1165\u11A8",
        "\u1100\u1167\u11AF\u1109\u1173\u11BC",
        "\u1100\u1167\u11AF\u1109\u1175\u11B7",
        "\u1100\u1167\u11AF\u110C\u1165\u11BC",
        "\u1100\u1167\u11AF\u1112\u1169\u11AB",
        "\u1100\u1167\u11BC\u1100\u1168",
        "\u1100\u1167\u11BC\u1100\u1169",
        "\u1100\u1167\u11BC\u1100\u1175",
        "\u1100\u1167\u11BC\u1105\u1167\u11A8",
        "\u1100\u1167\u11BC\u1107\u1169\u11A8\u1100\u116E\u11BC",
        "\u1100\u1167\u11BC\u1107\u1175",
        "\u1100\u1167\u11BC\u1109\u1161\u11BC\u1103\u1169",
        "\u1100\u1167\u11BC\u110B\u1167\u11BC",
        "\u1100\u1167\u11BC\u110B\u116E",
        "\u1100\u1167\u11BC\u110C\u1162\u11BC",
        "\u1100\u1167\u11BC\u110C\u1166",
        "\u1100\u1167\u11BC\u110C\u116E",
        "\u1100\u1167\u11BC\u110E\u1161\u11AF",
        "\u1100\u1167\u11BC\u110E\u1175",
        "\u1100\u1167\u11BC\u1112\u1163\u11BC",
        "\u1100\u1167\u11BC\u1112\u1165\u11B7",
        "\u1100\u1168\u1100\u1169\u11A8",
        "\u1100\u1168\u1103\u1161\u11AB",
        "\u1100\u1168\u1105\u1161\u11AB",
        "\u1100\u1168\u1109\u1161\u11AB",
        "\u1100\u1168\u1109\u1169\u11A8",
        "\u1100\u1168\u110B\u1163\u11A8",
        "\u1100\u1168\u110C\u1165\u11AF",
        "\u1100\u1168\u110E\u1173\u11BC",
        "\u1100\u1168\u1112\u116C\u11A8",
        "\u1100\u1169\u1100\u1162\u11A8",
        "\u1100\u1169\u1100\u116E\u1105\u1167",
        "\u1100\u1169\u1100\u116E\u11BC",
        "\u1100\u1169\u1100\u1173\u11B8",
        "\u1100\u1169\u1103\u1173\u11BC\u1112\u1161\u11A8\u1109\u1162\u11BC",
        "\u1100\u1169\u1106\u116E\u1109\u1175\u11AB",
        "\u1100\u1169\u1106\u1175\u11AB",
        "\u1100\u1169\u110B\u1163\u11BC\u110B\u1175",
        "\u1100\u1169\u110C\u1161\u11BC",
        "\u1100\u1169\u110C\u1165\u11AB",
        "\u1100\u1169\u110C\u1175\u11B8",
        "\u1100\u1169\u110E\u116E\u11BA\u1100\u1161\u1105\u116E",
        "\u1100\u1169\u1110\u1169\u11BC",
        "\u1100\u1169\u1112\u1163\u11BC",
        "\u1100\u1169\u11A8\u1109\u1175\u11A8",
        "\u1100\u1169\u11AF\u1106\u1169\u11A8",
        "\u1100\u1169\u11AF\u110D\u1161\u1100\u1175",
        "\u1100\u1169\u11AF\u1111\u1173",
        "\u1100\u1169\u11BC\u1100\u1161\u11AB",
        "\u1100\u1169\u11BC\u1100\u1162",
        "\u1100\u1169\u11BC\u1100\u1167\u11A8",
        "\u1100\u1169\u11BC\u1100\u116E\u11AB",
        "\u1100\u1169\u11BC\u1100\u1173\u11B8",
        "\u1100\u1169\u11BC\u1100\u1175",
        "\u1100\u1169\u11BC\u1103\u1169\u11BC",
        "\u1100\u1169\u11BC\u1106\u116E\u110B\u116F\u11AB",
        "\u1100\u1169\u11BC\u1107\u116E",
        "\u1100\u1169\u11BC\u1109\u1161",
        "\u1100\u1169\u11BC\u1109\u1175\u11A8",
        "\u1100\u1169\u11BC\u110B\u1165\u11B8",
        "\u1100\u1169\u11BC\u110B\u1167\u11AB",
        "\u1100\u1169\u11BC\u110B\u116F\u11AB",
        "\u1100\u1169\u11BC\u110C\u1161\u11BC",
        "\u1100\u1169\u11BC\u110D\u1161",
        "\u1100\u1169\u11BC\u110E\u1162\u11A8",
        "\u1100\u1169\u11BC\u1110\u1169\u11BC",
        "\u1100\u1169\u11BC\u1111\u1169",
        "\u1100\u1169\u11BC\u1112\u1161\u11BC",
        "\u1100\u1169\u11BC\u1112\u1172\u110B\u1175\u11AF",
        "\u1100\u116A\u1106\u1169\u11A8",
        "\u1100\u116A\u110B\u1175\u11AF",
        "\u1100\u116A\u110C\u1161\u11BC",
        "\u1100\u116A\u110C\u1165\u11BC",
        "\u1100\u116A\u1112\u1161\u11A8",
        "\u1100\u116A\u11AB\u1100\u1162\u11A8",
        "\u1100\u116A\u11AB\u1100\u1168",
        "\u1100\u116A\u11AB\u1100\u116A\u11BC",
        "\u1100\u116A\u11AB\u1102\u1167\u11B7",
        "\u1100\u116A\u11AB\u1105\u1161\u11B7",
        "\u1100\u116A\u11AB\u1105\u1167\u11AB",
        "\u1100\u116A\u11AB\u1105\u1175",
        "\u1100\u116A\u11AB\u1109\u1173\u11B8",
        "\u1100\u116A\u11AB\u1109\u1175\u11B7",
        "\u1100\u116A\u11AB\u110C\u1165\u11B7",
        "\u1100\u116A\u11AB\u110E\u1161\u11AF",
        "\u1100\u116A\u11BC\u1100\u1167\u11BC",
        "\u1100\u116A\u11BC\u1100\u1169",
        "\u1100\u116A\u11BC\u110C\u1161\u11BC",
        "\u1100\u116A\u11BC\u110C\u116E",
        "\u1100\u116C\u1105\u1169\u110B\u116E\u11B7",
        "\u1100\u116C\u11BC\u110C\u1161\u11BC\u1112\u1175",
        "\u1100\u116D\u1100\u116A\u1109\u1165",
        "\u1100\u116D\u1106\u116E\u11AB",
        "\u1100\u116D\u1107\u1169\u11A8",
        "\u1100\u116D\u1109\u1175\u11AF",
        "\u1100\u116D\u110B\u1163\u11BC",
        "\u1100\u116D\u110B\u1172\u11A8",
        "\u1100\u116D\u110C\u1161\u11BC",
        "\u1100\u116D\u110C\u1175\u11A8",
        "\u1100\u116D\u1110\u1169\u11BC",
        "\u1100\u116D\u1112\u116A\u11AB",
        "\u1100\u116D\u1112\u116E\u11AB",
        "\u1100\u116E\u1100\u1167\u11BC",
        "\u1100\u116E\u1105\u1173\u11B7",
        "\u1100\u116E\u1106\u1165\u11BC",
        "\u1100\u116E\u1107\u1167\u11AF",
        "\u1100\u116E\u1107\u116E\u11AB",
        "\u1100\u116E\u1109\u1165\u11A8",
        "\u1100\u116E\u1109\u1165\u11BC",
        "\u1100\u116E\u1109\u1169\u11A8",
        "\u1100\u116E\u110B\u1167\u11A8",
        "\u1100\u116E\u110B\u1175\u11B8",
        "\u1100\u116E\u110E\u1165\u11BC",
        "\u1100\u116E\u110E\u1166\u110C\u1165\u11A8",
        "\u1100\u116E\u11A8\u1100\u1161",
        "\u1100\u116E\u11A8\u1100\u1175",
        "\u1100\u116E\u11A8\u1102\u1162",
        "\u1100\u116E\u11A8\u1105\u1175\u11B8",
        "\u1100\u116E\u11A8\u1106\u116E\u11AF",
        "\u1100\u116E\u11A8\u1106\u1175\u11AB",
        "\u1100\u116E\u11A8\u1109\u116E",
        "\u1100\u116E\u11A8\u110B\u1165",
        "\u1100\u116E\u11A8\u110B\u116A\u11BC",
        "\u1100\u116E\u11A8\u110C\u1165\u11A8",
        "\u1100\u116E\u11A8\u110C\u1166",
        "\u1100\u116E\u11A8\u1112\u116C",
        "\u1100\u116E\u11AB\u1103\u1162",
        "\u1100\u116E\u11AB\u1109\u1161",
        "\u1100\u116E\u11AB\u110B\u1175\u11AB",
        "\u1100\u116E\u11BC\u1100\u1173\u11A8\u110C\u1165\u11A8",
        "\u1100\u116F\u11AB\u1105\u1175",
        "\u1100\u116F\u11AB\u110B\u1171",
        "\u1100\u116F\u11AB\u1110\u116E",
        "\u1100\u1171\u1100\u116E\u11A8",
        "\u1100\u1171\u1109\u1175\u11AB",
        "\u1100\u1172\u110C\u1165\u11BC",
        "\u1100\u1172\u110E\u1175\u11A8",
        "\u1100\u1172\u11AB\u1112\u1167\u11BC",
        "\u1100\u1173\u1102\u1161\u11AF",
        "\u1100\u1173\u1102\u1163\u11BC",
        "\u1100\u1173\u1102\u1173\u11AF",
        "\u1100\u1173\u1105\u1165\u1102\u1161",
        "\u1100\u1173\u1105\u116E\u11B8",
        "\u1100\u1173\u1105\u1173\u11BA",
        "\u1100\u1173\u1105\u1175\u11B7",
        "\u1100\u1173\u110C\u1166\u1109\u1165\u110B\u1163",
        "\u1100\u1173\u1110\u1169\u1105\u1169\u11A8",
        "\u1100\u1173\u11A8\u1107\u1169\u11A8",
        "\u1100\u1173\u11A8\u1112\u1175",
        "\u1100\u1173\u11AB\u1100\u1165",
        "\u1100\u1173\u11AB\u1100\u116D",
        "\u1100\u1173\u11AB\u1105\u1162",
        "\u1100\u1173\u11AB\u1105\u1169",
        "\u1100\u1173\u11AB\u1106\u116E",
        "\u1100\u1173\u11AB\u1107\u1169\u11AB",
        "\u1100\u1173\u11AB\u110B\u116F\u11AB",
        "\u1100\u1173\u11AB\u110B\u1172\u11A8",
        "\u1100\u1173\u11AB\u110E\u1165",
        "\u1100\u1173\u11AF\u110A\u1175",
        "\u1100\u1173\u11AF\u110C\u1161",
        "\u1100\u1173\u11B7\u1100\u1161\u11BC\u1109\u1161\u11AB",
        "\u1100\u1173\u11B7\u1100\u1169",
        "\u1100\u1173\u11B7\u1102\u1167\u11AB",
        "\u1100\u1173\u11B7\u1106\u1166\u1103\u1161\u11AF",
        "\u1100\u1173\u11B7\u110B\u1162\u11A8",
        "\u1100\u1173\u11B7\u110B\u1167\u11AB",
        "\u1100\u1173\u11B7\u110B\u116D\u110B\u1175\u11AF",
        "\u1100\u1173\u11B7\u110C\u1175",
        "\u1100\u1173\u11BC\u110C\u1165\u11BC\u110C\u1165\u11A8",
        "\u1100\u1175\u1100\u1161\u11AB",
        "\u1100\u1175\u1100\u116A\u11AB",
        "\u1100\u1175\u1102\u1167\u11B7",
        "\u1100\u1175\u1102\u1173\u11BC",
        "\u1100\u1175\u1103\u1169\u11A8\u1100\u116D",
        "\u1100\u1175\u1103\u116E\u11BC",
        "\u1100\u1175\u1105\u1169\u11A8",
        "\u1100\u1175\u1105\u1173\u11B7",
        "\u1100\u1175\u1107\u1165\u11B8",
        "\u1100\u1175\u1107\u1169\u11AB",
        "\u1100\u1175\u1107\u116E\u11AB",
        "\u1100\u1175\u1108\u1173\u11B7",
        "\u1100\u1175\u1109\u116E\u11A8\u1109\u1161",
        "\u1100\u1175\u1109\u116E\u11AF",
        "\u1100\u1175\u110B\u1165\u11A8",
        "\u1100\u1175\u110B\u1165\u11B8",
        "\u1100\u1175\u110B\u1169\u11AB",
        "\u1100\u1175\u110B\u116E\u11AB",
        "\u1100\u1175\u110B\u116F\u11AB",
        "\u1100\u1175\u110C\u1165\u11A8",
        "\u1100\u1175\u110C\u116E\u11AB",
        "\u1100\u1175\u110E\u1175\u11B7",
        "\u1100\u1175\u1112\u1169\u11AB",
        "\u1100\u1175\u1112\u116C\u11A8",
        "\u1100\u1175\u11AB\u1100\u1173\u11B8",
        "\u1100\u1175\u11AB\u110C\u1161\u11BC",
        "\u1100\u1175\u11AF\u110B\u1175",
        "\u1100\u1175\u11B7\u1107\u1161\u11B8",
        "\u1100\u1175\u11B7\u110E\u1175",
        "\u1100\u1175\u11B7\u1111\u1169\u1100\u1169\u11BC\u1112\u1161\u11BC",
        "\u1101\u1161\u11A8\u1103\u116E\u1100\u1175",
        "\u1101\u1161\u11B7\u1108\u1161\u11A8",
        "\u1101\u1162\u1103\u1161\u11AF\u110B\u1173\u11B7",
        "\u1101\u1162\u1109\u1169\u1100\u1173\u11B7",
        "\u1101\u1165\u11B8\u110C\u1175\u11AF",
        "\u1101\u1169\u11A8\u1103\u1162\u1100\u1175",
        "\u1101\u1169\u11BE\u110B\u1175\u11C1",
        "\u1102\u1161\u1103\u1173\u11AF\u110B\u1175",
        "\u1102\u1161\u1105\u1161\u11AB\u1112\u1175",
        "\u1102\u1161\u1106\u1165\u110C\u1175",
        "\u1102\u1161\u1106\u116E\u11AF",
        "\u1102\u1161\u110E\u1175\u11B7\u1107\u1161\u11AB",
        "\u1102\u1161\u1112\u1173\u11AF",
        "\u1102\u1161\u11A8\u110B\u1167\u11B8",
        "\u1102\u1161\u11AB\u1107\u1161\u11BC",
        "\u1102\u1161\u11AF\u1100\u1162",
        "\u1102\u1161\u11AF\u110A\u1175",
        "\u1102\u1161\u11AF\u110D\u1161",
        "\u1102\u1161\u11B7\u1102\u1167",
        "\u1102\u1161\u11B7\u1103\u1162\u1106\u116E\u11AB",
        "\u1102\u1161\u11B7\u1106\u1162",
        "\u1102\u1161\u11B7\u1109\u1161\u11AB",
        "\u1102\u1161\u11B7\u110C\u1161",
        "\u1102\u1161\u11B7\u1111\u1167\u11AB",
        "\u1102\u1161\u11B7\u1112\u1161\u11A8\u1109\u1162\u11BC",
        "\u1102\u1161\u11BC\u1107\u1175",
        "\u1102\u1161\u11C0\u1106\u1161\u11AF",
        "\u1102\u1162\u1102\u1167\u11AB",
        "\u1102\u1162\u110B\u116D\u11BC",
        "\u1102\u1162\u110B\u1175\u11AF",
        "\u1102\u1162\u11B7\u1107\u1175",
        "\u1102\u1162\u11B7\u1109\u1162",
        "\u1102\u1162\u11BA\u1106\u116E\u11AF",
        "\u1102\u1162\u11BC\u1103\u1169\u11BC",
        "\u1102\u1162\u11BC\u1106\u1167\u11AB",
        "\u1102\u1162\u11BC\u1107\u1161\u11BC",
        "\u1102\u1162\u11BC\u110C\u1161\u11BC\u1100\u1169",
        "\u1102\u1166\u11A8\u1110\u1161\u110B\u1175",
        "\u1102\u1166\u11BA\u110D\u1162",
        "\u1102\u1169\u1103\u1169\u11BC",
        "\u1102\u1169\u1105\u1161\u11AB\u1109\u1162\u11A8",
        "\u1102\u1169\u1105\u1167\u11A8",
        "\u1102\u1169\u110B\u1175\u11AB",
        "\u1102\u1169\u11A8\u110B\u1173\u11B7",
        "\u1102\u1169\u11A8\u110E\u1161",
        "\u1102\u1169\u11A8\u1112\u116A",
        "\u1102\u1169\u11AB\u1105\u1175",
        "\u1102\u1169\u11AB\u1106\u116E\u11AB",
        "\u1102\u1169\u11AB\u110C\u1162\u11BC",
        "\u1102\u1169\u11AF\u110B\u1175",
        "\u1102\u1169\u11BC\u1100\u116E",
        "\u1102\u1169\u11BC\u1103\u1161\u11B7",
        "\u1102\u1169\u11BC\u1106\u1175\u11AB",
        "\u1102\u1169\u11BC\u1107\u116E",
        "\u1102\u1169\u11BC\u110B\u1165\u11B8",
        "\u1102\u1169\u11BC\u110C\u1161\u11BC",
        "\u1102\u1169\u11BC\u110E\u1169\u11AB",
        "\u1102\u1169\u11C1\u110B\u1175",
        "\u1102\u116E\u11AB\u1103\u1169\u11BC\u110C\u1161",
        "\u1102\u116E\u11AB\u1106\u116E\u11AF",
        "\u1102\u116E\u11AB\u110A\u1165\u11B8",
        "\u1102\u1172\u110B\u116D\u11A8",
        "\u1102\u1173\u1101\u1175\u11B7",
        "\u1102\u1173\u11A8\u1103\u1162",
        "\u1102\u1173\u11BC\u1103\u1169\u11BC\u110C\u1165\u11A8",
        "\u1102\u1173\u11BC\u1105\u1167\u11A8",
        "\u1103\u1161\u1107\u1161\u11BC",
        "\u1103\u1161\u110B\u1163\u11BC\u1109\u1165\u11BC",
        "\u1103\u1161\u110B\u1173\u11B7",
        "\u1103\u1161\u110B\u1175\u110B\u1165\u1110\u1173",
        "\u1103\u1161\u1112\u1162\u11BC",
        "\u1103\u1161\u11AB\u1100\u1168",
        "\u1103\u1161\u11AB\u1100\u1169\u11AF",
        "\u1103\u1161\u11AB\u1103\u1169\u11A8",
        "\u1103\u1161\u11AB\u1106\u1161\u11BA",
        "\u1103\u1161\u11AB\u1109\u116E\u11AB",
        "\u1103\u1161\u11AB\u110B\u1165",
        "\u1103\u1161\u11AB\u110B\u1171",
        "\u1103\u1161\u11AB\u110C\u1165\u11B7",
        "\u1103\u1161\u11AB\u110E\u1166",
        "\u1103\u1161\u11AB\u110E\u116E",
        "\u1103\u1161\u11AB\u1111\u1167\u11AB",
        "\u1103\u1161\u11AB\u1111\u116E\u11BC",
        "\u1103\u1161\u11AF\u1100\u1163\u11AF",
        "\u1103\u1161\u11AF\u1105\u1165",
        "\u1103\u1161\u11AF\u1105\u1167\u11A8",
        "\u1103\u1161\u11AF\u1105\u1175",
        "\u1103\u1161\u11B0\u1100\u1169\u1100\u1175",
        "\u1103\u1161\u11B7\u1103\u1161\u11BC",
        "\u1103\u1161\u11B7\u1107\u1162",
        "\u1103\u1161\u11B7\u110B\u116D",
        "\u1103\u1161\u11B7\u110B\u1175\u11B7",
        "\u1103\u1161\u11B8\u1107\u1167\u11AB",
        "\u1103\u1161\u11B8\u110C\u1161\u11BC",
        "\u1103\u1161\u11BC\u1100\u1173\u11AB",
        "\u1103\u1161\u11BC\u1107\u116E\u11AB\u1100\u1161\u11AB",
        "\u1103\u1161\u11BC\u110B\u1167\u11AB\u1112\u1175",
        "\u1103\u1161\u11BC\u110C\u1161\u11BC",
        "\u1103\u1162\u1100\u1172\u1106\u1169",
        "\u1103\u1162\u1102\u1161\u11BD",
        "\u1103\u1162\u1103\u1161\u11AB\u1112\u1175",
        "\u1103\u1162\u1103\u1161\u11B8",
        "\u1103\u1162\u1103\u1169\u1109\u1175",
        "\u1103\u1162\u1105\u1163\u11A8",
        "\u1103\u1162\u1105\u1163\u11BC",
        "\u1103\u1162\u1105\u1172\u11A8",
        "\u1103\u1162\u1106\u116E\u11AB",
        "\u1103\u1162\u1107\u116E\u1107\u116E\u11AB",
        "\u1103\u1162\u1109\u1175\u11AB",
        "\u1103\u1162\u110B\u1173\u11BC",
        "\u1103\u1162\u110C\u1161\u11BC",
        "\u1103\u1162\u110C\u1165\u11AB",
        "\u1103\u1162\u110C\u1165\u11B8",
        "\u1103\u1162\u110C\u116E\u11BC",
        "\u1103\u1162\u110E\u1162\u11A8",
        "\u1103\u1162\u110E\u116E\u11AF",
        "\u1103\u1162\u110E\u116E\u11BC",
        "\u1103\u1162\u1110\u1169\u11BC\u1105\u1167\u11BC",
        "\u1103\u1162\u1112\u1161\u11A8",
        "\u1103\u1162\u1112\u1161\u11AB\u1106\u1175\u11AB\u1100\u116E\u11A8",
        "\u1103\u1162\u1112\u1161\u11B8\u1109\u1175\u11AF",
        "\u1103\u1162\u1112\u1167\u11BC",
        "\u1103\u1165\u11BC\u110B\u1165\u1105\u1175",
        "\u1103\u1166\u110B\u1175\u1110\u1173",
        "\u1103\u1169\u1103\u1162\u110E\u1166",
        "\u1103\u1169\u1103\u1165\u11A8",
        "\u1103\u1169\u1103\u116E\u11A8",
        "\u1103\u1169\u1106\u1161\u11BC",
        "\u1103\u1169\u1109\u1165\u1100\u116A\u11AB",
        "\u1103\u1169\u1109\u1175\u11B7",
        "\u1103\u1169\u110B\u116E\u11B7",
        "\u1103\u1169\u110B\u1175\u11B8",
        "\u1103\u1169\u110C\u1161\u1100\u1175",
        "\u1103\u1169\u110C\u1165\u1112\u1175",
        "\u1103\u1169\u110C\u1165\u11AB",
        "\u1103\u1169\u110C\u116E\u11BC",
        "\u1103\u1169\u110E\u1161\u11A8",
        "\u1103\u1169\u11A8\u1100\u1161\u11B7",
        "\u1103\u1169\u11A8\u1105\u1175\u11B8",
        "\u1103\u1169\u11A8\u1109\u1165",
        "\u1103\u1169\u11A8\u110B\u1175\u11AF",
        "\u1103\u1169\u11A8\u110E\u1161\u11BC\u110C\u1165\u11A8",
        "\u1103\u1169\u11BC\u1112\u116A\u110E\u1162\u11A8",
        "\u1103\u1171\u11BA\u1106\u1169\u1109\u1173\u11B8",
        "\u1103\u1171\u11BA\u1109\u1161\u11AB",
        "\u1104\u1161\u11AF\u110B\u1161\u110B\u1175",
        "\u1106\u1161\u1102\u116E\u1105\u1161",
        "\u1106\u1161\u1102\u1173\u11AF",
        "\u1106\u1161\u1103\u1161\u11BC",
        "\u1106\u1161\u1105\u1161\u1110\u1169\u11AB",
        "\u1106\u1161\u1105\u1167\u11AB",
        "\u1106\u1161\u1106\u116E\u1105\u1175",
        "\u1106\u1161\u1109\u1161\u110C\u1175",
        "\u1106\u1161\u110B\u1163\u11A8",
        "\u1106\u1161\u110B\u116D\u1102\u1166\u110C\u1173",
        "\u1106\u1161\u110B\u1173\u11AF",
        "\u1106\u1161\u110B\u1173\u11B7",
        "\u1106\u1161\u110B\u1175\u110F\u1173",
        "\u1106\u1161\u110C\u116E\u11BC",
        "\u1106\u1161\u110C\u1175\u1106\u1161\u11A8",
        "\u1106\u1161\u110E\u1161\u11AB\u1100\u1161\u110C\u1175",
        "\u1106\u1161\u110E\u1161\u11AF",
        "\u1106\u1161\u1112\u1173\u11AB",
        "\u1106\u1161\u11A8\u1100\u1165\u11AF\u1105\u1175",
        "\u1106\u1161\u11A8\u1102\u1162",
        "\u1106\u1161\u11A8\u1109\u1161\u11BC",
        "\u1106\u1161\u11AB\u1102\u1161\u11B7",
        "\u1106\u1161\u11AB\u1103\u116E",
        "\u1106\u1161\u11AB\u1109\u1166",
        "\u1106\u1161\u11AB\u110B\u1163\u11A8",
        "\u1106\u1161\u11AB\u110B\u1175\u11AF",
        "\u1106\u1161\u11AB\u110C\u1165\u11B7",
        "\u1106\u1161\u11AB\u110C\u1169\u11A8",
        "\u1106\u1161\u11AB\u1112\u116A",
        "\u1106\u1161\u11AD\u110B\u1175",
        "\u1106\u1161\u11AF\u1100\u1175",
        "\u1106\u1161\u11AF\u110A\u1173\u11B7",
        "\u1106\u1161\u11AF\u1110\u116E",
        "\u1106\u1161\u11B7\u1103\u1162\u1105\u1169",
        "\u1106\u1161\u11BC\u110B\u116F\u11AB\u1100\u1167\u11BC",
        "\u1106\u1162\u1102\u1167\u11AB",
        "\u1106\u1162\u1103\u1161\u11AF",
        "\u1106\u1162\u1105\u1167\u11A8",
        "\u1106\u1162\u1107\u1165\u11AB",
        "\u1106\u1162\u1109\u1173\u110F\u1165\u11B7",
        "\u1106\u1162\u110B\u1175\u11AF",
        "\u1106\u1162\u110C\u1161\u11BC",
        "\u1106\u1162\u11A8\u110C\u116E",
        "\u1106\u1165\u11A8\u110B\u1175",
        "\u1106\u1165\u11AB\u110C\u1165",
        "\u1106\u1165\u11AB\u110C\u1175",
        "\u1106\u1165\u11AF\u1105\u1175",
        "\u1106\u1166\u110B\u1175\u11AF",
        "\u1106\u1167\u1102\u1173\u1105\u1175",
        "\u1106\u1167\u110E\u1175\u11AF",
        "\u1106\u1167\u11AB\u1103\u1161\u11B7",
        "\u1106\u1167\u11AF\u110E\u1175",
        "\u1106\u1167\u11BC\u1103\u1161\u11AB",
        "\u1106\u1167\u11BC\u1105\u1167\u11BC",
        "\u1106\u1167\u11BC\u110B\u1168",
        "\u1106\u1167\u11BC\u110B\u1174",
        "\u1106\u1167\u11BC\u110C\u1165\u11AF",
        "\u1106\u1167\u11BC\u110E\u1175\u11BC",
        "\u1106\u1167\u11BC\u1112\u1161\u11B7",
        "\u1106\u1169\u1100\u1173\u11B7",
        "\u1106\u1169\u1102\u1175\u1110\u1165",
        "\u1106\u1169\u1103\u1166\u11AF",
        "\u1106\u1169\u1103\u1173\u11AB",
        "\u1106\u1169\u1107\u1165\u11B7",
        "\u1106\u1169\u1109\u1173\u11B8",
        "\u1106\u1169\u110B\u1163\u11BC",
        "\u1106\u1169\u110B\u1175\u11B7",
        "\u1106\u1169\u110C\u1169\u1105\u1175",
        "\u1106\u1169\u110C\u1175\u11B8",
        "\u1106\u1169\u1110\u116E\u11BC\u110B\u1175",
        "\u1106\u1169\u11A8\u1100\u1165\u11AF\u110B\u1175",
        "\u1106\u1169\u11A8\u1105\u1169\u11A8",
        "\u1106\u1169\u11A8\u1109\u1161",
        "\u1106\u1169\u11A8\u1109\u1169\u1105\u1175",
        "\u1106\u1169\u11A8\u1109\u116E\u11B7",
        "\u1106\u1169\u11A8\u110C\u1165\u11A8",
        "\u1106\u1169\u11A8\u1111\u116D",
        "\u1106\u1169\u11AF\u1105\u1162",
        "\u1106\u1169\u11B7\u1106\u1162",
        "\u1106\u1169\u11B7\u1106\u116E\u1100\u1166",
        "\u1106\u1169\u11B7\u1109\u1161\u11AF",
        "\u1106\u1169\u11B7\u1109\u1169\u11A8",
        "\u1106\u1169\u11B7\u110C\u1175\u11BA",
        "\u1106\u1169\u11B7\u1110\u1169\u11BC",
        "\u1106\u1169\u11B8\u1109\u1175",
        "\u1106\u116E\u1100\u116A\u11AB\u1109\u1175\u11B7",
        "\u1106\u116E\u1100\u116E\u11BC\u1112\u116A",
        "\u1106\u116E\u1103\u1165\u110B\u1171",
        "\u1106\u116E\u1103\u1165\u11B7",
        "\u1106\u116E\u1105\u1173\u11C1",
        "\u1106\u116E\u1109\u1173\u11AB",
        "\u1106\u116E\u110B\u1165\u11BA",
        "\u1106\u116E\u110B\u1167\u11A8",
        "\u1106\u116E\u110B\u116D\u11BC",
        "\u1106\u116E\u110C\u1169\u1100\u1165\u11AB",
        "\u1106\u116E\u110C\u1175\u1100\u1162",
        "\u1106\u116E\u110E\u1165\u11A8",
        "\u1106\u116E\u11AB\u1100\u116E",
        "\u1106\u116E\u11AB\u1103\u1173\u11A8",
        "\u1106\u116E\u11AB\u1107\u1165\u11B8",
        "\u1106\u116E\u11AB\u1109\u1165",
        "\u1106\u116E\u11AB\u110C\u1166",
        "\u1106\u116E\u11AB\u1112\u1161\u11A8",
        "\u1106\u116E\u11AB\u1112\u116A",
        "\u1106\u116E\u11AF\u1100\u1161",
        "\u1106\u116E\u11AF\u1100\u1165\u11AB",
        "\u1106\u116E\u11AF\u1100\u1167\u11AF",
        "\u1106\u116E\u11AF\u1100\u1169\u1100\u1175",
        "\u1106\u116E\u11AF\u1105\u1169\u11AB",
        "\u1106\u116E\u11AF\u1105\u1175\u1112\u1161\u11A8",
        "\u1106\u116E\u11AF\u110B\u1173\u11B7",
        "\u1106\u116E\u11AF\u110C\u1175\u11AF",
        "\u1106\u116E\u11AF\u110E\u1166",
        "\u1106\u1175\u1100\u116E\u11A8",
        "\u1106\u1175\u1103\u1175\u110B\u1165",
        "\u1106\u1175\u1109\u1161\u110B\u1175\u11AF",
        "\u1106\u1175\u1109\u116E\u11AF",
        "\u1106\u1175\u110B\u1167\u11A8",
        "\u1106\u1175\u110B\u116D\u11BC\u1109\u1175\u11AF",
        "\u1106\u1175\u110B\u116E\u11B7",
        "\u1106\u1175\u110B\u1175\u11AB",
        "\u1106\u1175\u1110\u1175\u11BC",
        "\u1106\u1175\u1112\u1169\u11AB",
        "\u1106\u1175\u11AB\u1100\u1161\u11AB",
        "\u1106\u1175\u11AB\u110C\u1169\u11A8",
        "\u1106\u1175\u11AB\u110C\u116E",
        "\u1106\u1175\u11AE\u110B\u1173\u11B7",
        "\u1106\u1175\u11AF\u1100\u1161\u1105\u116E",
        "\u1106\u1175\u11AF\u1105\u1175\u1106\u1175\u1110\u1165",
        "\u1106\u1175\u11C0\u1107\u1161\u1103\u1161\u11A8",
        "\u1107\u1161\u1100\u1161\u110C\u1175",
        "\u1107\u1161\u1100\u116E\u1102\u1175",
        "\u1107\u1161\u1102\u1161\u1102\u1161",
        "\u1107\u1161\u1102\u1173\u11AF",
        "\u1107\u1161\u1103\u1161\u11A8",
        "\u1107\u1161\u1103\u1161\u11BA\u1100\u1161",
        "\u1107\u1161\u1105\u1161\u11B7",
        "\u1107\u1161\u110B\u1175\u1105\u1165\u1109\u1173",
        "\u1107\u1161\u1110\u1161\u11BC",
        "\u1107\u1161\u11A8\u1106\u116E\u11AF\u1100\u116A\u11AB",
        "\u1107\u1161\u11A8\u1109\u1161",
        "\u1107\u1161\u11A8\u1109\u116E",
        "\u1107\u1161\u11AB\u1103\u1162",
        "\u1107\u1161\u11AB\u1103\u1173\u1109\u1175",
        "\u1107\u1161\u11AB\u1106\u1161\u11AF",
        "\u1107\u1161\u11AB\u1107\u1161\u11AF",
        "\u1107\u1161\u11AB\u1109\u1165\u11BC",
        "\u1107\u1161\u11AB\u110B\u1173\u11BC",
        "\u1107\u1161\u11AB\u110C\u1161\u11BC",
        "\u1107\u1161\u11AB\u110C\u116E\u11A8",
        "\u1107\u1161\u11AB\u110C\u1175",
        "\u1107\u1161\u11AB\u110E\u1161\u11AB",
        "\u1107\u1161\u11AE\u110E\u1175\u11B7",
        "\u1107\u1161\u11AF\u1100\u1161\u1105\u1161\u11A8",
        "\u1107\u1161\u11AF\u1100\u1165\u11AF\u110B\u1173\u11B7",
        "\u1107\u1161\u11AF\u1100\u1167\u11AB",
        "\u1107\u1161\u11AF\u1103\u1161\u11AF",
        "\u1107\u1161\u11AF\u1105\u1166",
        "\u1107\u1161\u11AF\u1106\u1169\u11A8",
        "\u1107\u1161\u11AF\u1107\u1161\u1103\u1161\u11A8",
        "\u1107\u1161\u11AF\u1109\u1162\u11BC",
        "\u1107\u1161\u11AF\u110B\u1173\u11B7",
        "\u1107\u1161\u11AF\u110C\u1161\u1100\u116E\u11A8",
        "\u1107\u1161\u11AF\u110C\u1165\u11AB",
        "\u1107\u1161\u11AF\u1110\u1169\u11B8",
        "\u1107\u1161\u11AF\u1111\u116D",
        "\u1107\u1161\u11B7\u1112\u1161\u1102\u1173\u11AF",
        "\u1107\u1161\u11B8\u1100\u1173\u1105\u1173\u11BA",
        "\u1107\u1161\u11B8\u1106\u1161\u11BA",
        "\u1107\u1161\u11B8\u1109\u1161\u11BC",
        "\u1107\u1161\u11B8\u1109\u1169\u11C0",
        "\u1107\u1161\u11BC\u1100\u1173\u11B7",
        "\u1107\u1161\u11BC\u1106\u1167\u11AB",
        "\u1107\u1161\u11BC\u1106\u116E\u11AB",
        "\u1107\u1161\u11BC\u1107\u1161\u1103\u1161\u11A8",
        "\u1107\u1161\u11BC\u1107\u1165\u11B8",
        "\u1107\u1161\u11BC\u1109\u1169\u11BC",
        "\u1107\u1161\u11BC\u1109\u1175\u11A8",
        "\u1107\u1161\u11BC\u110B\u1161\u11AB",
        "\u1107\u1161\u11BC\u110B\u116E\u11AF",
        "\u1107\u1161\u11BC\u110C\u1175",
        "\u1107\u1161\u11BC\u1112\u1161\u11A8",
        "\u1107\u1161\u11BC\u1112\u1162",
        "\u1107\u1161\u11BC\u1112\u1163\u11BC",
        "\u1107\u1162\u1100\u1167\u11BC",
        "\u1107\u1162\u1101\u1169\u11B8",
        "\u1107\u1162\u1103\u1161\u11AF",
        "\u1107\u1162\u1103\u1173\u1106\u1175\u11AB\u1110\u1165\u11AB",
        "\u1107\u1162\u11A8\u1103\u116E\u1109\u1161\u11AB",
        "\u1107\u1162\u11A8\u1109\u1162\u11A8",
        "\u1107\u1162\u11A8\u1109\u1165\u11BC",
        "\u1107\u1162\u11A8\u110B\u1175\u11AB",
        "\u1107\u1162\u11A8\u110C\u1166",
        "\u1107\u1162\u11A8\u1112\u116A\u110C\u1165\u11B7",
        "\u1107\u1165\u1105\u1173\u11BA",
        "\u1107\u1165\u1109\u1165\u11BA",
        "\u1107\u1165\u1110\u1173\u11AB",
        "\u1107\u1165\u11AB\u1100\u1162",
        "\u1107\u1165\u11AB\u110B\u1167\u11A8",
        "\u1107\u1165\u11AB\u110C\u1175",
        "\u1107\u1165\u11AB\u1112\u1169",
        "\u1107\u1165\u11AF\u1100\u1173\u11B7",
        "\u1107\u1165\u11AF\u1105\u1166",
        "\u1107\u1165\u11AF\u110A\u1165",
        "\u1107\u1165\u11B7\u110B\u1171",
        "\u1107\u1165\u11B7\u110B\u1175\u11AB",
        "\u1107\u1165\u11B7\u110C\u116C",
        "\u1107\u1165\u11B8\u1105\u1172\u11AF",
        "\u1107\u1165\u11B8\u110B\u116F\u11AB",
        "\u1107\u1165\u11B8\u110C\u1165\u11A8",
        "\u1107\u1165\u11B8\u110E\u1175\u11A8",
        "\u1107\u1166\u110B\u1175\u110C\u1175\u11BC",
        "\u1107\u1166\u11AF\u1110\u1173",
        "\u1107\u1167\u11AB\u1100\u1167\u11BC",
        "\u1107\u1167\u11AB\u1103\u1169\u11BC",
        "\u1107\u1167\u11AB\u1106\u1167\u11BC",
        "\u1107\u1167\u11AB\u1109\u1175\u11AB",
        "\u1107\u1167\u11AB\u1112\u1169\u1109\u1161",
        "\u1107\u1167\u11AB\u1112\u116A",
        "\u1107\u1167\u11AF\u1103\u1169",
        "\u1107\u1167\u11AF\u1106\u1167\u11BC",
        "\u1107\u1167\u11AF\u110B\u1175\u11AF",
        "\u1107\u1167\u11BC\u1109\u1175\u11AF",
        "\u1107\u1167\u11BC\u110B\u1161\u1105\u1175",
        "\u1107\u1167\u11BC\u110B\u116F\u11AB",
        "\u1107\u1169\u1100\u116A\u11AB",
        "\u1107\u1169\u1102\u1165\u1109\u1173",
        "\u1107\u1169\u1105\u1161\u1109\u1162\u11A8",
        "\u1107\u1169\u1105\u1161\u11B7",
        "\u1107\u1169\u1105\u1173\u11B7",
        "\u1107\u1169\u1109\u1161\u11BC",
        "\u1107\u1169\u110B\u1161\u11AB",
        "\u1107\u1169\u110C\u1161\u1100\u1175",
        "\u1107\u1169\u110C\u1161\u11BC",
        "\u1107\u1169\u110C\u1165\u11AB",
        "\u1107\u1169\u110C\u1169\u11AB",
        "\u1107\u1169\u1110\u1169\u11BC",
        "\u1107\u1169\u1111\u1167\u11AB\u110C\u1165\u11A8",
        "\u1107\u1169\u1112\u1165\u11B7",
        "\u1107\u1169\u11A8\u1103\u1169",
        "\u1107\u1169\u11A8\u1109\u1161",
        "\u1107\u1169\u11A8\u1109\u116E\u11BC\u110B\u1161",
        "\u1107\u1169\u11A8\u1109\u1173\u11B8",
        "\u1107\u1169\u11A9\u110B\u1173\u11B7",
        "\u1107\u1169\u11AB\u1100\u1167\u11A8\u110C\u1165\u11A8",
        "\u1107\u1169\u11AB\u1105\u1162",
        "\u1107\u1169\u11AB\u1107\u116E",
        "\u1107\u1169\u11AB\u1109\u1161",
        "\u1107\u1169\u11AB\u1109\u1165\u11BC",
        "\u1107\u1169\u11AB\u110B\u1175\u11AB",
        "\u1107\u1169\u11AB\u110C\u1175\u11AF",
        "\u1107\u1169\u11AF\u1111\u1166\u11AB",
        "\u1107\u1169\u11BC\u1109\u1161",
        "\u1107\u1169\u11BC\u110C\u1175",
        "\u1107\u1169\u11BC\u1110\u116E",
        "\u1107\u116E\u1100\u1173\u11AB",
        "\u1107\u116E\u1101\u1173\u1105\u1165\u110B\u116E\u11B7",
        "\u1107\u116E\u1103\u1161\u11B7",
        "\u1107\u116E\u1103\u1169\u11BC\u1109\u1161\u11AB",
        "\u1107\u116E\u1106\u116E\u11AB",
        "\u1107\u116E\u1107\u116E\u11AB",
        "\u1107\u116E\u1109\u1161\u11AB",
        "\u1107\u116E\u1109\u1161\u11BC",
        "\u1107\u116E\u110B\u1165\u11BF",
        "\u1107\u116E\u110B\u1175\u11AB",
        "\u1107\u116E\u110C\u1161\u11A8\u110B\u116D\u11BC",
        "\u1107\u116E\u110C\u1161\u11BC",
        "\u1107\u116E\u110C\u1165\u11BC",
        "\u1107\u116E\u110C\u1169\u11A8",
        "\u1107\u116E\u110C\u1175\u1105\u1165\u11AB\u1112\u1175",
        "\u1107\u116E\u110E\u1175\u11AB",
        "\u1107\u116E\u1110\u1161\u11A8",
        "\u1107\u116E\u1111\u116E\u11B7",
        "\u1107\u116E\u1112\u116C\u110C\u1161\u11BC",
        "\u1107\u116E\u11A8\u1107\u116E",
        "\u1107\u116E\u11A8\u1112\u1161\u11AB",
        "\u1107\u116E\u11AB\u1102\u1169",
        "\u1107\u116E\u11AB\u1105\u1163\u11BC",
        "\u1107\u116E\u11AB\u1105\u1175",
        "\u1107\u116E\u11AB\u1106\u1167\u11BC",
        "\u1107\u116E\u11AB\u1109\u1165\u11A8",
        "\u1107\u116E\u11AB\u110B\u1163",
        "\u1107\u116E\u11AB\u110B\u1171\u1100\u1175",
        "\u1107\u116E\u11AB\u1111\u1175\u11AF",
        "\u1107\u116E\u11AB\u1112\u1169\u11BC\u1109\u1162\u11A8",
        "\u1107\u116E\u11AF\u1100\u1169\u1100\u1175",
        "\u1107\u116E\u11AF\u1100\u116A",
        "\u1107\u116E\u11AF\u1100\u116D",
        "\u1107\u116E\u11AF\u1101\u1169\u11BE",
        "\u1107\u116E\u11AF\u1106\u1161\u11AB",
        "\u1107\u116E\u11AF\u1107\u1165\u11B8",
        "\u1107\u116E\u11AF\u1107\u1175\u11BE",
        "\u1107\u116E\u11AF\u110B\u1161\u11AB",
        "\u1107\u116E\u11AF\u110B\u1175\u110B\u1175\u11A8",
        "\u1107\u116E\u11AF\u1112\u1162\u11BC",
        "\u1107\u1173\u1105\u1162\u11AB\u1103\u1173",
        "\u1107\u1175\u1100\u1173\u11A8",
        "\u1107\u1175\u1102\u1161\u11AB",
        "\u1107\u1175\u1102\u1175\u11AF",
        "\u1107\u1175\u1103\u116E\u11AF\u1100\u1175",
        "\u1107\u1175\u1103\u1175\u110B\u1169",
        "\u1107\u1175\u1105\u1169\u1109\u1169",
        "\u1107\u1175\u1106\u1161\u11AB",
        "\u1107\u1175\u1106\u1167\u11BC",
        "\u1107\u1175\u1106\u1175\u11AF",
        "\u1107\u1175\u1107\u1161\u1105\u1161\u11B7",
        "\u1107\u1175\u1107\u1175\u11B7\u1107\u1161\u11B8",
        "\u1107\u1175\u1109\u1161\u11BC",
        "\u1107\u1175\u110B\u116D\u11BC",
        "\u1107\u1175\u110B\u1172\u11AF",
        "\u1107\u1175\u110C\u116E\u11BC",
        "\u1107\u1175\u1110\u1161\u1106\u1175\u11AB",
        "\u1107\u1175\u1111\u1161\u11AB",
        "\u1107\u1175\u11AF\u1103\u1175\u11BC",
        "\u1107\u1175\u11BA\u1106\u116E\u11AF",
        "\u1107\u1175\u11BA\u1107\u1161\u11BC\u110B\u116E\u11AF",
        "\u1107\u1175\u11BA\u110C\u116E\u11AF\u1100\u1175",
        "\u1107\u1175\u11BE\u1101\u1161\u11AF",
        "\u1108\u1161\u11AF\u1100\u1161\u11AB\u1109\u1162\u11A8",
        "\u1108\u1161\u11AF\u1105\u1162",
        "\u1108\u1161\u11AF\u1105\u1175",
        "\u1109\u1161\u1100\u1165\u11AB",
        "\u1109\u1161\u1100\u1168\u110C\u1165\u11AF",
        "\u1109\u1161\u1102\u1161\u110B\u1175",
        "\u1109\u1161\u1102\u1163\u11BC",
        "\u1109\u1161\u1105\u1161\u11B7",
        "\u1109\u1161\u1105\u1161\u11BC",
        "\u1109\u1161\u1105\u1175\u11B8",
        "\u1109\u1161\u1106\u1169\u1102\u1175\u11B7",
        "\u1109\u1161\u1106\u116E\u11AF",
        "\u1109\u1161\u1107\u1161\u11BC",
        "\u1109\u1161\u1109\u1161\u11BC",
        "\u1109\u1161\u1109\u1162\u11BC\u1112\u116A\u11AF",
        "\u1109\u1161\u1109\u1165\u11AF",
        "\u1109\u1161\u1109\u1173\u11B7",
        "\u1109\u1161\u1109\u1175\u11AF",
        "\u1109\u1161\u110B\u1165\u11B8",
        "\u1109\u1161\u110B\u116D\u11BC",
        "\u1109\u1161\u110B\u116F\u11AF",
        "\u1109\u1161\u110C\u1161\u11BC",
        "\u1109\u1161\u110C\u1165\u11AB",
        "\u1109\u1161\u110C\u1175\u11AB",
        "\u1109\u1161\u110E\u1169\u11AB",
        "\u1109\u1161\u110E\u116E\u11AB\u1100\u1175",
        "\u1109\u1161\u1110\u1161\u11BC",
        "\u1109\u1161\u1110\u116E\u1105\u1175",
        "\u1109\u1161\u1112\u1173\u11AF",
        "\u1109\u1161\u11AB\u1100\u1175\u11AF",
        "\u1109\u1161\u11AB\u1107\u116E\u110B\u1175\u11AB\u1100\u116A",
        "\u1109\u1161\u11AB\u110B\u1165\u11B8",
        "\u1109\u1161\u11AB\u110E\u1162\u11A8",
        "\u1109\u1161\u11AF\u1105\u1175\u11B7",
        "\u1109\u1161\u11AF\u110B\u1175\u11AB",
        "\u1109\u1161\u11AF\u110D\u1161\u11A8",
        "\u1109\u1161\u11B7\u1100\u1168\u1110\u1161\u11BC",
        "\u1109\u1161\u11B7\u1100\u116E\u11A8",
        "\u1109\u1161\u11B7\u1109\u1175\u11B8",
        "\u1109\u1161\u11B7\u110B\u116F\u11AF",
        "\u1109\u1161\u11B7\u110E\u1169\u11AB",
        "\u1109\u1161\u11BC\u1100\u116A\u11AB",
        "\u1109\u1161\u11BC\u1100\u1173\u11B7",
        "\u1109\u1161\u11BC\u1103\u1162",
        "\u1109\u1161\u11BC\u1105\u1172",
        "\u1109\u1161\u11BC\u1107\u1161\u11AB\u1100\u1175",
        "\u1109\u1161\u11BC\u1109\u1161\u11BC",
        "\u1109\u1161\u11BC\u1109\u1175\u11A8",
        "\u1109\u1161\u11BC\u110B\u1165\u11B8",
        "\u1109\u1161\u11BC\u110B\u1175\u11AB",
        "\u1109\u1161\u11BC\u110C\u1161",
        "\u1109\u1161\u11BC\u110C\u1165\u11B7",
        "\u1109\u1161\u11BC\u110E\u1165",
        "\u1109\u1161\u11BC\u110E\u116E",
        "\u1109\u1161\u11BC\u1110\u1162",
        "\u1109\u1161\u11BC\u1111\u116D",
        "\u1109\u1161\u11BC\u1111\u116E\u11B7",
        "\u1109\u1161\u11BC\u1112\u116A\u11BC",
        "\u1109\u1162\u1107\u1167\u11A8",
        "\u1109\u1162\u11A8\u1101\u1161\u11AF",
        "\u1109\u1162\u11A8\u110B\u1167\u11AB\u1111\u1175\u11AF",
        "\u1109\u1162\u11BC\u1100\u1161\u11A8",
        "\u1109\u1162\u11BC\u1106\u1167\u11BC",
        "\u1109\u1162\u11BC\u1106\u116E\u11AF",
        "\u1109\u1162\u11BC\u1107\u1161\u11BC\u1109\u1169\u11BC",
        "\u1109\u1162\u11BC\u1109\u1161\u11AB",
        "\u1109\u1162\u11BC\u1109\u1165\u11AB",
        "\u1109\u1162\u11BC\u1109\u1175\u11AB",
        "\u1109\u1162\u11BC\u110B\u1175\u11AF",
        "\u1109\u1162\u11BC\u1112\u116A\u11AF",
        "\u1109\u1165\u1105\u1161\u11B8",
        "\u1109\u1165\u1105\u1173\u11AB",
        "\u1109\u1165\u1106\u1167\u11BC",
        "\u1109\u1165\u1106\u1175\u11AB",
        "\u1109\u1165\u1107\u1175\u1109\u1173",
        "\u1109\u1165\u110B\u1163\u11BC",
        "\u1109\u1165\u110B\u116E\u11AF",
        "\u1109\u1165\u110C\u1165\u11A8",
        "\u1109\u1165\u110C\u1165\u11B7",
        "\u1109\u1165\u110D\u1169\u11A8",
        "\u1109\u1165\u110F\u1173\u11AF",
        "\u1109\u1165\u11A8\u1109\u1161",
        "\u1109\u1165\u11A8\u110B\u1172",
        "\u1109\u1165\u11AB\u1100\u1165",
        "\u1109\u1165\u11AB\u1106\u116E\u11AF",
        "\u1109\u1165\u11AB\u1107\u1162",
        "\u1109\u1165\u11AB\u1109\u1162\u11BC",
        "\u1109\u1165\u11AB\u1109\u116E",
        "\u1109\u1165\u11AB\u110B\u116F\u11AB",
        "\u1109\u1165\u11AB\u110C\u1161\u11BC",
        "\u1109\u1165\u11AB\u110C\u1165\u11AB",
        "\u1109\u1165\u11AB\u1110\u1162\u11A8",
        "\u1109\u1165\u11AB\u1111\u116E\u11BC\u1100\u1175",
        "\u1109\u1165\u11AF\u1100\u1165\u110C\u1175",
        "\u1109\u1165\u11AF\u1102\u1161\u11AF",
        "\u1109\u1165\u11AF\u1105\u1165\u11BC\u1110\u1161\u11BC",
        "\u1109\u1165\u11AF\u1106\u1167\u11BC",
        "\u1109\u1165\u11AF\u1106\u116E\u11AB",
        "\u1109\u1165\u11AF\u1109\u1161",
        "\u1109\u1165\u11AF\u110B\u1161\u11A8\u1109\u1161\u11AB",
        "\u1109\u1165\u11AF\u110E\u1175",
        "\u1109\u1165\u11AF\u1110\u1161\u11BC",
        "\u1109\u1165\u11B8\u110A\u1175",
        "\u1109\u1165\u11BC\u1100\u1169\u11BC",
        "\u1109\u1165\u11BC\u1103\u1161\u11BC",
        "\u1109\u1165\u11BC\u1106\u1167\u11BC",
        "\u1109\u1165\u11BC\u1107\u1167\u11AF",
        "\u1109\u1165\u11BC\u110B\u1175\u11AB",
        "\u1109\u1165\u11BC\u110C\u1161\u11BC",
        "\u1109\u1165\u11BC\u110C\u1165\u11A8",
        "\u1109\u1165\u11BC\u110C\u1175\u11AF",
        "\u1109\u1165\u11BC\u1112\u1161\u11B7",
        "\u1109\u1166\u1100\u1173\u11B7",
        "\u1109\u1166\u1106\u1175\u1102\u1161",
        "\u1109\u1166\u1109\u1161\u11BC",
        "\u1109\u1166\u110B\u116F\u11AF",
        "\u1109\u1166\u110C\u1169\u11BC\u1103\u1162\u110B\u116A\u11BC",
        "\u1109\u1166\u1110\u1161\u11A8",
        "\u1109\u1166\u11AB\u1110\u1165",
        "\u1109\u1166\u11AB\u1110\u1175\u1106\u1175\u1110\u1165",
        "\u1109\u1166\u11BA\u110D\u1162",
        "\u1109\u1169\u1100\u1172\u1106\u1169",
        "\u1109\u1169\u1100\u1173\u11A8\u110C\u1165\u11A8",
        "\u1109\u1169\u1100\u1173\u11B7",
        "\u1109\u1169\u1102\u1161\u1100\u1175",
        "\u1109\u1169\u1102\u1167\u11AB",
        "\u1109\u1169\u1103\u1173\u11A8",
        "\u1109\u1169\u1106\u1161\u11BC",
        "\u1109\u1169\u1106\u116E\u11AB",
        "\u1109\u1169\u1109\u1165\u11AF",
        "\u1109\u1169\u1109\u1169\u11A8",
        "\u1109\u1169\u110B\u1161\u1100\u116A",
        "\u1109\u1169\u110B\u116D\u11BC",
        "\u1109\u1169\u110B\u116F\u11AB",
        "\u1109\u1169\u110B\u1173\u11B7",
        "\u1109\u1169\u110C\u116E\u11BC\u1112\u1175",
        "\u1109\u1169\u110C\u1175\u1111\u116E\u11B7",
        "\u1109\u1169\u110C\u1175\u11AF",
        "\u1109\u1169\u1111\u116E\u11BC",
        "\u1109\u1169\u1112\u1167\u11BC",
        "\u1109\u1169\u11A8\u1103\u1161\u11B7",
        "\u1109\u1169\u11A8\u1103\u1169",
        "\u1109\u1169\u11A8\u110B\u1169\u11BA",
        "\u1109\u1169\u11AB\u1100\u1161\u1105\u1161\u11A8",
        "\u1109\u1169\u11AB\u1100\u1175\u11AF",
        "\u1109\u1169\u11AB\u1102\u1167",
        "\u1109\u1169\u11AB\u1102\u1175\u11B7",
        "\u1109\u1169\u11AB\u1103\u1173\u11BC",
        "\u1109\u1169\u11AB\u1106\u1169\u11A8",
        "\u1109\u1169\u11AB\u1108\u1167\u11A8",
        "\u1109\u1169\u11AB\u1109\u1175\u11AF",
        "\u1109\u1169\u11AB\u110C\u1175\u11AF",
        "\u1109\u1169\u11AB\u1110\u1169\u11B8",
        "\u1109\u1169\u11AB\u1112\u1162",
        "\u1109\u1169\u11AF\u110C\u1175\u11A8\u1112\u1175",
        "\u1109\u1169\u11B7\u110A\u1175",
        "\u1109\u1169\u11BC\u110B\u1161\u110C\u1175",
        "\u1109\u1169\u11BC\u110B\u1175",
        "\u1109\u1169\u11BC\u1111\u1167\u11AB",
        "\u1109\u116C\u1100\u1169\u1100\u1175",
        "\u1109\u116D\u1111\u1175\u11BC",
        "\u1109\u116E\u1100\u1165\u11AB",
        "\u1109\u116E\u1102\u1167\u11AB",
        "\u1109\u116E\u1103\u1161\u11AB",
        "\u1109\u116E\u1103\u1169\u11BA\u1106\u116E\u11AF",
        "\u1109\u116E\u1103\u1169\u11BC\u110C\u1165\u11A8",
        "\u1109\u116E\u1106\u1167\u11AB",
        "\u1109\u116E\u1106\u1167\u11BC",
        "\u1109\u116E\u1107\u1161\u11A8",
        "\u1109\u116E\u1109\u1161\u11BC",
        "\u1109\u116E\u1109\u1165\u11A8",
        "\u1109\u116E\u1109\u116E\u11AF",
        "\u1109\u116E\u1109\u1175\u1105\u1169",
        "\u1109\u116E\u110B\u1165\u11B8",
        "\u1109\u116E\u110B\u1167\u11B7",
        "\u1109\u116E\u110B\u1167\u11BC",
        "\u1109\u116E\u110B\u1175\u11B8",
        "\u1109\u116E\u110C\u116E\u11AB",
        "\u1109\u116E\u110C\u1175\u11B8",
        "\u1109\u116E\u110E\u116E\u11AF",
        "\u1109\u116E\u110F\u1165\u11BA",
        "\u1109\u116E\u1111\u1175\u11AF",
        "\u1109\u116E\u1112\u1161\u11A8",
        "\u1109\u116E\u1112\u1165\u11B7\u1109\u1162\u11BC",
        "\u1109\u116E\u1112\u116A\u1100\u1175",
        "\u1109\u116E\u11A8\u1102\u1167",
        "\u1109\u116E\u11A8\u1109\u1169",
        "\u1109\u116E\u11A8\u110C\u1166",
        "\u1109\u116E\u11AB\u1100\u1161\u11AB",
        "\u1109\u116E\u11AB\u1109\u1165",
        "\u1109\u116E\u11AB\u1109\u116E",
        "\u1109\u116E\u11AB\u1109\u1175\u11A8\u1100\u1161\u11AB",
        "\u1109\u116E\u11AB\u110B\u1171",
        "\u1109\u116E\u11AE\u1100\u1161\u1105\u1161\u11A8",
        "\u1109\u116E\u11AF\u1107\u1167\u11BC",
        "\u1109\u116E\u11AF\u110C\u1175\u11B8",
        "\u1109\u116E\u11BA\u110C\u1161",
        "\u1109\u1173\u1102\u1175\u11B7",
        "\u1109\u1173\u1106\u116E\u11AF",
        "\u1109\u1173\u1109\u1173\u1105\u1169",
        "\u1109\u1173\u1109\u1173\u11BC",
        "\u1109\u1173\u110B\u1170\u1110\u1165",
        "\u1109\u1173\u110B\u1171\u110E\u1175",
        "\u1109\u1173\u110F\u1166\u110B\u1175\u1110\u1173",
        "\u1109\u1173\u1110\u1172\u1103\u1175\u110B\u1169",
        "\u1109\u1173\u1110\u1173\u1105\u1166\u1109\u1173",
        "\u1109\u1173\u1111\u1169\u110E\u1173",
        "\u1109\u1173\u11AF\u110D\u1165\u11A8",
        "\u1109\u1173\u11AF\u1111\u1173\u11B7",
        "\u1109\u1173\u11B8\u1100\u116A\u11AB",
        "\u1109\u1173\u11B8\u1100\u1175",
        "\u1109\u1173\u11BC\u1100\u1162\u11A8",
        "\u1109\u1173\u11BC\u1105\u1175",
        "\u1109\u1173\u11BC\u1107\u116E",
        "\u1109\u1173\u11BC\u110B\u116D\u11BC\u110E\u1161",
        "\u1109\u1173\u11BC\u110C\u1175\u11AB",
        "\u1109\u1175\u1100\u1161\u11A8",
        "\u1109\u1175\u1100\u1161\u11AB",
        "\u1109\u1175\u1100\u1169\u11AF",
        "\u1109\u1175\u1100\u1173\u11B7\u110E\u1175",
        "\u1109\u1175\u1102\u1161\u1105\u1175\u110B\u1169",
        "\u1109\u1175\u1103\u1162\u11A8",
        "\u1109\u1175\u1105\u1175\u110C\u1173",
        "\u1109\u1175\u1106\u1166\u11AB\u1110\u1173",
        "\u1109\u1175\u1106\u1175\u11AB",
        "\u1109\u1175\u1107\u116E\u1106\u1169",
        "\u1109\u1175\u1109\u1165\u11AB",
        "\u1109\u1175\u1109\u1165\u11AF",
        "\u1109\u1175\u1109\u1173\u1110\u1166\u11B7",
        "\u1109\u1175\u110B\u1161\u1107\u1165\u110C\u1175",
        "\u1109\u1175\u110B\u1165\u1106\u1165\u1102\u1175",
        "\u1109\u1175\u110B\u116F\u11AF",
        "\u1109\u1175\u110B\u1175\u11AB",
        "\u1109\u1175\u110B\u1175\u11AF",
        "\u1109\u1175\u110C\u1161\u11A8",
        "\u1109\u1175\u110C\u1161\u11BC",
        "\u1109\u1175\u110C\u1165\u11AF",
        "\u1109\u1175\u110C\u1165\u11B7",
        "\u1109\u1175\u110C\u116E\u11BC",
        "\u1109\u1175\u110C\u1173\u11AB",
        "\u1109\u1175\u110C\u1175\u11B8",
        "\u1109\u1175\u110E\u1165\u11BC",
        "\u1109\u1175\u1112\u1161\u11B8",
        "\u1109\u1175\u1112\u1165\u11B7",
        "\u1109\u1175\u11A8\u1100\u116E",
        "\u1109\u1175\u11A8\u1100\u1175",
        "\u1109\u1175\u11A8\u1103\u1161\u11BC",
        "\u1109\u1175\u11A8\u1105\u1163\u11BC",
        "\u1109\u1175\u11A8\u1105\u116D\u1111\u116E\u11B7",
        "\u1109\u1175\u11A8\u1106\u116E\u11AF",
        "\u1109\u1175\u11A8\u1108\u1161\u11BC",
        "\u1109\u1175\u11A8\u1109\u1161",
        "\u1109\u1175\u11A8\u1109\u1162\u11BC\u1112\u116A\u11AF",
        "\u1109\u1175\u11A8\u110E\u1169",
        "\u1109\u1175\u11A8\u1110\u1161\u11A8",
        "\u1109\u1175\u11A8\u1111\u116E\u11B7",
        "\u1109\u1175\u11AB\u1100\u1169",
        "\u1109\u1175\u11AB\u1100\u1172",
        "\u1109\u1175\u11AB\u1102\u1167\u11B7",
        "\u1109\u1175\u11AB\u1106\u116E\u11AB",
        "\u1109\u1175\u11AB\u1107\u1161\u11AF",
        "\u1109\u1175\u11AB\u1107\u1175",
        "\u1109\u1175\u11AB\u1109\u1161",
        "\u1109\u1175\u11AB\u1109\u1166",
        "\u1109\u1175\u11AB\u110B\u116D\u11BC",
        "\u1109\u1175\u11AB\u110C\u1166\u1111\u116E\u11B7",
        "\u1109\u1175\u11AB\u110E\u1165\u11BC",
        "\u1109\u1175\u11AB\u110E\u1166",
        "\u1109\u1175\u11AB\u1112\u116A",
        "\u1109\u1175\u11AF\u1100\u1161\u11B7",
        "\u1109\u1175\u11AF\u1102\u1162",
        "\u1109\u1175\u11AF\u1105\u1167\u11A8",
        "\u1109\u1175\u11AF\u1105\u1168",
        "\u1109\u1175\u11AF\u1106\u1161\u11BC",
        "\u1109\u1175\u11AF\u1109\u116E",
        "\u1109\u1175\u11AF\u1109\u1173\u11B8",
        "\u1109\u1175\u11AF\u1109\u1175",
        "\u1109\u1175\u11AF\u110C\u1161\u11BC",
        "\u1109\u1175\u11AF\u110C\u1165\u11BC",
        "\u1109\u1175\u11AF\u110C\u1175\u11AF\u110C\u1165\u11A8",
        "\u1109\u1175\u11AF\u110E\u1165\u11AB",
        "\u1109\u1175\u11AF\u110E\u1166",
        "\u1109\u1175\u11AF\u110F\u1165\u11BA",
        "\u1109\u1175\u11AF\u1110\u1162",
        "\u1109\u1175\u11AF\u1111\u1162",
        "\u1109\u1175\u11AF\u1112\u1165\u11B7",
        "\u1109\u1175\u11AF\u1112\u1167\u11AB",
        "\u1109\u1175\u11B7\u1105\u1175",
        "\u1109\u1175\u11B7\u1107\u116E\u1105\u1173\u11B7",
        "\u1109\u1175\u11B7\u1109\u1161",
        "\u1109\u1175\u11B7\u110C\u1161\u11BC",
        "\u1109\u1175\u11B7\u110C\u1165\u11BC",
        "\u1109\u1175\u11B7\u1111\u1161\u11AB",
        "\u110A\u1161\u11BC\u1103\u116E\u11BC\u110B\u1175",
        "\u110A\u1175\u1105\u1173\u11B7",
        "\u110A\u1175\u110B\u1161\u11BA",
        "\u110B\u1161\u1100\u1161\u110A\u1175",
        "\u110B\u1161\u1102\u1161\u110B\u116E\u11AB\u1109\u1165",
        "\u110B\u1161\u1103\u1173\u1102\u1175\u11B7",
        "\u110B\u1161\u1103\u1173\u11AF",
        "\u110B\u1161\u1109\u1171\u110B\u116E\u11B7",
        "\u110B\u1161\u1109\u1173\u1111\u1161\u11AF\u1110\u1173",
        "\u110B\u1161\u1109\u1175\u110B\u1161",
        "\u110B\u1161\u110B\u116E\u11AF\u1105\u1165",
        "\u110B\u1161\u110C\u1165\u110A\u1175",
        "\u110B\u1161\u110C\u116E\u11B7\u1106\u1161",
        "\u110B\u1161\u110C\u1175\u11A8",
        "\u110B\u1161\u110E\u1175\u11B7",
        "\u110B\u1161\u1111\u1161\u1110\u1173",
        "\u110B\u1161\u1111\u1173\u1105\u1175\u110F\u1161",
        "\u110B\u1161\u1111\u1173\u11B7",
        "\u110B\u1161\u1112\u1169\u11B8",
        "\u110B\u1161\u1112\u1173\u11AB",
        "\u110B\u1161\u11A8\u1100\u1175",
        "\u110B\u1161\u11A8\u1106\u1169\u11BC",
        "\u110B\u1161\u11A8\u1109\u116E",
        "\u110B\u1161\u11AB\u1100\u1162",
        "\u110B\u1161\u11AB\u1100\u1167\u11BC",
        "\u110B\u1161\u11AB\u1100\u116A",
        "\u110B\u1161\u11AB\u1102\u1162",
        "\u110B\u1161\u11AB\u1102\u1167\u11BC",
        "\u110B\u1161\u11AB\u1103\u1169\u11BC",
        "\u110B\u1161\u11AB\u1107\u1161\u11BC",
        "\u110B\u1161\u11AB\u1107\u116E",
        "\u110B\u1161\u11AB\u110C\u116E",
        "\u110B\u1161\u11AF\u1105\u116E\u1106\u1175\u1102\u1172\u11B7",
        "\u110B\u1161\u11AF\u110F\u1169\u110B\u1169\u11AF",
        "\u110B\u1161\u11B7\u1109\u1175",
        "\u110B\u1161\u11B7\u110F\u1165\u11BA",
        "\u110B\u1161\u11B8\u1105\u1167\u11A8",
        "\u110B\u1161\u11C1\u1102\u1161\u11AF",
        "\u110B\u1161\u11C1\u1106\u116E\u11AB",
        "\u110B\u1162\u110B\u1175\u11AB",
        "\u110B\u1162\u110C\u1165\u11BC",
        "\u110B\u1162\u11A8\u1109\u116E",
        "\u110B\u1162\u11AF\u1107\u1165\u11B7",
        "\u110B\u1163\u1100\u1161\u11AB",
        "\u110B\u1163\u1103\u1161\u11AB",
        "\u110B\u1163\u110B\u1169\u11BC",
        "\u110B\u1163\u11A8\u1100\u1161\u11AB",
        "\u110B\u1163\u11A8\u1100\u116E\u11A8",
        "\u110B\u1163\u11A8\u1109\u1169\u11A8",
        "\u110B\u1163\u11A8\u1109\u116E",
        "\u110B\u1163\u11A8\u110C\u1165\u11B7",
        "\u110B\u1163\u11A8\u1111\u116E\u11B7",
        "\u110B\u1163\u11A8\u1112\u1169\u11AB\u1102\u1167",
        "\u110B\u1163\u11BC\u1102\u1167\u11B7",
        "\u110B\u1163\u11BC\u1105\u1167\u11A8",
        "\u110B\u1163\u11BC\u1106\u1161\u11AF",
        "\u110B\u1163\u11BC\u1107\u1162\u110E\u116E",
        "\u110B\u1163\u11BC\u110C\u116E",
        "\u110B\u1163\u11BC\u1111\u1161",
        "\u110B\u1165\u1103\u116E\u11B7",
        "\u110B\u1165\u1105\u1167\u110B\u116E\u11B7",
        "\u110B\u1165\u1105\u1173\u11AB",
        "\u110B\u1165\u110C\u1166\u11BA\u1107\u1161\u11B7",
        "\u110B\u1165\u110D\u1162\u11BB\u1103\u1173\u11AB",
        "\u110B\u1165\u110D\u1165\u1103\u1161\u1100\u1161",
        "\u110B\u1165\u110D\u1165\u11AB\u110C\u1175",
        "\u110B\u1165\u11AB\u1102\u1175",
        "\u110B\u1165\u11AB\u1103\u1165\u11A8",
        "\u110B\u1165\u11AB\u1105\u1169\u11AB",
        "\u110B\u1165\u11AB\u110B\u1165",
        "\u110B\u1165\u11AF\u1100\u116E\u11AF",
        "\u110B\u1165\u11AF\u1105\u1173\u11AB",
        "\u110B\u1165\u11AF\u110B\u1173\u11B7",
        "\u110B\u1165\u11AF\u1111\u1175\u11BA",
        "\u110B\u1165\u11B7\u1106\u1161",
        "\u110B\u1165\u11B8\u1106\u116E",
        "\u110B\u1165\u11B8\u110C\u1169\u11BC",
        "\u110B\u1165\u11B8\u110E\u1166",
        "\u110B\u1165\u11BC\u1103\u1165\u11BC\u110B\u1175",
        "\u110B\u1165\u11BC\u1106\u1161\u11BC",
        "\u110B\u1165\u11BC\u1110\u1165\u1105\u1175",
        "\u110B\u1165\u11BD\u1100\u1173\u110C\u1166",
        "\u110B\u1166\u1102\u1165\u110C\u1175",
        "\u110B\u1166\u110B\u1165\u110F\u1165\u11AB",
        "\u110B\u1166\u11AB\u110C\u1175\u11AB",
        "\u110B\u1167\u1100\u1165\u11AB",
        "\u110B\u1167\u1100\u1169\u1109\u1162\u11BC",
        "\u110B\u1167\u1100\u116A\u11AB",
        "\u110B\u1167\u1100\u116E\u11AB",
        "\u110B\u1167\u1100\u116F\u11AB",
        "\u110B\u1167\u1103\u1162\u1109\u1162\u11BC",
        "\u110B\u1167\u1103\u1165\u11B2",
        "\u110B\u1167\u1103\u1169\u11BC\u1109\u1162\u11BC",
        "\u110B\u1167\u1103\u1173\u11AB",
        "\u110B\u1167\u1105\u1169\u11AB",
        "\u110B\u1167\u1105\u1173\u11B7",
        "\u110B\u1167\u1109\u1165\u11BA",
        "\u110B\u1167\u1109\u1165\u11BC",
        "\u110B\u1167\u110B\u116A\u11BC",
        "\u110B\u1167\u110B\u1175\u11AB",
        "\u110B\u1167\u110C\u1165\u11AB\u1112\u1175",
        "\u110B\u1167\u110C\u1175\u11A8\u110B\u116F\u11AB",
        "\u110B\u1167\u1112\u1161\u11A8\u1109\u1162\u11BC",
        "\u110B\u1167\u1112\u1162\u11BC",
        "\u110B\u1167\u11A8\u1109\u1161",
        "\u110B\u1167\u11A8\u1109\u1175",
        "\u110B\u1167\u11A8\u1112\u1161\u11AF",
        "\u110B\u1167\u11AB\u1100\u1167\u11AF",
        "\u110B\u1167\u11AB\u1100\u116E",
        "\u110B\u1167\u11AB\u1100\u1173\u11A8",
        "\u110B\u1167\u11AB\u1100\u1175",
        "\u110B\u1167\u11AB\u1105\u1161\u11A8",
        "\u110B\u1167\u11AB\u1109\u1165\u11AF",
        "\u110B\u1167\u11AB\u1109\u1166",
        "\u110B\u1167\u11AB\u1109\u1169\u11A8",
        "\u110B\u1167\u11AB\u1109\u1173\u11B8",
        "\u110B\u1167\u11AB\u110B\u1162",
        "\u110B\u1167\u11AB\u110B\u1168\u110B\u1175\u11AB",
        "\u110B\u1167\u11AB\u110B\u1175\u11AB",
        "\u110B\u1167\u11AB\u110C\u1161\u11BC",
        "\u110B\u1167\u11AB\u110C\u116E",
        "\u110B\u1167\u11AB\u110E\u116E\u11AF",
        "\u110B\u1167\u11AB\u1111\u1175\u11AF",
        "\u110B\u1167\u11AB\u1112\u1161\u11B8",
        "\u110B\u1167\u11AB\u1112\u1172",
        "\u110B\u1167\u11AF\u1100\u1175",
        "\u110B\u1167\u11AF\u1106\u1162",
        "\u110B\u1167\u11AF\u1109\u116C",
        "\u110B\u1167\u11AF\u1109\u1175\u11B7\u1112\u1175",
        "\u110B\u1167\u11AF\u110C\u1165\u11BC",
        "\u110B\u1167\u11AF\u110E\u1161",
        "\u110B\u1167\u11AF\u1112\u1173\u11AF",
        "\u110B\u1167\u11B7\u1105\u1167",
        "\u110B\u1167\u11B8\u1109\u1165",
        "\u110B\u1167\u11BC\u1100\u116E\u11A8",
        "\u110B\u1167\u11BC\u1102\u1161\u11B7",
        "\u110B\u1167\u11BC\u1109\u1161\u11BC",
        "\u110B\u1167\u11BC\u110B\u1163\u11BC",
        "\u110B\u1167\u11BC\u110B\u1167\u11A8",
        "\u110B\u1167\u11BC\u110B\u116E\u11BC",
        "\u110B\u1167\u11BC\u110B\u116F\u11AB\u1112\u1175",
        "\u110B\u1167\u11BC\u1112\u1161",
        "\u110B\u1167\u11BC\u1112\u1163\u11BC",
        "\u110B\u1167\u11BC\u1112\u1169\u11AB",
        "\u110B\u1167\u11BC\u1112\u116A",
        "\u110B\u1167\u11C1\u1100\u116E\u1105\u1175",
        "\u110B\u1167\u11C1\u1107\u1161\u11BC",
        "\u110B\u1167\u11C1\u110C\u1175\u11B8",
        "\u110B\u1168\u1100\u1161\u11B7",
        "\u110B\u1168\u1100\u1173\u11B7",
        "\u110B\u1168\u1107\u1161\u11BC",
        "\u110B\u1168\u1109\u1161\u11AB",
        "\u110B\u1168\u1109\u1161\u11BC",
        "\u110B\u1168\u1109\u1165\u11AB",
        "\u110B\u1168\u1109\u116E\u11AF",
        "\u110B\u1168\u1109\u1173\u11B8",
        "\u110B\u1168\u1109\u1175\u11A8\u110C\u1161\u11BC",
        "\u110B\u1168\u110B\u1163\u11A8",
        "\u110B\u1168\u110C\u1165\u11AB",
        "\u110B\u1168\u110C\u1165\u11AF",
        "\u110B\u1168\u110C\u1165\u11BC",
        "\u110B\u1168\u110F\u1165\u11AB\u1103\u1162",
        "\u110B\u1168\u11BA\u1102\u1161\u11AF",
        "\u110B\u1169\u1102\u1173\u11AF",
        "\u110B\u1169\u1105\u1161\u11A8",
        "\u110B\u1169\u1105\u1162\u11BA\u1103\u1169\u11BC\u110B\u1161\u11AB",
        "\u110B\u1169\u1105\u1166\u11AB\u110C\u1175",
        "\u110B\u1169\u1105\u1169\u110C\u1175",
        "\u110B\u1169\u1105\u1173\u11AB\u1107\u1161\u11AF",
        "\u110B\u1169\u1107\u1173\u11AB",
        "\u110B\u1169\u1109\u1175\u11B8",
        "\u110B\u1169\u110B\u1167\u11B7",
        "\u110B\u1169\u110B\u116F\u11AF",
        "\u110B\u1169\u110C\u1165\u11AB",
        "\u110B\u1169\u110C\u1175\u11A8",
        "\u110B\u1169\u110C\u1175\u11BC\u110B\u1165",
        "\u110B\u1169\u1111\u1166\u1105\u1161",
        "\u110B\u1169\u1111\u1175\u1109\u1173\u1110\u1166\u11AF",
        "\u110B\u1169\u1112\u1175\u1105\u1167",
        "\u110B\u1169\u11A8\u1109\u1161\u11BC",
        "\u110B\u1169\u11A8\u1109\u116E\u1109\u116E",
        "\u110B\u1169\u11AB\u1100\u1161\u11BD",
        "\u110B\u1169\u11AB\u1105\u1161\u110B\u1175\u11AB",
        "\u110B\u1169\u11AB\u1106\u1169\u11B7",
        "\u110B\u1169\u11AB\u110C\u1169\u11BC\u110B\u1175\u11AF",
        "\u110B\u1169\u11AB\u1110\u1169\u11BC",
        "\u110B\u1169\u11AF\u1100\u1161\u110B\u1173\u11AF",
        "\u110B\u1169\u11AF\u1105\u1175\u11B7\u1111\u1175\u11A8",
        "\u110B\u1169\u11AF\u1112\u1162",
        "\u110B\u1169\u11BA\u110E\u1161\u1105\u1175\u11B7",
        "\u110B\u116A\u110B\u1175\u1109\u1167\u110E\u1173",
        "\u110B\u116A\u110B\u1175\u11AB",
        "\u110B\u116A\u11AB\u1109\u1165\u11BC",
        "\u110B\u116A\u11AB\u110C\u1165\u11AB",
        "\u110B\u116A\u11BC\u1107\u1175",
        "\u110B\u116A\u11BC\u110C\u1161",
        "\u110B\u116B\u1102\u1163\u1112\u1161\u1106\u1167\u11AB",
        "\u110B\u116B\u11AB\u110C\u1175",
        "\u110B\u116C\u1100\u1161\u11BA\u110C\u1175\u11B8",
        "\u110B\u116C\u1100\u116E\u11A8",
        "\u110B\u116C\u1105\u1169\u110B\u116E\u11B7",
        "\u110B\u116C\u1109\u1161\u11B7\u110E\u1169\u11AB",
        "\u110B\u116C\u110E\u116E\u11AF",
        "\u110B\u116C\u110E\u1175\u11B7",
        "\u110B\u116C\u1112\u1161\u11AF\u1106\u1165\u1102\u1175",
        "\u110B\u116C\u11AB\u1107\u1161\u11AF",
        "\u110B\u116C\u11AB\u1109\u1169\u11AB",
        "\u110B\u116C\u11AB\u110D\u1169\u11A8",
        "\u110B\u116D\u1100\u1173\u11B7",
        "\u110B\u116D\u110B\u1175\u11AF",
        "\u110B\u116D\u110C\u1173\u11B7",
        "\u110B\u116D\u110E\u1165\u11BC",
        "\u110B\u116D\u11BC\u1100\u1175",
        "\u110B\u116D\u11BC\u1109\u1165",
        "\u110B\u116D\u11BC\u110B\u1165",
        "\u110B\u116E\u1109\u1161\u11AB",
        "\u110B\u116E\u1109\u1165\u11AB",
        "\u110B\u116E\u1109\u1173\u11BC",
        "\u110B\u116E\u110B\u1167\u11AB\u1112\u1175",
        "\u110B\u116E\u110C\u1165\u11BC",
        "\u110B\u116E\u110E\u1166\u1100\u116E\u11A8",
        "\u110B\u116E\u1111\u1167\u11AB",
        "\u110B\u116E\u11AB\u1103\u1169\u11BC",
        "\u110B\u116E\u11AB\u1106\u1167\u11BC",
        "\u110B\u116E\u11AB\u1107\u1161\u11AB",
        "\u110B\u116E\u11AB\u110C\u1165\u11AB",
        "\u110B\u116E\u11AB\u1112\u1162\u11BC",
        "\u110B\u116E\u11AF\u1109\u1161\u11AB",
        "\u110B\u116E\u11AF\u110B\u1173\u11B7",
        "\u110B\u116E\u11B7\u110C\u1175\u11A8\u110B\u1175\u11B7",
        "\u110B\u116E\u11BA\u110B\u1165\u1105\u1173\u11AB",
        "\u110B\u116E\u11BA\u110B\u1173\u11B7",
        "\u110B\u116F\u1102\u1161\u11A8",
        "\u110B\u116F\u11AB\u1100\u1169",
        "\u110B\u116F\u11AB\u1105\u1162",
        "\u110B\u116F\u11AB\u1109\u1165",
        "\u110B\u116F\u11AB\u1109\u116E\u11BC\u110B\u1175",
        "\u110B\u116F\u11AB\u110B\u1175\u11AB",
        "\u110B\u116F\u11AB\u110C\u1161\u11BC",
        "\u110B\u116F\u11AB\u1111\u1175\u1109\u1173",
        "\u110B\u116F\u11AF\u1100\u1173\u11B8",
        "\u110B\u116F\u11AF\u1103\u1173\u110F\u1165\u11B8",
        "\u110B\u116F\u11AF\u1109\u1166",
        "\u110B\u116F\u11AF\u110B\u116D\u110B\u1175\u11AF",
        "\u110B\u1170\u110B\u1175\u1110\u1165",
        "\u110B\u1171\u1107\u1161\u11AB",
        "\u110B\u1171\u1107\u1165\u11B8",
        "\u110B\u1171\u1109\u1165\u11BC",
        "\u110B\u1171\u110B\u116F\u11AB",
        "\u110B\u1171\u1112\u1165\u11B7",
        "\u110B\u1171\u1112\u1167\u11B8",
        "\u110B\u1171\u11BA\u1109\u1161\u1105\u1161\u11B7",
        "\u110B\u1172\u1102\u1161\u11AB\u1112\u1175",
        "\u110B\u1172\u1105\u1165\u11B8",
        "\u110B\u1172\u1106\u1167\u11BC",
        "\u110B\u1172\u1106\u116E\u11AF",
        "\u110B\u1172\u1109\u1161\u11AB",
        "\u110B\u1172\u110C\u1165\u11A8",
        "\u110B\u1172\u110E\u1175\u110B\u116F\u11AB",
        "\u110B\u1172\u1112\u1161\u11A8",
        "\u110B\u1172\u1112\u1162\u11BC",
        "\u110B\u1172\u1112\u1167\u11BC",
        "\u110B\u1172\u11A8\u1100\u116E\u11AB",
        "\u110B\u1172\u11A8\u1109\u1161\u11BC",
        "\u110B\u1172\u11A8\u1109\u1175\u11B8",
        "\u110B\u1172\u11A8\u110E\u1166",
        "\u110B\u1173\u11AB\u1112\u1162\u11BC",
        "\u110B\u1173\u11B7\u1105\u1167\u11A8",
        "\u110B\u1173\u11B7\u1105\u116D",
        "\u110B\u1173\u11B7\u1107\u1161\u11AB",
        "\u110B\u1173\u11B7\u1109\u1165\u11BC",
        "\u110B\u1173\u11B7\u1109\u1175\u11A8",
        "\u110B\u1173\u11B7\u110B\u1161\u11A8",
        "\u110B\u1173\u11B7\u110C\u116E",
        "\u110B\u1174\u1100\u1167\u11AB",
        "\u110B\u1174\u1102\u1169\u11AB",
        "\u110B\u1174\u1106\u116E\u11AB",
        "\u110B\u1174\u1107\u1169\u11A8",
        "\u110B\u1174\u1109\u1175\u11A8",
        "\u110B\u1174\u1109\u1175\u11B7",
        "\u110B\u1174\u110B\u116C\u1105\u1169",
        "\u110B\u1174\u110B\u116D\u11A8",
        "\u110B\u1174\u110B\u116F\u11AB",
        "\u110B\u1174\u1112\u1161\u11A8",
        "\u110B\u1175\u1100\u1165\u11BA",
        "\u110B\u1175\u1100\u1169\u11BA",
        "\u110B\u1175\u1102\u1167\u11B7",
        "\u110B\u1175\u1102\u1169\u11B7",
        "\u110B\u1175\u1103\u1161\u11AF",
        "\u110B\u1175\u1103\u1162\u1105\u1169",
        "\u110B\u1175\u1103\u1169\u11BC",
        "\u110B\u1175\u1105\u1165\u11C2\u1100\u1166",
        "\u110B\u1175\u1105\u1167\u11A8\u1109\u1165",
        "\u110B\u1175\u1105\u1169\u11AB\u110C\u1165\u11A8",
        "\u110B\u1175\u1105\u1173\u11B7",
        "\u110B\u1175\u1106\u1175\u11AB",
        "\u110B\u1175\u1107\u1161\u11AF\u1109\u1169",
        "\u110B\u1175\u1107\u1167\u11AF",
        "\u110B\u1175\u1107\u116E\u11AF",
        "\u110B\u1175\u1108\u1161\u11AF",
        "\u110B\u1175\u1109\u1161\u11BC",
        "\u110B\u1175\u1109\u1165\u11BC",
        "\u110B\u1175\u1109\u1173\u11AF",
        "\u110B\u1175\u110B\u1163\u1100\u1175",
        "\u110B\u1175\u110B\u116D\u11BC",
        "\u110B\u1175\u110B\u116E\u11BA",
        "\u110B\u1175\u110B\u116F\u11AF",
        "\u110B\u1175\u110B\u1173\u11A8\u1100\u1169",
        "\u110B\u1175\u110B\u1175\u11A8",
        "\u110B\u1175\u110C\u1165\u11AB",
        "\u110B\u1175\u110C\u116E\u11BC",
        "\u110B\u1175\u1110\u1173\u11AE\u1102\u1161\u11AF",
        "\u110B\u1175\u1110\u1173\u11AF",
        "\u110B\u1175\u1112\u1169\u11AB",
        "\u110B\u1175\u11AB\u1100\u1161\u11AB",
        "\u110B\u1175\u11AB\u1100\u1167\u11A8",
        "\u110B\u1175\u11AB\u1100\u1169\u11BC",
        "\u110B\u1175\u11AB\u1100\u116E",
        "\u110B\u1175\u11AB\u1100\u1173\u11AB",
        "\u110B\u1175\u11AB\u1100\u1175",
        "\u110B\u1175\u11AB\u1103\u1169",
        "\u110B\u1175\u11AB\u1105\u1172",
        "\u110B\u1175\u11AB\u1106\u116E\u11AF",
        "\u110B\u1175\u11AB\u1109\u1162\u11BC",
        "\u110B\u1175\u11AB\u1109\u116B",
        "\u110B\u1175\u11AB\u110B\u1167\u11AB",
        "\u110B\u1175\u11AB\u110B\u116F\u11AB",
        "\u110B\u1175\u11AB\u110C\u1162",
        "\u110B\u1175\u11AB\u110C\u1169\u11BC",
        "\u110B\u1175\u11AB\u110E\u1165\u11AB",
        "\u110B\u1175\u11AB\u110E\u1166",
        "\u110B\u1175\u11AB\u1110\u1165\u1102\u1166\u11BA",
        "\u110B\u1175\u11AB\u1112\u1161",
        "\u110B\u1175\u11AB\u1112\u1167\u11BC",
        "\u110B\u1175\u11AF\u1100\u1169\u11B8",
        "\u110B\u1175\u11AF\u1100\u1175",
        "\u110B\u1175\u11AF\u1103\u1161\u11AB",
        "\u110B\u1175\u11AF\u1103\u1162",
        "\u110B\u1175\u11AF\u1103\u1173\u11BC",
        "\u110B\u1175\u11AF\u1107\u1161\u11AB",
        "\u110B\u1175\u11AF\u1107\u1169\u11AB",
        "\u110B\u1175\u11AF\u1107\u116E",
        "\u110B\u1175\u11AF\u1109\u1161\u11BC",
        "\u110B\u1175\u11AF\u1109\u1162\u11BC",
        "\u110B\u1175\u11AF\u1109\u1169\u11AB",
        "\u110B\u1175\u11AF\u110B\u116D\u110B\u1175\u11AF",
        "\u110B\u1175\u11AF\u110B\u116F\u11AF",
        "\u110B\u1175\u11AF\u110C\u1165\u11BC",
        "\u110B\u1175\u11AF\u110C\u1169\u11BC",
        "\u110B\u1175\u11AF\u110C\u116E\u110B\u1175\u11AF",
        "\u110B\u1175\u11AF\u110D\u1175\u11A8",
        "\u110B\u1175\u11AF\u110E\u1166",
        "\u110B\u1175\u11AF\u110E\u1175",
        "\u110B\u1175\u11AF\u1112\u1162\u11BC",
        "\u110B\u1175\u11AF\u1112\u116C\u110B\u116D\u11BC",
        "\u110B\u1175\u11B7\u1100\u1173\u11B7",
        "\u110B\u1175\u11B7\u1106\u116E",
        "\u110B\u1175\u11B8\u1103\u1162",
        "\u110B\u1175\u11B8\u1105\u1167\u11A8",
        "\u110B\u1175\u11B8\u1106\u1161\u11BA",
        "\u110B\u1175\u11B8\u1109\u1161",
        "\u110B\u1175\u11B8\u1109\u116E\u11AF",
        "\u110B\u1175\u11B8\u1109\u1175",
        "\u110B\u1175\u11B8\u110B\u116F\u11AB",
        "\u110B\u1175\u11B8\u110C\u1161\u11BC",
        "\u110B\u1175\u11B8\u1112\u1161\u11A8",
        "\u110C\u1161\u1100\u1161\u110B\u116D\u11BC",
        "\u110C\u1161\u1100\u1167\u11A8",
        "\u110C\u1161\u1100\u1173\u11A8",
        "\u110C\u1161\u1103\u1169\u11BC",
        "\u110C\u1161\u1105\u1161\u11BC",
        "\u110C\u1161\u1107\u116E\u1109\u1175\u11B7",
        "\u110C\u1161\u1109\u1175\u11A8",
        "\u110C\u1161\u1109\u1175\u11AB",
        "\u110C\u1161\u110B\u1167\u11AB",
        "\u110C\u1161\u110B\u116F\u11AB",
        "\u110C\u1161\u110B\u1172\u11AF",
        "\u110C\u1161\u110C\u1165\u11AB\u1100\u1165",
        "\u110C\u1161\u110C\u1165\u11BC",
        "\u110C\u1161\u110C\u1169\u11AB\u1109\u1175\u11B7",
        "\u110C\u1161\u1111\u1161\u11AB",
        "\u110C\u1161\u11A8\u1100\u1161",
        "\u110C\u1161\u11A8\u1102\u1167\u11AB",
        "\u110C\u1161\u11A8\u1109\u1165\u11BC",
        "\u110C\u1161\u11A8\u110B\u1165\u11B8",
        "\u110C\u1161\u11A8\u110B\u116D\u11BC",
        "\u110C\u1161\u11A8\u110B\u1173\u11AB\u1104\u1161\u11AF",
        "\u110C\u1161\u11A8\u1111\u116E\u11B7",
        "\u110C\u1161\u11AB\u1103\u1175",
        "\u110C\u1161\u11AB\u1104\u1173\u11A8",
        "\u110C\u1161\u11AB\u110E\u1175",
        "\u110C\u1161\u11AF\u1106\u1169\u11BA",
        "\u110C\u1161\u11B7\u1101\u1161\u11AB",
        "\u110C\u1161\u11B7\u1109\u116E\u1112\u1161\u11B7",
        "\u110C\u1161\u11B7\u1109\u1175",
        "\u110C\u1161\u11B7\u110B\u1169\u11BA",
        "\u110C\u1161\u11B7\u110C\u1161\u1105\u1175",
        "\u110C\u1161\u11B8\u110C\u1175",
        "\u110C\u1161\u11BC\u1100\u116A\u11AB",
        "\u110C\u1161\u11BC\u1100\u116E\u11AB",
        "\u110C\u1161\u11BC\u1100\u1175\u1100\u1161\u11AB",
        "\u110C\u1161\u11BC\u1105\u1162",
        "\u110C\u1161\u11BC\u1105\u1168",
        "\u110C\u1161\u11BC\u1105\u1173",
        "\u110C\u1161\u11BC\u1106\u1161",
        "\u110C\u1161\u11BC\u1106\u1167\u11AB",
        "\u110C\u1161\u11BC\u1106\u1169",
        "\u110C\u1161\u11BC\u1106\u1175",
        "\u110C\u1161\u11BC\u1107\u1175",
        "\u110C\u1161\u11BC\u1109\u1161",
        "\u110C\u1161\u11BC\u1109\u1169",
        "\u110C\u1161\u11BC\u1109\u1175\u11A8",
        "\u110C\u1161\u11BC\u110B\u1162\u110B\u1175\u11AB",
        "\u110C\u1161\u11BC\u110B\u1175\u11AB",
        "\u110C\u1161\u11BC\u110C\u1165\u11B7",
        "\u110C\u1161\u11BC\u110E\u1161",
        "\u110C\u1161\u11BC\u1112\u1161\u11A8\u1100\u1173\u11B7",
        "\u110C\u1162\u1102\u1173\u11BC",
        "\u110C\u1162\u1108\u1161\u11AF\u1105\u1175",
        "\u110C\u1162\u1109\u1161\u11AB",
        "\u110C\u1162\u1109\u1162\u11BC",
        "\u110C\u1162\u110C\u1161\u11A8\u1102\u1167\u11AB",
        "\u110C\u1162\u110C\u1165\u11BC",
        "\u110C\u1162\u110E\u1162\u1100\u1175",
        "\u110C\u1162\u1111\u1161\u11AB",
        "\u110C\u1162\u1112\u1161\u11A8",
        "\u110C\u1162\u1112\u116A\u11AF\u110B\u116D\u11BC",
        "\u110C\u1165\u1100\u1165\u11BA",
        "\u110C\u1165\u1100\u1169\u1105\u1175",
        "\u110C\u1165\u1100\u1169\u11BA",
        "\u110C\u1165\u1102\u1167\u11A8",
        "\u110C\u1165\u1105\u1165\u11AB",
        "\u110C\u1165\u1105\u1165\u11C2\u1100\u1166",
        "\u110C\u1165\u1107\u1165\u11AB",
        "\u110C\u1165\u110B\u116E\u11AF",
        "\u110C\u1165\u110C\u1165\u11AF\u1105\u1169",
        "\u110C\u1165\u110E\u116E\u11A8",
        "\u110C\u1165\u11A8\u1100\u1173\u11A8",
        "\u110C\u1165\u11A8\u1103\u1161\u11BC\u1112\u1175",
        "\u110C\u1165\u11A8\u1109\u1165\u11BC",
        "\u110C\u1165\u11A8\u110B\u116D\u11BC",
        "\u110C\u1165\u11A8\u110B\u1173\u11BC",
        "\u110C\u1165\u11AB\u1100\u1162",
        "\u110C\u1165\u11AB\u1100\u1169\u11BC",
        "\u110C\u1165\u11AB\u1100\u1175",
        "\u110C\u1165\u11AB\u1103\u1161\u11AF",
        "\u110C\u1165\u11AB\u1105\u1161\u1103\u1169",
        "\u110C\u1165\u11AB\u1106\u1161\u11BC",
        "\u110C\u1165\u11AB\u1106\u116E\u11AB",
        "\u110C\u1165\u11AB\u1107\u1161\u11AB",
        "\u110C\u1165\u11AB\u1107\u116E",
        "\u110C\u1165\u11AB\u1109\u1166",
        "\u110C\u1165\u11AB\u1109\u1175",
        "\u110C\u1165\u11AB\u110B\u116D\u11BC",
        "\u110C\u1165\u11AB\u110C\u1161",
        "\u110C\u1165\u11AB\u110C\u1162\u11BC",
        "\u110C\u1165\u11AB\u110C\u116E",
        "\u110C\u1165\u11AB\u110E\u1165\u11AF",
        "\u110C\u1165\u11AB\u110E\u1166",
        "\u110C\u1165\u11AB\u1110\u1169\u11BC",
        "\u110C\u1165\u11AB\u1112\u1167",
        "\u110C\u1165\u11AB\u1112\u116E",
        "\u110C\u1165\u11AF\u1103\u1162",
        "\u110C\u1165\u11AF\u1106\u1161\u11BC",
        "\u110C\u1165\u11AF\u1107\u1161\u11AB",
        "\u110C\u1165\u11AF\u110B\u1163\u11A8",
        "\u110C\u1165\u11AF\u110E\u1161",
        "\u110C\u1165\u11B7\u1100\u1165\u11B7",
        "\u110C\u1165\u11B7\u1109\u116E",
        "\u110C\u1165\u11B7\u1109\u1175\u11B7",
        "\u110C\u1165\u11B7\u110B\u116F\u11AB",
        "\u110C\u1165\u11B7\u110C\u1165\u11B7",
        "\u110C\u1165\u11B7\u110E\u1161",
        "\u110C\u1165\u11B8\u1100\u1173\u11AB",
        "\u110C\u1165\u11B8\u1109\u1175",
        "\u110C\u1165\u11B8\u110E\u1169\u11A8",
        "\u110C\u1165\u11BA\u1100\u1161\u1105\u1161\u11A8",
        "\u110C\u1165\u11BC\u1100\u1165\u110C\u1161\u11BC",
        "\u110C\u1165\u11BC\u1103\u1169",
        "\u110C\u1165\u11BC\u1105\u1172\u110C\u1161\u11BC",
        "\u110C\u1165\u11BC\u1105\u1175",
        "\u110C\u1165\u11BC\u1106\u1161\u11AF",
        "\u110C\u1165\u11BC\u1106\u1167\u11AB",
        "\u110C\u1165\u11BC\u1106\u116E\u11AB",
        "\u110C\u1165\u11BC\u1107\u1161\u11AB\u1103\u1162",
        "\u110C\u1165\u11BC\u1107\u1169",
        "\u110C\u1165\u11BC\u1107\u116E",
        "\u110C\u1165\u11BC\u1107\u1175",
        "\u110C\u1165\u11BC\u1109\u1161\u11BC",
        "\u110C\u1165\u11BC\u1109\u1165\u11BC",
        "\u110C\u1165\u11BC\u110B\u1169",
        "\u110C\u1165\u11BC\u110B\u116F\u11AB",
        "\u110C\u1165\u11BC\u110C\u1161\u11BC",
        "\u110C\u1165\u11BC\u110C\u1175",
        "\u110C\u1165\u11BC\u110E\u1175",
        "\u110C\u1165\u11BC\u1112\u116A\u11A8\u1112\u1175",
        "\u110C\u1166\u1100\u1169\u11BC",
        "\u110C\u1166\u1100\u116A\u110C\u1165\u11B7",
        "\u110C\u1166\u1103\u1162\u1105\u1169",
        "\u110C\u1166\u1106\u1169\u11A8",
        "\u110C\u1166\u1107\u1161\u11AF",
        "\u110C\u1166\u1107\u1165\u11B8",
        "\u110C\u1166\u1109\u1161\u11BA\u1102\u1161\u11AF",
        "\u110C\u1166\u110B\u1161\u11AB",
        "\u110C\u1166\u110B\u1175\u11AF",
        "\u110C\u1166\u110C\u1161\u11A8",
        "\u110C\u1166\u110C\u116E\u1103\u1169",
        "\u110C\u1166\u110E\u116E\u11AF",
        "\u110C\u1166\u1111\u116E\u11B7",
        "\u110C\u1166\u1112\u1161\u11AB",
        "\u110C\u1169\u1100\u1161\u11A8",
        "\u110C\u1169\u1100\u1165\u11AB",
        "\u110C\u1169\u1100\u1173\u11B7",
        "\u110C\u1169\u1100\u1175\u11BC",
        "\u110C\u1169\u1106\u1167\u11BC",
        "\u110C\u1169\u1106\u1175\u1105\u116D",
        "\u110C\u1169\u1109\u1161\u11BC",
        "\u110C\u1169\u1109\u1165\u11AB",
        "\u110C\u1169\u110B\u116D\u11BC\u1112\u1175",
        "\u110C\u1169\u110C\u1165\u11AF",
        "\u110C\u1169\u110C\u1165\u11BC",
        "\u110C\u1169\u110C\u1175\u11A8",
        "\u110C\u1169\u11AB\u1103\u1162\u11BA\u1106\u1161\u11AF",
        "\u110C\u1169\u11AB\u110C\u1162",
        "\u110C\u1169\u11AF\u110B\u1165\u11B8",
        "\u110C\u1169\u11AF\u110B\u1173\u11B7",
        "\u110C\u1169\u11BC\u1100\u116D",
        "\u110C\u1169\u11BC\u1105\u1169",
        "\u110C\u1169\u11BC\u1105\u1172",
        "\u110C\u1169\u11BC\u1109\u1169\u1105\u1175",
        "\u110C\u1169\u11BC\u110B\u1165\u11B8\u110B\u116F\u11AB",
        "\u110C\u1169\u11BC\u110C\u1169\u11BC",
        "\u110C\u1169\u11BC\u1112\u1161\u11B8",
        "\u110C\u116A\u1109\u1165\u11A8",
        "\u110C\u116C\u110B\u1175\u11AB",
        "\u110C\u116E\u1100\u116A\u11AB\u110C\u1165\u11A8",
        "\u110C\u116E\u1105\u1173\u11B7",
        "\u110C\u116E\u1106\u1161\u11AF",
        "\u110C\u116E\u1106\u1165\u1102\u1175",
        "\u110C\u116E\u1106\u1165\u11A8",
        "\u110C\u116E\u1106\u116E\u11AB",
        "\u110C\u116E\u1106\u1175\u11AB",
        "\u110C\u116E\u1107\u1161\u11BC",
        "\u110C\u116E\u1107\u1167\u11AB",
        "\u110C\u116E\u1109\u1175\u11A8",
        "\u110C\u116E\u110B\u1175\u11AB",
        "\u110C\u116E\u110B\u1175\u11AF",
        "\u110C\u116E\u110C\u1161\u11BC",
        "\u110C\u116E\u110C\u1165\u11AB\u110C\u1161",
        "\u110C\u116E\u1110\u1162\u11A8",
        "\u110C\u116E\u11AB\u1107\u1175",
        "\u110C\u116E\u11AF\u1100\u1165\u1105\u1175",
        "\u110C\u116E\u11AF\u1100\u1175",
        "\u110C\u116E\u11AF\u1106\u116E\u1102\u1174",
        "\u110C\u116E\u11BC\u1100\u1161\u11AB",
        "\u110C\u116E\u11BC\u1100\u1168\u1107\u1161\u11BC\u1109\u1169\u11BC",
        "\u110C\u116E\u11BC\u1100\u116E\u11A8",
        "\u110C\u116E\u11BC\u1102\u1167\u11AB",
        "\u110C\u116E\u11BC\u1103\u1161\u11AB",
        "\u110C\u116E\u11BC\u1103\u1169\u11A8",
        "\u110C\u116E\u11BC\u1107\u1161\u11AB",
        "\u110C\u116E\u11BC\u1107\u116E",
        "\u110C\u116E\u11BC\u1109\u1166",
        "\u110C\u116E\u11BC\u1109\u1169\u1100\u1175\u110B\u1165\u11B8",
        "\u110C\u116E\u11BC\u1109\u116E\u11AB",
        "\u110C\u116E\u11BC\u110B\u1161\u11BC",
        "\u110C\u116E\u11BC\u110B\u116D",
        "\u110C\u116E\u11BC\u1112\u1161\u11A8\u1100\u116D",
        "\u110C\u1173\u11A8\u1109\u1165\u11A8",
        "\u110C\u1173\u11A8\u1109\u1175",
        "\u110C\u1173\u11AF\u1100\u1165\u110B\u116E\u11B7",
        "\u110C\u1173\u11BC\u1100\u1161",
        "\u110C\u1173\u11BC\u1100\u1165",
        "\u110C\u1173\u11BC\u1100\u116F\u11AB",
        "\u110C\u1173\u11BC\u1109\u1161\u11BC",
        "\u110C\u1173\u11BC\u1109\u1166",
        "\u110C\u1175\u1100\u1161\u11A8",
        "\u110C\u1175\u1100\u1161\u11B8",
        "\u110C\u1175\u1100\u1167\u11BC",
        "\u110C\u1175\u1100\u1173\u11A8\u1112\u1175",
        "\u110C\u1175\u1100\u1173\u11B7",
        "\u110C\u1175\u1100\u1173\u11B8",
        "\u110C\u1175\u1102\u1173\u11BC",
        "\u110C\u1175\u1105\u1173\u11B7\u1100\u1175\u11AF",
        "\u110C\u1175\u1105\u1175\u1109\u1161\u11AB",
        "\u110C\u1175\u1107\u1161\u11BC",
        "\u110C\u1175\u1107\u116E\u11BC",
        "\u110C\u1175\u1109\u1175\u11A8",
        "\u110C\u1175\u110B\u1167\u11A8",
        "\u110C\u1175\u110B\u116E\u1100\u1162",
        "\u110C\u1175\u110B\u116F\u11AB",
        "\u110C\u1175\u110C\u1165\u11A8",
        "\u110C\u1175\u110C\u1165\u11B7",
        "\u110C\u1175\u110C\u1175\u11AB",
        "\u110C\u1175\u110E\u116E\u11AF",
        "\u110C\u1175\u11A8\u1109\u1165\u11AB",
        "\u110C\u1175\u11A8\u110B\u1165\u11B8",
        "\u110C\u1175\u11A8\u110B\u116F\u11AB",
        "\u110C\u1175\u11A8\u110C\u1161\u11BC",
        "\u110C\u1175\u11AB\u1100\u1173\u11B8",
        "\u110C\u1175\u11AB\u1103\u1169\u11BC",
        "\u110C\u1175\u11AB\u1105\u1169",
        "\u110C\u1175\u11AB\u1105\u116D",
        "\u110C\u1175\u11AB\u1105\u1175",
        "\u110C\u1175\u11AB\u110D\u1161",
        "\u110C\u1175\u11AB\u110E\u1161\u11AF",
        "\u110C\u1175\u11AB\u110E\u116E\u11AF",
        "\u110C\u1175\u11AB\u1110\u1169\u11BC",
        "\u110C\u1175\u11AB\u1112\u1162\u11BC",
        "\u110C\u1175\u11AF\u1106\u116E\u11AB",
        "\u110C\u1175\u11AF\u1107\u1167\u11BC",
        "\u110C\u1175\u11AF\u1109\u1165",
        "\u110C\u1175\u11B7\u110C\u1161\u11A8",
        "\u110C\u1175\u11B8\u1103\u1161\u11AB",
        "\u110C\u1175\u11B8\u110B\u1161\u11AB",
        "\u110C\u1175\u11B8\u110C\u116E\u11BC",
        "\u110D\u1161\u110C\u1173\u11BC",
        "\u110D\u1175\u1101\u1165\u1100\u1175",
        "\u110E\u1161\u1102\u1161\u11B7",
        "\u110E\u1161\u1105\u1161\u1105\u1175",
        "\u110E\u1161\u1105\u1163\u11BC",
        "\u110E\u1161\u1105\u1175\u11B7",
        "\u110E\u1161\u1107\u1167\u11AF",
        "\u110E\u1161\u1109\u1165\u11AB",
        "\u110E\u1161\u110E\u1173\u11B7",
        "\u110E\u1161\u11A8\u1100\u1161\u11A8",
        "\u110E\u1161\u11AB\u1106\u116E\u11AF",
        "\u110E\u1161\u11AB\u1109\u1165\u11BC",
        "\u110E\u1161\u11B7\u1100\u1161",
        "\u110E\u1161\u11B7\u1100\u1175\u1105\u1173\u11B7",
        "\u110E\u1161\u11B7\u1109\u1162",
        "\u110E\u1161\u11B7\u1109\u1165\u11A8",
        "\u110E\u1161\u11B7\u110B\u1167",
        "\u110E\u1161\u11B7\u110B\u116C",
        "\u110E\u1161\u11B7\u110C\u1169",
        "\u110E\u1161\u11BA\u110C\u1161\u11AB",
        "\u110E\u1161\u11BC\u1100\u1161",
        "\u110E\u1161\u11BC\u1100\u1169",
        "\u110E\u1161\u11BC\u1100\u116E",
        "\u110E\u1161\u11BC\u1106\u116E\u11AB",
        "\u110E\u1161\u11BC\u1107\u1161\u11A9",
        "\u110E\u1161\u11BC\u110C\u1161\u11A8",
        "\u110E\u1161\u11BC\u110C\u1169",
        "\u110E\u1162\u1102\u1165\u11AF",
        "\u110E\u1162\u110C\u1165\u11B7",
        "\u110E\u1162\u11A8\u1100\u1161\u1107\u1161\u11BC",
        "\u110E\u1162\u11A8\u1107\u1161\u11BC",
        "\u110E\u1162\u11A8\u1109\u1161\u11BC",
        "\u110E\u1162\u11A8\u110B\u1175\u11B7",
        "\u110E\u1162\u11B7\u1111\u1175\u110B\u1165\u11AB",
        "\u110E\u1165\u1107\u1165\u11AF",
        "\u110E\u1165\u110B\u1173\u11B7",
        "\u110E\u1165\u11AB\u1100\u116E\u11A8",
        "\u110E\u1165\u11AB\u1103\u116E\u11BC",
        "\u110E\u1165\u11AB\u110C\u1161\u11BC",
        "\u110E\u1165\u11AB\u110C\u1162",
        "\u110E\u1165\u11AB\u110E\u1165\u11AB\u1112\u1175",
        "\u110E\u1165\u11AF\u1103\u1169",
        "\u110E\u1165\u11AF\u110C\u1165\u1112\u1175",
        "\u110E\u1165\u11AF\u1112\u1161\u11A8",
        "\u110E\u1165\u11BA\u1102\u1161\u11AF",
        "\u110E\u1165\u11BA\u110D\u1162",
        "\u110E\u1165\u11BC\u1102\u1167\u11AB",
        "\u110E\u1165\u11BC\u1107\u1161\u110C\u1175",
        "\u110E\u1165\u11BC\u1109\u1169",
        "\u110E\u1165\u11BC\u110E\u116E\u11AB",
        "\u110E\u1166\u1100\u1168",
        "\u110E\u1166\u1105\u1167\u11A8",
        "\u110E\u1166\u110B\u1169\u11AB",
        "\u110E\u1166\u110B\u1172\u11A8",
        "\u110E\u1166\u110C\u116E\u11BC",
        "\u110E\u1166\u1112\u1165\u11B7",
        "\u110E\u1169\u1103\u1173\u11BC\u1112\u1161\u11A8\u1109\u1162\u11BC",
        "\u110E\u1169\u1107\u1161\u11AB",
        "\u110E\u1169\u1107\u1161\u11B8",
        "\u110E\u1169\u1109\u1161\u11BC\u1112\u116A",
        "\u110E\u1169\u1109\u116E\u11AB",
        "\u110E\u1169\u110B\u1167\u1105\u1173\u11B7",
        "\u110E\u1169\u110B\u116F\u11AB",
        "\u110E\u1169\u110C\u1165\u1102\u1167\u11A8",
        "\u110E\u1169\u110C\u1165\u11B7",
        "\u110E\u1169\u110E\u1165\u11BC",
        "\u110E\u1169\u110F\u1169\u11AF\u1105\u1175\u11BA",
        "\u110E\u1169\u11BA\u1107\u116E\u11AF",
        "\u110E\u1169\u11BC\u1100\u1161\u11A8",
        "\u110E\u1169\u11BC\u1105\u1175",
        "\u110E\u1169\u11BC\u110C\u1161\u11BC",
        "\u110E\u116A\u11AF\u110B\u1167\u11BC",
        "\u110E\u116C\u1100\u1173\u11AB",
        "\u110E\u116C\u1109\u1161\u11BC",
        "\u110E\u116C\u1109\u1165\u11AB",
        "\u110E\u116C\u1109\u1175\u11AB",
        "\u110E\u116C\u110B\u1161\u11A8",
        "\u110E\u116C\u110C\u1169\u11BC",
        "\u110E\u116E\u1109\u1165\u11A8",
        "\u110E\u116E\u110B\u1165\u11A8",
        "\u110E\u116E\u110C\u1175\u11AB",
        "\u110E\u116E\u110E\u1165\u11AB",
        "\u110E\u116E\u110E\u1173\u11A8",
        "\u110E\u116E\u11A8\u1100\u116E",
        "\u110E\u116E\u11A8\u1109\u1169",
        "\u110E\u116E\u11A8\u110C\u1166",
        "\u110E\u116E\u11A8\u1112\u1161",
        "\u110E\u116E\u11AF\u1100\u1173\u11AB",
        "\u110E\u116E\u11AF\u1107\u1161\u11AF",
        "\u110E\u116E\u11AF\u1109\u1161\u11AB",
        "\u110E\u116E\u11AF\u1109\u1175\u11AB",
        "\u110E\u116E\u11AF\u110B\u1167\u11AB",
        "\u110E\u116E\u11AF\u110B\u1175\u11B8",
        "\u110E\u116E\u11AF\u110C\u1161\u11BC",
        "\u110E\u116E\u11AF\u1111\u1161\u11AB",
        "\u110E\u116E\u11BC\u1100\u1167\u11A8",
        "\u110E\u116E\u11BC\u1100\u1169",
        "\u110E\u116E\u11BC\u1103\u1169\u11AF",
        "\u110E\u116E\u11BC\u1107\u116E\u11AB\u1112\u1175",
        "\u110E\u116E\u11BC\u110E\u1165\u11BC\u1103\u1169",
        "\u110E\u1171\u110B\u1165\u11B8",
        "\u110E\u1171\u110C\u1175\u11A8",
        "\u110E\u1171\u1112\u1163\u11BC",
        "\u110E\u1175\u110B\u1163\u11A8",
        "\u110E\u1175\u11AB\u1100\u116E",
        "\u110E\u1175\u11AB\u110E\u1165\u11A8",
        "\u110E\u1175\u11AF\u1109\u1175\u11B8",
        "\u110E\u1175\u11AF\u110B\u116F\u11AF",
        "\u110E\u1175\u11AF\u1111\u1161\u11AB",
        "\u110E\u1175\u11B7\u1103\u1162",
        "\u110E\u1175\u11B7\u1106\u116E\u11A8",
        "\u110E\u1175\u11B7\u1109\u1175\u11AF",
        "\u110E\u1175\u11BA\u1109\u1169\u11AF",
        "\u110E\u1175\u11BC\u110E\u1161\u11AB",
        "\u110F\u1161\u1106\u1166\u1105\u1161",
        "\u110F\u1161\u110B\u116E\u11AB\u1110\u1165",
        "\u110F\u1161\u11AF\u1100\u116E\u11A8\u1109\u116E",
        "\u110F\u1162\u1105\u1175\u11A8\u1110\u1165",
        "\u110F\u1162\u11B7\u1111\u1165\u1109\u1173",
        "\u110F\u1162\u11B7\u1111\u1166\u110B\u1175\u11AB",
        "\u110F\u1165\u1110\u1173\u11AB",
        "\u110F\u1165\u11AB\u1103\u1175\u1109\u1167\u11AB",
        "\u110F\u1165\u11AF\u1105\u1165",
        "\u110F\u1165\u11B7\u1111\u1172\u1110\u1165",
        "\u110F\u1169\u1101\u1175\u1105\u1175",
        "\u110F\u1169\u1106\u1175\u1103\u1175",
        "\u110F\u1169\u11AB\u1109\u1165\u1110\u1173",
        "\u110F\u1169\u11AF\u1105\u1161",
        "\u110F\u1169\u11B7\u1111\u1173\u11AF\u1105\u1166\u11A8\u1109\u1173",
        "\u110F\u1169\u11BC\u1102\u1161\u1106\u116E\u11AF",
        "\u110F\u116B\u1100\u1161\u11B7",
        "\u110F\u116E\u1103\u1166\u1110\u1161",
        "\u110F\u1173\u1105\u1175\u11B7",
        "\u110F\u1173\u11AB\u1100\u1175\u11AF",
        "\u110F\u1173\u11AB\u1104\u1161\u11AF",
        "\u110F\u1173\u11AB\u1109\u1169\u1105\u1175",
        "\u110F\u1173\u11AB\u110B\u1161\u1103\u1173\u11AF",
        "\u110F\u1173\u11AB\u110B\u1165\u1106\u1165\u1102\u1175",
        "\u110F\u1173\u11AB\u110B\u1175\u11AF",
        "\u110F\u1173\u11AB\u110C\u1165\u11AF",
        "\u110F\u1173\u11AF\u1105\u1162\u1109\u1175\u11A8",
        "\u110F\u1173\u11AF\u1105\u1165\u11B8",
        "\u110F\u1175\u11AF\u1105\u1169",
        "\u1110\u1161\u110B\u1175\u11B8",
        "\u1110\u1161\u110C\u1161\u1100\u1175",
        "\u1110\u1161\u11A8\u1100\u116E",
        "\u1110\u1161\u11A8\u110C\u1161",
        "\u1110\u1161\u11AB\u1109\u1162\u11BC",
        "\u1110\u1162\u1100\u116F\u11AB\u1103\u1169",
        "\u1110\u1162\u110B\u1163\u11BC",
        "\u1110\u1162\u1111\u116E\u11BC",
        "\u1110\u1162\u11A8\u1109\u1175",
        "\u1110\u1162\u11AF\u1105\u1165\u11AB\u1110\u1173",
        "\u1110\u1165\u1102\u1165\u11AF",
        "\u1110\u1165\u1106\u1175\u1102\u1165\u11AF",
        "\u1110\u1166\u1102\u1175\u1109\u1173",
        "\u1110\u1166\u1109\u1173\u1110\u1173",
        "\u1110\u1166\u110B\u1175\u1107\u1173\u11AF",
        "\u1110\u1166\u11AF\u1105\u1166\u1107\u1175\u110C\u1165\u11AB",
        "\u1110\u1169\u1105\u1169\u11AB",
        "\u1110\u1169\u1106\u1161\u1110\u1169",
        "\u1110\u1169\u110B\u116D\u110B\u1175\u11AF",
        "\u1110\u1169\u11BC\u1100\u1168",
        "\u1110\u1169\u11BC\u1100\u116A",
        "\u1110\u1169\u11BC\u1105\u1169",
        "\u1110\u1169\u11BC\u1109\u1175\u11AB",
        "\u1110\u1169\u11BC\u110B\u1167\u11A8",
        "\u1110\u1169\u11BC\u110B\u1175\u11AF",
        "\u1110\u1169\u11BC\u110C\u1161\u11BC",
        "\u1110\u1169\u11BC\u110C\u1166",
        "\u1110\u1169\u11BC\u110C\u1173\u11BC",
        "\u1110\u1169\u11BC\u1112\u1161\u11B8",
        "\u1110\u1169\u11BC\u1112\u116A",
        "\u1110\u116C\u1100\u1173\u11AB",
        "\u1110\u116C\u110B\u116F\u11AB",
        "\u1110\u116C\u110C\u1175\u11A8\u1100\u1173\u11B7",
        "\u1110\u1171\u1100\u1175\u11B7",
        "\u1110\u1173\u1105\u1165\u11A8",
        "\u1110\u1173\u11A8\u1100\u1173\u11B8",
        "\u1110\u1173\u11A8\u1107\u1167\u11AF",
        "\u1110\u1173\u11A8\u1109\u1165\u11BC",
        "\u1110\u1173\u11A8\u1109\u116E",
        "\u1110\u1173\u11A8\u110C\u1175\u11BC",
        "\u1110\u1173\u11A8\u1112\u1175",
        "\u1110\u1173\u11AB\u1110\u1173\u11AB\u1112\u1175",
        "\u1110\u1175\u1109\u1167\u110E\u1173",
        "\u1111\u1161\u1105\u1161\u11AB\u1109\u1162\u11A8",
        "\u1111\u1161\u110B\u1175\u11AF",
        "\u1111\u1161\u110E\u116E\u11AF\u1109\u1169",
        "\u1111\u1161\u11AB\u1100\u1167\u11AF",
        "\u1111\u1161\u11AB\u1103\u1161\u11AB",
        "\u1111\u1161\u11AB\u1106\u1162",
        "\u1111\u1161\u11AB\u1109\u1161",
        "\u1111\u1161\u11AF\u1109\u1175\u11B8",
        "\u1111\u1161\u11AF\u110B\u116F\u11AF",
        "\u1111\u1161\u11B8\u1109\u1169\u11BC",
        "\u1111\u1162\u1109\u1167\u11AB",
        "\u1111\u1162\u11A8\u1109\u1173",
        "\u1111\u1162\u11A8\u1109\u1175\u1106\u1175\u11AF\u1105\u1175",
        "\u1111\u1162\u11AB\u1110\u1175",
        "\u1111\u1165\u1109\u1166\u11AB\u1110\u1173",
        "\u1111\u1166\u110B\u1175\u11AB\u1110\u1173",
        "\u1111\u1167\u11AB\u1100\u1167\u11AB",
        "\u1111\u1167\u11AB\u110B\u1174",
        "\u1111\u1167\u11AB\u110C\u1175",
        "\u1111\u1167\u11AB\u1112\u1175",
        "\u1111\u1167\u11BC\u1100\u1161",
        "\u1111\u1167\u11BC\u1100\u1172\u11AB",
        "\u1111\u1167\u11BC\u1109\u1162\u11BC",
        "\u1111\u1167\u11BC\u1109\u1169",
        "\u1111\u1167\u11BC\u110B\u1163\u11BC",
        "\u1111\u1167\u11BC\u110B\u1175\u11AF",
        "\u1111\u1167\u11BC\u1112\u116A",
        "\u1111\u1169\u1109\u1173\u1110\u1165",
        "\u1111\u1169\u110B\u1175\u11AB\u1110\u1173",
        "\u1111\u1169\u110C\u1161\u11BC",
        "\u1111\u1169\u1112\u1161\u11B7",
        "\u1111\u116D\u1106\u1167\u11AB",
        "\u1111\u116D\u110C\u1165\u11BC",
        "\u1111\u116D\u110C\u116E\u11AB",
        "\u1111\u116D\u1112\u1167\u11AB",
        "\u1111\u116E\u11B7\u1106\u1169\u11A8",
        "\u1111\u116E\u11B7\u110C\u1175\u11AF",
        "\u1111\u116E\u11BC\u1100\u1167\u11BC",
        "\u1111\u116E\u11BC\u1109\u1169\u11A8",
        "\u1111\u116E\u11BC\u1109\u1173\u11B8",
        "\u1111\u1173\u1105\u1161\u11BC\u1109\u1173",
        "\u1111\u1173\u1105\u1175\u11AB\u1110\u1165",
        "\u1111\u1173\u11AF\u1105\u1161\u1109\u1173\u1110\u1175\u11A8",
        "\u1111\u1175\u1100\u1169\u11AB",
        "\u1111\u1175\u1106\u1161\u11BC",
        "\u1111\u1175\u110B\u1161\u1102\u1169",
        "\u1111\u1175\u11AF\u1105\u1173\u11B7",
        "\u1111\u1175\u11AF\u1109\u116E",
        "\u1111\u1175\u11AF\u110B\u116D",
        "\u1111\u1175\u11AF\u110C\u1161",
        "\u1111\u1175\u11AF\u1110\u1169\u11BC",
        "\u1111\u1175\u11BC\u1100\u1168",
        "\u1112\u1161\u1102\u1173\u1102\u1175\u11B7",
        "\u1112\u1161\u1102\u1173\u11AF",
        "\u1112\u1161\u1103\u1173\u110B\u1170\u110B\u1165",
        "\u1112\u1161\u1105\u116E\u11BA\u1107\u1161\u11B7",
        "\u1112\u1161\u1107\u1161\u11AB\u1100\u1175",
        "\u1112\u1161\u1109\u116E\u11A8\u110C\u1175\u11B8",
        "\u1112\u1161\u1109\u116E\u11AB",
        "\u1112\u1161\u110B\u1167\u1110\u1173\u11AB",
        "\u1112\u1161\u110C\u1175\u1106\u1161\u11AB",
        "\u1112\u1161\u110E\u1165\u11AB",
        "\u1112\u1161\u1111\u116E\u11B7",
        "\u1112\u1161\u1111\u1175\u11AF",
        "\u1112\u1161\u11A8\u1100\u116A",
        "\u1112\u1161\u11A8\u1100\u116D",
        "\u1112\u1161\u11A8\u1100\u1173\u11B8",
        "\u1112\u1161\u11A8\u1100\u1175",
        "\u1112\u1161\u11A8\u1102\u1167\u11AB",
        "\u1112\u1161\u11A8\u1105\u1167\u11A8",
        "\u1112\u1161\u11A8\u1107\u1165\u11AB",
        "\u1112\u1161\u11A8\u1107\u116E\u1106\u1169",
        "\u1112\u1161\u11A8\u1107\u1175",
        "\u1112\u1161\u11A8\u1109\u1162\u11BC",
        "\u1112\u1161\u11A8\u1109\u116E\u11AF",
        "\u1112\u1161\u11A8\u1109\u1173\u11B8",
        "\u1112\u1161\u11A8\u110B\u116D\u11BC\u1111\u116E\u11B7",
        "\u1112\u1161\u11A8\u110B\u116F\u11AB",
        "\u1112\u1161\u11A8\u110B\u1171",
        "\u1112\u1161\u11A8\u110C\u1161",
        "\u1112\u1161\u11A8\u110C\u1165\u11B7",
        "\u1112\u1161\u11AB\u1100\u1168",
        "\u1112\u1161\u11AB\u1100\u1173\u11AF",
        "\u1112\u1161\u11AB\u1101\u1165\u1107\u1165\u11AB\u110B\u1166",
        "\u1112\u1161\u11AB\u1102\u1161\u11BD",
        "\u1112\u1161\u11AB\u1102\u116E\u11AB",
        "\u1112\u1161\u11AB\u1103\u1169\u11BC\u110B\u1161\u11AB",
        "\u1112\u1161\u11AB\u1104\u1162",
        "\u1112\u1161\u11AB\u1105\u1161\u1109\u1161\u11AB",
        "\u1112\u1161\u11AB\u1106\u1161\u1103\u1175",
        "\u1112\u1161\u11AB\u1106\u116E\u11AB",
        "\u1112\u1161\u11AB\u1107\u1165\u11AB",
        "\u1112\u1161\u11AB\u1107\u1169\u11A8",
        "\u1112\u1161\u11AB\u1109\u1175\u11A8",
        "\u1112\u1161\u11AB\u110B\u1167\u1105\u1173\u11B7",
        "\u1112\u1161\u11AB\u110D\u1169\u11A8",
        "\u1112\u1161\u11AF\u1106\u1165\u1102\u1175",
        "\u1112\u1161\u11AF\u110B\u1161\u1107\u1165\u110C\u1175",
        "\u1112\u1161\u11AF\u110B\u1175\u11AB",
        "\u1112\u1161\u11B7\u1101\u1166",
        "\u1112\u1161\u11B7\u1107\u116E\u1105\u1169",
        "\u1112\u1161\u11B8\u1100\u1167\u11A8",
        "\u1112\u1161\u11B8\u1105\u1175\u110C\u1165\u11A8",
        "\u1112\u1161\u11BC\u1100\u1169\u11BC",
        "\u1112\u1161\u11BC\u1100\u116E",
        "\u1112\u1161\u11BC\u1109\u1161\u11BC",
        "\u1112\u1161\u11BC\u110B\u1174",
        "\u1112\u1162\u1100\u1167\u11AF",
        "\u1112\u1162\u1100\u116E\u11AB",
        "\u1112\u1162\u1103\u1161\u11B8",
        "\u1112\u1162\u1103\u1161\u11BC",
        "\u1112\u1162\u1106\u116E\u11AF",
        "\u1112\u1162\u1109\u1165\u11A8",
        "\u1112\u1162\u1109\u1165\u11AF",
        "\u1112\u1162\u1109\u116E\u110B\u116D\u11A8\u110C\u1161\u11BC",
        "\u1112\u1162\u110B\u1161\u11AB",
        "\u1112\u1162\u11A8\u1109\u1175\u11B7",
        "\u1112\u1162\u11AB\u1103\u1173\u1107\u1162\u11A8",
        "\u1112\u1162\u11B7\u1107\u1165\u1100\u1165",
        "\u1112\u1162\u11BA\u1107\u1167\u11C0",
        "\u1112\u1162\u11BA\u1109\u1161\u11AF",
        "\u1112\u1162\u11BC\u1103\u1169\u11BC",
        "\u1112\u1162\u11BC\u1107\u1169\u11A8",
        "\u1112\u1162\u11BC\u1109\u1161",
        "\u1112\u1162\u11BC\u110B\u116E\u11AB",
        "\u1112\u1162\u11BC\u110B\u1171",
        "\u1112\u1163\u11BC\u1100\u1175",
        "\u1112\u1163\u11BC\u1109\u1161\u11BC",
        "\u1112\u1163\u11BC\u1109\u116E",
        "\u1112\u1165\u1105\u1161\u11A8",
        "\u1112\u1165\u110B\u116D\u11BC",
        "\u1112\u1166\u11AF\u1100\u1175",
        "\u1112\u1167\u11AB\u1100\u116A\u11AB",
        "\u1112\u1167\u11AB\u1100\u1173\u11B7",
        "\u1112\u1167\u11AB\u1103\u1162",
        "\u1112\u1167\u11AB\u1109\u1161\u11BC",
        "\u1112\u1167\u11AB\u1109\u1175\u11AF",
        "\u1112\u1167\u11AB\u110C\u1161\u11BC",
        "\u1112\u1167\u11AB\u110C\u1162",
        "\u1112\u1167\u11AB\u110C\u1175",
        "\u1112\u1167\u11AF\u110B\u1162\u11A8",
        "\u1112\u1167\u11B8\u1105\u1167\u11A8",
        "\u1112\u1167\u11BC\u1107\u116E",
        "\u1112\u1167\u11BC\u1109\u1161",
        "\u1112\u1167\u11BC\u1109\u116E",
        "\u1112\u1167\u11BC\u1109\u1175\u11A8",
        "\u1112\u1167\u11BC\u110C\u1166",
        "\u1112\u1167\u11BC\u1110\u1162",
        "\u1112\u1167\u11BC\u1111\u1167\u11AB",
        "\u1112\u1168\u1110\u1162\u11A8",
        "\u1112\u1169\u1100\u1175\u1109\u1175\u11B7",
        "\u1112\u1169\u1102\u1161\u11B7",
        "\u1112\u1169\u1105\u1161\u11BC\u110B\u1175",
        "\u1112\u1169\u1107\u1161\u11A8",
        "\u1112\u1169\u1110\u1166\u11AF",
        "\u1112\u1169\u1112\u1173\u11B8",
        "\u1112\u1169\u11A8\u1109\u1175",
        "\u1112\u1169\u11AF\u1105\u1169",
        "\u1112\u1169\u11B7\u1111\u1166\u110B\u1175\u110C\u1175",
        "\u1112\u1169\u11BC\u1107\u1169",
        "\u1112\u1169\u11BC\u1109\u116E",
        "\u1112\u1169\u11BC\u110E\u1161",
        "\u1112\u116A\u1106\u1167\u11AB",
        "\u1112\u116A\u1107\u116E\u11AB",
        "\u1112\u116A\u1109\u1161\u11AF",
        "\u1112\u116A\u110B\u116D\u110B\u1175\u11AF",
        "\u1112\u116A\u110C\u1161\u11BC",
        "\u1112\u116A\u1112\u1161\u11A8",
        "\u1112\u116A\u11A8\u1107\u1169",
        "\u1112\u116A\u11A8\u110B\u1175\u11AB",
        "\u1112\u116A\u11A8\u110C\u1161\u11BC",
        "\u1112\u116A\u11A8\u110C\u1165\u11BC",
        "\u1112\u116A\u11AB\u1100\u1161\u11B8",
        "\u1112\u116A\u11AB\u1100\u1167\u11BC",
        "\u1112\u116A\u11AB\u110B\u1167\u11BC",
        "\u1112\u116A\u11AB\u110B\u1172\u11AF",
        "\u1112\u116A\u11AB\u110C\u1161",
        "\u1112\u116A\u11AF\u1100\u1175",
        "\u1112\u116A\u11AF\u1103\u1169\u11BC",
        "\u1112\u116A\u11AF\u1107\u1161\u11AF\u1112\u1175",
        "\u1112\u116A\u11AF\u110B\u116D\u11BC",
        "\u1112\u116A\u11AF\u110D\u1161\u11A8",
        "\u1112\u116C\u1100\u1167\u11AB",
        "\u1112\u116C\u1100\u116A\u11AB",
        "\u1112\u116C\u1107\u1169\u11A8",
        "\u1112\u116C\u1109\u1162\u11A8",
        "\u1112\u116C\u110B\u116F\u11AB",
        "\u1112\u116C\u110C\u1161\u11BC",
        "\u1112\u116C\u110C\u1165\u11AB",
        "\u1112\u116C\u11BA\u1109\u116E",
        "\u1112\u116C\u11BC\u1103\u1161\u11AB\u1107\u1169\u1103\u1169",
        "\u1112\u116D\u110B\u1172\u11AF\u110C\u1165\u11A8",
        "\u1112\u116E\u1107\u1161\u11AB",
        "\u1112\u116E\u110E\u116E\u11BA\u1100\u1161\u1105\u116E",
        "\u1112\u116E\u11AB\u1105\u1167\u11AB",
        "\u1112\u116F\u11AF\u110A\u1175\u11AB",
        "\u1112\u1172\u1109\u1175\u11A8",
        "\u1112\u1172\u110B\u1175\u11AF",
        "\u1112\u1172\u11BC\u1102\u1162",
        "\u1112\u1173\u1105\u1173\u11B7",
        "\u1112\u1173\u11A8\u1107\u1162\u11A8",
        "\u1112\u1173\u11A8\u110B\u1175\u11AB",
        "\u1112\u1173\u11AB\u110C\u1165\u11A8",
        "\u1112\u1173\u11AB\u1112\u1175",
        "\u1112\u1173\u11BC\u1106\u1175",
        "\u1112\u1173\u11BC\u1107\u116E\u11AB",
        "\u1112\u1174\u1100\u1169\u11A8",
        "\u1112\u1174\u1106\u1161\u11BC",
        "\u1112\u1174\u1109\u1162\u11BC",
        "\u1112\u1174\u11AB\u1109\u1162\u11A8",
        "\u1112\u1175\u11B7\u1101\u1165\u11BA"
      ];
    }
  });

  // node_modules/bip39/src/wordlists/french.json
  var require_french = __commonJS({
    "node_modules/bip39/src/wordlists/french.json"(exports9, module) {
      module.exports = [
        "abaisser",
        "abandon",
        "abdiquer",
        "abeille",
        "abolir",
        "aborder",
        "aboutir",
        "aboyer",
        "abrasif",
        "abreuver",
        "abriter",
        "abroger",
        "abrupt",
        "absence",
        "absolu",
        "absurde",
        "abusif",
        "abyssal",
        "acade\u0301mie",
        "acajou",
        "acarien",
        "accabler",
        "accepter",
        "acclamer",
        "accolade",
        "accroche",
        "accuser",
        "acerbe",
        "achat",
        "acheter",
        "aciduler",
        "acier",
        "acompte",
        "acque\u0301rir",
        "acronyme",
        "acteur",
        "actif",
        "actuel",
        "adepte",
        "ade\u0301quat",
        "adhe\u0301sif",
        "adjectif",
        "adjuger",
        "admettre",
        "admirer",
        "adopter",
        "adorer",
        "adoucir",
        "adresse",
        "adroit",
        "adulte",
        "adverbe",
        "ae\u0301rer",
        "ae\u0301ronef",
        "affaire",
        "affecter",
        "affiche",
        "affreux",
        "affubler",
        "agacer",
        "agencer",
        "agile",
        "agiter",
        "agrafer",
        "agre\u0301able",
        "agrume",
        "aider",
        "aiguille",
        "ailier",
        "aimable",
        "aisance",
        "ajouter",
        "ajuster",
        "alarmer",
        "alchimie",
        "alerte",
        "alge\u0300bre",
        "algue",
        "alie\u0301ner",
        "aliment",
        "alle\u0301ger",
        "alliage",
        "allouer",
        "allumer",
        "alourdir",
        "alpaga",
        "altesse",
        "alve\u0301ole",
        "amateur",
        "ambigu",
        "ambre",
        "ame\u0301nager",
        "amertume",
        "amidon",
        "amiral",
        "amorcer",
        "amour",
        "amovible",
        "amphibie",
        "ampleur",
        "amusant",
        "analyse",
        "anaphore",
        "anarchie",
        "anatomie",
        "ancien",
        "ane\u0301antir",
        "angle",
        "angoisse",
        "anguleux",
        "animal",
        "annexer",
        "annonce",
        "annuel",
        "anodin",
        "anomalie",
        "anonyme",
        "anormal",
        "antenne",
        "antidote",
        "anxieux",
        "apaiser",
        "ape\u0301ritif",
        "aplanir",
        "apologie",
        "appareil",
        "appeler",
        "apporter",
        "appuyer",
        "aquarium",
        "aqueduc",
        "arbitre",
        "arbuste",
        "ardeur",
        "ardoise",
        "argent",
        "arlequin",
        "armature",
        "armement",
        "armoire",
        "armure",
        "arpenter",
        "arracher",
        "arriver",
        "arroser",
        "arsenic",
        "arte\u0301riel",
        "article",
        "aspect",
        "asphalte",
        "aspirer",
        "assaut",
        "asservir",
        "assiette",
        "associer",
        "assurer",
        "asticot",
        "astre",
        "astuce",
        "atelier",
        "atome",
        "atrium",
        "atroce",
        "attaque",
        "attentif",
        "attirer",
        "attraper",
        "aubaine",
        "auberge",
        "audace",
        "audible",
        "augurer",
        "aurore",
        "automne",
        "autruche",
        "avaler",
        "avancer",
        "avarice",
        "avenir",
        "averse",
        "aveugle",
        "aviateur",
        "avide",
        "avion",
        "aviser",
        "avoine",
        "avouer",
        "avril",
        "axial",
        "axiome",
        "badge",
        "bafouer",
        "bagage",
        "baguette",
        "baignade",
        "balancer",
        "balcon",
        "baleine",
        "balisage",
        "bambin",
        "bancaire",
        "bandage",
        "banlieue",
        "bannie\u0300re",
        "banquier",
        "barbier",
        "baril",
        "baron",
        "barque",
        "barrage",
        "bassin",
        "bastion",
        "bataille",
        "bateau",
        "batterie",
        "baudrier",
        "bavarder",
        "belette",
        "be\u0301lier",
        "belote",
        "be\u0301ne\u0301fice",
        "berceau",
        "berger",
        "berline",
        "bermuda",
        "besace",
        "besogne",
        "be\u0301tail",
        "beurre",
        "biberon",
        "bicycle",
        "bidule",
        "bijou",
        "bilan",
        "bilingue",
        "billard",
        "binaire",
        "biologie",
        "biopsie",
        "biotype",
        "biscuit",
        "bison",
        "bistouri",
        "bitume",
        "bizarre",
        "blafard",
        "blague",
        "blanchir",
        "blessant",
        "blinder",
        "blond",
        "bloquer",
        "blouson",
        "bobard",
        "bobine",
        "boire",
        "boiser",
        "bolide",
        "bonbon",
        "bondir",
        "bonheur",
        "bonifier",
        "bonus",
        "bordure",
        "borne",
        "botte",
        "boucle",
        "boueux",
        "bougie",
        "boulon",
        "bouquin",
        "bourse",
        "boussole",
        "boutique",
        "boxeur",
        "branche",
        "brasier",
        "brave",
        "brebis",
        "bre\u0300che",
        "breuvage",
        "bricoler",
        "brigade",
        "brillant",
        "brioche",
        "brique",
        "brochure",
        "broder",
        "bronzer",
        "brousse",
        "broyeur",
        "brume",
        "brusque",
        "brutal",
        "bruyant",
        "buffle",
        "buisson",
        "bulletin",
        "bureau",
        "burin",
        "bustier",
        "butiner",
        "butoir",
        "buvable",
        "buvette",
        "cabanon",
        "cabine",
        "cachette",
        "cadeau",
        "cadre",
        "cafe\u0301ine",
        "caillou",
        "caisson",
        "calculer",
        "calepin",
        "calibre",
        "calmer",
        "calomnie",
        "calvaire",
        "camarade",
        "came\u0301ra",
        "camion",
        "campagne",
        "canal",
        "caneton",
        "canon",
        "cantine",
        "canular",
        "capable",
        "caporal",
        "caprice",
        "capsule",
        "capter",
        "capuche",
        "carabine",
        "carbone",
        "caresser",
        "caribou",
        "carnage",
        "carotte",
        "carreau",
        "carton",
        "cascade",
        "casier",
        "casque",
        "cassure",
        "causer",
        "caution",
        "cavalier",
        "caverne",
        "caviar",
        "ce\u0301dille",
        "ceinture",
        "ce\u0301leste",
        "cellule",
        "cendrier",
        "censurer",
        "central",
        "cercle",
        "ce\u0301re\u0301bral",
        "cerise",
        "cerner",
        "cerveau",
        "cesser",
        "chagrin",
        "chaise",
        "chaleur",
        "chambre",
        "chance",
        "chapitre",
        "charbon",
        "chasseur",
        "chaton",
        "chausson",
        "chavirer",
        "chemise",
        "chenille",
        "che\u0301quier",
        "chercher",
        "cheval",
        "chien",
        "chiffre",
        "chignon",
        "chime\u0300re",
        "chiot",
        "chlorure",
        "chocolat",
        "choisir",
        "chose",
        "chouette",
        "chrome",
        "chute",
        "cigare",
        "cigogne",
        "cimenter",
        "cine\u0301ma",
        "cintrer",
        "circuler",
        "cirer",
        "cirque",
        "citerne",
        "citoyen",
        "citron",
        "civil",
        "clairon",
        "clameur",
        "claquer",
        "classe",
        "clavier",
        "client",
        "cligner",
        "climat",
        "clivage",
        "cloche",
        "clonage",
        "cloporte",
        "cobalt",
        "cobra",
        "cocasse",
        "cocotier",
        "coder",
        "codifier",
        "coffre",
        "cogner",
        "cohe\u0301sion",
        "coiffer",
        "coincer",
        "cole\u0300re",
        "colibri",
        "colline",
        "colmater",
        "colonel",
        "combat",
        "come\u0301die",
        "commande",
        "compact",
        "concert",
        "conduire",
        "confier",
        "congeler",
        "connoter",
        "consonne",
        "contact",
        "convexe",
        "copain",
        "copie",
        "corail",
        "corbeau",
        "cordage",
        "corniche",
        "corpus",
        "correct",
        "corte\u0300ge",
        "cosmique",
        "costume",
        "coton",
        "coude",
        "coupure",
        "courage",
        "couteau",
        "couvrir",
        "coyote",
        "crabe",
        "crainte",
        "cravate",
        "crayon",
        "cre\u0301ature",
        "cre\u0301diter",
        "cre\u0301meux",
        "creuser",
        "crevette",
        "cribler",
        "crier",
        "cristal",
        "crite\u0300re",
        "croire",
        "croquer",
        "crotale",
        "crucial",
        "cruel",
        "crypter",
        "cubique",
        "cueillir",
        "cuille\u0300re",
        "cuisine",
        "cuivre",
        "culminer",
        "cultiver",
        "cumuler",
        "cupide",
        "curatif",
        "curseur",
        "cyanure",
        "cycle",
        "cylindre",
        "cynique",
        "daigner",
        "damier",
        "danger",
        "danseur",
        "dauphin",
        "de\u0301battre",
        "de\u0301biter",
        "de\u0301border",
        "de\u0301brider",
        "de\u0301butant",
        "de\u0301caler",
        "de\u0301cembre",
        "de\u0301chirer",
        "de\u0301cider",
        "de\u0301clarer",
        "de\u0301corer",
        "de\u0301crire",
        "de\u0301cupler",
        "de\u0301dale",
        "de\u0301ductif",
        "de\u0301esse",
        "de\u0301fensif",
        "de\u0301filer",
        "de\u0301frayer",
        "de\u0301gager",
        "de\u0301givrer",
        "de\u0301glutir",
        "de\u0301grafer",
        "de\u0301jeuner",
        "de\u0301lice",
        "de\u0301loger",
        "demander",
        "demeurer",
        "de\u0301molir",
        "de\u0301nicher",
        "de\u0301nouer",
        "dentelle",
        "de\u0301nuder",
        "de\u0301part",
        "de\u0301penser",
        "de\u0301phaser",
        "de\u0301placer",
        "de\u0301poser",
        "de\u0301ranger",
        "de\u0301rober",
        "de\u0301sastre",
        "descente",
        "de\u0301sert",
        "de\u0301signer",
        "de\u0301sobe\u0301ir",
        "dessiner",
        "destrier",
        "de\u0301tacher",
        "de\u0301tester",
        "de\u0301tourer",
        "de\u0301tresse",
        "devancer",
        "devenir",
        "deviner",
        "devoir",
        "diable",
        "dialogue",
        "diamant",
        "dicter",
        "diffe\u0301rer",
        "dige\u0301rer",
        "digital",
        "digne",
        "diluer",
        "dimanche",
        "diminuer",
        "dioxyde",
        "directif",
        "diriger",
        "discuter",
        "disposer",
        "dissiper",
        "distance",
        "divertir",
        "diviser",
        "docile",
        "docteur",
        "dogme",
        "doigt",
        "domaine",
        "domicile",
        "dompter",
        "donateur",
        "donjon",
        "donner",
        "dopamine",
        "dortoir",
        "dorure",
        "dosage",
        "doseur",
        "dossier",
        "dotation",
        "douanier",
        "double",
        "douceur",
        "douter",
        "doyen",
        "dragon",
        "draper",
        "dresser",
        "dribbler",
        "droiture",
        "duperie",
        "duplexe",
        "durable",
        "durcir",
        "dynastie",
        "e\u0301blouir",
        "e\u0301carter",
        "e\u0301charpe",
        "e\u0301chelle",
        "e\u0301clairer",
        "e\u0301clipse",
        "e\u0301clore",
        "e\u0301cluse",
        "e\u0301cole",
        "e\u0301conomie",
        "e\u0301corce",
        "e\u0301couter",
        "e\u0301craser",
        "e\u0301cre\u0301mer",
        "e\u0301crivain",
        "e\u0301crou",
        "e\u0301cume",
        "e\u0301cureuil",
        "e\u0301difier",
        "e\u0301duquer",
        "effacer",
        "effectif",
        "effigie",
        "effort",
        "effrayer",
        "effusion",
        "e\u0301galiser",
        "e\u0301garer",
        "e\u0301jecter",
        "e\u0301laborer",
        "e\u0301largir",
        "e\u0301lectron",
        "e\u0301le\u0301gant",
        "e\u0301le\u0301phant",
        "e\u0301le\u0300ve",
        "e\u0301ligible",
        "e\u0301litisme",
        "e\u0301loge",
        "e\u0301lucider",
        "e\u0301luder",
        "emballer",
        "embellir",
        "embryon",
        "e\u0301meraude",
        "e\u0301mission",
        "emmener",
        "e\u0301motion",
        "e\u0301mouvoir",
        "empereur",
        "employer",
        "emporter",
        "emprise",
        "e\u0301mulsion",
        "encadrer",
        "enche\u0300re",
        "enclave",
        "encoche",
        "endiguer",
        "endosser",
        "endroit",
        "enduire",
        "e\u0301nergie",
        "enfance",
        "enfermer",
        "enfouir",
        "engager",
        "engin",
        "englober",
        "e\u0301nigme",
        "enjamber",
        "enjeu",
        "enlever",
        "ennemi",
        "ennuyeux",
        "enrichir",
        "enrobage",
        "enseigne",
        "entasser",
        "entendre",
        "entier",
        "entourer",
        "entraver",
        "e\u0301nume\u0301rer",
        "envahir",
        "enviable",
        "envoyer",
        "enzyme",
        "e\u0301olien",
        "e\u0301paissir",
        "e\u0301pargne",
        "e\u0301patant",
        "e\u0301paule",
        "e\u0301picerie",
        "e\u0301pide\u0301mie",
        "e\u0301pier",
        "e\u0301pilogue",
        "e\u0301pine",
        "e\u0301pisode",
        "e\u0301pitaphe",
        "e\u0301poque",
        "e\u0301preuve",
        "e\u0301prouver",
        "e\u0301puisant",
        "e\u0301querre",
        "e\u0301quipe",
        "e\u0301riger",
        "e\u0301rosion",
        "erreur",
        "e\u0301ruption",
        "escalier",
        "espadon",
        "espe\u0300ce",
        "espie\u0300gle",
        "espoir",
        "esprit",
        "esquiver",
        "essayer",
        "essence",
        "essieu",
        "essorer",
        "estime",
        "estomac",
        "estrade",
        "e\u0301tage\u0300re",
        "e\u0301taler",
        "e\u0301tanche",
        "e\u0301tatique",
        "e\u0301teindre",
        "e\u0301tendoir",
        "e\u0301ternel",
        "e\u0301thanol",
        "e\u0301thique",
        "ethnie",
        "e\u0301tirer",
        "e\u0301toffer",
        "e\u0301toile",
        "e\u0301tonnant",
        "e\u0301tourdir",
        "e\u0301trange",
        "e\u0301troit",
        "e\u0301tude",
        "euphorie",
        "e\u0301valuer",
        "e\u0301vasion",
        "e\u0301ventail",
        "e\u0301vidence",
        "e\u0301viter",
        "e\u0301volutif",
        "e\u0301voquer",
        "exact",
        "exage\u0301rer",
        "exaucer",
        "exceller",
        "excitant",
        "exclusif",
        "excuse",
        "exe\u0301cuter",
        "exemple",
        "exercer",
        "exhaler",
        "exhorter",
        "exigence",
        "exiler",
        "exister",
        "exotique",
        "expe\u0301dier",
        "explorer",
        "exposer",
        "exprimer",
        "exquis",
        "extensif",
        "extraire",
        "exulter",
        "fable",
        "fabuleux",
        "facette",
        "facile",
        "facture",
        "faiblir",
        "falaise",
        "fameux",
        "famille",
        "farceur",
        "farfelu",
        "farine",
        "farouche",
        "fasciner",
        "fatal",
        "fatigue",
        "faucon",
        "fautif",
        "faveur",
        "favori",
        "fe\u0301brile",
        "fe\u0301conder",
        "fe\u0301de\u0301rer",
        "fe\u0301lin",
        "femme",
        "fe\u0301mur",
        "fendoir",
        "fe\u0301odal",
        "fermer",
        "fe\u0301roce",
        "ferveur",
        "festival",
        "feuille",
        "feutre",
        "fe\u0301vrier",
        "fiasco",
        "ficeler",
        "fictif",
        "fide\u0300le",
        "figure",
        "filature",
        "filetage",
        "filie\u0300re",
        "filleul",
        "filmer",
        "filou",
        "filtrer",
        "financer",
        "finir",
        "fiole",
        "firme",
        "fissure",
        "fixer",
        "flairer",
        "flamme",
        "flasque",
        "flatteur",
        "fle\u0301au",
        "fle\u0300che",
        "fleur",
        "flexion",
        "flocon",
        "flore",
        "fluctuer",
        "fluide",
        "fluvial",
        "folie",
        "fonderie",
        "fongible",
        "fontaine",
        "forcer",
        "forgeron",
        "formuler",
        "fortune",
        "fossile",
        "foudre",
        "fouge\u0300re",
        "fouiller",
        "foulure",
        "fourmi",
        "fragile",
        "fraise",
        "franchir",
        "frapper",
        "frayeur",
        "fre\u0301gate",
        "freiner",
        "frelon",
        "fre\u0301mir",
        "fre\u0301ne\u0301sie",
        "fre\u0300re",
        "friable",
        "friction",
        "frisson",
        "frivole",
        "froid",
        "fromage",
        "frontal",
        "frotter",
        "fruit",
        "fugitif",
        "fuite",
        "fureur",
        "furieux",
        "furtif",
        "fusion",
        "futur",
        "gagner",
        "galaxie",
        "galerie",
        "gambader",
        "garantir",
        "gardien",
        "garnir",
        "garrigue",
        "gazelle",
        "gazon",
        "ge\u0301ant",
        "ge\u0301latine",
        "ge\u0301lule",
        "gendarme",
        "ge\u0301ne\u0301ral",
        "ge\u0301nie",
        "genou",
        "gentil",
        "ge\u0301ologie",
        "ge\u0301ome\u0300tre",
        "ge\u0301ranium",
        "germe",
        "gestuel",
        "geyser",
        "gibier",
        "gicler",
        "girafe",
        "givre",
        "glace",
        "glaive",
        "glisser",
        "globe",
        "gloire",
        "glorieux",
        "golfeur",
        "gomme",
        "gonfler",
        "gorge",
        "gorille",
        "goudron",
        "gouffre",
        "goulot",
        "goupille",
        "gourmand",
        "goutte",
        "graduel",
        "graffiti",
        "graine",
        "grand",
        "grappin",
        "gratuit",
        "gravir",
        "grenat",
        "griffure",
        "griller",
        "grimper",
        "grogner",
        "gronder",
        "grotte",
        "groupe",
        "gruger",
        "grutier",
        "gruye\u0300re",
        "gue\u0301pard",
        "guerrier",
        "guide",
        "guimauve",
        "guitare",
        "gustatif",
        "gymnaste",
        "gyrostat",
        "habitude",
        "hachoir",
        "halte",
        "hameau",
        "hangar",
        "hanneton",
        "haricot",
        "harmonie",
        "harpon",
        "hasard",
        "he\u0301lium",
        "he\u0301matome",
        "herbe",
        "he\u0301risson",
        "hermine",
        "he\u0301ron",
        "he\u0301siter",
        "heureux",
        "hiberner",
        "hibou",
        "hilarant",
        "histoire",
        "hiver",
        "homard",
        "hommage",
        "homoge\u0300ne",
        "honneur",
        "honorer",
        "honteux",
        "horde",
        "horizon",
        "horloge",
        "hormone",
        "horrible",
        "houleux",
        "housse",
        "hublot",
        "huileux",
        "humain",
        "humble",
        "humide",
        "humour",
        "hurler",
        "hydromel",
        "hygie\u0300ne",
        "hymne",
        "hypnose",
        "idylle",
        "ignorer",
        "iguane",
        "illicite",
        "illusion",
        "image",
        "imbiber",
        "imiter",
        "immense",
        "immobile",
        "immuable",
        "impact",
        "impe\u0301rial",
        "implorer",
        "imposer",
        "imprimer",
        "imputer",
        "incarner",
        "incendie",
        "incident",
        "incliner",
        "incolore",
        "indexer",
        "indice",
        "inductif",
        "ine\u0301dit",
        "ineptie",
        "inexact",
        "infini",
        "infliger",
        "informer",
        "infusion",
        "inge\u0301rer",
        "inhaler",
        "inhiber",
        "injecter",
        "injure",
        "innocent",
        "inoculer",
        "inonder",
        "inscrire",
        "insecte",
        "insigne",
        "insolite",
        "inspirer",
        "instinct",
        "insulter",
        "intact",
        "intense",
        "intime",
        "intrigue",
        "intuitif",
        "inutile",
        "invasion",
        "inventer",
        "inviter",
        "invoquer",
        "ironique",
        "irradier",
        "irre\u0301el",
        "irriter",
        "isoler",
        "ivoire",
        "ivresse",
        "jaguar",
        "jaillir",
        "jambe",
        "janvier",
        "jardin",
        "jauger",
        "jaune",
        "javelot",
        "jetable",
        "jeton",
        "jeudi",
        "jeunesse",
        "joindre",
        "joncher",
        "jongler",
        "joueur",
        "jouissif",
        "journal",
        "jovial",
        "joyau",
        "joyeux",
        "jubiler",
        "jugement",
        "junior",
        "jupon",
        "juriste",
        "justice",
        "juteux",
        "juve\u0301nile",
        "kayak",
        "kimono",
        "kiosque",
        "label",
        "labial",
        "labourer",
        "lace\u0301rer",
        "lactose",
        "lagune",
        "laine",
        "laisser",
        "laitier",
        "lambeau",
        "lamelle",
        "lampe",
        "lanceur",
        "langage",
        "lanterne",
        "lapin",
        "largeur",
        "larme",
        "laurier",
        "lavabo",
        "lavoir",
        "lecture",
        "le\u0301gal",
        "le\u0301ger",
        "le\u0301gume",
        "lessive",
        "lettre",
        "levier",
        "lexique",
        "le\u0301zard",
        "liasse",
        "libe\u0301rer",
        "libre",
        "licence",
        "licorne",
        "lie\u0300ge",
        "lie\u0300vre",
        "ligature",
        "ligoter",
        "ligue",
        "limer",
        "limite",
        "limonade",
        "limpide",
        "line\u0301aire",
        "lingot",
        "lionceau",
        "liquide",
        "lisie\u0300re",
        "lister",
        "lithium",
        "litige",
        "littoral",
        "livreur",
        "logique",
        "lointain",
        "loisir",
        "lombric",
        "loterie",
        "louer",
        "lourd",
        "loutre",
        "louve",
        "loyal",
        "lubie",
        "lucide",
        "lucratif",
        "lueur",
        "lugubre",
        "luisant",
        "lumie\u0300re",
        "lunaire",
        "lundi",
        "luron",
        "lutter",
        "luxueux",
        "machine",
        "magasin",
        "magenta",
        "magique",
        "maigre",
        "maillon",
        "maintien",
        "mairie",
        "maison",
        "majorer",
        "malaxer",
        "male\u0301fice",
        "malheur",
        "malice",
        "mallette",
        "mammouth",
        "mandater",
        "maniable",
        "manquant",
        "manteau",
        "manuel",
        "marathon",
        "marbre",
        "marchand",
        "mardi",
        "maritime",
        "marqueur",
        "marron",
        "marteler",
        "mascotte",
        "massif",
        "mate\u0301riel",
        "matie\u0300re",
        "matraque",
        "maudire",
        "maussade",
        "mauve",
        "maximal",
        "me\u0301chant",
        "me\u0301connu",
        "me\u0301daille",
        "me\u0301decin",
        "me\u0301diter",
        "me\u0301duse",
        "meilleur",
        "me\u0301lange",
        "me\u0301lodie",
        "membre",
        "me\u0301moire",
        "menacer",
        "mener",
        "menhir",
        "mensonge",
        "mentor",
        "mercredi",
        "me\u0301rite",
        "merle",
        "messager",
        "mesure",
        "me\u0301tal",
        "me\u0301te\u0301ore",
        "me\u0301thode",
        "me\u0301tier",
        "meuble",
        "miauler",
        "microbe",
        "miette",
        "mignon",
        "migrer",
        "milieu",
        "million",
        "mimique",
        "mince",
        "mine\u0301ral",
        "minimal",
        "minorer",
        "minute",
        "miracle",
        "miroiter",
        "missile",
        "mixte",
        "mobile",
        "moderne",
        "moelleux",
        "mondial",
        "moniteur",
        "monnaie",
        "monotone",
        "monstre",
        "montagne",
        "monument",
        "moqueur",
        "morceau",
        "morsure",
        "mortier",
        "moteur",
        "motif",
        "mouche",
        "moufle",
        "moulin",
        "mousson",
        "mouton",
        "mouvant",
        "multiple",
        "munition",
        "muraille",
        "mure\u0300ne",
        "murmure",
        "muscle",
        "muse\u0301um",
        "musicien",
        "mutation",
        "muter",
        "mutuel",
        "myriade",
        "myrtille",
        "myste\u0300re",
        "mythique",
        "nageur",
        "nappe",
        "narquois",
        "narrer",
        "natation",
        "nation",
        "nature",
        "naufrage",
        "nautique",
        "navire",
        "ne\u0301buleux",
        "nectar",
        "ne\u0301faste",
        "ne\u0301gation",
        "ne\u0301gliger",
        "ne\u0301gocier",
        "neige",
        "nerveux",
        "nettoyer",
        "neurone",
        "neutron",
        "neveu",
        "niche",
        "nickel",
        "nitrate",
        "niveau",
        "noble",
        "nocif",
        "nocturne",
        "noirceur",
        "noisette",
        "nomade",
        "nombreux",
        "nommer",
        "normatif",
        "notable",
        "notifier",
        "notoire",
        "nourrir",
        "nouveau",
        "novateur",
        "novembre",
        "novice",
        "nuage",
        "nuancer",
        "nuire",
        "nuisible",
        "nume\u0301ro",
        "nuptial",
        "nuque",
        "nutritif",
        "obe\u0301ir",
        "objectif",
        "obliger",
        "obscur",
        "observer",
        "obstacle",
        "obtenir",
        "obturer",
        "occasion",
        "occuper",
        "oce\u0301an",
        "octobre",
        "octroyer",
        "octupler",
        "oculaire",
        "odeur",
        "odorant",
        "offenser",
        "officier",
        "offrir",
        "ogive",
        "oiseau",
        "oisillon",
        "olfactif",
        "olivier",
        "ombrage",
        "omettre",
        "onctueux",
        "onduler",
        "one\u0301reux",
        "onirique",
        "opale",
        "opaque",
        "ope\u0301rer",
        "opinion",
        "opportun",
        "opprimer",
        "opter",
        "optique",
        "orageux",
        "orange",
        "orbite",
        "ordonner",
        "oreille",
        "organe",
        "orgueil",
        "orifice",
        "ornement",
        "orque",
        "ortie",
        "osciller",
        "osmose",
        "ossature",
        "otarie",
        "ouragan",
        "ourson",
        "outil",
        "outrager",
        "ouvrage",
        "ovation",
        "oxyde",
        "oxyge\u0300ne",
        "ozone",
        "paisible",
        "palace",
        "palmare\u0300s",
        "palourde",
        "palper",
        "panache",
        "panda",
        "pangolin",
        "paniquer",
        "panneau",
        "panorama",
        "pantalon",
        "papaye",
        "papier",
        "papoter",
        "papyrus",
        "paradoxe",
        "parcelle",
        "paresse",
        "parfumer",
        "parler",
        "parole",
        "parrain",
        "parsemer",
        "partager",
        "parure",
        "parvenir",
        "passion",
        "paste\u0300que",
        "paternel",
        "patience",
        "patron",
        "pavillon",
        "pavoiser",
        "payer",
        "paysage",
        "peigne",
        "peintre",
        "pelage",
        "pe\u0301lican",
        "pelle",
        "pelouse",
        "peluche",
        "pendule",
        "pe\u0301ne\u0301trer",
        "pe\u0301nible",
        "pensif",
        "pe\u0301nurie",
        "pe\u0301pite",
        "pe\u0301plum",
        "perdrix",
        "perforer",
        "pe\u0301riode",
        "permuter",
        "perplexe",
        "persil",
        "perte",
        "peser",
        "pe\u0301tale",
        "petit",
        "pe\u0301trir",
        "peuple",
        "pharaon",
        "phobie",
        "phoque",
        "photon",
        "phrase",
        "physique",
        "piano",
        "pictural",
        "pie\u0300ce",
        "pierre",
        "pieuvre",
        "pilote",
        "pinceau",
        "pipette",
        "piquer",
        "pirogue",
        "piscine",
        "piston",
        "pivoter",
        "pixel",
        "pizza",
        "placard",
        "plafond",
        "plaisir",
        "planer",
        "plaque",
        "plastron",
        "plateau",
        "pleurer",
        "plexus",
        "pliage",
        "plomb",
        "plonger",
        "pluie",
        "plumage",
        "pochette",
        "poe\u0301sie",
        "poe\u0300te",
        "pointe",
        "poirier",
        "poisson",
        "poivre",
        "polaire",
        "policier",
        "pollen",
        "polygone",
        "pommade",
        "pompier",
        "ponctuel",
        "ponde\u0301rer",
        "poney",
        "portique",
        "position",
        "posse\u0301der",
        "posture",
        "potager",
        "poteau",
        "potion",
        "pouce",
        "poulain",
        "poumon",
        "pourpre",
        "poussin",
        "pouvoir",
        "prairie",
        "pratique",
        "pre\u0301cieux",
        "pre\u0301dire",
        "pre\u0301fixe",
        "pre\u0301lude",
        "pre\u0301nom",
        "pre\u0301sence",
        "pre\u0301texte",
        "pre\u0301voir",
        "primitif",
        "prince",
        "prison",
        "priver",
        "proble\u0300me",
        "proce\u0301der",
        "prodige",
        "profond",
        "progre\u0300s",
        "proie",
        "projeter",
        "prologue",
        "promener",
        "propre",
        "prospe\u0300re",
        "prote\u0301ger",
        "prouesse",
        "proverbe",
        "prudence",
        "pruneau",
        "psychose",
        "public",
        "puceron",
        "puiser",
        "pulpe",
        "pulsar",
        "punaise",
        "punitif",
        "pupitre",
        "purifier",
        "puzzle",
        "pyramide",
        "quasar",
        "querelle",
        "question",
        "quie\u0301tude",
        "quitter",
        "quotient",
        "racine",
        "raconter",
        "radieux",
        "ragondin",
        "raideur",
        "raisin",
        "ralentir",
        "rallonge",
        "ramasser",
        "rapide",
        "rasage",
        "ratisser",
        "ravager",
        "ravin",
        "rayonner",
        "re\u0301actif",
        "re\u0301agir",
        "re\u0301aliser",
        "re\u0301animer",
        "recevoir",
        "re\u0301citer",
        "re\u0301clamer",
        "re\u0301colter",
        "recruter",
        "reculer",
        "recycler",
        "re\u0301diger",
        "redouter",
        "refaire",
        "re\u0301flexe",
        "re\u0301former",
        "refrain",
        "refuge",
        "re\u0301galien",
        "re\u0301gion",
        "re\u0301glage",
        "re\u0301gulier",
        "re\u0301ite\u0301rer",
        "rejeter",
        "rejouer",
        "relatif",
        "relever",
        "relief",
        "remarque",
        "reme\u0300de",
        "remise",
        "remonter",
        "remplir",
        "remuer",
        "renard",
        "renfort",
        "renifler",
        "renoncer",
        "rentrer",
        "renvoi",
        "replier",
        "reporter",
        "reprise",
        "reptile",
        "requin",
        "re\u0301serve",
        "re\u0301sineux",
        "re\u0301soudre",
        "respect",
        "rester",
        "re\u0301sultat",
        "re\u0301tablir",
        "retenir",
        "re\u0301ticule",
        "retomber",
        "retracer",
        "re\u0301union",
        "re\u0301ussir",
        "revanche",
        "revivre",
        "re\u0301volte",
        "re\u0301vulsif",
        "richesse",
        "rideau",
        "rieur",
        "rigide",
        "rigoler",
        "rincer",
        "riposter",
        "risible",
        "risque",
        "rituel",
        "rival",
        "rivie\u0300re",
        "rocheux",
        "romance",
        "rompre",
        "ronce",
        "rondin",
        "roseau",
        "rosier",
        "rotatif",
        "rotor",
        "rotule",
        "rouge",
        "rouille",
        "rouleau",
        "routine",
        "royaume",
        "ruban",
        "rubis",
        "ruche",
        "ruelle",
        "rugueux",
        "ruiner",
        "ruisseau",
        "ruser",
        "rustique",
        "rythme",
        "sabler",
        "saboter",
        "sabre",
        "sacoche",
        "safari",
        "sagesse",
        "saisir",
        "salade",
        "salive",
        "salon",
        "saluer",
        "samedi",
        "sanction",
        "sanglier",
        "sarcasme",
        "sardine",
        "saturer",
        "saugrenu",
        "saumon",
        "sauter",
        "sauvage",
        "savant",
        "savonner",
        "scalpel",
        "scandale",
        "sce\u0301le\u0301rat",
        "sce\u0301nario",
        "sceptre",
        "sche\u0301ma",
        "science",
        "scinder",
        "score",
        "scrutin",
        "sculpter",
        "se\u0301ance",
        "se\u0301cable",
        "se\u0301cher",
        "secouer",
        "se\u0301cre\u0301ter",
        "se\u0301datif",
        "se\u0301duire",
        "seigneur",
        "se\u0301jour",
        "se\u0301lectif",
        "semaine",
        "sembler",
        "semence",
        "se\u0301minal",
        "se\u0301nateur",
        "sensible",
        "sentence",
        "se\u0301parer",
        "se\u0301quence",
        "serein",
        "sergent",
        "se\u0301rieux",
        "serrure",
        "se\u0301rum",
        "service",
        "se\u0301same",
        "se\u0301vir",
        "sevrage",
        "sextuple",
        "side\u0301ral",
        "sie\u0300cle",
        "sie\u0301ger",
        "siffler",
        "sigle",
        "signal",
        "silence",
        "silicium",
        "simple",
        "since\u0300re",
        "sinistre",
        "siphon",
        "sirop",
        "sismique",
        "situer",
        "skier",
        "social",
        "socle",
        "sodium",
        "soigneux",
        "soldat",
        "soleil",
        "solitude",
        "soluble",
        "sombre",
        "sommeil",
        "somnoler",
        "sonde",
        "songeur",
        "sonnette",
        "sonore",
        "sorcier",
        "sortir",
        "sosie",
        "sottise",
        "soucieux",
        "soudure",
        "souffle",
        "soulever",
        "soupape",
        "source",
        "soutirer",
        "souvenir",
        "spacieux",
        "spatial",
        "spe\u0301cial",
        "sphe\u0300re",
        "spiral",
        "stable",
        "station",
        "sternum",
        "stimulus",
        "stipuler",
        "strict",
        "studieux",
        "stupeur",
        "styliste",
        "sublime",
        "substrat",
        "subtil",
        "subvenir",
        "succe\u0300s",
        "sucre",
        "suffixe",
        "sugge\u0301rer",
        "suiveur",
        "sulfate",
        "superbe",
        "supplier",
        "surface",
        "suricate",
        "surmener",
        "surprise",
        "sursaut",
        "survie",
        "suspect",
        "syllabe",
        "symbole",
        "syme\u0301trie",
        "synapse",
        "syntaxe",
        "syste\u0300me",
        "tabac",
        "tablier",
        "tactile",
        "tailler",
        "talent",
        "talisman",
        "talonner",
        "tambour",
        "tamiser",
        "tangible",
        "tapis",
        "taquiner",
        "tarder",
        "tarif",
        "tartine",
        "tasse",
        "tatami",
        "tatouage",
        "taupe",
        "taureau",
        "taxer",
        "te\u0301moin",
        "temporel",
        "tenaille",
        "tendre",
        "teneur",
        "tenir",
        "tension",
        "terminer",
        "terne",
        "terrible",
        "te\u0301tine",
        "texte",
        "the\u0300me",
        "the\u0301orie",
        "the\u0301rapie",
        "thorax",
        "tibia",
        "tie\u0300de",
        "timide",
        "tirelire",
        "tiroir",
        "tissu",
        "titane",
        "titre",
        "tituber",
        "toboggan",
        "tole\u0301rant",
        "tomate",
        "tonique",
        "tonneau",
        "toponyme",
        "torche",
        "tordre",
        "tornade",
        "torpille",
        "torrent",
        "torse",
        "tortue",
        "totem",
        "toucher",
        "tournage",
        "tousser",
        "toxine",
        "traction",
        "trafic",
        "tragique",
        "trahir",
        "train",
        "trancher",
        "travail",
        "tre\u0300fle",
        "tremper",
        "tre\u0301sor",
        "treuil",
        "triage",
        "tribunal",
        "tricoter",
        "trilogie",
        "triomphe",
        "tripler",
        "triturer",
        "trivial",
        "trombone",
        "tronc",
        "tropical",
        "troupeau",
        "tuile",
        "tulipe",
        "tumulte",
        "tunnel",
        "turbine",
        "tuteur",
        "tutoyer",
        "tuyau",
        "tympan",
        "typhon",
        "typique",
        "tyran",
        "ubuesque",
        "ultime",
        "ultrason",
        "unanime",
        "unifier",
        "union",
        "unique",
        "unitaire",
        "univers",
        "uranium",
        "urbain",
        "urticant",
        "usage",
        "usine",
        "usuel",
        "usure",
        "utile",
        "utopie",
        "vacarme",
        "vaccin",
        "vagabond",
        "vague",
        "vaillant",
        "vaincre",
        "vaisseau",
        "valable",
        "valise",
        "vallon",
        "valve",
        "vampire",
        "vanille",
        "vapeur",
        "varier",
        "vaseux",
        "vassal",
        "vaste",
        "vecteur",
        "vedette",
        "ve\u0301ge\u0301tal",
        "ve\u0301hicule",
        "veinard",
        "ve\u0301loce",
        "vendredi",
        "ve\u0301ne\u0301rer",
        "venger",
        "venimeux",
        "ventouse",
        "verdure",
        "ve\u0301rin",
        "vernir",
        "verrou",
        "verser",
        "vertu",
        "veston",
        "ve\u0301te\u0301ran",
        "ve\u0301tuste",
        "vexant",
        "vexer",
        "viaduc",
        "viande",
        "victoire",
        "vidange",
        "vide\u0301o",
        "vignette",
        "vigueur",
        "vilain",
        "village",
        "vinaigre",
        "violon",
        "vipe\u0300re",
        "virement",
        "virtuose",
        "virus",
        "visage",
        "viseur",
        "vision",
        "visqueux",
        "visuel",
        "vital",
        "vitesse",
        "viticole",
        "vitrine",
        "vivace",
        "vivipare",
        "vocation",
        "voguer",
        "voile",
        "voisin",
        "voiture",
        "volaille",
        "volcan",
        "voltiger",
        "volume",
        "vorace",
        "vortex",
        "voter",
        "vouloir",
        "voyage",
        "voyelle",
        "wagon",
        "xe\u0301non",
        "yacht",
        "ze\u0300bre",
        "ze\u0301nith",
        "zeste",
        "zoologie"
      ];
    }
  });

  // node_modules/bip39/src/wordlists/italian.json
  var require_italian = __commonJS({
    "node_modules/bip39/src/wordlists/italian.json"(exports9, module) {
      module.exports = [
        "abaco",
        "abbaglio",
        "abbinato",
        "abete",
        "abisso",
        "abolire",
        "abrasivo",
        "abrogato",
        "accadere",
        "accenno",
        "accusato",
        "acetone",
        "achille",
        "acido",
        "acqua",
        "acre",
        "acrilico",
        "acrobata",
        "acuto",
        "adagio",
        "addebito",
        "addome",
        "adeguato",
        "aderire",
        "adipe",
        "adottare",
        "adulare",
        "affabile",
        "affetto",
        "affisso",
        "affranto",
        "aforisma",
        "afoso",
        "africano",
        "agave",
        "agente",
        "agevole",
        "aggancio",
        "agire",
        "agitare",
        "agonismo",
        "agricolo",
        "agrumeto",
        "aguzzo",
        "alabarda",
        "alato",
        "albatro",
        "alberato",
        "albo",
        "albume",
        "alce",
        "alcolico",
        "alettone",
        "alfa",
        "algebra",
        "aliante",
        "alibi",
        "alimento",
        "allagato",
        "allegro",
        "allievo",
        "allodola",
        "allusivo",
        "almeno",
        "alogeno",
        "alpaca",
        "alpestre",
        "altalena",
        "alterno",
        "alticcio",
        "altrove",
        "alunno",
        "alveolo",
        "alzare",
        "amalgama",
        "amanita",
        "amarena",
        "ambito",
        "ambrato",
        "ameba",
        "america",
        "ametista",
        "amico",
        "ammasso",
        "ammenda",
        "ammirare",
        "ammonito",
        "amore",
        "ampio",
        "ampliare",
        "amuleto",
        "anacardo",
        "anagrafe",
        "analista",
        "anarchia",
        "anatra",
        "anca",
        "ancella",
        "ancora",
        "andare",
        "andrea",
        "anello",
        "angelo",
        "angolare",
        "angusto",
        "anima",
        "annegare",
        "annidato",
        "anno",
        "annuncio",
        "anonimo",
        "anticipo",
        "anzi",
        "apatico",
        "apertura",
        "apode",
        "apparire",
        "appetito",
        "appoggio",
        "approdo",
        "appunto",
        "aprile",
        "arabica",
        "arachide",
        "aragosta",
        "araldica",
        "arancio",
        "aratura",
        "arazzo",
        "arbitro",
        "archivio",
        "ardito",
        "arenile",
        "argento",
        "argine",
        "arguto",
        "aria",
        "armonia",
        "arnese",
        "arredato",
        "arringa",
        "arrosto",
        "arsenico",
        "arso",
        "artefice",
        "arzillo",
        "asciutto",
        "ascolto",
        "asepsi",
        "asettico",
        "asfalto",
        "asino",
        "asola",
        "aspirato",
        "aspro",
        "assaggio",
        "asse",
        "assoluto",
        "assurdo",
        "asta",
        "astenuto",
        "astice",
        "astratto",
        "atavico",
        "ateismo",
        "atomico",
        "atono",
        "attesa",
        "attivare",
        "attorno",
        "attrito",
        "attuale",
        "ausilio",
        "austria",
        "autista",
        "autonomo",
        "autunno",
        "avanzato",
        "avere",
        "avvenire",
        "avviso",
        "avvolgere",
        "azione",
        "azoto",
        "azzimo",
        "azzurro",
        "babele",
        "baccano",
        "bacino",
        "baco",
        "badessa",
        "badilata",
        "bagnato",
        "baita",
        "balcone",
        "baldo",
        "balena",
        "ballata",
        "balzano",
        "bambino",
        "bandire",
        "baraonda",
        "barbaro",
        "barca",
        "baritono",
        "barlume",
        "barocco",
        "basilico",
        "basso",
        "batosta",
        "battuto",
        "baule",
        "bava",
        "bavosa",
        "becco",
        "beffa",
        "belgio",
        "belva",
        "benda",
        "benevole",
        "benigno",
        "benzina",
        "bere",
        "berlina",
        "beta",
        "bibita",
        "bici",
        "bidone",
        "bifido",
        "biga",
        "bilancia",
        "bimbo",
        "binocolo",
        "biologo",
        "bipede",
        "bipolare",
        "birbante",
        "birra",
        "biscotto",
        "bisesto",
        "bisnonno",
        "bisonte",
        "bisturi",
        "bizzarro",
        "blando",
        "blatta",
        "bollito",
        "bonifico",
        "bordo",
        "bosco",
        "botanico",
        "bottino",
        "bozzolo",
        "braccio",
        "bradipo",
        "brama",
        "branca",
        "bravura",
        "bretella",
        "brevetto",
        "brezza",
        "briglia",
        "brillante",
        "brindare",
        "broccolo",
        "brodo",
        "bronzina",
        "brullo",
        "bruno",
        "bubbone",
        "buca",
        "budino",
        "buffone",
        "buio",
        "bulbo",
        "buono",
        "burlone",
        "burrasca",
        "bussola",
        "busta",
        "cadetto",
        "caduco",
        "calamaro",
        "calcolo",
        "calesse",
        "calibro",
        "calmo",
        "caloria",
        "cambusa",
        "camerata",
        "camicia",
        "cammino",
        "camola",
        "campale",
        "canapa",
        "candela",
        "cane",
        "canino",
        "canotto",
        "cantina",
        "capace",
        "capello",
        "capitolo",
        "capogiro",
        "cappero",
        "capra",
        "capsula",
        "carapace",
        "carcassa",
        "cardo",
        "carisma",
        "carovana",
        "carretto",
        "cartolina",
        "casaccio",
        "cascata",
        "caserma",
        "caso",
        "cassone",
        "castello",
        "casuale",
        "catasta",
        "catena",
        "catrame",
        "cauto",
        "cavillo",
        "cedibile",
        "cedrata",
        "cefalo",
        "celebre",
        "cellulare",
        "cena",
        "cenone",
        "centesimo",
        "ceramica",
        "cercare",
        "certo",
        "cerume",
        "cervello",
        "cesoia",
        "cespo",
        "ceto",
        "chela",
        "chiaro",
        "chicca",
        "chiedere",
        "chimera",
        "china",
        "chirurgo",
        "chitarra",
        "ciao",
        "ciclismo",
        "cifrare",
        "cigno",
        "cilindro",
        "ciottolo",
        "circa",
        "cirrosi",
        "citrico",
        "cittadino",
        "ciuffo",
        "civetta",
        "civile",
        "classico",
        "clinica",
        "cloro",
        "cocco",
        "codardo",
        "codice",
        "coerente",
        "cognome",
        "collare",
        "colmato",
        "colore",
        "colposo",
        "coltivato",
        "colza",
        "coma",
        "cometa",
        "commando",
        "comodo",
        "computer",
        "comune",
        "conciso",
        "condurre",
        "conferma",
        "congelare",
        "coniuge",
        "connesso",
        "conoscere",
        "consumo",
        "continuo",
        "convegno",
        "coperto",
        "copione",
        "coppia",
        "copricapo",
        "corazza",
        "cordata",
        "coricato",
        "cornice",
        "corolla",
        "corpo",
        "corredo",
        "corsia",
        "cortese",
        "cosmico",
        "costante",
        "cottura",
        "covato",
        "cratere",
        "cravatta",
        "creato",
        "credere",
        "cremoso",
        "crescita",
        "creta",
        "criceto",
        "crinale",
        "crisi",
        "critico",
        "croce",
        "cronaca",
        "crostata",
        "cruciale",
        "crusca",
        "cucire",
        "cuculo",
        "cugino",
        "cullato",
        "cupola",
        "curatore",
        "cursore",
        "curvo",
        "cuscino",
        "custode",
        "dado",
        "daino",
        "dalmata",
        "damerino",
        "daniela",
        "dannoso",
        "danzare",
        "datato",
        "davanti",
        "davvero",
        "debutto",
        "decennio",
        "deciso",
        "declino",
        "decollo",
        "decreto",
        "dedicato",
        "definito",
        "deforme",
        "degno",
        "delegare",
        "delfino",
        "delirio",
        "delta",
        "demenza",
        "denotato",
        "dentro",
        "deposito",
        "derapata",
        "derivare",
        "deroga",
        "descritto",
        "deserto",
        "desiderio",
        "desumere",
        "detersivo",
        "devoto",
        "diametro",
        "dicembre",
        "diedro",
        "difeso",
        "diffuso",
        "digerire",
        "digitale",
        "diluvio",
        "dinamico",
        "dinnanzi",
        "dipinto",
        "diploma",
        "dipolo",
        "diradare",
        "dire",
        "dirotto",
        "dirupo",
        "disagio",
        "discreto",
        "disfare",
        "disgelo",
        "disposto",
        "distanza",
        "disumano",
        "dito",
        "divano",
        "divelto",
        "dividere",
        "divorato",
        "doblone",
        "docente",
        "doganale",
        "dogma",
        "dolce",
        "domato",
        "domenica",
        "dominare",
        "dondolo",
        "dono",
        "dormire",
        "dote",
        "dottore",
        "dovuto",
        "dozzina",
        "drago",
        "druido",
        "dubbio",
        "dubitare",
        "ducale",
        "duna",
        "duomo",
        "duplice",
        "duraturo",
        "ebano",
        "eccesso",
        "ecco",
        "eclissi",
        "economia",
        "edera",
        "edicola",
        "edile",
        "editoria",
        "educare",
        "egemonia",
        "egli",
        "egoismo",
        "egregio",
        "elaborato",
        "elargire",
        "elegante",
        "elencato",
        "eletto",
        "elevare",
        "elfico",
        "elica",
        "elmo",
        "elsa",
        "eluso",
        "emanato",
        "emblema",
        "emesso",
        "emiro",
        "emotivo",
        "emozione",
        "empirico",
        "emulo",
        "endemico",
        "enduro",
        "energia",
        "enfasi",
        "enoteca",
        "entrare",
        "enzima",
        "epatite",
        "epilogo",
        "episodio",
        "epocale",
        "eppure",
        "equatore",
        "erario",
        "erba",
        "erboso",
        "erede",
        "eremita",
        "erigere",
        "ermetico",
        "eroe",
        "erosivo",
        "errante",
        "esagono",
        "esame",
        "esanime",
        "esaudire",
        "esca",
        "esempio",
        "esercito",
        "esibito",
        "esigente",
        "esistere",
        "esito",
        "esofago",
        "esortato",
        "esoso",
        "espanso",
        "espresso",
        "essenza",
        "esso",
        "esteso",
        "estimare",
        "estonia",
        "estroso",
        "esultare",
        "etilico",
        "etnico",
        "etrusco",
        "etto",
        "euclideo",
        "europa",
        "evaso",
        "evidenza",
        "evitato",
        "evoluto",
        "evviva",
        "fabbrica",
        "faccenda",
        "fachiro",
        "falco",
        "famiglia",
        "fanale",
        "fanfara",
        "fango",
        "fantasma",
        "fare",
        "farfalla",
        "farinoso",
        "farmaco",
        "fascia",
        "fastoso",
        "fasullo",
        "faticare",
        "fato",
        "favoloso",
        "febbre",
        "fecola",
        "fede",
        "fegato",
        "felpa",
        "feltro",
        "femmina",
        "fendere",
        "fenomeno",
        "fermento",
        "ferro",
        "fertile",
        "fessura",
        "festivo",
        "fetta",
        "feudo",
        "fiaba",
        "fiducia",
        "fifa",
        "figurato",
        "filo",
        "finanza",
        "finestra",
        "finire",
        "fiore",
        "fiscale",
        "fisico",
        "fiume",
        "flacone",
        "flamenco",
        "flebo",
        "flemma",
        "florido",
        "fluente",
        "fluoro",
        "fobico",
        "focaccia",
        "focoso",
        "foderato",
        "foglio",
        "folata",
        "folclore",
        "folgore",
        "fondente",
        "fonetico",
        "fonia",
        "fontana",
        "forbito",
        "forchetta",
        "foresta",
        "formica",
        "fornaio",
        "foro",
        "fortezza",
        "forzare",
        "fosfato",
        "fosso",
        "fracasso",
        "frana",
        "frassino",
        "fratello",
        "freccetta",
        "frenata",
        "fresco",
        "frigo",
        "frollino",
        "fronde",
        "frugale",
        "frutta",
        "fucilata",
        "fucsia",
        "fuggente",
        "fulmine",
        "fulvo",
        "fumante",
        "fumetto",
        "fumoso",
        "fune",
        "funzione",
        "fuoco",
        "furbo",
        "furgone",
        "furore",
        "fuso",
        "futile",
        "gabbiano",
        "gaffe",
        "galateo",
        "gallina",
        "galoppo",
        "gambero",
        "gamma",
        "garanzia",
        "garbo",
        "garofano",
        "garzone",
        "gasdotto",
        "gasolio",
        "gastrico",
        "gatto",
        "gaudio",
        "gazebo",
        "gazzella",
        "geco",
        "gelatina",
        "gelso",
        "gemello",
        "gemmato",
        "gene",
        "genitore",
        "gennaio",
        "genotipo",
        "gergo",
        "ghepardo",
        "ghiaccio",
        "ghisa",
        "giallo",
        "gilda",
        "ginepro",
        "giocare",
        "gioiello",
        "giorno",
        "giove",
        "girato",
        "girone",
        "gittata",
        "giudizio",
        "giurato",
        "giusto",
        "globulo",
        "glutine",
        "gnomo",
        "gobba",
        "golf",
        "gomito",
        "gommone",
        "gonfio",
        "gonna",
        "governo",
        "gracile",
        "grado",
        "grafico",
        "grammo",
        "grande",
        "grattare",
        "gravoso",
        "grazia",
        "greca",
        "gregge",
        "grifone",
        "grigio",
        "grinza",
        "grotta",
        "gruppo",
        "guadagno",
        "guaio",
        "guanto",
        "guardare",
        "gufo",
        "guidare",
        "ibernato",
        "icona",
        "identico",
        "idillio",
        "idolo",
        "idra",
        "idrico",
        "idrogeno",
        "igiene",
        "ignaro",
        "ignorato",
        "ilare",
        "illeso",
        "illogico",
        "illudere",
        "imballo",
        "imbevuto",
        "imbocco",
        "imbuto",
        "immane",
        "immerso",
        "immolato",
        "impacco",
        "impeto",
        "impiego",
        "importo",
        "impronta",
        "inalare",
        "inarcare",
        "inattivo",
        "incanto",
        "incendio",
        "inchino",
        "incisivo",
        "incluso",
        "incontro",
        "incrocio",
        "incubo",
        "indagine",
        "india",
        "indole",
        "inedito",
        "infatti",
        "infilare",
        "inflitto",
        "ingaggio",
        "ingegno",
        "inglese",
        "ingordo",
        "ingrosso",
        "innesco",
        "inodore",
        "inoltrare",
        "inondato",
        "insano",
        "insetto",
        "insieme",
        "insonnia",
        "insulina",
        "intasato",
        "intero",
        "intonaco",
        "intuito",
        "inumidire",
        "invalido",
        "invece",
        "invito",
        "iperbole",
        "ipnotico",
        "ipotesi",
        "ippica",
        "iride",
        "irlanda",
        "ironico",
        "irrigato",
        "irrorare",
        "isolato",
        "isotopo",
        "isterico",
        "istituto",
        "istrice",
        "italia",
        "iterare",
        "labbro",
        "labirinto",
        "lacca",
        "lacerato",
        "lacrima",
        "lacuna",
        "laddove",
        "lago",
        "lampo",
        "lancetta",
        "lanterna",
        "lardoso",
        "larga",
        "laringe",
        "lastra",
        "latenza",
        "latino",
        "lattuga",
        "lavagna",
        "lavoro",
        "legale",
        "leggero",
        "lembo",
        "lentezza",
        "lenza",
        "leone",
        "lepre",
        "lesivo",
        "lessato",
        "lesto",
        "letterale",
        "leva",
        "levigato",
        "libero",
        "lido",
        "lievito",
        "lilla",
        "limatura",
        "limitare",
        "limpido",
        "lineare",
        "lingua",
        "liquido",
        "lira",
        "lirica",
        "lisca",
        "lite",
        "litigio",
        "livrea",
        "locanda",
        "lode",
        "logica",
        "lombare",
        "londra",
        "longevo",
        "loquace",
        "lorenzo",
        "loto",
        "lotteria",
        "luce",
        "lucidato",
        "lumaca",
        "luminoso",
        "lungo",
        "lupo",
        "luppolo",
        "lusinga",
        "lusso",
        "lutto",
        "macabro",
        "macchina",
        "macero",
        "macinato",
        "madama",
        "magico",
        "maglia",
        "magnete",
        "magro",
        "maiolica",
        "malafede",
        "malgrado",
        "malinteso",
        "malsano",
        "malto",
        "malumore",
        "mana",
        "mancia",
        "mandorla",
        "mangiare",
        "manifesto",
        "mannaro",
        "manovra",
        "mansarda",
        "mantide",
        "manubrio",
        "mappa",
        "maratona",
        "marcire",
        "maretta",
        "marmo",
        "marsupio",
        "maschera",
        "massaia",
        "mastino",
        "materasso",
        "matricola",
        "mattone",
        "maturo",
        "mazurca",
        "meandro",
        "meccanico",
        "mecenate",
        "medesimo",
        "meditare",
        "mega",
        "melassa",
        "melis",
        "melodia",
        "meninge",
        "meno",
        "mensola",
        "mercurio",
        "merenda",
        "merlo",
        "meschino",
        "mese",
        "messere",
        "mestolo",
        "metallo",
        "metodo",
        "mettere",
        "miagolare",
        "mica",
        "micelio",
        "michele",
        "microbo",
        "midollo",
        "miele",
        "migliore",
        "milano",
        "milite",
        "mimosa",
        "minerale",
        "mini",
        "minore",
        "mirino",
        "mirtillo",
        "miscela",
        "missiva",
        "misto",
        "misurare",
        "mitezza",
        "mitigare",
        "mitra",
        "mittente",
        "mnemonico",
        "modello",
        "modifica",
        "modulo",
        "mogano",
        "mogio",
        "mole",
        "molosso",
        "monastero",
        "monco",
        "mondina",
        "monetario",
        "monile",
        "monotono",
        "monsone",
        "montato",
        "monviso",
        "mora",
        "mordere",
        "morsicato",
        "mostro",
        "motivato",
        "motosega",
        "motto",
        "movenza",
        "movimento",
        "mozzo",
        "mucca",
        "mucosa",
        "muffa",
        "mughetto",
        "mugnaio",
        "mulatto",
        "mulinello",
        "multiplo",
        "mummia",
        "munto",
        "muovere",
        "murale",
        "musa",
        "muscolo",
        "musica",
        "mutevole",
        "muto",
        "nababbo",
        "nafta",
        "nanometro",
        "narciso",
        "narice",
        "narrato",
        "nascere",
        "nastrare",
        "naturale",
        "nautica",
        "naviglio",
        "nebulosa",
        "necrosi",
        "negativo",
        "negozio",
        "nemmeno",
        "neofita",
        "neretto",
        "nervo",
        "nessuno",
        "nettuno",
        "neutrale",
        "neve",
        "nevrotico",
        "nicchia",
        "ninfa",
        "nitido",
        "nobile",
        "nocivo",
        "nodo",
        "nome",
        "nomina",
        "nordico",
        "normale",
        "norvegese",
        "nostrano",
        "notare",
        "notizia",
        "notturno",
        "novella",
        "nucleo",
        "nulla",
        "numero",
        "nuovo",
        "nutrire",
        "nuvola",
        "nuziale",
        "oasi",
        "obbedire",
        "obbligo",
        "obelisco",
        "oblio",
        "obolo",
        "obsoleto",
        "occasione",
        "occhio",
        "occidente",
        "occorrere",
        "occultare",
        "ocra",
        "oculato",
        "odierno",
        "odorare",
        "offerta",
        "offrire",
        "offuscato",
        "oggetto",
        "oggi",
        "ognuno",
        "olandese",
        "olfatto",
        "oliato",
        "oliva",
        "ologramma",
        "oltre",
        "omaggio",
        "ombelico",
        "ombra",
        "omega",
        "omissione",
        "ondoso",
        "onere",
        "onice",
        "onnivoro",
        "onorevole",
        "onta",
        "operato",
        "opinione",
        "opposto",
        "oracolo",
        "orafo",
        "ordine",
        "orecchino",
        "orefice",
        "orfano",
        "organico",
        "origine",
        "orizzonte",
        "orma",
        "ormeggio",
        "ornativo",
        "orologio",
        "orrendo",
        "orribile",
        "ortensia",
        "ortica",
        "orzata",
        "orzo",
        "osare",
        "oscurare",
        "osmosi",
        "ospedale",
        "ospite",
        "ossa",
        "ossidare",
        "ostacolo",
        "oste",
        "otite",
        "otre",
        "ottagono",
        "ottimo",
        "ottobre",
        "ovale",
        "ovest",
        "ovino",
        "oviparo",
        "ovocito",
        "ovunque",
        "ovviare",
        "ozio",
        "pacchetto",
        "pace",
        "pacifico",
        "padella",
        "padrone",
        "paese",
        "paga",
        "pagina",
        "palazzina",
        "palesare",
        "pallido",
        "palo",
        "palude",
        "pandoro",
        "pannello",
        "paolo",
        "paonazzo",
        "paprica",
        "parabola",
        "parcella",
        "parere",
        "pargolo",
        "pari",
        "parlato",
        "parola",
        "partire",
        "parvenza",
        "parziale",
        "passivo",
        "pasticca",
        "patacca",
        "patologia",
        "pattume",
        "pavone",
        "peccato",
        "pedalare",
        "pedonale",
        "peggio",
        "peloso",
        "penare",
        "pendice",
        "penisola",
        "pennuto",
        "penombra",
        "pensare",
        "pentola",
        "pepe",
        "pepita",
        "perbene",
        "percorso",
        "perdonato",
        "perforare",
        "pergamena",
        "periodo",
        "permesso",
        "perno",
        "perplesso",
        "persuaso",
        "pertugio",
        "pervaso",
        "pesatore",
        "pesista",
        "peso",
        "pestifero",
        "petalo",
        "pettine",
        "petulante",
        "pezzo",
        "piacere",
        "pianta",
        "piattino",
        "piccino",
        "picozza",
        "piega",
        "pietra",
        "piffero",
        "pigiama",
        "pigolio",
        "pigro",
        "pila",
        "pilifero",
        "pillola",
        "pilota",
        "pimpante",
        "pineta",
        "pinna",
        "pinolo",
        "pioggia",
        "piombo",
        "piramide",
        "piretico",
        "pirite",
        "pirolisi",
        "pitone",
        "pizzico",
        "placebo",
        "planare",
        "plasma",
        "platano",
        "plenario",
        "pochezza",
        "poderoso",
        "podismo",
        "poesia",
        "poggiare",
        "polenta",
        "poligono",
        "pollice",
        "polmonite",
        "polpetta",
        "polso",
        "poltrona",
        "polvere",
        "pomice",
        "pomodoro",
        "ponte",
        "popoloso",
        "porfido",
        "poroso",
        "porpora",
        "porre",
        "portata",
        "posa",
        "positivo",
        "possesso",
        "postulato",
        "potassio",
        "potere",
        "pranzo",
        "prassi",
        "pratica",
        "precluso",
        "predica",
        "prefisso",
        "pregiato",
        "prelievo",
        "premere",
        "prenotare",
        "preparato",
        "presenza",
        "pretesto",
        "prevalso",
        "prima",
        "principe",
        "privato",
        "problema",
        "procura",
        "produrre",
        "profumo",
        "progetto",
        "prolunga",
        "promessa",
        "pronome",
        "proposta",
        "proroga",
        "proteso",
        "prova",
        "prudente",
        "prugna",
        "prurito",
        "psiche",
        "pubblico",
        "pudica",
        "pugilato",
        "pugno",
        "pulce",
        "pulito",
        "pulsante",
        "puntare",
        "pupazzo",
        "pupilla",
        "puro",
        "quadro",
        "qualcosa",
        "quasi",
        "querela",
        "quota",
        "raccolto",
        "raddoppio",
        "radicale",
        "radunato",
        "raffica",
        "ragazzo",
        "ragione",
        "ragno",
        "ramarro",
        "ramingo",
        "ramo",
        "randagio",
        "rantolare",
        "rapato",
        "rapina",
        "rappreso",
        "rasatura",
        "raschiato",
        "rasente",
        "rassegna",
        "rastrello",
        "rata",
        "ravveduto",
        "reale",
        "recepire",
        "recinto",
        "recluta",
        "recondito",
        "recupero",
        "reddito",
        "redimere",
        "regalato",
        "registro",
        "regola",
        "regresso",
        "relazione",
        "remare",
        "remoto",
        "renna",
        "replica",
        "reprimere",
        "reputare",
        "resa",
        "residente",
        "responso",
        "restauro",
        "rete",
        "retina",
        "retorica",
        "rettifica",
        "revocato",
        "riassunto",
        "ribadire",
        "ribelle",
        "ribrezzo",
        "ricarica",
        "ricco",
        "ricevere",
        "riciclato",
        "ricordo",
        "ricreduto",
        "ridicolo",
        "ridurre",
        "rifasare",
        "riflesso",
        "riforma",
        "rifugio",
        "rigare",
        "rigettato",
        "righello",
        "rilassato",
        "rilevato",
        "rimanere",
        "rimbalzo",
        "rimedio",
        "rimorchio",
        "rinascita",
        "rincaro",
        "rinforzo",
        "rinnovo",
        "rinomato",
        "rinsavito",
        "rintocco",
        "rinuncia",
        "rinvenire",
        "riparato",
        "ripetuto",
        "ripieno",
        "riportare",
        "ripresa",
        "ripulire",
        "risata",
        "rischio",
        "riserva",
        "risibile",
        "riso",
        "rispetto",
        "ristoro",
        "risultato",
        "risvolto",
        "ritardo",
        "ritegno",
        "ritmico",
        "ritrovo",
        "riunione",
        "riva",
        "riverso",
        "rivincita",
        "rivolto",
        "rizoma",
        "roba",
        "robotico",
        "robusto",
        "roccia",
        "roco",
        "rodaggio",
        "rodere",
        "roditore",
        "rogito",
        "rollio",
        "romantico",
        "rompere",
        "ronzio",
        "rosolare",
        "rospo",
        "rotante",
        "rotondo",
        "rotula",
        "rovescio",
        "rubizzo",
        "rubrica",
        "ruga",
        "rullino",
        "rumine",
        "rumoroso",
        "ruolo",
        "rupe",
        "russare",
        "rustico",
        "sabato",
        "sabbiare",
        "sabotato",
        "sagoma",
        "salasso",
        "saldatura",
        "salgemma",
        "salivare",
        "salmone",
        "salone",
        "saltare",
        "saluto",
        "salvo",
        "sapere",
        "sapido",
        "saporito",
        "saraceno",
        "sarcasmo",
        "sarto",
        "sassoso",
        "satellite",
        "satira",
        "satollo",
        "saturno",
        "savana",
        "savio",
        "saziato",
        "sbadiglio",
        "sbalzo",
        "sbancato",
        "sbarra",
        "sbattere",
        "sbavare",
        "sbendare",
        "sbirciare",
        "sbloccato",
        "sbocciato",
        "sbrinare",
        "sbruffone",
        "sbuffare",
        "scabroso",
        "scadenza",
        "scala",
        "scambiare",
        "scandalo",
        "scapola",
        "scarso",
        "scatenare",
        "scavato",
        "scelto",
        "scenico",
        "scettro",
        "scheda",
        "schiena",
        "sciarpa",
        "scienza",
        "scindere",
        "scippo",
        "sciroppo",
        "scivolo",
        "sclerare",
        "scodella",
        "scolpito",
        "scomparto",
        "sconforto",
        "scoprire",
        "scorta",
        "scossone",
        "scozzese",
        "scriba",
        "scrollare",
        "scrutinio",
        "scuderia",
        "scultore",
        "scuola",
        "scuro",
        "scusare",
        "sdebitare",
        "sdoganare",
        "seccatura",
        "secondo",
        "sedano",
        "seggiola",
        "segnalato",
        "segregato",
        "seguito",
        "selciato",
        "selettivo",
        "sella",
        "selvaggio",
        "semaforo",
        "sembrare",
        "seme",
        "seminato",
        "sempre",
        "senso",
        "sentire",
        "sepolto",
        "sequenza",
        "serata",
        "serbato",
        "sereno",
        "serio",
        "serpente",
        "serraglio",
        "servire",
        "sestina",
        "setola",
        "settimana",
        "sfacelo",
        "sfaldare",
        "sfamato",
        "sfarzoso",
        "sfaticato",
        "sfera",
        "sfida",
        "sfilato",
        "sfinge",
        "sfocato",
        "sfoderare",
        "sfogo",
        "sfoltire",
        "sforzato",
        "sfratto",
        "sfruttato",
        "sfuggito",
        "sfumare",
        "sfuso",
        "sgabello",
        "sgarbato",
        "sgonfiare",
        "sgorbio",
        "sgrassato",
        "sguardo",
        "sibilo",
        "siccome",
        "sierra",
        "sigla",
        "signore",
        "silenzio",
        "sillaba",
        "simbolo",
        "simpatico",
        "simulato",
        "sinfonia",
        "singolo",
        "sinistro",
        "sino",
        "sintesi",
        "sinusoide",
        "sipario",
        "sisma",
        "sistole",
        "situato",
        "slitta",
        "slogatura",
        "sloveno",
        "smarrito",
        "smemorato",
        "smentito",
        "smeraldo",
        "smilzo",
        "smontare",
        "smottato",
        "smussato",
        "snellire",
        "snervato",
        "snodo",
        "sobbalzo",
        "sobrio",
        "soccorso",
        "sociale",
        "sodale",
        "soffitto",
        "sogno",
        "soldato",
        "solenne",
        "solido",
        "sollazzo",
        "solo",
        "solubile",
        "solvente",
        "somatico",
        "somma",
        "sonda",
        "sonetto",
        "sonnifero",
        "sopire",
        "soppeso",
        "sopra",
        "sorgere",
        "sorpasso",
        "sorriso",
        "sorso",
        "sorteggio",
        "sorvolato",
        "sospiro",
        "sosta",
        "sottile",
        "spada",
        "spalla",
        "spargere",
        "spatola",
        "spavento",
        "spazzola",
        "specie",
        "spedire",
        "spegnere",
        "spelatura",
        "speranza",
        "spessore",
        "spettrale",
        "spezzato",
        "spia",
        "spigoloso",
        "spillato",
        "spinoso",
        "spirale",
        "splendido",
        "sportivo",
        "sposo",
        "spranga",
        "sprecare",
        "spronato",
        "spruzzo",
        "spuntino",
        "squillo",
        "sradicare",
        "srotolato",
        "stabile",
        "stacco",
        "staffa",
        "stagnare",
        "stampato",
        "stantio",
        "starnuto",
        "stasera",
        "statuto",
        "stelo",
        "steppa",
        "sterzo",
        "stiletto",
        "stima",
        "stirpe",
        "stivale",
        "stizzoso",
        "stonato",
        "storico",
        "strappo",
        "stregato",
        "stridulo",
        "strozzare",
        "strutto",
        "stuccare",
        "stufo",
        "stupendo",
        "subentro",
        "succoso",
        "sudore",
        "suggerito",
        "sugo",
        "sultano",
        "suonare",
        "superbo",
        "supporto",
        "surgelato",
        "surrogato",
        "sussurro",
        "sutura",
        "svagare",
        "svedese",
        "sveglio",
        "svelare",
        "svenuto",
        "svezia",
        "sviluppo",
        "svista",
        "svizzera",
        "svolta",
        "svuotare",
        "tabacco",
        "tabulato",
        "tacciare",
        "taciturno",
        "tale",
        "talismano",
        "tampone",
        "tannino",
        "tara",
        "tardivo",
        "targato",
        "tariffa",
        "tarpare",
        "tartaruga",
        "tasto",
        "tattico",
        "taverna",
        "tavolata",
        "tazza",
        "teca",
        "tecnico",
        "telefono",
        "temerario",
        "tempo",
        "temuto",
        "tendone",
        "tenero",
        "tensione",
        "tentacolo",
        "teorema",
        "terme",
        "terrazzo",
        "terzetto",
        "tesi",
        "tesserato",
        "testato",
        "tetro",
        "tettoia",
        "tifare",
        "tigella",
        "timbro",
        "tinto",
        "tipico",
        "tipografo",
        "tiraggio",
        "tiro",
        "titanio",
        "titolo",
        "titubante",
        "tizio",
        "tizzone",
        "toccare",
        "tollerare",
        "tolto",
        "tombola",
        "tomo",
        "tonfo",
        "tonsilla",
        "topazio",
        "topologia",
        "toppa",
        "torba",
        "tornare",
        "torrone",
        "tortora",
        "toscano",
        "tossire",
        "tostatura",
        "totano",
        "trabocco",
        "trachea",
        "trafila",
        "tragedia",
        "tralcio",
        "tramonto",
        "transito",
        "trapano",
        "trarre",
        "trasloco",
        "trattato",
        "trave",
        "treccia",
        "tremolio",
        "trespolo",
        "tributo",
        "tricheco",
        "trifoglio",
        "trillo",
        "trincea",
        "trio",
        "tristezza",
        "triturato",
        "trivella",
        "tromba",
        "trono",
        "troppo",
        "trottola",
        "trovare",
        "truccato",
        "tubatura",
        "tuffato",
        "tulipano",
        "tumulto",
        "tunisia",
        "turbare",
        "turchino",
        "tuta",
        "tutela",
        "ubicato",
        "uccello",
        "uccisore",
        "udire",
        "uditivo",
        "uffa",
        "ufficio",
        "uguale",
        "ulisse",
        "ultimato",
        "umano",
        "umile",
        "umorismo",
        "uncinetto",
        "ungere",
        "ungherese",
        "unicorno",
        "unificato",
        "unisono",
        "unitario",
        "unte",
        "uovo",
        "upupa",
        "uragano",
        "urgenza",
        "urlo",
        "usanza",
        "usato",
        "uscito",
        "usignolo",
        "usuraio",
        "utensile",
        "utilizzo",
        "utopia",
        "vacante",
        "vaccinato",
        "vagabondo",
        "vagliato",
        "valanga",
        "valgo",
        "valico",
        "valletta",
        "valoroso",
        "valutare",
        "valvola",
        "vampata",
        "vangare",
        "vanitoso",
        "vano",
        "vantaggio",
        "vanvera",
        "vapore",
        "varano",
        "varcato",
        "variante",
        "vasca",
        "vedetta",
        "vedova",
        "veduto",
        "vegetale",
        "veicolo",
        "velcro",
        "velina",
        "velluto",
        "veloce",
        "venato",
        "vendemmia",
        "vento",
        "verace",
        "verbale",
        "vergogna",
        "verifica",
        "vero",
        "verruca",
        "verticale",
        "vescica",
        "vessillo",
        "vestale",
        "veterano",
        "vetrina",
        "vetusto",
        "viandante",
        "vibrante",
        "vicenda",
        "vichingo",
        "vicinanza",
        "vidimare",
        "vigilia",
        "vigneto",
        "vigore",
        "vile",
        "villano",
        "vimini",
        "vincitore",
        "viola",
        "vipera",
        "virgola",
        "virologo",
        "virulento",
        "viscoso",
        "visione",
        "vispo",
        "vissuto",
        "visura",
        "vita",
        "vitello",
        "vittima",
        "vivanda",
        "vivido",
        "viziare",
        "voce",
        "voga",
        "volatile",
        "volere",
        "volpe",
        "voragine",
        "vulcano",
        "zampogna",
        "zanna",
        "zappato",
        "zattera",
        "zavorra",
        "zefiro",
        "zelante",
        "zelo",
        "zenzero",
        "zerbino",
        "zibetto",
        "zinco",
        "zircone",
        "zitto",
        "zolla",
        "zotico",
        "zucchero",
        "zufolo",
        "zulu",
        "zuppa"
      ];
    }
  });

  // node_modules/bip39/src/wordlists/spanish.json
  var require_spanish = __commonJS({
    "node_modules/bip39/src/wordlists/spanish.json"(exports9, module) {
      module.exports = [
        "a\u0301baco",
        "abdomen",
        "abeja",
        "abierto",
        "abogado",
        "abono",
        "aborto",
        "abrazo",
        "abrir",
        "abuelo",
        "abuso",
        "acabar",
        "academia",
        "acceso",
        "accio\u0301n",
        "aceite",
        "acelga",
        "acento",
        "aceptar",
        "a\u0301cido",
        "aclarar",
        "acne\u0301",
        "acoger",
        "acoso",
        "activo",
        "acto",
        "actriz",
        "actuar",
        "acudir",
        "acuerdo",
        "acusar",
        "adicto",
        "admitir",
        "adoptar",
        "adorno",
        "aduana",
        "adulto",
        "ae\u0301reo",
        "afectar",
        "aficio\u0301n",
        "afinar",
        "afirmar",
        "a\u0301gil",
        "agitar",
        "agoni\u0301a",
        "agosto",
        "agotar",
        "agregar",
        "agrio",
        "agua",
        "agudo",
        "a\u0301guila",
        "aguja",
        "ahogo",
        "ahorro",
        "aire",
        "aislar",
        "ajedrez",
        "ajeno",
        "ajuste",
        "alacra\u0301n",
        "alambre",
        "alarma",
        "alba",
        "a\u0301lbum",
        "alcalde",
        "aldea",
        "alegre",
        "alejar",
        "alerta",
        "aleta",
        "alfiler",
        "alga",
        "algodo\u0301n",
        "aliado",
        "aliento",
        "alivio",
        "alma",
        "almeja",
        "almi\u0301bar",
        "altar",
        "alteza",
        "altivo",
        "alto",
        "altura",
        "alumno",
        "alzar",
        "amable",
        "amante",
        "amapola",
        "amargo",
        "amasar",
        "a\u0301mbar",
        "a\u0301mbito",
        "ameno",
        "amigo",
        "amistad",
        "amor",
        "amparo",
        "amplio",
        "ancho",
        "anciano",
        "ancla",
        "andar",
        "ande\u0301n",
        "anemia",
        "a\u0301ngulo",
        "anillo",
        "a\u0301nimo",
        "ani\u0301s",
        "anotar",
        "antena",
        "antiguo",
        "antojo",
        "anual",
        "anular",
        "anuncio",
        "an\u0303adir",
        "an\u0303ejo",
        "an\u0303o",
        "apagar",
        "aparato",
        "apetito",
        "apio",
        "aplicar",
        "apodo",
        "aporte",
        "apoyo",
        "aprender",
        "aprobar",
        "apuesta",
        "apuro",
        "arado",
        "aran\u0303a",
        "arar",
        "a\u0301rbitro",
        "a\u0301rbol",
        "arbusto",
        "archivo",
        "arco",
        "arder",
        "ardilla",
        "arduo",
        "a\u0301rea",
        "a\u0301rido",
        "aries",
        "armoni\u0301a",
        "arne\u0301s",
        "aroma",
        "arpa",
        "arpo\u0301n",
        "arreglo",
        "arroz",
        "arruga",
        "arte",
        "artista",
        "asa",
        "asado",
        "asalto",
        "ascenso",
        "asegurar",
        "aseo",
        "asesor",
        "asiento",
        "asilo",
        "asistir",
        "asno",
        "asombro",
        "a\u0301spero",
        "astilla",
        "astro",
        "astuto",
        "asumir",
        "asunto",
        "atajo",
        "ataque",
        "atar",
        "atento",
        "ateo",
        "a\u0301tico",
        "atleta",
        "a\u0301tomo",
        "atraer",
        "atroz",
        "atu\u0301n",
        "audaz",
        "audio",
        "auge",
        "aula",
        "aumento",
        "ausente",
        "autor",
        "aval",
        "avance",
        "avaro",
        "ave",
        "avellana",
        "avena",
        "avestruz",
        "avio\u0301n",
        "aviso",
        "ayer",
        "ayuda",
        "ayuno",
        "azafra\u0301n",
        "azar",
        "azote",
        "azu\u0301car",
        "azufre",
        "azul",
        "baba",
        "babor",
        "bache",
        "bahi\u0301a",
        "baile",
        "bajar",
        "balanza",
        "balco\u0301n",
        "balde",
        "bambu\u0301",
        "banco",
        "banda",
        "ban\u0303o",
        "barba",
        "barco",
        "barniz",
        "barro",
        "ba\u0301scula",
        "basto\u0301n",
        "basura",
        "batalla",
        "bateri\u0301a",
        "batir",
        "batuta",
        "bau\u0301l",
        "bazar",
        "bebe\u0301",
        "bebida",
        "bello",
        "besar",
        "beso",
        "bestia",
        "bicho",
        "bien",
        "bingo",
        "blanco",
        "bloque",
        "blusa",
        "boa",
        "bobina",
        "bobo",
        "boca",
        "bocina",
        "boda",
        "bodega",
        "boina",
        "bola",
        "bolero",
        "bolsa",
        "bomba",
        "bondad",
        "bonito",
        "bono",
        "bonsa\u0301i",
        "borde",
        "borrar",
        "bosque",
        "bote",
        "boti\u0301n",
        "bo\u0301veda",
        "bozal",
        "bravo",
        "brazo",
        "brecha",
        "breve",
        "brillo",
        "brinco",
        "brisa",
        "broca",
        "broma",
        "bronce",
        "brote",
        "bruja",
        "brusco",
        "bruto",
        "buceo",
        "bucle",
        "bueno",
        "buey",
        "bufanda",
        "bufo\u0301n",
        "bu\u0301ho",
        "buitre",
        "bulto",
        "burbuja",
        "burla",
        "burro",
        "buscar",
        "butaca",
        "buzo\u0301n",
        "caballo",
        "cabeza",
        "cabina",
        "cabra",
        "cacao",
        "cada\u0301ver",
        "cadena",
        "caer",
        "cafe\u0301",
        "cai\u0301da",
        "caima\u0301n",
        "caja",
        "cajo\u0301n",
        "cal",
        "calamar",
        "calcio",
        "caldo",
        "calidad",
        "calle",
        "calma",
        "calor",
        "calvo",
        "cama",
        "cambio",
        "camello",
        "camino",
        "campo",
        "ca\u0301ncer",
        "candil",
        "canela",
        "canguro",
        "canica",
        "canto",
        "can\u0303a",
        "can\u0303o\u0301n",
        "caoba",
        "caos",
        "capaz",
        "capita\u0301n",
        "capote",
        "captar",
        "capucha",
        "cara",
        "carbo\u0301n",
        "ca\u0301rcel",
        "careta",
        "carga",
        "carin\u0303o",
        "carne",
        "carpeta",
        "carro",
        "carta",
        "casa",
        "casco",
        "casero",
        "caspa",
        "castor",
        "catorce",
        "catre",
        "caudal",
        "causa",
        "cazo",
        "cebolla",
        "ceder",
        "cedro",
        "celda",
        "ce\u0301lebre",
        "celoso",
        "ce\u0301lula",
        "cemento",
        "ceniza",
        "centro",
        "cerca",
        "cerdo",
        "cereza",
        "cero",
        "cerrar",
        "certeza",
        "ce\u0301sped",
        "cetro",
        "chacal",
        "chaleco",
        "champu\u0301",
        "chancla",
        "chapa",
        "charla",
        "chico",
        "chiste",
        "chivo",
        "choque",
        "choza",
        "chuleta",
        "chupar",
        "ciclo\u0301n",
        "ciego",
        "cielo",
        "cien",
        "cierto",
        "cifra",
        "cigarro",
        "cima",
        "cinco",
        "cine",
        "cinta",
        "cipre\u0301s",
        "circo",
        "ciruela",
        "cisne",
        "cita",
        "ciudad",
        "clamor",
        "clan",
        "claro",
        "clase",
        "clave",
        "cliente",
        "clima",
        "cli\u0301nica",
        "cobre",
        "coccio\u0301n",
        "cochino",
        "cocina",
        "coco",
        "co\u0301digo",
        "codo",
        "cofre",
        "coger",
        "cohete",
        "coji\u0301n",
        "cojo",
        "cola",
        "colcha",
        "colegio",
        "colgar",
        "colina",
        "collar",
        "colmo",
        "columna",
        "combate",
        "comer",
        "comida",
        "co\u0301modo",
        "compra",
        "conde",
        "conejo",
        "conga",
        "conocer",
        "consejo",
        "contar",
        "copa",
        "copia",
        "corazo\u0301n",
        "corbata",
        "corcho",
        "cordo\u0301n",
        "corona",
        "correr",
        "coser",
        "cosmos",
        "costa",
        "cra\u0301neo",
        "cra\u0301ter",
        "crear",
        "crecer",
        "crei\u0301do",
        "crema",
        "cri\u0301a",
        "crimen",
        "cripta",
        "crisis",
        "cromo",
        "cro\u0301nica",
        "croqueta",
        "crudo",
        "cruz",
        "cuadro",
        "cuarto",
        "cuatro",
        "cubo",
        "cubrir",
        "cuchara",
        "cuello",
        "cuento",
        "cuerda",
        "cuesta",
        "cueva",
        "cuidar",
        "culebra",
        "culpa",
        "culto",
        "cumbre",
        "cumplir",
        "cuna",
        "cuneta",
        "cuota",
        "cupo\u0301n",
        "cu\u0301pula",
        "curar",
        "curioso",
        "curso",
        "curva",
        "cutis",
        "dama",
        "danza",
        "dar",
        "dardo",
        "da\u0301til",
        "deber",
        "de\u0301bil",
        "de\u0301cada",
        "decir",
        "dedo",
        "defensa",
        "definir",
        "dejar",
        "delfi\u0301n",
        "delgado",
        "delito",
        "demora",
        "denso",
        "dental",
        "deporte",
        "derecho",
        "derrota",
        "desayuno",
        "deseo",
        "desfile",
        "desnudo",
        "destino",
        "desvi\u0301o",
        "detalle",
        "detener",
        "deuda",
        "di\u0301a",
        "diablo",
        "diadema",
        "diamante",
        "diana",
        "diario",
        "dibujo",
        "dictar",
        "diente",
        "dieta",
        "diez",
        "difi\u0301cil",
        "digno",
        "dilema",
        "diluir",
        "dinero",
        "directo",
        "dirigir",
        "disco",
        "disen\u0303o",
        "disfraz",
        "diva",
        "divino",
        "doble",
        "doce",
        "dolor",
        "domingo",
        "don",
        "donar",
        "dorado",
        "dormir",
        "dorso",
        "dos",
        "dosis",
        "drago\u0301n",
        "droga",
        "ducha",
        "duda",
        "duelo",
        "duen\u0303o",
        "dulce",
        "du\u0301o",
        "duque",
        "durar",
        "dureza",
        "duro",
        "e\u0301bano",
        "ebrio",
        "echar",
        "eco",
        "ecuador",
        "edad",
        "edicio\u0301n",
        "edificio",
        "editor",
        "educar",
        "efecto",
        "eficaz",
        "eje",
        "ejemplo",
        "elefante",
        "elegir",
        "elemento",
        "elevar",
        "elipse",
        "e\u0301lite",
        "elixir",
        "elogio",
        "eludir",
        "embudo",
        "emitir",
        "emocio\u0301n",
        "empate",
        "empen\u0303o",
        "empleo",
        "empresa",
        "enano",
        "encargo",
        "enchufe",
        "enci\u0301a",
        "enemigo",
        "enero",
        "enfado",
        "enfermo",
        "engan\u0303o",
        "enigma",
        "enlace",
        "enorme",
        "enredo",
        "ensayo",
        "ensen\u0303ar",
        "entero",
        "entrar",
        "envase",
        "envi\u0301o",
        "e\u0301poca",
        "equipo",
        "erizo",
        "escala",
        "escena",
        "escolar",
        "escribir",
        "escudo",
        "esencia",
        "esfera",
        "esfuerzo",
        "espada",
        "espejo",
        "espi\u0301a",
        "esposa",
        "espuma",
        "esqui\u0301",
        "estar",
        "este",
        "estilo",
        "estufa",
        "etapa",
        "eterno",
        "e\u0301tica",
        "etnia",
        "evadir",
        "evaluar",
        "evento",
        "evitar",
        "exacto",
        "examen",
        "exceso",
        "excusa",
        "exento",
        "exigir",
        "exilio",
        "existir",
        "e\u0301xito",
        "experto",
        "explicar",
        "exponer",
        "extremo",
        "fa\u0301brica",
        "fa\u0301bula",
        "fachada",
        "fa\u0301cil",
        "factor",
        "faena",
        "faja",
        "falda",
        "fallo",
        "falso",
        "faltar",
        "fama",
        "familia",
        "famoso",
        "farao\u0301n",
        "farmacia",
        "farol",
        "farsa",
        "fase",
        "fatiga",
        "fauna",
        "favor",
        "fax",
        "febrero",
        "fecha",
        "feliz",
        "feo",
        "feria",
        "feroz",
        "fe\u0301rtil",
        "fervor",
        "festi\u0301n",
        "fiable",
        "fianza",
        "fiar",
        "fibra",
        "ficcio\u0301n",
        "ficha",
        "fideo",
        "fiebre",
        "fiel",
        "fiera",
        "fiesta",
        "figura",
        "fijar",
        "fijo",
        "fila",
        "filete",
        "filial",
        "filtro",
        "fin",
        "finca",
        "fingir",
        "finito",
        "firma",
        "flaco",
        "flauta",
        "flecha",
        "flor",
        "flota",
        "fluir",
        "flujo",
        "flu\u0301or",
        "fobia",
        "foca",
        "fogata",
        "fogo\u0301n",
        "folio",
        "folleto",
        "fondo",
        "forma",
        "forro",
        "fortuna",
        "forzar",
        "fosa",
        "foto",
        "fracaso",
        "fra\u0301gil",
        "franja",
        "frase",
        "fraude",
        "frei\u0301r",
        "freno",
        "fresa",
        "fri\u0301o",
        "frito",
        "fruta",
        "fuego",
        "fuente",
        "fuerza",
        "fuga",
        "fumar",
        "funcio\u0301n",
        "funda",
        "furgo\u0301n",
        "furia",
        "fusil",
        "fu\u0301tbol",
        "futuro",
        "gacela",
        "gafas",
        "gaita",
        "gajo",
        "gala",
        "galeri\u0301a",
        "gallo",
        "gamba",
        "ganar",
        "gancho",
        "ganga",
        "ganso",
        "garaje",
        "garza",
        "gasolina",
        "gastar",
        "gato",
        "gavila\u0301n",
        "gemelo",
        "gemir",
        "gen",
        "ge\u0301nero",
        "genio",
        "gente",
        "geranio",
        "gerente",
        "germen",
        "gesto",
        "gigante",
        "gimnasio",
        "girar",
        "giro",
        "glaciar",
        "globo",
        "gloria",
        "gol",
        "golfo",
        "goloso",
        "golpe",
        "goma",
        "gordo",
        "gorila",
        "gorra",
        "gota",
        "goteo",
        "gozar",
        "grada",
        "gra\u0301fico",
        "grano",
        "grasa",
        "gratis",
        "grave",
        "grieta",
        "grillo",
        "gripe",
        "gris",
        "grito",
        "grosor",
        "gru\u0301a",
        "grueso",
        "grumo",
        "grupo",
        "guante",
        "guapo",
        "guardia",
        "guerra",
        "gui\u0301a",
        "guin\u0303o",
        "guion",
        "guiso",
        "guitarra",
        "gusano",
        "gustar",
        "haber",
        "ha\u0301bil",
        "hablar",
        "hacer",
        "hacha",
        "hada",
        "hallar",
        "hamaca",
        "harina",
        "haz",
        "hazan\u0303a",
        "hebilla",
        "hebra",
        "hecho",
        "helado",
        "helio",
        "hembra",
        "herir",
        "hermano",
        "he\u0301roe",
        "hervir",
        "hielo",
        "hierro",
        "hi\u0301gado",
        "higiene",
        "hijo",
        "himno",
        "historia",
        "hocico",
        "hogar",
        "hoguera",
        "hoja",
        "hombre",
        "hongo",
        "honor",
        "honra",
        "hora",
        "hormiga",
        "horno",
        "hostil",
        "hoyo",
        "hueco",
        "huelga",
        "huerta",
        "hueso",
        "huevo",
        "huida",
        "huir",
        "humano",
        "hu\u0301medo",
        "humilde",
        "humo",
        "hundir",
        "huraca\u0301n",
        "hurto",
        "icono",
        "ideal",
        "idioma",
        "i\u0301dolo",
        "iglesia",
        "iglu\u0301",
        "igual",
        "ilegal",
        "ilusio\u0301n",
        "imagen",
        "ima\u0301n",
        "imitar",
        "impar",
        "imperio",
        "imponer",
        "impulso",
        "incapaz",
        "i\u0301ndice",
        "inerte",
        "infiel",
        "informe",
        "ingenio",
        "inicio",
        "inmenso",
        "inmune",
        "innato",
        "insecto",
        "instante",
        "intere\u0301s",
        "i\u0301ntimo",
        "intuir",
        "inu\u0301til",
        "invierno",
        "ira",
        "iris",
        "ironi\u0301a",
        "isla",
        "islote",
        "jabali\u0301",
        "jabo\u0301n",
        "jamo\u0301n",
        "jarabe",
        "jardi\u0301n",
        "jarra",
        "jaula",
        "jazmi\u0301n",
        "jefe",
        "jeringa",
        "jinete",
        "jornada",
        "joroba",
        "joven",
        "joya",
        "juerga",
        "jueves",
        "juez",
        "jugador",
        "jugo",
        "juguete",
        "juicio",
        "junco",
        "jungla",
        "junio",
        "juntar",
        "ju\u0301piter",
        "jurar",
        "justo",
        "juvenil",
        "juzgar",
        "kilo",
        "koala",
        "labio",
        "lacio",
        "lacra",
        "lado",
        "ladro\u0301n",
        "lagarto",
        "la\u0301grima",
        "laguna",
        "laico",
        "lamer",
        "la\u0301mina",
        "la\u0301mpara",
        "lana",
        "lancha",
        "langosta",
        "lanza",
        "la\u0301piz",
        "largo",
        "larva",
        "la\u0301stima",
        "lata",
        "la\u0301tex",
        "latir",
        "laurel",
        "lavar",
        "lazo",
        "leal",
        "leccio\u0301n",
        "leche",
        "lector",
        "leer",
        "legio\u0301n",
        "legumbre",
        "lejano",
        "lengua",
        "lento",
        "len\u0303a",
        "leo\u0301n",
        "leopardo",
        "lesio\u0301n",
        "letal",
        "letra",
        "leve",
        "leyenda",
        "libertad",
        "libro",
        "licor",
        "li\u0301der",
        "lidiar",
        "lienzo",
        "liga",
        "ligero",
        "lima",
        "li\u0301mite",
        "limo\u0301n",
        "limpio",
        "lince",
        "lindo",
        "li\u0301nea",
        "lingote",
        "lino",
        "linterna",
        "li\u0301quido",
        "liso",
        "lista",
        "litera",
        "litio",
        "litro",
        "llaga",
        "llama",
        "llanto",
        "llave",
        "llegar",
        "llenar",
        "llevar",
        "llorar",
        "llover",
        "lluvia",
        "lobo",
        "locio\u0301n",
        "loco",
        "locura",
        "lo\u0301gica",
        "logro",
        "lombriz",
        "lomo",
        "lonja",
        "lote",
        "lucha",
        "lucir",
        "lugar",
        "lujo",
        "luna",
        "lunes",
        "lupa",
        "lustro",
        "luto",
        "luz",
        "maceta",
        "macho",
        "madera",
        "madre",
        "maduro",
        "maestro",
        "mafia",
        "magia",
        "mago",
        "mai\u0301z",
        "maldad",
        "maleta",
        "malla",
        "malo",
        "mama\u0301",
        "mambo",
        "mamut",
        "manco",
        "mando",
        "manejar",
        "manga",
        "maniqui\u0301",
        "manjar",
        "mano",
        "manso",
        "manta",
        "man\u0303ana",
        "mapa",
        "ma\u0301quina",
        "mar",
        "marco",
        "marea",
        "marfil",
        "margen",
        "marido",
        "ma\u0301rmol",
        "marro\u0301n",
        "martes",
        "marzo",
        "masa",
        "ma\u0301scara",
        "masivo",
        "matar",
        "materia",
        "matiz",
        "matriz",
        "ma\u0301ximo",
        "mayor",
        "mazorca",
        "mecha",
        "medalla",
        "medio",
        "me\u0301dula",
        "mejilla",
        "mejor",
        "melena",
        "melo\u0301n",
        "memoria",
        "menor",
        "mensaje",
        "mente",
        "menu\u0301",
        "mercado",
        "merengue",
        "me\u0301rito",
        "mes",
        "meso\u0301n",
        "meta",
        "meter",
        "me\u0301todo",
        "metro",
        "mezcla",
        "miedo",
        "miel",
        "miembro",
        "miga",
        "mil",
        "milagro",
        "militar",
        "millo\u0301n",
        "mimo",
        "mina",
        "minero",
        "mi\u0301nimo",
        "minuto",
        "miope",
        "mirar",
        "misa",
        "miseria",
        "misil",
        "mismo",
        "mitad",
        "mito",
        "mochila",
        "mocio\u0301n",
        "moda",
        "modelo",
        "moho",
        "mojar",
        "molde",
        "moler",
        "molino",
        "momento",
        "momia",
        "monarca",
        "moneda",
        "monja",
        "monto",
        "mon\u0303o",
        "morada",
        "morder",
        "moreno",
        "morir",
        "morro",
        "morsa",
        "mortal",
        "mosca",
        "mostrar",
        "motivo",
        "mover",
        "mo\u0301vil",
        "mozo",
        "mucho",
        "mudar",
        "mueble",
        "muela",
        "muerte",
        "muestra",
        "mugre",
        "mujer",
        "mula",
        "muleta",
        "multa",
        "mundo",
        "mun\u0303eca",
        "mural",
        "muro",
        "mu\u0301sculo",
        "museo",
        "musgo",
        "mu\u0301sica",
        "muslo",
        "na\u0301car",
        "nacio\u0301n",
        "nadar",
        "naipe",
        "naranja",
        "nariz",
        "narrar",
        "nasal",
        "natal",
        "nativo",
        "natural",
        "na\u0301usea",
        "naval",
        "nave",
        "navidad",
        "necio",
        "ne\u0301ctar",
        "negar",
        "negocio",
        "negro",
        "neo\u0301n",
        "nervio",
        "neto",
        "neutro",
        "nevar",
        "nevera",
        "nicho",
        "nido",
        "niebla",
        "nieto",
        "nin\u0303ez",
        "nin\u0303o",
        "ni\u0301tido",
        "nivel",
        "nobleza",
        "noche",
        "no\u0301mina",
        "noria",
        "norma",
        "norte",
        "nota",
        "noticia",
        "novato",
        "novela",
        "novio",
        "nube",
        "nuca",
        "nu\u0301cleo",
        "nudillo",
        "nudo",
        "nuera",
        "nueve",
        "nuez",
        "nulo",
        "nu\u0301mero",
        "nutria",
        "oasis",
        "obeso",
        "obispo",
        "objeto",
        "obra",
        "obrero",
        "observar",
        "obtener",
        "obvio",
        "oca",
        "ocaso",
        "oce\u0301ano",
        "ochenta",
        "ocho",
        "ocio",
        "ocre",
        "octavo",
        "octubre",
        "oculto",
        "ocupar",
        "ocurrir",
        "odiar",
        "odio",
        "odisea",
        "oeste",
        "ofensa",
        "oferta",
        "oficio",
        "ofrecer",
        "ogro",
        "oi\u0301do",
        "oi\u0301r",
        "ojo",
        "ola",
        "oleada",
        "olfato",
        "olivo",
        "olla",
        "olmo",
        "olor",
        "olvido",
        "ombligo",
        "onda",
        "onza",
        "opaco",
        "opcio\u0301n",
        "o\u0301pera",
        "opinar",
        "oponer",
        "optar",
        "o\u0301ptica",
        "opuesto",
        "oracio\u0301n",
        "orador",
        "oral",
        "o\u0301rbita",
        "orca",
        "orden",
        "oreja",
        "o\u0301rgano",
        "orgi\u0301a",
        "orgullo",
        "oriente",
        "origen",
        "orilla",
        "oro",
        "orquesta",
        "oruga",
        "osadi\u0301a",
        "oscuro",
        "osezno",
        "oso",
        "ostra",
        "oton\u0303o",
        "otro",
        "oveja",
        "o\u0301vulo",
        "o\u0301xido",
        "oxi\u0301geno",
        "oyente",
        "ozono",
        "pacto",
        "padre",
        "paella",
        "pa\u0301gina",
        "pago",
        "pai\u0301s",
        "pa\u0301jaro",
        "palabra",
        "palco",
        "paleta",
        "pa\u0301lido",
        "palma",
        "paloma",
        "palpar",
        "pan",
        "panal",
        "pa\u0301nico",
        "pantera",
        "pan\u0303uelo",
        "papa\u0301",
        "papel",
        "papilla",
        "paquete",
        "parar",
        "parcela",
        "pared",
        "parir",
        "paro",
        "pa\u0301rpado",
        "parque",
        "pa\u0301rrafo",
        "parte",
        "pasar",
        "paseo",
        "pasio\u0301n",
        "paso",
        "pasta",
        "pata",
        "patio",
        "patria",
        "pausa",
        "pauta",
        "pavo",
        "payaso",
        "peato\u0301n",
        "pecado",
        "pecera",
        "pecho",
        "pedal",
        "pedir",
        "pegar",
        "peine",
        "pelar",
        "peldan\u0303o",
        "pelea",
        "peligro",
        "pellejo",
        "pelo",
        "peluca",
        "pena",
        "pensar",
        "pen\u0303o\u0301n",
        "peo\u0301n",
        "peor",
        "pepino",
        "pequen\u0303o",
        "pera",
        "percha",
        "perder",
        "pereza",
        "perfil",
        "perico",
        "perla",
        "permiso",
        "perro",
        "persona",
        "pesa",
        "pesca",
        "pe\u0301simo",
        "pestan\u0303a",
        "pe\u0301talo",
        "petro\u0301leo",
        "pez",
        "pezun\u0303a",
        "picar",
        "picho\u0301n",
        "pie",
        "piedra",
        "pierna",
        "pieza",
        "pijama",
        "pilar",
        "piloto",
        "pimienta",
        "pino",
        "pintor",
        "pinza",
        "pin\u0303a",
        "piojo",
        "pipa",
        "pirata",
        "pisar",
        "piscina",
        "piso",
        "pista",
        "pito\u0301n",
        "pizca",
        "placa",
        "plan",
        "plata",
        "playa",
        "plaza",
        "pleito",
        "pleno",
        "plomo",
        "pluma",
        "plural",
        "pobre",
        "poco",
        "poder",
        "podio",
        "poema",
        "poesi\u0301a",
        "poeta",
        "polen",
        "polici\u0301a",
        "pollo",
        "polvo",
        "pomada",
        "pomelo",
        "pomo",
        "pompa",
        "poner",
        "porcio\u0301n",
        "portal",
        "posada",
        "poseer",
        "posible",
        "poste",
        "potencia",
        "potro",
        "pozo",
        "prado",
        "precoz",
        "pregunta",
        "premio",
        "prensa",
        "preso",
        "previo",
        "primo",
        "pri\u0301ncipe",
        "prisio\u0301n",
        "privar",
        "proa",
        "probar",
        "proceso",
        "producto",
        "proeza",
        "profesor",
        "programa",
        "prole",
        "promesa",
        "pronto",
        "propio",
        "pro\u0301ximo",
        "prueba",
        "pu\u0301blico",
        "puchero",
        "pudor",
        "pueblo",
        "puerta",
        "puesto",
        "pulga",
        "pulir",
        "pulmo\u0301n",
        "pulpo",
        "pulso",
        "puma",
        "punto",
        "pun\u0303al",
        "pun\u0303o",
        "pupa",
        "pupila",
        "pure\u0301",
        "quedar",
        "queja",
        "quemar",
        "querer",
        "queso",
        "quieto",
        "qui\u0301mica",
        "quince",
        "quitar",
        "ra\u0301bano",
        "rabia",
        "rabo",
        "racio\u0301n",
        "radical",
        "rai\u0301z",
        "rama",
        "rampa",
        "rancho",
        "rango",
        "rapaz",
        "ra\u0301pido",
        "rapto",
        "rasgo",
        "raspa",
        "rato",
        "rayo",
        "raza",
        "razo\u0301n",
        "reaccio\u0301n",
        "realidad",
        "reban\u0303o",
        "rebote",
        "recaer",
        "receta",
        "rechazo",
        "recoger",
        "recreo",
        "recto",
        "recurso",
        "red",
        "redondo",
        "reducir",
        "reflejo",
        "reforma",
        "refra\u0301n",
        "refugio",
        "regalo",
        "regir",
        "regla",
        "regreso",
        "rehe\u0301n",
        "reino",
        "rei\u0301r",
        "reja",
        "relato",
        "relevo",
        "relieve",
        "relleno",
        "reloj",
        "remar",
        "remedio",
        "remo",
        "rencor",
        "rendir",
        "renta",
        "reparto",
        "repetir",
        "reposo",
        "reptil",
        "res",
        "rescate",
        "resina",
        "respeto",
        "resto",
        "resumen",
        "retiro",
        "retorno",
        "retrato",
        "reunir",
        "reve\u0301s",
        "revista",
        "rey",
        "rezar",
        "rico",
        "riego",
        "rienda",
        "riesgo",
        "rifa",
        "ri\u0301gido",
        "rigor",
        "rinco\u0301n",
        "rin\u0303o\u0301n",
        "ri\u0301o",
        "riqueza",
        "risa",
        "ritmo",
        "rito",
        "rizo",
        "roble",
        "roce",
        "rociar",
        "rodar",
        "rodeo",
        "rodilla",
        "roer",
        "rojizo",
        "rojo",
        "romero",
        "romper",
        "ron",
        "ronco",
        "ronda",
        "ropa",
        "ropero",
        "rosa",
        "rosca",
        "rostro",
        "rotar",
        "rubi\u0301",
        "rubor",
        "rudo",
        "rueda",
        "rugir",
        "ruido",
        "ruina",
        "ruleta",
        "rulo",
        "rumbo",
        "rumor",
        "ruptura",
        "ruta",
        "rutina",
        "sa\u0301bado",
        "saber",
        "sabio",
        "sable",
        "sacar",
        "sagaz",
        "sagrado",
        "sala",
        "saldo",
        "salero",
        "salir",
        "salmo\u0301n",
        "salo\u0301n",
        "salsa",
        "salto",
        "salud",
        "salvar",
        "samba",
        "sancio\u0301n",
        "sandi\u0301a",
        "sanear",
        "sangre",
        "sanidad",
        "sano",
        "santo",
        "sapo",
        "saque",
        "sardina",
        "sarte\u0301n",
        "sastre",
        "sata\u0301n",
        "sauna",
        "saxofo\u0301n",
        "seccio\u0301n",
        "seco",
        "secreto",
        "secta",
        "sed",
        "seguir",
        "seis",
        "sello",
        "selva",
        "semana",
        "semilla",
        "senda",
        "sensor",
        "sen\u0303al",
        "sen\u0303or",
        "separar",
        "sepia",
        "sequi\u0301a",
        "ser",
        "serie",
        "sermo\u0301n",
        "servir",
        "sesenta",
        "sesio\u0301n",
        "seta",
        "setenta",
        "severo",
        "sexo",
        "sexto",
        "sidra",
        "siesta",
        "siete",
        "siglo",
        "signo",
        "si\u0301laba",
        "silbar",
        "silencio",
        "silla",
        "si\u0301mbolo",
        "simio",
        "sirena",
        "sistema",
        "sitio",
        "situar",
        "sobre",
        "socio",
        "sodio",
        "sol",
        "solapa",
        "soldado",
        "soledad",
        "so\u0301lido",
        "soltar",
        "solucio\u0301n",
        "sombra",
        "sondeo",
        "sonido",
        "sonoro",
        "sonrisa",
        "sopa",
        "soplar",
        "soporte",
        "sordo",
        "sorpresa",
        "sorteo",
        "soste\u0301n",
        "so\u0301tano",
        "suave",
        "subir",
        "suceso",
        "sudor",
        "suegra",
        "suelo",
        "suen\u0303o",
        "suerte",
        "sufrir",
        "sujeto",
        "sulta\u0301n",
        "sumar",
        "superar",
        "suplir",
        "suponer",
        "supremo",
        "sur",
        "surco",
        "suren\u0303o",
        "surgir",
        "susto",
        "sutil",
        "tabaco",
        "tabique",
        "tabla",
        "tabu\u0301",
        "taco",
        "tacto",
        "tajo",
        "talar",
        "talco",
        "talento",
        "talla",
        "talo\u0301n",
        "taman\u0303o",
        "tambor",
        "tango",
        "tanque",
        "tapa",
        "tapete",
        "tapia",
        "tapo\u0301n",
        "taquilla",
        "tarde",
        "tarea",
        "tarifa",
        "tarjeta",
        "tarot",
        "tarro",
        "tarta",
        "tatuaje",
        "tauro",
        "taza",
        "tazo\u0301n",
        "teatro",
        "techo",
        "tecla",
        "te\u0301cnica",
        "tejado",
        "tejer",
        "tejido",
        "tela",
        "tele\u0301fono",
        "tema",
        "temor",
        "templo",
        "tenaz",
        "tender",
        "tener",
        "tenis",
        "tenso",
        "teori\u0301a",
        "terapia",
        "terco",
        "te\u0301rmino",
        "ternura",
        "terror",
        "tesis",
        "tesoro",
        "testigo",
        "tetera",
        "texto",
        "tez",
        "tibio",
        "tiburo\u0301n",
        "tiempo",
        "tienda",
        "tierra",
        "tieso",
        "tigre",
        "tijera",
        "tilde",
        "timbre",
        "ti\u0301mido",
        "timo",
        "tinta",
        "ti\u0301o",
        "ti\u0301pico",
        "tipo",
        "tira",
        "tiro\u0301n",
        "tita\u0301n",
        "ti\u0301tere",
        "ti\u0301tulo",
        "tiza",
        "toalla",
        "tobillo",
        "tocar",
        "tocino",
        "todo",
        "toga",
        "toldo",
        "tomar",
        "tono",
        "tonto",
        "topar",
        "tope",
        "toque",
        "to\u0301rax",
        "torero",
        "tormenta",
        "torneo",
        "toro",
        "torpedo",
        "torre",
        "torso",
        "tortuga",
        "tos",
        "tosco",
        "toser",
        "to\u0301xico",
        "trabajo",
        "tractor",
        "traer",
        "tra\u0301fico",
        "trago",
        "traje",
        "tramo",
        "trance",
        "trato",
        "trauma",
        "trazar",
        "tre\u0301bol",
        "tregua",
        "treinta",
        "tren",
        "trepar",
        "tres",
        "tribu",
        "trigo",
        "tripa",
        "triste",
        "triunfo",
        "trofeo",
        "trompa",
        "tronco",
        "tropa",
        "trote",
        "trozo",
        "truco",
        "trueno",
        "trufa",
        "tuberi\u0301a",
        "tubo",
        "tuerto",
        "tumba",
        "tumor",
        "tu\u0301nel",
        "tu\u0301nica",
        "turbina",
        "turismo",
        "turno",
        "tutor",
        "ubicar",
        "u\u0301lcera",
        "umbral",
        "unidad",
        "unir",
        "universo",
        "uno",
        "untar",
        "un\u0303a",
        "urbano",
        "urbe",
        "urgente",
        "urna",
        "usar",
        "usuario",
        "u\u0301til",
        "utopi\u0301a",
        "uva",
        "vaca",
        "vaci\u0301o",
        "vacuna",
        "vagar",
        "vago",
        "vaina",
        "vajilla",
        "vale",
        "va\u0301lido",
        "valle",
        "valor",
        "va\u0301lvula",
        "vampiro",
        "vara",
        "variar",
        "varo\u0301n",
        "vaso",
        "vecino",
        "vector",
        "vehi\u0301culo",
        "veinte",
        "vejez",
        "vela",
        "velero",
        "veloz",
        "vena",
        "vencer",
        "venda",
        "veneno",
        "vengar",
        "venir",
        "venta",
        "venus",
        "ver",
        "verano",
        "verbo",
        "verde",
        "vereda",
        "verja",
        "verso",
        "verter",
        "vi\u0301a",
        "viaje",
        "vibrar",
        "vicio",
        "vi\u0301ctima",
        "vida",
        "vi\u0301deo",
        "vidrio",
        "viejo",
        "viernes",
        "vigor",
        "vil",
        "villa",
        "vinagre",
        "vino",
        "vin\u0303edo",
        "violi\u0301n",
        "viral",
        "virgo",
        "virtud",
        "visor",
        "vi\u0301spera",
        "vista",
        "vitamina",
        "viudo",
        "vivaz",
        "vivero",
        "vivir",
        "vivo",
        "volca\u0301n",
        "volumen",
        "volver",
        "voraz",
        "votar",
        "voto",
        "voz",
        "vuelo",
        "vulgar",
        "yacer",
        "yate",
        "yegua",
        "yema",
        "yerno",
        "yeso",
        "yodo",
        "yoga",
        "yogur",
        "zafiro",
        "zanja",
        "zapato",
        "zarza",
        "zona",
        "zorro",
        "zumo",
        "zurdo"
      ];
    }
  });

  // node_modules/bip39/src/wordlists/japanese.json
  var require_japanese = __commonJS({
    "node_modules/bip39/src/wordlists/japanese.json"(exports9, module) {
      module.exports = [
        "\u3042\u3044\u3053\u304F\u3057\u3093",
        "\u3042\u3044\u3055\u3064",
        "\u3042\u3044\u305F\u3099",
        "\u3042\u304A\u305D\u3099\u3089",
        "\u3042\u304B\u3061\u3083\u3093",
        "\u3042\u304D\u308B",
        "\u3042\u3051\u304B\u3099\u305F",
        "\u3042\u3051\u308B",
        "\u3042\u3053\u304B\u3099\u308C\u308B",
        "\u3042\u3055\u3044",
        "\u3042\u3055\u3072",
        "\u3042\u3057\u3042\u3068",
        "\u3042\u3057\u3099\u308F\u3046",
        "\u3042\u3059\u3099\u304B\u308B",
        "\u3042\u3059\u3099\u304D",
        "\u3042\u305D\u3075\u3099",
        "\u3042\u305F\u3048\u308B",
        "\u3042\u305F\u305F\u3081\u308B",
        "\u3042\u305F\u308A\u307E\u3048",
        "\u3042\u305F\u308B",
        "\u3042\u3064\u3044",
        "\u3042\u3064\u304B\u3046",
        "\u3042\u3063\u3057\u3085\u304F",
        "\u3042\u3064\u307E\u308A",
        "\u3042\u3064\u3081\u308B",
        "\u3042\u3066\u306A",
        "\u3042\u3066\u306F\u307E\u308B",
        "\u3042\u3072\u308B",
        "\u3042\u3075\u3099\u3089",
        "\u3042\u3075\u3099\u308B",
        "\u3042\u3075\u308C\u308B",
        "\u3042\u307E\u3044",
        "\u3042\u307E\u3068\u3099",
        "\u3042\u307E\u3084\u304B\u3059",
        "\u3042\u307E\u308A",
        "\u3042\u307F\u3082\u306E",
        "\u3042\u3081\u308A\u304B",
        "\u3042\u3084\u307E\u308B",
        "\u3042\u3086\u3080",
        "\u3042\u3089\u3044\u304F\u3099\u307E",
        "\u3042\u3089\u3057",
        "\u3042\u3089\u3059\u3057\u3099",
        "\u3042\u3089\u305F\u3081\u308B",
        "\u3042\u3089\u3086\u308B",
        "\u3042\u3089\u308F\u3059",
        "\u3042\u308A\u304B\u3099\u3068\u3046",
        "\u3042\u308F\u305B\u308B",
        "\u3042\u308F\u3066\u308B",
        "\u3042\u3093\u3044",
        "\u3042\u3093\u304B\u3099\u3044",
        "\u3042\u3093\u3053",
        "\u3042\u3093\u305B\u3099\u3093",
        "\u3042\u3093\u3066\u3044",
        "\u3042\u3093\u306A\u3044",
        "\u3042\u3093\u307E\u308A",
        "\u3044\u3044\u305F\u3099\u3059",
        "\u3044\u304A\u3093",
        "\u3044\u304B\u3099\u3044",
        "\u3044\u304B\u3099\u304F",
        "\u3044\u304D\u304A\u3044",
        "\u3044\u304D\u306A\u308A",
        "\u3044\u304D\u3082\u306E",
        "\u3044\u304D\u308B",
        "\u3044\u304F\u3057\u3099",
        "\u3044\u304F\u3075\u3099\u3093",
        "\u3044\u3051\u306F\u3099\u306A",
        "\u3044\u3051\u3093",
        "\u3044\u3053\u3046",
        "\u3044\u3053\u304F",
        "\u3044\u3053\u3064",
        "\u3044\u3055\u307E\u3057\u3044",
        "\u3044\u3055\u3093",
        "\u3044\u3057\u304D",
        "\u3044\u3057\u3099\u3085\u3046",
        "\u3044\u3057\u3099\u3087\u3046",
        "\u3044\u3057\u3099\u308F\u308B",
        "\u3044\u3059\u3099\u307F",
        "\u3044\u3059\u3099\u308C",
        "\u3044\u305B\u3044",
        "\u3044\u305B\u3048\u3072\u3099",
        "\u3044\u305B\u304B\u3044",
        "\u3044\u305B\u304D",
        "\u3044\u305B\u3099\u3093",
        "\u3044\u305D\u3046\u308D\u3046",
        "\u3044\u305D\u304B\u3099\u3057\u3044",
        "\u3044\u305F\u3099\u3044",
        "\u3044\u305F\u3099\u304F",
        "\u3044\u305F\u3059\u3099\u3089",
        "\u3044\u305F\u307F",
        "\u3044\u305F\u308A\u3042",
        "\u3044\u3061\u304A\u3046",
        "\u3044\u3061\u3057\u3099",
        "\u3044\u3061\u3068\u3099",
        "\u3044\u3061\u306F\u3099",
        "\u3044\u3061\u3075\u3099",
        "\u3044\u3061\u308A\u3085\u3046",
        "\u3044\u3064\u304B",
        "\u3044\u3063\u3057\u3085\u3093",
        "\u3044\u3063\u305B\u3044",
        "\u3044\u3063\u305D\u3046",
        "\u3044\u3063\u305F\u3093",
        "\u3044\u3063\u3061",
        "\u3044\u3063\u3066\u3044",
        "\u3044\u3063\u307B\u309A\u3046",
        "\u3044\u3066\u3055\u3099",
        "\u3044\u3066\u3093",
        "\u3044\u3068\u3099\u3046",
        "\u3044\u3068\u3053",
        "\u3044\u306A\u3044",
        "\u3044\u306A\u304B",
        "\u3044\u306D\u3080\u308A",
        "\u3044\u306E\u3061",
        "\u3044\u306E\u308B",
        "\u3044\u306F\u3064",
        "\u3044\u306F\u3099\u308B",
        "\u3044\u306F\u3093",
        "\u3044\u3072\u3099\u304D",
        "\u3044\u3072\u3093",
        "\u3044\u3075\u304F",
        "\u3044\u3078\u3093",
        "\u3044\u307B\u3046",
        "\u3044\u307F\u3093",
        "\u3044\u3082\u3046\u3068",
        "\u3044\u3082\u305F\u308C",
        "\u3044\u3082\u308A",
        "\u3044\u3084\u304B\u3099\u308B",
        "\u3044\u3084\u3059",
        "\u3044\u3088\u304B\u3093",
        "\u3044\u3088\u304F",
        "\u3044\u3089\u3044",
        "\u3044\u3089\u3059\u3068",
        "\u3044\u308A\u304F\u3099\u3061",
        "\u3044\u308A\u3087\u3046",
        "\u3044\u308C\u3044",
        "\u3044\u308C\u3082\u306E",
        "\u3044\u308C\u308B",
        "\u3044\u308D\u3048\u3093\u3072\u309A\u3064",
        "\u3044\u308F\u3044",
        "\u3044\u308F\u3046",
        "\u3044\u308F\u304B\u3093",
        "\u3044\u308F\u306F\u3099",
        "\u3044\u308F\u3086\u308B",
        "\u3044\u3093\u3051\u3099\u3093\u307E\u3081",
        "\u3044\u3093\u3055\u3064",
        "\u3044\u3093\u3057\u3087\u3046",
        "\u3044\u3093\u3088\u3046",
        "\u3046\u3048\u304D",
        "\u3046\u3048\u308B",
        "\u3046\u304A\u3055\u3099",
        "\u3046\u304B\u3099\u3044",
        "\u3046\u304B\u3075\u3099",
        "\u3046\u304B\u3078\u3099\u308B",
        "\u3046\u304D\u308F",
        "\u3046\u304F\u3089\u3044\u306A",
        "\u3046\u304F\u308C\u308C",
        "\u3046\u3051\u305F\u307E\u308F\u308B",
        "\u3046\u3051\u3064\u3051",
        "\u3046\u3051\u3068\u308B",
        "\u3046\u3051\u3082\u3064",
        "\u3046\u3051\u308B",
        "\u3046\u3053\u3099\u304B\u3059",
        "\u3046\u3053\u3099\u304F",
        "\u3046\u3053\u3093",
        "\u3046\u3055\u304D\u3099",
        "\u3046\u3057\u306A\u3046",
        "\u3046\u3057\u308D\u304B\u3099\u307F",
        "\u3046\u3059\u3044",
        "\u3046\u3059\u304D\u3099",
        "\u3046\u3059\u304F\u3099\u3089\u3044",
        "\u3046\u3059\u3081\u308B",
        "\u3046\u305B\u3064",
        "\u3046\u3061\u3042\u308F\u305B",
        "\u3046\u3061\u304B\u3099\u308F",
        "\u3046\u3061\u304D",
        "\u3046\u3061\u3085\u3046",
        "\u3046\u3063\u304B\u308A",
        "\u3046\u3064\u304F\u3057\u3044",
        "\u3046\u3063\u305F\u3048\u308B",
        "\u3046\u3064\u308B",
        "\u3046\u3068\u3099\u3093",
        "\u3046\u306A\u304D\u3099",
        "\u3046\u306A\u3057\u3099",
        "\u3046\u306A\u3059\u3099\u304F",
        "\u3046\u306A\u308B",
        "\u3046\u306D\u308B",
        "\u3046\u306E\u3046",
        "\u3046\u3075\u3099\u3051\u3099",
        "\u3046\u3075\u3099\u3053\u3099\u3048",
        "\u3046\u307E\u308C\u308B",
        "\u3046\u3081\u308B",
        "\u3046\u3082\u3046",
        "\u3046\u3084\u307E\u3046",
        "\u3046\u3088\u304F",
        "\u3046\u3089\u304B\u3099\u3048\u3059",
        "\u3046\u3089\u304F\u3099\u3061",
        "\u3046\u3089\u306A\u3044",
        "\u3046\u308A\u3042\u3051\u3099",
        "\u3046\u308A\u304D\u308C",
        "\u3046\u308B\u3055\u3044",
        "\u3046\u308C\u3057\u3044",
        "\u3046\u308C\u3086\u304D",
        "\u3046\u308C\u308B",
        "\u3046\u308D\u3053",
        "\u3046\u308F\u304D",
        "\u3046\u308F\u3055",
        "\u3046\u3093\u3053\u3046",
        "\u3046\u3093\u3061\u3093",
        "\u3046\u3093\u3066\u3093",
        "\u3046\u3093\u3068\u3099\u3046",
        "\u3048\u3044\u3048\u3093",
        "\u3048\u3044\u304B\u3099",
        "\u3048\u3044\u304D\u3087\u3046",
        "\u3048\u3044\u3053\u3099",
        "\u3048\u3044\u305B\u3044",
        "\u3048\u3044\u3075\u3099\u3093",
        "\u3048\u3044\u3088\u3046",
        "\u3048\u3044\u308F",
        "\u3048\u304A\u308A",
        "\u3048\u304B\u3099\u304A",
        "\u3048\u304B\u3099\u304F",
        "\u3048\u304D\u305F\u3044",
        "\u3048\u304F\u305B\u308B",
        "\u3048\u3057\u3083\u304F",
        "\u3048\u3059\u3066",
        "\u3048\u3064\u3089\u3093",
        "\u3048\u306E\u304F\u3099",
        "\u3048\u307B\u3046\u307E\u304D",
        "\u3048\u307B\u3093",
        "\u3048\u307E\u304D",
        "\u3048\u3082\u3057\u3099",
        "\u3048\u3082\u306E",
        "\u3048\u3089\u3044",
        "\u3048\u3089\u3075\u3099",
        "\u3048\u308A\u3042",
        "\u3048\u3093\u3048\u3093",
        "\u3048\u3093\u304B\u3044",
        "\u3048\u3093\u304D\u3099",
        "\u3048\u3093\u3051\u3099\u304D",
        "\u3048\u3093\u3057\u3085\u3046",
        "\u3048\u3093\u305B\u3099\u3064",
        "\u3048\u3093\u305D\u304F",
        "\u3048\u3093\u3061\u3087\u3046",
        "\u3048\u3093\u3068\u3064",
        "\u304A\u3044\u304B\u3051\u308B",
        "\u304A\u3044\u3053\u3059",
        "\u304A\u3044\u3057\u3044",
        "\u304A\u3044\u3064\u304F",
        "\u304A\u3046\u3048\u3093",
        "\u304A\u3046\u3055\u307E",
        "\u304A\u3046\u3057\u3099",
        "\u304A\u3046\u305B\u3064",
        "\u304A\u3046\u305F\u3044",
        "\u304A\u3046\u3075\u304F",
        "\u304A\u3046\u3078\u3099\u3044",
        "\u304A\u3046\u3088\u3046",
        "\u304A\u3048\u308B",
        "\u304A\u304A\u3044",
        "\u304A\u304A\u3046",
        "\u304A\u304A\u3068\u3099\u304A\u308A",
        "\u304A\u304A\u3084",
        "\u304A\u304A\u3088\u305D",
        "\u304A\u304B\u3048\u308A",
        "\u304A\u304B\u3059\u3099",
        "\u304A\u304B\u3099\u3080",
        "\u304A\u304B\u308F\u308A",
        "\u304A\u304D\u3099\u306A\u3046",
        "\u304A\u304D\u308B",
        "\u304A\u304F\u3055\u307E",
        "\u304A\u304F\u3057\u3099\u3087\u3046",
        "\u304A\u304F\u308A\u304B\u3099\u306A",
        "\u304A\u304F\u308B",
        "\u304A\u304F\u308C\u308B",
        "\u304A\u3053\u3059",
        "\u304A\u3053\u306A\u3046",
        "\u304A\u3053\u308B",
        "\u304A\u3055\u3048\u308B",
        "\u304A\u3055\u306A\u3044",
        "\u304A\u3055\u3081\u308B",
        "\u304A\u3057\u3044\u308C",
        "\u304A\u3057\u3048\u308B",
        "\u304A\u3057\u3099\u304D\u3099",
        "\u304A\u3057\u3099\u3055\u3093",
        "\u304A\u3057\u3083\u308C",
        "\u304A\u305D\u3089\u304F",
        "\u304A\u305D\u308F\u308B",
        "\u304A\u305F\u304B\u3099\u3044",
        "\u304A\u305F\u304F",
        "\u304A\u305F\u3099\u3084\u304B",
        "\u304A\u3061\u3064\u304F",
        "\u304A\u3063\u3068",
        "\u304A\u3064\u308A",
        "\u304A\u3066\u3099\u304B\u3051",
        "\u304A\u3068\u3057\u3082\u306E",
        "\u304A\u3068\u306A\u3057\u3044",
        "\u304A\u3068\u3099\u308A",
        "\u304A\u3068\u3099\u308D\u304B\u3059",
        "\u304A\u306F\u3099\u3055\u3093",
        "\u304A\u307E\u3044\u308A",
        "\u304A\u3081\u3066\u3099\u3068\u3046",
        "\u304A\u3082\u3044\u3066\u3099",
        "\u304A\u3082\u3046",
        "\u304A\u3082\u305F\u3044",
        "\u304A\u3082\u3061\u3083",
        "\u304A\u3084\u3064",
        "\u304A\u3084\u3086\u3072\u3099",
        "\u304A\u3088\u307B\u3099\u3059",
        "\u304A\u3089\u3093\u305F\u3099",
        "\u304A\u308D\u3059",
        "\u304A\u3093\u304B\u3099\u304F",
        "\u304A\u3093\u3051\u3044",
        "\u304A\u3093\u3057\u3083",
        "\u304A\u3093\u305B\u3093",
        "\u304A\u3093\u305F\u3099\u3093",
        "\u304A\u3093\u3061\u3085\u3046",
        "\u304A\u3093\u3068\u3099\u3051\u3044",
        "\u304B\u3042\u3064",
        "\u304B\u3044\u304B\u3099",
        "\u304B\u3099\u3044\u304D",
        "\u304B\u3099\u3044\u3051\u3093",
        "\u304B\u3099\u3044\u3053\u3046",
        "\u304B\u3044\u3055\u3064",
        "\u304B\u3044\u3057\u3083",
        "\u304B\u3044\u3059\u3044\u3088\u304F",
        "\u304B\u3044\u305B\u3099\u3093",
        "\u304B\u3044\u305D\u3099\u3046\u3068\u3099",
        "\u304B\u3044\u3064\u3046",
        "\u304B\u3044\u3066\u3093",
        "\u304B\u3044\u3068\u3046",
        "\u304B\u3044\u3075\u304F",
        "\u304B\u3099\u3044\u3078\u304D",
        "\u304B\u3044\u307B\u3046",
        "\u304B\u3044\u3088\u3046",
        "\u304B\u3099\u3044\u3089\u3044",
        "\u304B\u3044\u308F",
        "\u304B\u3048\u308B",
        "\u304B\u304A\u308A",
        "\u304B\u304B\u3048\u308B",
        "\u304B\u304B\u3099\u304F",
        "\u304B\u304B\u3099\u3057",
        "\u304B\u304B\u3099\u307F",
        "\u304B\u304F\u3053\u3099",
        "\u304B\u304F\u3068\u304F",
        "\u304B\u3055\u3099\u308B",
        "\u304B\u3099\u305D\u3099\u3046",
        "\u304B\u305F\u3044",
        "\u304B\u305F\u3061",
        "\u304B\u3099\u3061\u3087\u3046",
        "\u304B\u3099\u3063\u304D\u3085\u3046",
        "\u304B\u3099\u3063\u3053\u3046",
        "\u304B\u3099\u3063\u3055\u3093",
        "\u304B\u3099\u3063\u3057\u3087\u3046",
        "\u304B\u306A\u3055\u3099\u308F\u3057",
        "\u304B\u306E\u3046",
        "\u304B\u3099\u306F\u304F",
        "\u304B\u3075\u3099\u304B",
        "\u304B\u307B\u3046",
        "\u304B\u307B\u3053\u3099",
        "\u304B\u307E\u3046",
        "\u304B\u307E\u307B\u3099\u3053",
        "\u304B\u3081\u308C\u304A\u3093",
        "\u304B\u3086\u3044",
        "\u304B\u3088\u3046\u3072\u3099",
        "\u304B\u3089\u3044",
        "\u304B\u308B\u3044",
        "\u304B\u308D\u3046",
        "\u304B\u308F\u304F",
        "\u304B\u308F\u3089",
        "\u304B\u3099\u3093\u304B",
        "\u304B\u3093\u3051\u3044",
        "\u304B\u3093\u3053\u3046",
        "\u304B\u3093\u3057\u3083",
        "\u304B\u3093\u305D\u3046",
        "\u304B\u3093\u305F\u3093",
        "\u304B\u3093\u3061",
        "\u304B\u3099\u3093\u306F\u3099\u308B",
        "\u304D\u3042\u3044",
        "\u304D\u3042\u3064",
        "\u304D\u3044\u308D",
        "\u304D\u3099\u3044\u3093",
        "\u304D\u3046\u3044",
        "\u304D\u3046\u3093",
        "\u304D\u3048\u308B",
        "\u304D\u304A\u3046",
        "\u304D\u304A\u304F",
        "\u304D\u304A\u3061",
        "\u304D\u304A\u3093",
        "\u304D\u304B\u3044",
        "\u304D\u304B\u304F",
        "\u304D\u304B\u3093\u3057\u3083",
        "\u304D\u304D\u3066",
        "\u304D\u304F\u306F\u3099\u308A",
        "\u304D\u304F\u3089\u3051\u3099",
        "\u304D\u3051\u3093\u305B\u3044",
        "\u304D\u3053\u3046",
        "\u304D\u3053\u3048\u308B",
        "\u304D\u3053\u304F",
        "\u304D\u3055\u3044",
        "\u304D\u3055\u304F",
        "\u304D\u3055\u307E",
        "\u304D\u3055\u3089\u304D\u3099",
        "\u304D\u3099\u3057\u3099\u304B\u304B\u3099\u304F",
        "\u304D\u3099\u3057\u304D",
        "\u304D\u3099\u3057\u3099\u305F\u3044\u3051\u3093",
        "\u304D\u3099\u3057\u3099\u306B\u3063\u3066\u3044",
        "\u304D\u3099\u3057\u3099\u3085\u3064\u3057\u3083",
        "\u304D\u3059\u3046",
        "\u304D\u305B\u3044",
        "\u304D\u305B\u304D",
        "\u304D\u305B\u3064",
        "\u304D\u305D\u3046",
        "\u304D\u305D\u3099\u304F",
        "\u304D\u305D\u3099\u3093",
        "\u304D\u305F\u3048\u308B",
        "\u304D\u3061\u3087\u3046",
        "\u304D\u3064\u3048\u3093",
        "\u304D\u3099\u3063\u3061\u308A",
        "\u304D\u3064\u3064\u304D",
        "\u304D\u3064\u306D",
        "\u304D\u3066\u3044",
        "\u304D\u3068\u3099\u3046",
        "\u304D\u3068\u3099\u304F",
        "\u304D\u306A\u3044",
        "\u304D\u306A\u304B\u3099",
        "\u304D\u306A\u3053",
        "\u304D\u306C\u3053\u3099\u3057",
        "\u304D\u306D\u3093",
        "\u304D\u306E\u3046",
        "\u304D\u306E\u3057\u305F",
        "\u304D\u306F\u304F",
        "\u304D\u3072\u3099\u3057\u3044",
        "\u304D\u3072\u3093",
        "\u304D\u3075\u304F",
        "\u304D\u3075\u3099\u3093",
        "\u304D\u307B\u3099\u3046",
        "\u304D\u307B\u3093",
        "\u304D\u307E\u308B",
        "\u304D\u307F\u3064",
        "\u304D\u3080\u3059\u3099\u304B\u3057\u3044",
        "\u304D\u3081\u308B",
        "\u304D\u3082\u305F\u3099\u3081\u3057",
        "\u304D\u3082\u3061",
        "\u304D\u3082\u306E",
        "\u304D\u3083\u304F",
        "\u304D\u3084\u304F",
        "\u304D\u3099\u3085\u3046\u306B\u304F",
        "\u304D\u3088\u3046",
        "\u304D\u3087\u3046\u308A\u3085\u3046",
        "\u304D\u3089\u3044",
        "\u304D\u3089\u304F",
        "\u304D\u308A\u3093",
        "\u304D\u308C\u3044",
        "\u304D\u308C\u3064",
        "\u304D\u308D\u304F",
        "\u304D\u3099\u308D\u3093",
        "\u304D\u308F\u3081\u308B",
        "\u304D\u3099\u3093\u3044\u308D",
        "\u304D\u3093\u304B\u304F\u3057\u3099",
        "\u304D\u3093\u3057\u3099\u3087",
        "\u304D\u3093\u3088\u3046\u3072\u3099",
        "\u304F\u3099\u3042\u3044",
        "\u304F\u3044\u3059\u3099",
        "\u304F\u3046\u304B\u3093",
        "\u304F\u3046\u304D",
        "\u304F\u3046\u304F\u3099\u3093",
        "\u304F\u3046\u3053\u3046",
        "\u304F\u3099\u3046\u305B\u3044",
        "\u304F\u3046\u305D\u3046",
        "\u304F\u3099\u3046\u305F\u3089",
        "\u304F\u3046\u3075\u304F",
        "\u304F\u3046\u307B\u3099",
        "\u304F\u304B\u3093",
        "\u304F\u304D\u3087\u3046",
        "\u304F\u3051\u3099\u3093",
        "\u304F\u3099\u3053\u3046",
        "\u304F\u3055\u3044",
        "\u304F\u3055\u304D",
        "\u304F\u3055\u306F\u3099\u306A",
        "\u304F\u3055\u308B",
        "\u304F\u3057\u3083\u307F",
        "\u304F\u3057\u3087\u3046",
        "\u304F\u3059\u306E\u304D",
        "\u304F\u3059\u308A\u3086\u3072\u3099",
        "\u304F\u305B\u3051\u3099",
        "\u304F\u305B\u3093",
        "\u304F\u3099\u305F\u3044\u3066\u304D",
        "\u304F\u305F\u3099\u3055\u308B",
        "\u304F\u305F\u3072\u3099\u308C\u308B",
        "\u304F\u3061\u3053\u307F",
        "\u304F\u3061\u3055\u304D",
        "\u304F\u3064\u3057\u305F",
        "\u304F\u3099\u3063\u3059\u308A",
        "\u304F\u3064\u308D\u304F\u3099",
        "\u304F\u3068\u3046\u3066\u3093",
        "\u304F\u3068\u3099\u304F",
        "\u304F\u306A\u3093",
        "\u304F\u306D\u304F\u306D",
        "\u304F\u306E\u3046",
        "\u304F\u3075\u3046",
        "\u304F\u307F\u3042\u308F\u305B",
        "\u304F\u307F\u305F\u3066\u308B",
        "\u304F\u3081\u308B",
        "\u304F\u3084\u304F\u3057\u3087",
        "\u304F\u3089\u3059",
        "\u304F\u3089\u3078\u3099\u308B",
        "\u304F\u308B\u307E",
        "\u304F\u308C\u308B",
        "\u304F\u308D\u3046",
        "\u304F\u308F\u3057\u3044",
        "\u304F\u3099\u3093\u304B\u3093",
        "\u304F\u3099\u3093\u3057\u3087\u304F",
        "\u304F\u3099\u3093\u305F\u3044",
        "\u304F\u3099\u3093\u3066",
        "\u3051\u3042\u306A",
        "\u3051\u3044\u304B\u304F",
        "\u3051\u3044\u3051\u3093",
        "\u3051\u3044\u3053",
        "\u3051\u3044\u3055\u3064",
        "\u3051\u3099\u3044\u3057\u3099\u3085\u3064",
        "\u3051\u3044\u305F\u3044",
        "\u3051\u3099\u3044\u306E\u3046\u3057\u3099\u3093",
        "\u3051\u3044\u308C\u304D",
        "\u3051\u3044\u308D",
        "\u3051\u304A\u3068\u3059",
        "\u3051\u304A\u308A\u3082\u306E",
        "\u3051\u3099\u304D\u304B",
        "\u3051\u3099\u304D\u3051\u3099\u3093",
        "\u3051\u3099\u304D\u305F\u3099\u3093",
        "\u3051\u3099\u304D\u3061\u3093",
        "\u3051\u3099\u304D\u3068\u3064",
        "\u3051\u3099\u304D\u306F",
        "\u3051\u3099\u304D\u3084\u304F",
        "\u3051\u3099\u3053\u3046",
        "\u3051\u3099\u3053\u304F\u3057\u3099\u3087\u3046",
        "\u3051\u3099\u3055\u3099\u3044",
        "\u3051\u3055\u304D",
        "\u3051\u3099\u3055\u3099\u3093",
        "\u3051\u3057\u304D",
        "\u3051\u3057\u3053\u3099\u3080",
        "\u3051\u3057\u3087\u3046",
        "\u3051\u3099\u3059\u3068",
        "\u3051\u305F\u306F\u3099",
        "\u3051\u3061\u3083\u3063\u3075\u309A",
        "\u3051\u3061\u3089\u3059",
        "\u3051\u3064\u3042\u3064",
        "\u3051\u3064\u3044",
        "\u3051\u3064\u3048\u304D",
        "\u3051\u3063\u3053\u3093",
        "\u3051\u3064\u3057\u3099\u3087",
        "\u3051\u3063\u305B\u304D",
        "\u3051\u3063\u3066\u3044",
        "\u3051\u3064\u307E\u3064",
        "\u3051\u3099\u3064\u3088\u3046\u3072\u3099",
        "\u3051\u3099\u3064\u308C\u3044",
        "\u3051\u3064\u308D\u3093",
        "\u3051\u3099\u3068\u3099\u304F",
        "\u3051\u3068\u306F\u3099\u3059",
        "\u3051\u3068\u308B",
        "\u3051\u306A\u3051\u3099",
        "\u3051\u306A\u3059",
        "\u3051\u306A\u307F",
        "\u3051\u306C\u304D",
        "\u3051\u3099\u306D\u3064",
        "\u3051\u306D\u3093",
        "\u3051\u306F\u3044",
        "\u3051\u3099\u3072\u3093",
        "\u3051\u3075\u3099\u304B\u3044",
        "\u3051\u3099\u307B\u3099\u304F",
        "\u3051\u307E\u308A",
        "\u3051\u307F\u304B\u308B",
        "\u3051\u3080\u3057",
        "\u3051\u3080\u308A",
        "\u3051\u3082\u306E",
        "\u3051\u3089\u3044",
        "\u3051\u308D\u3051\u308D",
        "\u3051\u308F\u3057\u3044",
        "\u3051\u3093\u3044",
        "\u3051\u3093\u3048\u3064",
        "\u3051\u3093\u304A",
        "\u3051\u3093\u304B",
        "\u3051\u3099\u3093\u304D",
        "\u3051\u3093\u3051\u3099\u3093",
        "\u3051\u3093\u3053\u3046",
        "\u3051\u3093\u3055\u304F",
        "\u3051\u3093\u3057\u3085\u3046",
        "\u3051\u3093\u3059\u3046",
        "\u3051\u3099\u3093\u305D\u3046",
        "\u3051\u3093\u3061\u304F",
        "\u3051\u3093\u3066\u3044",
        "\u3051\u3093\u3068\u3046",
        "\u3051\u3093\u306A\u3044",
        "\u3051\u3093\u306B\u3093",
        "\u3051\u3099\u3093\u3075\u3099\u3064",
        "\u3051\u3093\u307E",
        "\u3051\u3093\u307F\u3093",
        "\u3051\u3093\u3081\u3044",
        "\u3051\u3093\u3089\u3093",
        "\u3051\u3093\u308A",
        "\u3053\u3042\u304F\u307E",
        "\u3053\u3044\u306C",
        "\u3053\u3044\u3072\u3099\u3068",
        "\u3053\u3099\u3046\u3044",
        "\u3053\u3046\u3048\u3093",
        "\u3053\u3046\u304A\u3093",
        "\u3053\u3046\u304B\u3093",
        "\u3053\u3099\u3046\u304D\u3085\u3046",
        "\u3053\u3099\u3046\u3051\u3044",
        "\u3053\u3046\u3053\u3046",
        "\u3053\u3046\u3055\u3044",
        "\u3053\u3046\u3057\u3099",
        "\u3053\u3046\u3059\u3044",
        "\u3053\u3099\u3046\u305B\u3044",
        "\u3053\u3046\u305D\u304F",
        "\u3053\u3046\u305F\u3044",
        "\u3053\u3046\u3061\u3083",
        "\u3053\u3046\u3064\u3046",
        "\u3053\u3046\u3066\u3044",
        "\u3053\u3046\u3068\u3099\u3046",
        "\u3053\u3046\u306A\u3044",
        "\u3053\u3046\u306F\u3044",
        "\u3053\u3099\u3046\u307B\u3046",
        "\u3053\u3099\u3046\u307E\u3093",
        "\u3053\u3046\u3082\u304F",
        "\u3053\u3046\u308A\u3064",
        "\u3053\u3048\u308B",
        "\u3053\u304A\u308A",
        "\u3053\u3099\u304B\u3044",
        "\u3053\u3099\u304B\u3099\u3064",
        "\u3053\u3099\u304B\u3093",
        "\u3053\u304F\u3053\u3099",
        "\u3053\u304F\u3055\u3044",
        "\u3053\u304F\u3068\u3046",
        "\u3053\u304F\u306A\u3044",
        "\u3053\u304F\u306F\u304F",
        "\u3053\u304F\u3099\u307E",
        "\u3053\u3051\u3044",
        "\u3053\u3051\u308B",
        "\u3053\u3053\u306E\u304B",
        "\u3053\u3053\u308D",
        "\u3053\u3055\u3081",
        "\u3053\u3057\u3064",
        "\u3053\u3059\u3046",
        "\u3053\u305B\u3044",
        "\u3053\u305B\u304D",
        "\u3053\u305B\u3099\u3093",
        "\u3053\u305D\u305F\u3099\u3066",
        "\u3053\u305F\u3044",
        "\u3053\u305F\u3048\u308B",
        "\u3053\u305F\u3064",
        "\u3053\u3061\u3087\u3046",
        "\u3053\u3063\u304B",
        "\u3053\u3064\u3053\u3064",
        "\u3053\u3064\u306F\u3099\u3093",
        "\u3053\u3064\u3075\u3099",
        "\u3053\u3066\u3044",
        "\u3053\u3066\u3093",
        "\u3053\u3068\u304B\u3099\u3089",
        "\u3053\u3068\u3057",
        "\u3053\u3068\u306F\u3099",
        "\u3053\u3068\u308A",
        "\u3053\u306A\u3053\u3099\u306A",
        "\u3053\u306D\u3053\u306D",
        "\u3053\u306E\u307E\u307E",
        "\u3053\u306E\u307F",
        "\u3053\u306E\u3088",
        "\u3053\u3099\u306F\u3093",
        "\u3053\u3072\u3064\u3057\u3099",
        "\u3053\u3075\u3046",
        "\u3053\u3075\u3093",
        "\u3053\u307B\u3099\u308C\u308B",
        "\u3053\u3099\u307E\u3042\u3075\u3099\u3089",
        "\u3053\u307E\u304B\u3044",
        "\u3053\u3099\u307E\u3059\u308A",
        "\u3053\u307E\u3064\u306A",
        "\u3053\u307E\u308B",
        "\u3053\u3080\u304D\u3099\u3053",
        "\u3053\u3082\u3057\u3099",
        "\u3053\u3082\u3061",
        "\u3053\u3082\u306E",
        "\u3053\u3082\u3093",
        "\u3053\u3084\u304F",
        "\u3053\u3084\u307E",
        "\u3053\u3086\u3046",
        "\u3053\u3086\u3072\u3099",
        "\u3053\u3088\u3044",
        "\u3053\u3088\u3046",
        "\u3053\u308A\u308B",
        "\u3053\u308C\u304F\u3057\u3087\u3093",
        "\u3053\u308D\u3063\u3051",
        "\u3053\u308F\u3082\u3066",
        "\u3053\u308F\u308C\u308B",
        "\u3053\u3093\u3044\u3093",
        "\u3053\u3093\u304B\u3044",
        "\u3053\u3093\u304D",
        "\u3053\u3093\u3057\u3085\u3046",
        "\u3053\u3093\u3059\u3044",
        "\u3053\u3093\u305F\u3099\u3066",
        "\u3053\u3093\u3068\u3093",
        "\u3053\u3093\u306A\u3093",
        "\u3053\u3093\u3072\u3099\u306B",
        "\u3053\u3093\u307B\u309A\u3093",
        "\u3053\u3093\u307E\u3051",
        "\u3053\u3093\u3084",
        "\u3053\u3093\u308C\u3044",
        "\u3053\u3093\u308F\u304F",
        "\u3055\u3099\u3044\u3048\u304D",
        "\u3055\u3044\u304B\u3044",
        "\u3055\u3044\u304D\u3093",
        "\u3055\u3099\u3044\u3051\u3099\u3093",
        "\u3055\u3099\u3044\u3053",
        "\u3055\u3044\u3057\u3087",
        "\u3055\u3044\u305B\u3044",
        "\u3055\u3099\u3044\u305F\u304F",
        "\u3055\u3099\u3044\u3061\u3085\u3046",
        "\u3055\u3044\u3066\u304D",
        "\u3055\u3099\u3044\u308A\u3087\u3046",
        "\u3055\u3046\u306A",
        "\u3055\u304B\u3044\u3057",
        "\u3055\u304B\u3099\u3059",
        "\u3055\u304B\u306A",
        "\u3055\u304B\u307F\u3061",
        "\u3055\u304B\u3099\u308B",
        "\u3055\u304D\u3099\u3087\u3046",
        "\u3055\u304F\u3057",
        "\u3055\u304F\u3072\u3093",
        "\u3055\u304F\u3089",
        "\u3055\u3053\u304F",
        "\u3055\u3053\u3064",
        "\u3055\u3059\u3099\u304B\u308B",
        "\u3055\u3099\u305B\u304D",
        "\u3055\u305F\u3093",
        "\u3055\u3064\u3048\u3044",
        "\u3055\u3099\u3064\u304A\u3093",
        "\u3055\u3099\u3063\u304B",
        "\u3055\u3099\u3064\u304B\u3099\u304F",
        "\u3055\u3063\u304D\u3087\u304F",
        "\u3055\u3099\u3063\u3057",
        "\u3055\u3064\u3057\u3099\u3093",
        "\u3055\u3099\u3063\u305D\u3046",
        "\u3055\u3064\u305F\u306F\u3099",
        "\u3055\u3064\u307E\u3044\u3082",
        "\u3055\u3066\u3044",
        "\u3055\u3068\u3044\u3082",
        "\u3055\u3068\u3046",
        "\u3055\u3068\u304A\u3084",
        "\u3055\u3068\u3057",
        "\u3055\u3068\u308B",
        "\u3055\u306E\u3046",
        "\u3055\u306F\u3099\u304F",
        "\u3055\u3072\u3099\u3057\u3044",
        "\u3055\u3078\u3099\u3064",
        "\u3055\u307B\u3046",
        "\u3055\u307B\u3068\u3099",
        "\u3055\u307E\u3059",
        "\u3055\u307F\u3057\u3044",
        "\u3055\u307F\u305F\u3099\u308C",
        "\u3055\u3080\u3051",
        "\u3055\u3081\u308B",
        "\u3055\u3084\u3048\u3093\u3068\u3099\u3046",
        "\u3055\u3086\u3046",
        "\u3055\u3088\u3046",
        "\u3055\u3088\u304F",
        "\u3055\u3089\u305F\u3099",
        "\u3055\u3099\u308B\u305D\u306F\u3099",
        "\u3055\u308F\u3084\u304B",
        "\u3055\u308F\u308B",
        "\u3055\u3093\u3044\u3093",
        "\u3055\u3093\u304B",
        "\u3055\u3093\u304D\u3083\u304F",
        "\u3055\u3093\u3053\u3046",
        "\u3055\u3093\u3055\u3044",
        "\u3055\u3099\u3093\u3057\u3087",
        "\u3055\u3093\u3059\u3046",
        "\u3055\u3093\u305B\u3044",
        "\u3055\u3093\u305D",
        "\u3055\u3093\u3061",
        "\u3055\u3093\u307E",
        "\u3055\u3093\u307F",
        "\u3055\u3093\u3089\u3093",
        "\u3057\u3042\u3044",
        "\u3057\u3042\u3051\u3099",
        "\u3057\u3042\u3055\u3063\u3066",
        "\u3057\u3042\u308F\u305B",
        "\u3057\u3044\u304F",
        "\u3057\u3044\u3093",
        "\u3057\u3046\u3061",
        "\u3057\u3048\u3044",
        "\u3057\u304A\u3051",
        "\u3057\u304B\u3044",
        "\u3057\u304B\u304F",
        "\u3057\u3099\u304B\u3093",
        "\u3057\u3053\u3099\u3068",
        "\u3057\u3059\u3046",
        "\u3057\u3099\u305F\u3099\u3044",
        "\u3057\u305F\u3046\u3051",
        "\u3057\u305F\u304D\u3099",
        "\u3057\u305F\u3066",
        "\u3057\u305F\u307F",
        "\u3057\u3061\u3087\u3046",
        "\u3057\u3061\u308A\u3093",
        "\u3057\u3063\u304B\u308A",
        "\u3057\u3064\u3057\u3099",
        "\u3057\u3064\u3082\u3093",
        "\u3057\u3066\u3044",
        "\u3057\u3066\u304D",
        "\u3057\u3066\u3064",
        "\u3057\u3099\u3066\u3093",
        "\u3057\u3099\u3068\u3099\u3046",
        "\u3057\u306A\u304D\u3099\u308C",
        "\u3057\u306A\u3082\u306E",
        "\u3057\u306A\u3093",
        "\u3057\u306D\u307E",
        "\u3057\u306D\u3093",
        "\u3057\u306E\u304F\u3099",
        "\u3057\u306E\u3075\u3099",
        "\u3057\u306F\u3044",
        "\u3057\u306F\u3099\u304B\u308A",
        "\u3057\u306F\u3064",
        "\u3057\u306F\u3089\u3044",
        "\u3057\u306F\u3093",
        "\u3057\u3072\u3087\u3046",
        "\u3057\u3075\u304F",
        "\u3057\u3099\u3075\u3099\u3093",
        "\u3057\u3078\u3044",
        "\u3057\u307B\u3046",
        "\u3057\u307B\u3093",
        "\u3057\u307E\u3046",
        "\u3057\u307E\u308B",
        "\u3057\u307F\u3093",
        "\u3057\u3080\u3051\u308B",
        "\u3057\u3099\u3080\u3057\u3087",
        "\u3057\u3081\u3044",
        "\u3057\u3081\u308B",
        "\u3057\u3082\u3093",
        "\u3057\u3083\u3044\u3093",
        "\u3057\u3083\u3046\u3093",
        "\u3057\u3083\u304A\u3093",
        "\u3057\u3099\u3083\u304B\u3099\u3044\u3082",
        "\u3057\u3084\u304F\u3057\u3087",
        "\u3057\u3083\u304F\u307B\u3046",
        "\u3057\u3083\u3051\u3093",
        "\u3057\u3083\u3053",
        "\u3057\u3083\u3055\u3099\u3044",
        "\u3057\u3083\u3057\u3093",
        "\u3057\u3083\u305B\u3093",
        "\u3057\u3083\u305D\u3046",
        "\u3057\u3083\u305F\u3044",
        "\u3057\u3083\u3061\u3087\u3046",
        "\u3057\u3083\u3063\u304D\u3093",
        "\u3057\u3099\u3083\u307E",
        "\u3057\u3083\u308A\u3093",
        "\u3057\u3083\u308C\u3044",
        "\u3057\u3099\u3086\u3046",
        "\u3057\u3099\u3085\u3046\u3057\u3087",
        "\u3057\u3085\u304F\u306F\u304F",
        "\u3057\u3099\u3085\u3057\u3093",
        "\u3057\u3085\u3063\u305B\u304D",
        "\u3057\u3085\u307F",
        "\u3057\u3085\u3089\u306F\u3099",
        "\u3057\u3099\u3085\u3093\u306F\u3099\u3093",
        "\u3057\u3087\u3046\u304B\u3044",
        "\u3057\u3087\u304F\u305F\u304F",
        "\u3057\u3087\u3063\u3051\u3093",
        "\u3057\u3087\u3068\u3099\u3046",
        "\u3057\u3087\u3082\u3064",
        "\u3057\u3089\u305B\u308B",
        "\u3057\u3089\u3078\u3099\u308B",
        "\u3057\u3093\u304B",
        "\u3057\u3093\u3053\u3046",
        "\u3057\u3099\u3093\u3057\u3099\u3083",
        "\u3057\u3093\u305B\u3044\u3057\u3099",
        "\u3057\u3093\u3061\u304F",
        "\u3057\u3093\u308A\u3093",
        "\u3059\u3042\u3051\u3099",
        "\u3059\u3042\u3057",
        "\u3059\u3042\u306A",
        "\u3059\u3099\u3042\u3093",
        "\u3059\u3044\u3048\u3044",
        "\u3059\u3044\u304B",
        "\u3059\u3044\u3068\u3046",
        "\u3059\u3099\u3044\u3075\u3099\u3093",
        "\u3059\u3044\u3088\u3046\u3072\u3099",
        "\u3059\u3046\u304B\u3099\u304F",
        "\u3059\u3046\u3057\u3099\u3064",
        "\u3059\u3046\u305B\u3093",
        "\u3059\u304A\u3068\u3099\u308A",
        "\u3059\u304D\u307E",
        "\u3059\u304F\u3046",
        "\u3059\u304F\u306A\u3044",
        "\u3059\u3051\u308B",
        "\u3059\u3053\u3099\u3044",
        "\u3059\u3053\u3057",
        "\u3059\u3099\u3055\u3093",
        "\u3059\u3059\u3099\u3057\u3044",
        "\u3059\u3059\u3080",
        "\u3059\u3059\u3081\u308B",
        "\u3059\u3063\u304B\u308A",
        "\u3059\u3099\u3063\u3057\u308A",
        "\u3059\u3099\u3063\u3068",
        "\u3059\u3066\u304D",
        "\u3059\u3066\u308B",
        "\u3059\u306D\u308B",
        "\u3059\u306E\u3053",
        "\u3059\u306F\u305F\u3099",
        "\u3059\u306F\u3099\u3089\u3057\u3044",
        "\u3059\u3099\u3072\u3087\u3046",
        "\u3059\u3099\u3075\u3099\u306C\u308C",
        "\u3059\u3075\u3099\u308A",
        "\u3059\u3075\u308C",
        "\u3059\u3078\u3099\u3066",
        "\u3059\u3078\u3099\u308B",
        "\u3059\u3099\u307B\u3046",
        "\u3059\u307B\u3099\u3093",
        "\u3059\u307E\u3044",
        "\u3059\u3081\u3057",
        "\u3059\u3082\u3046",
        "\u3059\u3084\u304D",
        "\u3059\u3089\u3059\u3089",
        "\u3059\u308B\u3081",
        "\u3059\u308C\u3061\u304B\u3099\u3046",
        "\u3059\u308D\u3063\u3068",
        "\u3059\u308F\u308B",
        "\u3059\u3093\u305B\u3099\u3093",
        "\u3059\u3093\u307B\u309A\u3046",
        "\u305B\u3042\u3075\u3099\u3089",
        "\u305B\u3044\u304B\u3064",
        "\u305B\u3044\u3051\u3099\u3093",
        "\u305B\u3044\u3057\u3099",
        "\u305B\u3044\u3088\u3046",
        "\u305B\u304A\u3046",
        "\u305B\u304B\u3044\u304B\u3093",
        "\u305B\u304D\u306B\u3093",
        "\u305B\u304D\u3080",
        "\u305B\u304D\u3086",
        "\u305B\u304D\u3089\u3093\u3046\u3093",
        "\u305B\u3051\u3093",
        "\u305B\u3053\u3046",
        "\u305B\u3059\u3057\u3099",
        "\u305B\u305F\u3044",
        "\u305B\u305F\u3051",
        "\u305B\u3063\u304B\u304F",
        "\u305B\u3063\u304D\u3083\u304F",
        "\u305B\u3099\u3063\u304F",
        "\u305B\u3063\u3051\u3093",
        "\u305B\u3063\u3053\u3064",
        "\u305B\u3063\u3055\u305F\u304F\u307E",
        "\u305B\u3064\u305D\u3099\u304F",
        "\u305B\u3064\u305F\u3099\u3093",
        "\u305B\u3064\u3066\u3099\u3093",
        "\u305B\u3063\u306F\u309A\u3093",
        "\u305B\u3064\u3072\u3099",
        "\u305B\u3064\u3075\u3099\u3093",
        "\u305B\u3064\u3081\u3044",
        "\u305B\u3064\u308A\u3064",
        "\u305B\u306A\u304B",
        "\u305B\u306E\u3072\u3099",
        "\u305B\u306F\u306F\u3099",
        "\u305B\u3072\u3099\u308D",
        "\u305B\u307B\u3099\u306D",
        "\u305B\u307E\u3044",
        "\u305B\u307E\u308B",
        "\u305B\u3081\u308B",
        "\u305B\u3082\u305F\u308C",
        "\u305B\u308A\u3075",
        "\u305B\u3099\u3093\u3042\u304F",
        "\u305B\u3093\u3044",
        "\u305B\u3093\u3048\u3044",
        "\u305B\u3093\u304B",
        "\u305B\u3093\u304D\u3087",
        "\u305B\u3093\u304F",
        "\u305B\u3093\u3051\u3099\u3093",
        "\u305B\u3099\u3093\u3053\u3099",
        "\u305B\u3093\u3055\u3044",
        "\u305B\u3093\u3057\u3085",
        "\u305B\u3093\u3059\u3044",
        "\u305B\u3093\u305B\u3044",
        "\u305B\u3093\u305D\u3099",
        "\u305B\u3093\u305F\u304F",
        "\u305B\u3093\u3061\u3087\u3046",
        "\u305B\u3093\u3066\u3044",
        "\u305B\u3093\u3068\u3046",
        "\u305B\u3093\u306C\u304D",
        "\u305B\u3093\u306D\u3093",
        "\u305B\u3093\u306F\u309A\u3044",
        "\u305B\u3099\u3093\u3075\u3099",
        "\u305B\u3099\u3093\u307B\u309A\u3046",
        "\u305B\u3093\u3080",
        "\u305B\u3093\u3081\u3093\u3057\u3099\u3087",
        "\u305B\u3093\u3082\u3093",
        "\u305B\u3093\u3084\u304F",
        "\u305B\u3093\u3086\u3046",
        "\u305B\u3093\u3088\u3046",
        "\u305B\u3099\u3093\u3089",
        "\u305B\u3099\u3093\u308A\u3083\u304F",
        "\u305B\u3093\u308C\u3044",
        "\u305B\u3093\u308D",
        "\u305D\u3042\u304F",
        "\u305D\u3044\u3068\u3051\u3099\u308B",
        "\u305D\u3044\u306D",
        "\u305D\u3046\u304B\u3099\u3093\u304D\u3087\u3046",
        "\u305D\u3046\u304D",
        "\u305D\u3046\u3053\u3099",
        "\u305D\u3046\u3057\u3093",
        "\u305D\u3046\u305F\u3099\u3093",
        "\u305D\u3046\u306A\u3093",
        "\u305D\u3046\u3072\u3099",
        "\u305D\u3046\u3081\u3093",
        "\u305D\u3046\u308A",
        "\u305D\u3048\u3082\u306E",
        "\u305D\u3048\u3093",
        "\u305D\u304B\u3099\u3044",
        "\u305D\u3051\u3099\u304D",
        "\u305D\u3053\u3046",
        "\u305D\u3053\u305D\u3053",
        "\u305D\u3055\u3099\u3044",
        "\u305D\u3057\u306A",
        "\u305D\u305B\u3044",
        "\u305D\u305B\u3093",
        "\u305D\u305D\u304F\u3099",
        "\u305D\u305F\u3099\u3066\u308B",
        "\u305D\u3064\u3046",
        "\u305D\u3064\u3048\u3093",
        "\u305D\u3063\u304B\u3093",
        "\u305D\u3064\u304D\u3099\u3087\u3046",
        "\u305D\u3063\u3051\u3064",
        "\u305D\u3063\u3053\u3046",
        "\u305D\u3063\u305B\u3093",
        "\u305D\u3063\u3068",
        "\u305D\u3068\u304B\u3099\u308F",
        "\u305D\u3068\u3064\u3099\u3089",
        "\u305D\u306A\u3048\u308B",
        "\u305D\u306A\u305F",
        "\u305D\u3075\u307B\u3099",
        "\u305D\u307B\u3099\u304F",
        "\u305D\u307B\u3099\u308D",
        "\u305D\u307E\u3064",
        "\u305D\u307E\u308B",
        "\u305D\u3080\u304F",
        "\u305D\u3080\u308A\u3048",
        "\u305D\u3081\u308B",
        "\u305D\u3082\u305D\u3082",
        "\u305D\u3088\u304B\u305B\u3099",
        "\u305D\u3089\u307E\u3081",
        "\u305D\u308D\u3046",
        "\u305D\u3093\u304B\u3044",
        "\u305D\u3093\u3051\u3044",
        "\u305D\u3093\u3055\u3099\u3044",
        "\u305D\u3093\u3057\u3064",
        "\u305D\u3093\u305D\u3099\u304F",
        "\u305D\u3093\u3061\u3087\u3046",
        "\u305D\u3099\u3093\u3072\u3099",
        "\u305D\u3099\u3093\u3075\u3099\u3093",
        "\u305D\u3093\u307F\u3093",
        "\u305F\u3042\u3044",
        "\u305F\u3044\u3044\u3093",
        "\u305F\u3044\u3046\u3093",
        "\u305F\u3044\u3048\u304D",
        "\u305F\u3044\u304A\u3046",
        "\u305F\u3099\u3044\u304B\u3099\u304F",
        "\u305F\u3044\u304D",
        "\u305F\u3044\u304F\u3099\u3046",
        "\u305F\u3044\u3051\u3093",
        "\u305F\u3044\u3053",
        "\u305F\u3044\u3055\u3099\u3044",
        "\u305F\u3099\u3044\u3057\u3099\u3087\u3046\u3075\u3099",
        "\u305F\u3099\u3044\u3059\u304D",
        "\u305F\u3044\u305B\u3064",
        "\u305F\u3044\u305D\u3046",
        "\u305F\u3099\u3044\u305F\u3044",
        "\u305F\u3044\u3061\u3087\u3046",
        "\u305F\u3044\u3066\u3044",
        "\u305F\u3099\u3044\u3068\u3099\u3053\u308D",
        "\u305F\u3044\u306A\u3044",
        "\u305F\u3044\u306D\u3064",
        "\u305F\u3044\u306E\u3046",
        "\u305F\u3044\u306F\u3093",
        "\u305F\u3099\u3044\u3072\u3087\u3046",
        "\u305F\u3044\u3075\u3046",
        "\u305F\u3044\u3078\u3093",
        "\u305F\u3044\u307B",
        "\u305F\u3044\u307E\u3064\u306F\u3099\u306A",
        "\u305F\u3044\u307F\u3093\u304F\u3099",
        "\u305F\u3044\u3080",
        "\u305F\u3044\u3081\u3093",
        "\u305F\u3044\u3084\u304D",
        "\u305F\u3044\u3088\u3046",
        "\u305F\u3044\u3089",
        "\u305F\u3044\u308A\u3087\u304F",
        "\u305F\u3044\u308B",
        "\u305F\u3044\u308F\u3093",
        "\u305F\u3046\u3048",
        "\u305F\u3048\u308B",
        "\u305F\u304A\u3059",
        "\u305F\u304A\u308B",
        "\u305F\u304A\u308C\u308B",
        "\u305F\u304B\u3044",
        "\u305F\u304B\u306D",
        "\u305F\u304D\u3072\u3099",
        "\u305F\u304F\u3055\u3093",
        "\u305F\u3053\u304F",
        "\u305F\u3053\u3084\u304D",
        "\u305F\u3055\u3044",
        "\u305F\u3057\u3055\u3099\u3093",
        "\u305F\u3099\u3057\u3099\u3083\u308C",
        "\u305F\u3059\u3051\u308B",
        "\u305F\u3059\u3099\u3055\u308F\u308B",
        "\u305F\u305D\u304B\u3099\u308C",
        "\u305F\u305F\u304B\u3046",
        "\u305F\u305F\u304F",
        "\u305F\u305F\u3099\u3057\u3044",
        "\u305F\u305F\u307F",
        "\u305F\u3061\u306F\u3099\u306A",
        "\u305F\u3099\u3063\u304B\u3044",
        "\u305F\u3099\u3063\u304D\u3083\u304F",
        "\u305F\u3099\u3063\u3053",
        "\u305F\u3099\u3063\u3057\u3085\u3064",
        "\u305F\u3099\u3063\u305F\u3044",
        "\u305F\u3066\u308B",
        "\u305F\u3068\u3048\u308B",
        "\u305F\u306A\u306F\u3099\u305F",
        "\u305F\u306B\u3093",
        "\u305F\u306C\u304D",
        "\u305F\u306E\u3057\u307F",
        "\u305F\u306F\u3064",
        "\u305F\u3075\u3099\u3093",
        "\u305F\u3078\u3099\u308B",
        "\u305F\u307B\u3099\u3046",
        "\u305F\u307E\u3053\u3099",
        "\u305F\u307E\u308B",
        "\u305F\u3099\u3080\u308B",
        "\u305F\u3081\u3044\u304D",
        "\u305F\u3081\u3059",
        "\u305F\u3081\u308B",
        "\u305F\u3082\u3064",
        "\u305F\u3084\u3059\u3044",
        "\u305F\u3088\u308B",
        "\u305F\u3089\u3059",
        "\u305F\u308A\u304D\u307B\u3093\u304B\u3099\u3093",
        "\u305F\u308A\u3087\u3046",
        "\u305F\u308A\u308B",
        "\u305F\u308B\u3068",
        "\u305F\u308C\u308B",
        "\u305F\u308C\u3093\u3068",
        "\u305F\u308D\u3063\u3068",
        "\u305F\u308F\u3080\u308C\u308B",
        "\u305F\u3099\u3093\u3042\u3064",
        "\u305F\u3093\u3044",
        "\u305F\u3093\u304A\u3093",
        "\u305F\u3093\u304B",
        "\u305F\u3093\u304D",
        "\u305F\u3093\u3051\u3093",
        "\u305F\u3093\u3053\u3099",
        "\u305F\u3093\u3055\u3093",
        "\u305F\u3093\u3057\u3099\u3087\u3046\u3072\u3099",
        "\u305F\u3099\u3093\u305B\u3044",
        "\u305F\u3093\u305D\u304F",
        "\u305F\u3093\u305F\u3044",
        "\u305F\u3099\u3093\u3061",
        "\u305F\u3093\u3066\u3044",
        "\u305F\u3093\u3068\u3046",
        "\u305F\u3099\u3093\u306A",
        "\u305F\u3093\u306B\u3093",
        "\u305F\u3099\u3093\u306D\u3064",
        "\u305F\u3093\u306E\u3046",
        "\u305F\u3093\u3072\u309A\u3093",
        "\u305F\u3099\u3093\u307B\u3099\u3046",
        "\u305F\u3093\u307E\u3064",
        "\u305F\u3093\u3081\u3044",
        "\u305F\u3099\u3093\u308C\u3064",
        "\u305F\u3099\u3093\u308D",
        "\u305F\u3099\u3093\u308F",
        "\u3061\u3042\u3044",
        "\u3061\u3042\u3093",
        "\u3061\u3044\u304D",
        "\u3061\u3044\u3055\u3044",
        "\u3061\u3048\u3093",
        "\u3061\u304B\u3044",
        "\u3061\u304B\u3089",
        "\u3061\u304D\u3085\u3046",
        "\u3061\u304D\u3093",
        "\u3061\u3051\u3044\u3059\u3099",
        "\u3061\u3051\u3093",
        "\u3061\u3053\u304F",
        "\u3061\u3055\u3044",
        "\u3061\u3057\u304D",
        "\u3061\u3057\u308A\u3087\u3046",
        "\u3061\u305B\u3044",
        "\u3061\u305D\u3046",
        "\u3061\u305F\u3044",
        "\u3061\u305F\u3093",
        "\u3061\u3061\u304A\u3084",
        "\u3061\u3064\u3057\u3099\u3087",
        "\u3061\u3066\u304D",
        "\u3061\u3066\u3093",
        "\u3061\u306C\u304D",
        "\u3061\u306C\u308A",
        "\u3061\u306E\u3046",
        "\u3061\u3072\u3087\u3046",
        "\u3061\u3078\u3044\u305B\u3093",
        "\u3061\u307B\u3046",
        "\u3061\u307E\u305F",
        "\u3061\u307F\u3064",
        "\u3061\u307F\u3068\u3099\u308D",
        "\u3061\u3081\u3044\u3068\u3099",
        "\u3061\u3083\u3093\u3053\u306A\u3078\u3099",
        "\u3061\u3085\u3046\u3044",
        "\u3061\u3086\u308A\u3087\u304F",
        "\u3061\u3087\u3046\u3057",
        "\u3061\u3087\u3055\u304F\u3051\u3093",
        "\u3061\u3089\u3057",
        "\u3061\u3089\u307F",
        "\u3061\u308A\u304B\u3099\u307F",
        "\u3061\u308A\u3087\u3046",
        "\u3061\u308B\u3068\u3099",
        "\u3061\u308F\u308F",
        "\u3061\u3093\u305F\u3044",
        "\u3061\u3093\u3082\u304F",
        "\u3064\u3044\u304B",
        "\u3064\u3044\u305F\u3061",
        "\u3064\u3046\u304B",
        "\u3064\u3046\u3057\u3099\u3087\u3046",
        "\u3064\u3046\u306F\u3093",
        "\u3064\u3046\u308F",
        "\u3064\u304B\u3046",
        "\u3064\u304B\u308C\u308B",
        "\u3064\u304F\u306D",
        "\u3064\u304F\u308B",
        "\u3064\u3051\u306D",
        "\u3064\u3051\u308B",
        "\u3064\u3053\u3099\u3046",
        "\u3064\u305F\u3048\u308B",
        "\u3064\u3064\u3099\u304F",
        "\u3064\u3064\u3057\u3099",
        "\u3064\u3064\u3080",
        "\u3064\u3068\u3081\u308B",
        "\u3064\u306A\u304B\u3099\u308B",
        "\u3064\u306A\u307F",
        "\u3064\u306D\u3064\u3099\u306D",
        "\u3064\u306E\u308B",
        "\u3064\u3075\u3099\u3059",
        "\u3064\u307E\u3089\u306A\u3044",
        "\u3064\u307E\u308B",
        "\u3064\u307F\u304D",
        "\u3064\u3081\u305F\u3044",
        "\u3064\u3082\u308A",
        "\u3064\u3082\u308B",
        "\u3064\u3088\u3044",
        "\u3064\u308B\u307B\u3099",
        "\u3064\u308B\u307F\u304F",
        "\u3064\u308F\u3082\u306E",
        "\u3064\u308F\u308A",
        "\u3066\u3042\u3057",
        "\u3066\u3042\u3066",
        "\u3066\u3042\u307F",
        "\u3066\u3044\u304A\u3093",
        "\u3066\u3044\u304B",
        "\u3066\u3044\u304D",
        "\u3066\u3044\u3051\u3044",
        "\u3066\u3044\u3053\u304F",
        "\u3066\u3044\u3055\u3064",
        "\u3066\u3044\u3057",
        "\u3066\u3044\u305B\u3044",
        "\u3066\u3044\u305F\u3044",
        "\u3066\u3044\u3068\u3099",
        "\u3066\u3044\u306D\u3044",
        "\u3066\u3044\u3072\u3087\u3046",
        "\u3066\u3044\u3078\u3093",
        "\u3066\u3044\u307B\u3099\u3046",
        "\u3066\u3046\u3061",
        "\u3066\u304A\u304F\u308C",
        "\u3066\u304D\u3068\u3046",
        "\u3066\u304F\u3072\u3099",
        "\u3066\u3099\u3053\u307B\u3099\u3053",
        "\u3066\u3055\u304D\u3099\u3087\u3046",
        "\u3066\u3055\u3051\u3099",
        "\u3066\u3059\u308A",
        "\u3066\u305D\u3046",
        "\u3066\u3061\u304B\u3099\u3044",
        "\u3066\u3061\u3087\u3046",
        "\u3066\u3064\u304B\u3099\u304F",
        "\u3066\u3064\u3064\u3099\u304D",
        "\u3066\u3099\u3063\u306F\u309A",
        "\u3066\u3064\u307B\u3099\u3046",
        "\u3066\u3064\u3084",
        "\u3066\u3099\u306C\u304B\u3048",
        "\u3066\u306C\u304D",
        "\u3066\u306C\u304F\u3099\u3044",
        "\u3066\u306E\u3072\u3089",
        "\u3066\u306F\u3044",
        "\u3066\u3075\u3099\u304F\u308D",
        "\u3066\u3075\u305F\u3099",
        "\u3066\u307B\u3068\u3099\u304D",
        "\u3066\u307B\u3093",
        "\u3066\u307E\u3048",
        "\u3066\u307E\u304D\u3059\u3099\u3057",
        "\u3066\u307F\u3057\u3099\u304B",
        "\u3066\u307F\u3084\u3051\u3099",
        "\u3066\u3089\u3059",
        "\u3066\u308C\u3072\u3099",
        "\u3066\u308F\u3051",
        "\u3066\u308F\u305F\u3057",
        "\u3066\u3099\u3093\u3042\u3064",
        "\u3066\u3093\u3044\u3093",
        "\u3066\u3093\u304B\u3044",
        "\u3066\u3093\u304D",
        "\u3066\u3093\u304F\u3099",
        "\u3066\u3093\u3051\u3093",
        "\u3066\u3093\u3053\u3099\u304F",
        "\u3066\u3093\u3055\u3044",
        "\u3066\u3093\u3057",
        "\u3066\u3093\u3059\u3046",
        "\u3066\u3099\u3093\u3061",
        "\u3066\u3093\u3066\u304D",
        "\u3066\u3093\u3068\u3046",
        "\u3066\u3093\u306A\u3044",
        "\u3066\u3093\u3075\u309A\u3089",
        "\u3066\u3093\u307B\u3099\u3046\u305F\u3099\u3044",
        "\u3066\u3093\u3081\u3064",
        "\u3066\u3093\u3089\u3093\u304B\u3044",
        "\u3066\u3099\u3093\u308A\u3087\u304F",
        "\u3066\u3099\u3093\u308F",
        "\u3068\u3099\u3042\u3044",
        "\u3068\u3044\u308C",
        "\u3068\u3099\u3046\u304B\u3093",
        "\u3068\u3046\u304D\u3085\u3046",
        "\u3068\u3099\u3046\u304F\u3099",
        "\u3068\u3046\u3057",
        "\u3068\u3046\u3080\u304D\u3099",
        "\u3068\u304A\u3044",
        "\u3068\u304A\u304B",
        "\u3068\u304A\u304F",
        "\u3068\u304A\u3059",
        "\u3068\u304A\u308B",
        "\u3068\u304B\u3044",
        "\u3068\u304B\u3059",
        "\u3068\u304D\u304A\u308A",
        "\u3068\u304D\u3068\u3099\u304D",
        "\u3068\u304F\u3044",
        "\u3068\u304F\u3057\u3085\u3046",
        "\u3068\u304F\u3066\u3093",
        "\u3068\u304F\u306B",
        "\u3068\u304F\u3078\u3099\u3064",
        "\u3068\u3051\u3044",
        "\u3068\u3051\u308B",
        "\u3068\u3053\u3084",
        "\u3068\u3055\u304B",
        "\u3068\u3057\u3087\u304B\u3093",
        "\u3068\u305D\u3046",
        "\u3068\u305F\u3093",
        "\u3068\u3061\u3085\u3046",
        "\u3068\u3063\u304D\u3085\u3046",
        "\u3068\u3063\u304F\u3093",
        "\u3068\u3064\u305B\u3099\u3093",
        "\u3068\u3064\u306B\u3085\u3046",
        "\u3068\u3068\u3099\u3051\u308B",
        "\u3068\u3068\u306E\u3048\u308B",
        "\u3068\u306A\u3044",
        "\u3068\u306A\u3048\u308B",
        "\u3068\u306A\u308A",
        "\u3068\u306E\u3055\u307E",
        "\u3068\u306F\u3099\u3059",
        "\u3068\u3099\u3075\u3099\u304B\u3099\u308F",
        "\u3068\u307B\u3046",
        "\u3068\u307E\u308B",
        "\u3068\u3081\u308B",
        "\u3068\u3082\u305F\u3099\u3061",
        "\u3068\u3082\u308B",
        "\u3068\u3099\u3088\u3046\u3072\u3099",
        "\u3068\u3089\u3048\u308B",
        "\u3068\u3093\u304B\u3064",
        "\u3068\u3099\u3093\u3075\u3099\u308A",
        "\u306A\u3044\u304B\u304F",
        "\u306A\u3044\u3053\u3046",
        "\u306A\u3044\u3057\u3087",
        "\u306A\u3044\u3059",
        "\u306A\u3044\u305B\u3093",
        "\u306A\u3044\u305D\u3046",
        "\u306A\u304A\u3059",
        "\u306A\u304B\u3099\u3044",
        "\u306A\u304F\u3059",
        "\u306A\u3051\u3099\u308B",
        "\u306A\u3053\u3046\u3068\u3099",
        "\u306A\u3055\u3051",
        "\u306A\u305F\u3066\u3099\u3053\u3053",
        "\u306A\u3063\u3068\u3046",
        "\u306A\u3064\u3084\u3059\u307F",
        "\u306A\u306A\u304A\u3057",
        "\u306A\u306B\u3053\u3099\u3068",
        "\u306A\u306B\u3082\u306E",
        "\u306A\u306B\u308F",
        "\u306A\u306E\u304B",
        "\u306A\u3075\u305F\u3099",
        "\u306A\u307E\u3044\u304D",
        "\u306A\u307E\u3048",
        "\u306A\u307E\u307F",
        "\u306A\u307F\u305F\u3099",
        "\u306A\u3081\u3089\u304B",
        "\u306A\u3081\u308B",
        "\u306A\u3084\u3080",
        "\u306A\u3089\u3046",
        "\u306A\u3089\u3072\u3099",
        "\u306A\u3089\u3075\u3099",
        "\u306A\u308C\u308B",
        "\u306A\u308F\u3068\u3072\u3099",
        "\u306A\u308F\u306F\u3099\u308A",
        "\u306B\u3042\u3046",
        "\u306B\u3044\u304B\u3099\u305F",
        "\u306B\u3046\u3051",
        "\u306B\u304A\u3044",
        "\u306B\u304B\u3044",
        "\u306B\u304B\u3099\u3066",
        "\u306B\u304D\u3072\u3099",
        "\u306B\u304F\u3057\u307F",
        "\u306B\u304F\u307E\u3093",
        "\u306B\u3051\u3099\u308B",
        "\u306B\u3055\u3093\u304B\u305F\u3093\u305D",
        "\u306B\u3057\u304D",
        "\u306B\u305B\u3082\u306E",
        "\u306B\u3061\u3057\u3099\u3087\u3046",
        "\u306B\u3061\u3088\u3046\u3072\u3099",
        "\u306B\u3063\u304B",
        "\u306B\u3063\u304D",
        "\u306B\u3063\u3051\u3044",
        "\u306B\u3063\u3053\u3046",
        "\u306B\u3063\u3055\u3093",
        "\u306B\u3063\u3057\u3087\u304F",
        "\u306B\u3063\u3059\u3046",
        "\u306B\u3063\u305B\u304D",
        "\u306B\u3063\u3066\u3044",
        "\u306B\u306A\u3046",
        "\u306B\u307B\u3093",
        "\u306B\u307E\u3081",
        "\u306B\u3082\u3064",
        "\u306B\u3084\u308A",
        "\u306B\u3085\u3046\u3044\u3093",
        "\u306B\u308A\u3093\u3057\u3083",
        "\u306B\u308F\u3068\u308A",
        "\u306B\u3093\u3044",
        "\u306B\u3093\u304B",
        "\u306B\u3093\u304D",
        "\u306B\u3093\u3051\u3099\u3093",
        "\u306B\u3093\u3057\u304D",
        "\u306B\u3093\u3059\u3099\u3046",
        "\u306B\u3093\u305D\u3046",
        "\u306B\u3093\u305F\u3044",
        "\u306B\u3093\u3061",
        "\u306B\u3093\u3066\u3044",
        "\u306B\u3093\u306B\u304F",
        "\u306B\u3093\u3075\u309A",
        "\u306B\u3093\u307E\u308A",
        "\u306B\u3093\u3080",
        "\u306B\u3093\u3081\u3044",
        "\u306B\u3093\u3088\u3046",
        "\u306C\u3044\u304F\u304D\u3099",
        "\u306C\u304B\u3059",
        "\u306C\u304F\u3099\u3044\u3068\u308B",
        "\u306C\u304F\u3099\u3046",
        "\u306C\u304F\u3082\u308A",
        "\u306C\u3059\u3080",
        "\u306C\u307E\u3048\u3072\u3099",
        "\u306C\u3081\u308A",
        "\u306C\u3089\u3059",
        "\u306C\u3093\u3061\u3083\u304F",
        "\u306D\u3042\u3051\u3099",
        "\u306D\u3044\u304D",
        "\u306D\u3044\u308B",
        "\u306D\u3044\u308D",
        "\u306D\u304F\u3099\u305B",
        "\u306D\u304F\u305F\u3044",
        "\u306D\u304F\u3089",
        "\u306D\u3053\u305B\u3099",
        "\u306D\u3053\u3080",
        "\u306D\u3055\u3051\u3099",
        "\u306D\u3059\u3053\u3099\u3059",
        "\u306D\u305D\u3078\u3099\u308B",
        "\u306D\u305F\u3099\u3093",
        "\u306D\u3064\u3044",
        "\u306D\u3063\u3057\u3093",
        "\u306D\u3064\u305D\u3099\u3046",
        "\u306D\u3063\u305F\u3044\u304D\u3099\u3087",
        "\u306D\u3075\u3099\u305D\u304F",
        "\u306D\u3075\u305F\u3099",
        "\u306D\u307B\u3099\u3046",
        "\u306D\u307B\u308A\u306F\u307B\u308A",
        "\u306D\u307E\u304D",
        "\u306D\u307E\u308F\u3057",
        "\u306D\u307F\u307F",
        "\u306D\u3080\u3044",
        "\u306D\u3080\u305F\u3044",
        "\u306D\u3082\u3068",
        "\u306D\u3089\u3046",
        "\u306D\u308F\u3055\u3099",
        "\u306D\u3093\u3044\u308A",
        "\u306D\u3093\u304A\u3057",
        "\u306D\u3093\u304B\u3093",
        "\u306D\u3093\u304D\u3093",
        "\u306D\u3093\u304F\u3099",
        "\u306D\u3093\u3055\u3099",
        "\u306D\u3093\u3057",
        "\u306D\u3093\u3061\u3083\u304F",
        "\u306D\u3093\u3068\u3099",
        "\u306D\u3093\u3072\u309A",
        "\u306D\u3093\u3075\u3099\u3064",
        "\u306D\u3093\u307E\u3064",
        "\u306D\u3093\u308A\u3087\u3046",
        "\u306D\u3093\u308C\u3044",
        "\u306E\u3044\u3059\u3099",
        "\u306E\u304A\u3064\u3099\u307E",
        "\u306E\u304B\u3099\u3059",
        "\u306E\u304D\u306A\u307F",
        "\u306E\u3053\u304D\u3099\u308A",
        "\u306E\u3053\u3059",
        "\u306E\u3053\u308B",
        "\u306E\u305B\u308B",
        "\u306E\u305D\u3099\u304F",
        "\u306E\u305D\u3099\u3080",
        "\u306E\u305F\u307E\u3046",
        "\u306E\u3061\u307B\u3068\u3099",
        "\u306E\u3063\u304F",
        "\u306E\u306F\u3099\u3059",
        "\u306E\u306F\u3089",
        "\u306E\u3078\u3099\u308B",
        "\u306E\u307B\u3099\u308B",
        "\u306E\u307F\u3082\u306E",
        "\u306E\u3084\u307E",
        "\u306E\u3089\u3044\u306C",
        "\u306E\u3089\u306D\u3053",
        "\u306E\u308A\u3082\u306E",
        "\u306E\u308A\u3086\u304D",
        "\u306E\u308C\u3093",
        "\u306E\u3093\u304D",
        "\u306F\u3099\u3042\u3044",
        "\u306F\u3042\u304F",
        "\u306F\u3099\u3042\u3055\u3093",
        "\u306F\u3099\u3044\u304B",
        "\u306F\u3099\u3044\u304F",
        "\u306F\u3044\u3051\u3093",
        "\u306F\u3044\u3053\u3099",
        "\u306F\u3044\u3057\u3093",
        "\u306F\u3044\u3059\u3044",
        "\u306F\u3044\u305B\u3093",
        "\u306F\u3044\u305D\u3046",
        "\u306F\u3044\u3061",
        "\u306F\u3099\u3044\u306F\u3099\u3044",
        "\u306F\u3044\u308C\u3064",
        "\u306F\u3048\u308B",
        "\u306F\u304A\u308B",
        "\u306F\u304B\u3044",
        "\u306F\u3099\u304B\u308A",
        "\u306F\u304B\u308B",
        "\u306F\u304F\u3057\u3085",
        "\u306F\u3051\u3093",
        "\u306F\u3053\u3075\u3099",
        "\u306F\u3055\u307F",
        "\u306F\u3055\u3093",
        "\u306F\u3057\u3053\u3099",
        "\u306F\u3099\u3057\u3087",
        "\u306F\u3057\u308B",
        "\u306F\u305B\u308B",
        "\u306F\u309A\u305D\u3053\u3093",
        "\u306F\u305D\u3093",
        "\u306F\u305F\u3093",
        "\u306F\u3061\u307F\u3064",
        "\u306F\u3064\u304A\u3093",
        "\u306F\u3063\u304B\u304F",
        "\u306F\u3064\u3099\u304D",
        "\u306F\u3063\u304D\u308A",
        "\u306F\u3063\u304F\u3064",
        "\u306F\u3063\u3051\u3093",
        "\u306F\u3063\u3053\u3046",
        "\u306F\u3063\u3055\u3093",
        "\u306F\u3063\u3057\u3093",
        "\u306F\u3063\u305F\u3064",
        "\u306F\u3063\u3061\u3085\u3046",
        "\u306F\u3063\u3066\u3093",
        "\u306F\u3063\u3072\u309A\u3087\u3046",
        "\u306F\u3063\u307B\u309A\u3046",
        "\u306F\u306A\u3059",
        "\u306F\u306A\u3072\u3099",
        "\u306F\u306B\u304B\u3080",
        "\u306F\u3075\u3099\u3089\u3057",
        "\u306F\u307F\u304B\u3099\u304D",
        "\u306F\u3080\u304B\u3046",
        "\u306F\u3081\u3064",
        "\u306F\u3084\u3044",
        "\u306F\u3084\u3057",
        "\u306F\u3089\u3046",
        "\u306F\u308D\u3046\u3043\u3093",
        "\u306F\u308F\u3044",
        "\u306F\u3093\u3044",
        "\u306F\u3093\u3048\u3044",
        "\u306F\u3093\u304A\u3093",
        "\u306F\u3093\u304B\u304F",
        "\u306F\u3093\u304D\u3087\u3046",
        "\u306F\u3099\u3093\u304F\u3099\u307F",
        "\u306F\u3093\u3053",
        "\u306F\u3093\u3057\u3083",
        "\u306F\u3093\u3059\u3046",
        "\u306F\u3093\u305F\u3099\u3093",
        "\u306F\u309A\u3093\u3061",
        "\u306F\u309A\u3093\u3064",
        "\u306F\u3093\u3066\u3044",
        "\u306F\u3093\u3068\u3057",
        "\u306F\u3093\u306E\u3046",
        "\u306F\u3093\u306F\u309A",
        "\u306F\u3093\u3075\u3099\u3093",
        "\u306F\u3093\u3078\u309A\u3093",
        "\u306F\u3093\u307B\u3099\u3046\u304D",
        "\u306F\u3093\u3081\u3044",
        "\u306F\u3093\u3089\u3093",
        "\u306F\u3093\u308D\u3093",
        "\u3072\u3044\u304D",
        "\u3072\u3046\u3093",
        "\u3072\u3048\u308B",
        "\u3072\u304B\u304F",
        "\u3072\u304B\u308A",
        "\u3072\u304B\u308B",
        "\u3072\u304B\u3093",
        "\u3072\u304F\u3044",
        "\u3072\u3051\u3064",
        "\u3072\u3053\u3046\u304D",
        "\u3072\u3053\u304F",
        "\u3072\u3055\u3044",
        "\u3072\u3055\u3057\u3075\u3099\u308A",
        "\u3072\u3055\u3093",
        "\u3072\u3099\u3057\u3099\u3085\u3064\u304B\u3093",
        "\u3072\u3057\u3087",
        "\u3072\u305D\u304B",
        "\u3072\u305D\u3080",
        "\u3072\u305F\u3080\u304D",
        "\u3072\u305F\u3099\u308A",
        "\u3072\u305F\u308B",
        "\u3072\u3064\u304D\u3099",
        "\u3072\u3063\u3053\u3057",
        "\u3072\u3063\u3057",
        "\u3072\u3064\u3057\u3099\u3085\u3072\u3093",
        "\u3072\u3063\u3059",
        "\u3072\u3064\u305B\u3099\u3093",
        "\u3072\u309A\u3063\u305F\u308A",
        "\u3072\u309A\u3063\u3061\u308A",
        "\u3072\u3064\u3088\u3046",
        "\u3072\u3066\u3044",
        "\u3072\u3068\u3053\u3099\u307F",
        "\u3072\u306A\u307E\u3064\u308A",
        "\u3072\u306A\u3093",
        "\u3072\u306D\u308B",
        "\u3072\u306F\u3093",
        "\u3072\u3072\u3099\u304F",
        "\u3072\u3072\u3087\u3046",
        "\u3072\u307B\u3046",
        "\u3072\u307E\u308F\u308A",
        "\u3072\u307E\u3093",
        "\u3072\u307F\u3064",
        "\u3072\u3081\u3044",
        "\u3072\u3081\u3057\u3099\u3057",
        "\u3072\u3084\u3051",
        "\u3072\u3084\u3059",
        "\u3072\u3088\u3046",
        "\u3072\u3099\u3087\u3046\u304D",
        "\u3072\u3089\u304B\u3099\u306A",
        "\u3072\u3089\u304F",
        "\u3072\u308A\u3064",
        "\u3072\u308A\u3087\u3046",
        "\u3072\u308B\u307E",
        "\u3072\u308B\u3084\u3059\u307F",
        "\u3072\u308C\u3044",
        "\u3072\u308D\u3044",
        "\u3072\u308D\u3046",
        "\u3072\u308D\u304D",
        "\u3072\u308D\u3086\u304D",
        "\u3072\u3093\u304B\u304F",
        "\u3072\u3093\u3051\u3064",
        "\u3072\u3093\u3053\u3093",
        "\u3072\u3093\u3057\u3085",
        "\u3072\u3093\u305D\u3046",
        "\u3072\u309A\u3093\u3061",
        "\u3072\u3093\u306F\u309A\u3093",
        "\u3072\u3099\u3093\u307B\u3099\u3046",
        "\u3075\u3042\u3093",
        "\u3075\u3044\u3046\u3061",
        "\u3075\u3046\u3051\u3044",
        "\u3075\u3046\u305B\u3093",
        "\u3075\u309A\u3046\u305F\u308D\u3046",
        "\u3075\u3046\u3068\u3046",
        "\u3075\u3046\u3075",
        "\u3075\u3048\u308B",
        "\u3075\u304A\u3093",
        "\u3075\u304B\u3044",
        "\u3075\u304D\u3093",
        "\u3075\u304F\u3055\u3099\u3064",
        "\u3075\u304F\u3075\u3099\u304F\u308D",
        "\u3075\u3053\u3046",
        "\u3075\u3055\u3044",
        "\u3075\u3057\u304D\u3099",
        "\u3075\u3057\u3099\u307F",
        "\u3075\u3059\u307E",
        "\u3075\u305B\u3044",
        "\u3075\u305B\u304F\u3099",
        "\u3075\u305D\u304F",
        "\u3075\u3099\u305F\u306B\u304F",
        "\u3075\u305F\u3093",
        "\u3075\u3061\u3087\u3046",
        "\u3075\u3064\u3046",
        "\u3075\u3064\u304B",
        "\u3075\u3063\u304B\u3064",
        "\u3075\u3063\u304D",
        "\u3075\u3063\u3053\u304F",
        "\u3075\u3099\u3068\u3099\u3046",
        "\u3075\u3068\u308B",
        "\u3075\u3068\u3093",
        "\u3075\u306E\u3046",
        "\u3075\u306F\u3044",
        "\u3075\u3072\u3087\u3046",
        "\u3075\u3078\u3093",
        "\u3075\u307E\u3093",
        "\u3075\u307F\u3093",
        "\u3075\u3081\u3064",
        "\u3075\u3081\u3093",
        "\u3075\u3088\u3046",
        "\u3075\u308A\u3053",
        "\u3075\u308A\u308B",
        "\u3075\u308B\u3044",
        "\u3075\u3093\u3044\u304D",
        "\u3075\u3099\u3093\u304B\u3099\u304F",
        "\u3075\u3099\u3093\u304F\u3099",
        "\u3075\u3093\u3057\u3064",
        "\u3075\u3099\u3093\u305B\u304D",
        "\u3075\u3093\u305D\u3046",
        "\u3075\u3099\u3093\u307B\u309A\u3046",
        "\u3078\u3044\u3042\u3093",
        "\u3078\u3044\u304A\u3093",
        "\u3078\u3044\u304B\u3099\u3044",
        "\u3078\u3044\u304D",
        "\u3078\u3044\u3051\u3099\u3093",
        "\u3078\u3044\u3053\u3046",
        "\u3078\u3044\u3055",
        "\u3078\u3044\u3057\u3083",
        "\u3078\u3044\u305B\u3064",
        "\u3078\u3044\u305D",
        "\u3078\u3044\u305F\u304F",
        "\u3078\u3044\u3066\u3093",
        "\u3078\u3044\u306D\u3064",
        "\u3078\u3044\u308F",
        "\u3078\u304D\u304B\u3099",
        "\u3078\u3053\u3080",
        "\u3078\u3099\u306B\u3044\u308D",
        "\u3078\u3099\u306B\u3057\u3087\u3046\u304B\u3099",
        "\u3078\u3089\u3059",
        "\u3078\u3093\u304B\u3093",
        "\u3078\u3099\u3093\u304D\u3087\u3046",
        "\u3078\u3099\u3093\u3053\u3099\u3057",
        "\u3078\u3093\u3055\u3044",
        "\u3078\u3093\u305F\u3044",
        "\u3078\u3099\u3093\u308A",
        "\u307B\u3042\u3093",
        "\u307B\u3044\u304F",
        "\u307B\u3099\u3046\u304D\u3099\u3087",
        "\u307B\u3046\u3053\u304F",
        "\u307B\u3046\u305D\u3046",
        "\u307B\u3046\u307B\u3046",
        "\u307B\u3046\u3082\u3093",
        "\u307B\u3046\u308A\u3064",
        "\u307B\u3048\u308B",
        "\u307B\u304A\u3093",
        "\u307B\u304B\u3093",
        "\u307B\u304D\u3087\u3046",
        "\u307B\u3099\u304D\u3093",
        "\u307B\u304F\u308D",
        "\u307B\u3051\u3064",
        "\u307B\u3051\u3093",
        "\u307B\u3053\u3046",
        "\u307B\u3053\u308B",
        "\u307B\u3057\u3044",
        "\u307B\u3057\u3064",
        "\u307B\u3057\u3085",
        "\u307B\u3057\u3087\u3046",
        "\u307B\u305B\u3044",
        "\u307B\u305D\u3044",
        "\u307B\u305D\u304F",
        "\u307B\u305F\u3066",
        "\u307B\u305F\u308B",
        "\u307B\u309A\u3061\u3075\u3099\u304F\u308D",
        "\u307B\u3063\u304D\u3087\u304F",
        "\u307B\u3063\u3055",
        "\u307B\u3063\u305F\u3093",
        "\u307B\u3068\u3093\u3068\u3099",
        "\u307B\u3081\u308B",
        "\u307B\u3093\u3044",
        "\u307B\u3093\u304D",
        "\u307B\u3093\u3051",
        "\u307B\u3093\u3057\u3064",
        "\u307B\u3093\u3084\u304F",
        "\u307E\u3044\u306B\u3061",
        "\u307E\u304B\u3044",
        "\u307E\u304B\u305B\u308B",
        "\u307E\u304B\u3099\u308B",
        "\u307E\u3051\u308B",
        "\u307E\u3053\u3068",
        "\u307E\u3055\u3064",
        "\u307E\u3057\u3099\u3081",
        "\u307E\u3059\u304F",
        "\u307E\u305B\u3099\u308B",
        "\u307E\u3064\u308A",
        "\u307E\u3068\u3081",
        "\u307E\u306A\u3075\u3099",
        "\u307E\u306C\u3051",
        "\u307E\u306D\u304F",
        "\u307E\u307B\u3046",
        "\u307E\u3082\u308B",
        "\u307E\u3086\u3051\u3099",
        "\u307E\u3088\u3046",
        "\u307E\u308D\u3084\u304B",
        "\u307E\u308F\u3059",
        "\u307E\u308F\u308A",
        "\u307E\u308F\u308B",
        "\u307E\u3093\u304B\u3099",
        "\u307E\u3093\u304D\u3064",
        "\u307E\u3093\u305D\u3099\u304F",
        "\u307E\u3093\u306A\u304B",
        "\u307F\u3044\u3089",
        "\u307F\u3046\u3061",
        "\u307F\u3048\u308B",
        "\u307F\u304B\u3099\u304F",
        "\u307F\u304B\u305F",
        "\u307F\u304B\u3093",
        "\u307F\u3051\u3093",
        "\u307F\u3053\u3093",
        "\u307F\u3057\u3099\u304B\u3044",
        "\u307F\u3059\u3044",
        "\u307F\u3059\u3048\u308B",
        "\u307F\u305B\u308B",
        "\u307F\u3063\u304B",
        "\u307F\u3064\u304B\u308B",
        "\u307F\u3064\u3051\u308B",
        "\u307F\u3066\u3044",
        "\u307F\u3068\u3081\u308B",
        "\u307F\u306A\u3068",
        "\u307F\u306A\u307F\u304B\u3055\u3044",
        "\u307F\u306D\u3089\u308B",
        "\u307F\u306E\u3046",
        "\u307F\u306E\u304B\u3099\u3059",
        "\u307F\u307B\u3093",
        "\u307F\u3082\u3068",
        "\u307F\u3084\u3051\u3099",
        "\u307F\u3089\u3044",
        "\u307F\u308A\u3087\u304F",
        "\u307F\u308F\u304F",
        "\u307F\u3093\u304B",
        "\u307F\u3093\u305D\u3099\u304F",
        "\u3080\u3044\u304B",
        "\u3080\u3048\u304D",
        "\u3080\u3048\u3093",
        "\u3080\u304B\u3044",
        "\u3080\u304B\u3046",
        "\u3080\u304B\u3048",
        "\u3080\u304B\u3057",
        "\u3080\u304D\u3099\u3061\u3083",
        "\u3080\u3051\u308B",
        "\u3080\u3051\u3099\u3093",
        "\u3080\u3055\u307B\u3099\u308B",
        "\u3080\u3057\u3042\u3064\u3044",
        "\u3080\u3057\u306F\u3099",
        "\u3080\u3057\u3099\u3085\u3093",
        "\u3080\u3057\u308D",
        "\u3080\u3059\u3046",
        "\u3080\u3059\u3053",
        "\u3080\u3059\u3075\u3099",
        "\u3080\u3059\u3081",
        "\u3080\u305B\u308B",
        "\u3080\u305B\u3093",
        "\u3080\u3061\u3085\u3046",
        "\u3080\u306A\u3057\u3044",
        "\u3080\u306E\u3046",
        "\u3080\u3084\u307F",
        "\u3080\u3088\u3046",
        "\u3080\u3089\u3055\u304D",
        "\u3080\u308A\u3087\u3046",
        "\u3080\u308D\u3093",
        "\u3081\u3044\u3042\u3093",
        "\u3081\u3044\u3046\u3093",
        "\u3081\u3044\u3048\u3093",
        "\u3081\u3044\u304B\u304F",
        "\u3081\u3044\u304D\u3087\u304F",
        "\u3081\u3044\u3055\u3044",
        "\u3081\u3044\u3057",
        "\u3081\u3044\u305D\u3046",
        "\u3081\u3044\u3075\u3099\u3064",
        "\u3081\u3044\u308C\u3044",
        "\u3081\u3044\u308F\u304F",
        "\u3081\u304F\u3099\u307E\u308C\u308B",
        "\u3081\u3055\u3099\u3059",
        "\u3081\u3057\u305F",
        "\u3081\u3059\u3099\u3089\u3057\u3044",
        "\u3081\u305F\u3099\u3064",
        "\u3081\u307E\u3044",
        "\u3081\u3084\u3059",
        "\u3081\u3093\u304D\u3087",
        "\u3081\u3093\u305B\u304D",
        "\u3081\u3093\u3068\u3099\u3046",
        "\u3082\u3046\u3057\u3042\u3051\u3099\u308B",
        "\u3082\u3046\u3068\u3099\u3046\u3051\u3093",
        "\u3082\u3048\u308B",
        "\u3082\u304F\u3057",
        "\u3082\u304F\u3066\u304D",
        "\u3082\u304F\u3088\u3046\u3072\u3099",
        "\u3082\u3061\u308D\u3093",
        "\u3082\u3068\u3099\u308B",
        "\u3082\u3089\u3046",
        "\u3082\u3093\u304F",
        "\u3082\u3093\u305F\u3099\u3044",
        "\u3084\u304A\u3084",
        "\u3084\u3051\u308B",
        "\u3084\u3055\u3044",
        "\u3084\u3055\u3057\u3044",
        "\u3084\u3059\u3044",
        "\u3084\u3059\u305F\u308D\u3046",
        "\u3084\u3059\u307F",
        "\u3084\u305B\u308B",
        "\u3084\u305D\u3046",
        "\u3084\u305F\u3044",
        "\u3084\u3061\u3093",
        "\u3084\u3063\u3068",
        "\u3084\u3063\u306F\u309A\u308A",
        "\u3084\u3075\u3099\u308B",
        "\u3084\u3081\u308B",
        "\u3084\u3084\u3053\u3057\u3044",
        "\u3084\u3088\u3044",
        "\u3084\u308F\u3089\u304B\u3044",
        "\u3086\u3046\u304D",
        "\u3086\u3046\u3072\u3099\u3093\u304D\u3087\u304F",
        "\u3086\u3046\u3078\u3099",
        "\u3086\u3046\u3081\u3044",
        "\u3086\u3051\u3064",
        "\u3086\u3057\u3085\u3064",
        "\u3086\u305B\u3093",
        "\u3086\u305D\u3046",
        "\u3086\u305F\u304B",
        "\u3086\u3061\u3083\u304F",
        "\u3086\u3066\u3099\u308B",
        "\u3086\u306B\u3085\u3046",
        "\u3086\u3072\u3099\u308F",
        "\u3086\u3089\u3044",
        "\u3086\u308C\u308B",
        "\u3088\u3046\u3044",
        "\u3088\u3046\u304B",
        "\u3088\u3046\u304D\u3085\u3046",
        "\u3088\u3046\u3057\u3099",
        "\u3088\u3046\u3059",
        "\u3088\u3046\u3061\u3048\u3093",
        "\u3088\u304B\u305B\u3099",
        "\u3088\u304B\u3093",
        "\u3088\u304D\u3093",
        "\u3088\u304F\u305B\u3044",
        "\u3088\u304F\u307B\u3099\u3046",
        "\u3088\u3051\u3044",
        "\u3088\u3053\u3099\u308C\u308B",
        "\u3088\u3055\u3093",
        "\u3088\u3057\u3085\u3046",
        "\u3088\u305D\u3046",
        "\u3088\u305D\u304F",
        "\u3088\u3063\u304B",
        "\u3088\u3066\u3044",
        "\u3088\u3068\u3099\u304B\u3099\u308F\u304F",
        "\u3088\u306D\u3064",
        "\u3088\u3084\u304F",
        "\u3088\u3086\u3046",
        "\u3088\u308D\u3053\u3075\u3099",
        "\u3088\u308D\u3057\u3044",
        "\u3089\u3044\u3046",
        "\u3089\u304F\u304B\u3099\u304D",
        "\u3089\u304F\u3053\u3099",
        "\u3089\u304F\u3055\u3064",
        "\u3089\u304F\u305F\u3099",
        "\u3089\u3057\u3093\u306F\u3099\u3093",
        "\u3089\u305B\u3093",
        "\u3089\u305D\u3099\u304F",
        "\u3089\u305F\u3044",
        "\u3089\u3063\u304B",
        "\u3089\u308C\u3064",
        "\u308A\u3048\u304D",
        "\u308A\u304B\u3044",
        "\u308A\u304D\u3055\u304F",
        "\u308A\u304D\u305B\u3064",
        "\u308A\u304F\u304F\u3099\u3093",
        "\u308A\u304F\u3064",
        "\u308A\u3051\u3093",
        "\u308A\u3053\u3046",
        "\u308A\u305B\u3044",
        "\u308A\u305D\u3046",
        "\u308A\u305D\u304F",
        "\u308A\u3066\u3093",
        "\u308A\u306D\u3093",
        "\u308A\u3086\u3046",
        "\u308A\u3085\u3046\u304B\u3099\u304F",
        "\u308A\u3088\u3046",
        "\u308A\u3087\u3046\u308A",
        "\u308A\u3087\u304B\u3093",
        "\u308A\u3087\u304F\u3061\u3083",
        "\u308A\u3087\u3053\u3046",
        "\u308A\u308A\u304F",
        "\u308A\u308C\u304D",
        "\u308A\u308D\u3093",
        "\u308A\u3093\u3053\u3099",
        "\u308B\u3044\u3051\u3044",
        "\u308B\u3044\u3055\u3044",
        "\u308B\u3044\u3057\u3099",
        "\u308B\u3044\u305B\u304D",
        "\u308B\u3059\u306F\u3099\u3093",
        "\u308B\u308A\u304B\u3099\u308F\u3089",
        "\u308C\u3044\u304B\u3093",
        "\u308C\u3044\u304D\u3099",
        "\u308C\u3044\u305B\u3044",
        "\u308C\u3044\u305D\u3099\u3046\u3053",
        "\u308C\u3044\u3068\u3046",
        "\u308C\u3044\u307B\u3099\u3046",
        "\u308C\u304D\u3057",
        "\u308C\u304D\u305F\u3099\u3044",
        "\u308C\u3093\u3042\u3044",
        "\u308C\u3093\u3051\u3044",
        "\u308C\u3093\u3053\u3093",
        "\u308C\u3093\u3055\u3044",
        "\u308C\u3093\u3057\u3085\u3046",
        "\u308C\u3093\u305D\u3099\u304F",
        "\u308C\u3093\u3089\u304F",
        "\u308D\u3046\u304B",
        "\u308D\u3046\u3053\u3099",
        "\u308D\u3046\u3057\u3099\u3093",
        "\u308D\u3046\u305D\u304F",
        "\u308D\u304F\u304B\u3099",
        "\u308D\u3053\u3064",
        "\u308D\u3057\u3099\u3046\u3089",
        "\u308D\u3057\u3085\u3064",
        "\u308D\u305B\u3093",
        "\u308D\u3066\u3093",
        "\u308D\u3081\u3093",
        "\u308D\u308C\u3064",
        "\u308D\u3093\u304D\u3099",
        "\u308D\u3093\u306F\u309A",
        "\u308D\u3093\u3075\u3099\u3093",
        "\u308D\u3093\u308A",
        "\u308F\u304B\u3059",
        "\u308F\u304B\u3081",
        "\u308F\u304B\u3084\u307E",
        "\u308F\u304B\u308C\u308B",
        "\u308F\u3057\u3064",
        "\u308F\u3057\u3099\u307E\u3057",
        "\u308F\u3059\u308C\u3082\u306E",
        "\u308F\u3089\u3046",
        "\u308F\u308C\u308B"
      ];
    }
  });

  // node_modules/bip39/src/wordlists/portuguese.json
  var require_portuguese = __commonJS({
    "node_modules/bip39/src/wordlists/portuguese.json"(exports9, module) {
      module.exports = [
        "abacate",
        "abaixo",
        "abalar",
        "abater",
        "abduzir",
        "abelha",
        "aberto",
        "abismo",
        "abotoar",
        "abranger",
        "abreviar",
        "abrigar",
        "abrupto",
        "absinto",
        "absoluto",
        "absurdo",
        "abutre",
        "acabado",
        "acalmar",
        "acampar",
        "acanhar",
        "acaso",
        "aceitar",
        "acelerar",
        "acenar",
        "acervo",
        "acessar",
        "acetona",
        "achatar",
        "acidez",
        "acima",
        "acionado",
        "acirrar",
        "aclamar",
        "aclive",
        "acolhida",
        "acomodar",
        "acoplar",
        "acordar",
        "acumular",
        "acusador",
        "adaptar",
        "adega",
        "adentro",
        "adepto",
        "adequar",
        "aderente",
        "adesivo",
        "adeus",
        "adiante",
        "aditivo",
        "adjetivo",
        "adjunto",
        "admirar",
        "adorar",
        "adquirir",
        "adubo",
        "adverso",
        "advogado",
        "aeronave",
        "afastar",
        "aferir",
        "afetivo",
        "afinador",
        "afivelar",
        "aflito",
        "afluente",
        "afrontar",
        "agachar",
        "agarrar",
        "agasalho",
        "agenciar",
        "agilizar",
        "agiota",
        "agitado",
        "agora",
        "agradar",
        "agreste",
        "agrupar",
        "aguardar",
        "agulha",
        "ajoelhar",
        "ajudar",
        "ajustar",
        "alameda",
        "alarme",
        "alastrar",
        "alavanca",
        "albergue",
        "albino",
        "alcatra",
        "aldeia",
        "alecrim",
        "alegria",
        "alertar",
        "alface",
        "alfinete",
        "algum",
        "alheio",
        "aliar",
        "alicate",
        "alienar",
        "alinhar",
        "aliviar",
        "almofada",
        "alocar",
        "alpiste",
        "alterar",
        "altitude",
        "alucinar",
        "alugar",
        "aluno",
        "alusivo",
        "alvo",
        "amaciar",
        "amador",
        "amarelo",
        "amassar",
        "ambas",
        "ambiente",
        "ameixa",
        "amenizar",
        "amido",
        "amistoso",
        "amizade",
        "amolador",
        "amontoar",
        "amoroso",
        "amostra",
        "amparar",
        "ampliar",
        "ampola",
        "anagrama",
        "analisar",
        "anarquia",
        "anatomia",
        "andaime",
        "anel",
        "anexo",
        "angular",
        "animar",
        "anjo",
        "anomalia",
        "anotado",
        "ansioso",
        "anterior",
        "anuidade",
        "anunciar",
        "anzol",
        "apagador",
        "apalpar",
        "apanhado",
        "apego",
        "apelido",
        "apertada",
        "apesar",
        "apetite",
        "apito",
        "aplauso",
        "aplicada",
        "apoio",
        "apontar",
        "aposta",
        "aprendiz",
        "aprovar",
        "aquecer",
        "arame",
        "aranha",
        "arara",
        "arcada",
        "ardente",
        "areia",
        "arejar",
        "arenito",
        "aresta",
        "argiloso",
        "argola",
        "arma",
        "arquivo",
        "arraial",
        "arrebate",
        "arriscar",
        "arroba",
        "arrumar",
        "arsenal",
        "arterial",
        "artigo",
        "arvoredo",
        "asfaltar",
        "asilado",
        "aspirar",
        "assador",
        "assinar",
        "assoalho",
        "assunto",
        "astral",
        "atacado",
        "atadura",
        "atalho",
        "atarefar",
        "atear",
        "atender",
        "aterro",
        "ateu",
        "atingir",
        "atirador",
        "ativo",
        "atoleiro",
        "atracar",
        "atrevido",
        "atriz",
        "atual",
        "atum",
        "auditor",
        "aumentar",
        "aura",
        "aurora",
        "autismo",
        "autoria",
        "autuar",
        "avaliar",
        "avante",
        "avaria",
        "avental",
        "avesso",
        "aviador",
        "avisar",
        "avulso",
        "axila",
        "azarar",
        "azedo",
        "azeite",
        "azulejo",
        "babar",
        "babosa",
        "bacalhau",
        "bacharel",
        "bacia",
        "bagagem",
        "baiano",
        "bailar",
        "baioneta",
        "bairro",
        "baixista",
        "bajular",
        "baleia",
        "baliza",
        "balsa",
        "banal",
        "bandeira",
        "banho",
        "banir",
        "banquete",
        "barato",
        "barbado",
        "baronesa",
        "barraca",
        "barulho",
        "baseado",
        "bastante",
        "batata",
        "batedor",
        "batida",
        "batom",
        "batucar",
        "baunilha",
        "beber",
        "beijo",
        "beirada",
        "beisebol",
        "beldade",
        "beleza",
        "belga",
        "beliscar",
        "bendito",
        "bengala",
        "benzer",
        "berimbau",
        "berlinda",
        "berro",
        "besouro",
        "bexiga",
        "bezerro",
        "bico",
        "bicudo",
        "bienal",
        "bifocal",
        "bifurcar",
        "bigorna",
        "bilhete",
        "bimestre",
        "bimotor",
        "biologia",
        "biombo",
        "biosfera",
        "bipolar",
        "birrento",
        "biscoito",
        "bisneto",
        "bispo",
        "bissexto",
        "bitola",
        "bizarro",
        "blindado",
        "bloco",
        "bloquear",
        "boato",
        "bobagem",
        "bocado",
        "bocejo",
        "bochecha",
        "boicotar",
        "bolada",
        "boletim",
        "bolha",
        "bolo",
        "bombeiro",
        "bonde",
        "boneco",
        "bonita",
        "borbulha",
        "borda",
        "boreal",
        "borracha",
        "bovino",
        "boxeador",
        "branco",
        "brasa",
        "braveza",
        "breu",
        "briga",
        "brilho",
        "brincar",
        "broa",
        "brochura",
        "bronzear",
        "broto",
        "bruxo",
        "bucha",
        "budismo",
        "bufar",
        "bule",
        "buraco",
        "busca",
        "busto",
        "buzina",
        "cabana",
        "cabelo",
        "cabide",
        "cabo",
        "cabrito",
        "cacau",
        "cacetada",
        "cachorro",
        "cacique",
        "cadastro",
        "cadeado",
        "cafezal",
        "caiaque",
        "caipira",
        "caixote",
        "cajado",
        "caju",
        "calafrio",
        "calcular",
        "caldeira",
        "calibrar",
        "calmante",
        "calota",
        "camada",
        "cambista",
        "camisa",
        "camomila",
        "campanha",
        "camuflar",
        "canavial",
        "cancelar",
        "caneta",
        "canguru",
        "canhoto",
        "canivete",
        "canoa",
        "cansado",
        "cantar",
        "canudo",
        "capacho",
        "capela",
        "capinar",
        "capotar",
        "capricho",
        "captador",
        "capuz",
        "caracol",
        "carbono",
        "cardeal",
        "careca",
        "carimbar",
        "carneiro",
        "carpete",
        "carreira",
        "cartaz",
        "carvalho",
        "casaco",
        "casca",
        "casebre",
        "castelo",
        "casulo",
        "catarata",
        "cativar",
        "caule",
        "causador",
        "cautelar",
        "cavalo",
        "caverna",
        "cebola",
        "cedilha",
        "cegonha",
        "celebrar",
        "celular",
        "cenoura",
        "censo",
        "centeio",
        "cercar",
        "cerrado",
        "certeiro",
        "cerveja",
        "cetim",
        "cevada",
        "chacota",
        "chaleira",
        "chamado",
        "chapada",
        "charme",
        "chatice",
        "chave",
        "chefe",
        "chegada",
        "cheiro",
        "cheque",
        "chicote",
        "chifre",
        "chinelo",
        "chocalho",
        "chover",
        "chumbo",
        "chutar",
        "chuva",
        "cicatriz",
        "ciclone",
        "cidade",
        "cidreira",
        "ciente",
        "cigana",
        "cimento",
        "cinto",
        "cinza",
        "ciranda",
        "circuito",
        "cirurgia",
        "citar",
        "clareza",
        "clero",
        "clicar",
        "clone",
        "clube",
        "coado",
        "coagir",
        "cobaia",
        "cobertor",
        "cobrar",
        "cocada",
        "coelho",
        "coentro",
        "coeso",
        "cogumelo",
        "coibir",
        "coifa",
        "coiote",
        "colar",
        "coleira",
        "colher",
        "colidir",
        "colmeia",
        "colono",
        "coluna",
        "comando",
        "combinar",
        "comentar",
        "comitiva",
        "comover",
        "complexo",
        "comum",
        "concha",
        "condor",
        "conectar",
        "confuso",
        "congelar",
        "conhecer",
        "conjugar",
        "consumir",
        "contrato",
        "convite",
        "cooperar",
        "copeiro",
        "copiador",
        "copo",
        "coquetel",
        "coragem",
        "cordial",
        "corneta",
        "coronha",
        "corporal",
        "correio",
        "cortejo",
        "coruja",
        "corvo",
        "cosseno",
        "costela",
        "cotonete",
        "couro",
        "couve",
        "covil",
        "cozinha",
        "cratera",
        "cravo",
        "creche",
        "credor",
        "creme",
        "crer",
        "crespo",
        "criada",
        "criminal",
        "crioulo",
        "crise",
        "criticar",
        "crosta",
        "crua",
        "cruzeiro",
        "cubano",
        "cueca",
        "cuidado",
        "cujo",
        "culatra",
        "culminar",
        "culpar",
        "cultura",
        "cumprir",
        "cunhado",
        "cupido",
        "curativo",
        "curral",
        "cursar",
        "curto",
        "cuspir",
        "custear",
        "cutelo",
        "damasco",
        "datar",
        "debater",
        "debitar",
        "deboche",
        "debulhar",
        "decalque",
        "decimal",
        "declive",
        "decote",
        "decretar",
        "dedal",
        "dedicado",
        "deduzir",
        "defesa",
        "defumar",
        "degelo",
        "degrau",
        "degustar",
        "deitado",
        "deixar",
        "delator",
        "delegado",
        "delinear",
        "delonga",
        "demanda",
        "demitir",
        "demolido",
        "dentista",
        "depenado",
        "depilar",
        "depois",
        "depressa",
        "depurar",
        "deriva",
        "derramar",
        "desafio",
        "desbotar",
        "descanso",
        "desenho",
        "desfiado",
        "desgaste",
        "desigual",
        "deslize",
        "desmamar",
        "desova",
        "despesa",
        "destaque",
        "desviar",
        "detalhar",
        "detentor",
        "detonar",
        "detrito",
        "deusa",
        "dever",
        "devido",
        "devotado",
        "dezena",
        "diagrama",
        "dialeto",
        "didata",
        "difuso",
        "digitar",
        "dilatado",
        "diluente",
        "diminuir",
        "dinastia",
        "dinheiro",
        "diocese",
        "direto",
        "discreta",
        "disfarce",
        "disparo",
        "disquete",
        "dissipar",
        "distante",
        "ditador",
        "diurno",
        "diverso",
        "divisor",
        "divulgar",
        "dizer",
        "dobrador",
        "dolorido",
        "domador",
        "dominado",
        "donativo",
        "donzela",
        "dormente",
        "dorsal",
        "dosagem",
        "dourado",
        "doutor",
        "drenagem",
        "drible",
        "drogaria",
        "duelar",
        "duende",
        "dueto",
        "duplo",
        "duquesa",
        "durante",
        "duvidoso",
        "eclodir",
        "ecoar",
        "ecologia",
        "edificar",
        "edital",
        "educado",
        "efeito",
        "efetivar",
        "ejetar",
        "elaborar",
        "eleger",
        "eleitor",
        "elenco",
        "elevador",
        "eliminar",
        "elogiar",
        "embargo",
        "embolado",
        "embrulho",
        "embutido",
        "emenda",
        "emergir",
        "emissor",
        "empatia",
        "empenho",
        "empinado",
        "empolgar",
        "emprego",
        "empurrar",
        "emulador",
        "encaixe",
        "encenado",
        "enchente",
        "encontro",
        "endeusar",
        "endossar",
        "enfaixar",
        "enfeite",
        "enfim",
        "engajado",
        "engenho",
        "englobar",
        "engomado",
        "engraxar",
        "enguia",
        "enjoar",
        "enlatar",
        "enquanto",
        "enraizar",
        "enrolado",
        "enrugar",
        "ensaio",
        "enseada",
        "ensino",
        "ensopado",
        "entanto",
        "enteado",
        "entidade",
        "entortar",
        "entrada",
        "entulho",
        "envergar",
        "enviado",
        "envolver",
        "enxame",
        "enxerto",
        "enxofre",
        "enxuto",
        "epiderme",
        "equipar",
        "ereto",
        "erguido",
        "errata",
        "erva",
        "ervilha",
        "esbanjar",
        "esbelto",
        "escama",
        "escola",
        "escrita",
        "escuta",
        "esfinge",
        "esfolar",
        "esfregar",
        "esfumado",
        "esgrima",
        "esmalte",
        "espanto",
        "espelho",
        "espiga",
        "esponja",
        "espreita",
        "espumar",
        "esquerda",
        "estaca",
        "esteira",
        "esticar",
        "estofado",
        "estrela",
        "estudo",
        "esvaziar",
        "etanol",
        "etiqueta",
        "euforia",
        "europeu",
        "evacuar",
        "evaporar",
        "evasivo",
        "eventual",
        "evidente",
        "evoluir",
        "exagero",
        "exalar",
        "examinar",
        "exato",
        "exausto",
        "excesso",
        "excitar",
        "exclamar",
        "executar",
        "exemplo",
        "exibir",
        "exigente",
        "exonerar",
        "expandir",
        "expelir",
        "expirar",
        "explanar",
        "exposto",
        "expresso",
        "expulsar",
        "externo",
        "extinto",
        "extrato",
        "fabricar",
        "fabuloso",
        "faceta",
        "facial",
        "fada",
        "fadiga",
        "faixa",
        "falar",
        "falta",
        "familiar",
        "fandango",
        "fanfarra",
        "fantoche",
        "fardado",
        "farelo",
        "farinha",
        "farofa",
        "farpa",
        "fartura",
        "fatia",
        "fator",
        "favorita",
        "faxina",
        "fazenda",
        "fechado",
        "feijoada",
        "feirante",
        "felino",
        "feminino",
        "fenda",
        "feno",
        "fera",
        "feriado",
        "ferrugem",
        "ferver",
        "festejar",
        "fetal",
        "feudal",
        "fiapo",
        "fibrose",
        "ficar",
        "ficheiro",
        "figurado",
        "fileira",
        "filho",
        "filme",
        "filtrar",
        "firmeza",
        "fisgada",
        "fissura",
        "fita",
        "fivela",
        "fixador",
        "fixo",
        "flacidez",
        "flamingo",
        "flanela",
        "flechada",
        "flora",
        "flutuar",
        "fluxo",
        "focal",
        "focinho",
        "fofocar",
        "fogo",
        "foguete",
        "foice",
        "folgado",
        "folheto",
        "forjar",
        "formiga",
        "forno",
        "forte",
        "fosco",
        "fossa",
        "fragata",
        "fralda",
        "frango",
        "frasco",
        "fraterno",
        "freira",
        "frente",
        "fretar",
        "frieza",
        "friso",
        "fritura",
        "fronha",
        "frustrar",
        "fruteira",
        "fugir",
        "fulano",
        "fuligem",
        "fundar",
        "fungo",
        "funil",
        "furador",
        "furioso",
        "futebol",
        "gabarito",
        "gabinete",
        "gado",
        "gaiato",
        "gaiola",
        "gaivota",
        "galega",
        "galho",
        "galinha",
        "galocha",
        "ganhar",
        "garagem",
        "garfo",
        "gargalo",
        "garimpo",
        "garoupa",
        "garrafa",
        "gasoduto",
        "gasto",
        "gata",
        "gatilho",
        "gaveta",
        "gazela",
        "gelado",
        "geleia",
        "gelo",
        "gemada",
        "gemer",
        "gemido",
        "generoso",
        "gengiva",
        "genial",
        "genoma",
        "genro",
        "geologia",
        "gerador",
        "germinar",
        "gesso",
        "gestor",
        "ginasta",
        "gincana",
        "gingado",
        "girafa",
        "girino",
        "glacial",
        "glicose",
        "global",
        "glorioso",
        "goela",
        "goiaba",
        "golfe",
        "golpear",
        "gordura",
        "gorjeta",
        "gorro",
        "gostoso",
        "goteira",
        "governar",
        "gracejo",
        "gradual",
        "grafite",
        "gralha",
        "grampo",
        "granada",
        "gratuito",
        "graveto",
        "graxa",
        "grego",
        "grelhar",
        "greve",
        "grilo",
        "grisalho",
        "gritaria",
        "grosso",
        "grotesco",
        "grudado",
        "grunhido",
        "gruta",
        "guache",
        "guarani",
        "guaxinim",
        "guerrear",
        "guiar",
        "guincho",
        "guisado",
        "gula",
        "guloso",
        "guru",
        "habitar",
        "harmonia",
        "haste",
        "haver",
        "hectare",
        "herdar",
        "heresia",
        "hesitar",
        "hiato",
        "hibernar",
        "hidratar",
        "hiena",
        "hino",
        "hipismo",
        "hipnose",
        "hipoteca",
        "hoje",
        "holofote",
        "homem",
        "honesto",
        "honrado",
        "hormonal",
        "hospedar",
        "humorado",
        "iate",
        "ideia",
        "idoso",
        "ignorado",
        "igreja",
        "iguana",
        "ileso",
        "ilha",
        "iludido",
        "iluminar",
        "ilustrar",
        "imagem",
        "imediato",
        "imenso",
        "imersivo",
        "iminente",
        "imitador",
        "imortal",
        "impacto",
        "impedir",
        "implante",
        "impor",
        "imprensa",
        "impune",
        "imunizar",
        "inalador",
        "inapto",
        "inativo",
        "incenso",
        "inchar",
        "incidir",
        "incluir",
        "incolor",
        "indeciso",
        "indireto",
        "indutor",
        "ineficaz",
        "inerente",
        "infantil",
        "infestar",
        "infinito",
        "inflamar",
        "informal",
        "infrator",
        "ingerir",
        "inibido",
        "inicial",
        "inimigo",
        "injetar",
        "inocente",
        "inodoro",
        "inovador",
        "inox",
        "inquieto",
        "inscrito",
        "inseto",
        "insistir",
        "inspetor",
        "instalar",
        "insulto",
        "intacto",
        "integral",
        "intimar",
        "intocado",
        "intriga",
        "invasor",
        "inverno",
        "invicto",
        "invocar",
        "iogurte",
        "iraniano",
        "ironizar",
        "irreal",
        "irritado",
        "isca",
        "isento",
        "isolado",
        "isqueiro",
        "italiano",
        "janeiro",
        "jangada",
        "janta",
        "jararaca",
        "jardim",
        "jarro",
        "jasmim",
        "jato",
        "javali",
        "jazida",
        "jejum",
        "joaninha",
        "joelhada",
        "jogador",
        "joia",
        "jornal",
        "jorrar",
        "jovem",
        "juba",
        "judeu",
        "judoca",
        "juiz",
        "julgador",
        "julho",
        "jurado",
        "jurista",
        "juro",
        "justa",
        "labareda",
        "laboral",
        "lacre",
        "lactante",
        "ladrilho",
        "lagarta",
        "lagoa",
        "laje",
        "lamber",
        "lamentar",
        "laminar",
        "lampejo",
        "lanche",
        "lapidar",
        "lapso",
        "laranja",
        "lareira",
        "largura",
        "lasanha",
        "lastro",
        "lateral",
        "latido",
        "lavanda",
        "lavoura",
        "lavrador",
        "laxante",
        "lazer",
        "lealdade",
        "lebre",
        "legado",
        "legendar",
        "legista",
        "leigo",
        "leiloar",
        "leitura",
        "lembrete",
        "leme",
        "lenhador",
        "lentilha",
        "leoa",
        "lesma",
        "leste",
        "letivo",
        "letreiro",
        "levar",
        "leveza",
        "levitar",
        "liberal",
        "libido",
        "liderar",
        "ligar",
        "ligeiro",
        "limitar",
        "limoeiro",
        "limpador",
        "linda",
        "linear",
        "linhagem",
        "liquidez",
        "listagem",
        "lisura",
        "litoral",
        "livro",
        "lixa",
        "lixeira",
        "locador",
        "locutor",
        "lojista",
        "lombo",
        "lona",
        "longe",
        "lontra",
        "lorde",
        "lotado",
        "loteria",
        "loucura",
        "lousa",
        "louvar",
        "luar",
        "lucidez",
        "lucro",
        "luneta",
        "lustre",
        "lutador",
        "luva",
        "macaco",
        "macete",
        "machado",
        "macio",
        "madeira",
        "madrinha",
        "magnata",
        "magreza",
        "maior",
        "mais",
        "malandro",
        "malha",
        "malote",
        "maluco",
        "mamilo",
        "mamoeiro",
        "mamute",
        "manada",
        "mancha",
        "mandato",
        "manequim",
        "manhoso",
        "manivela",
        "manobrar",
        "mansa",
        "manter",
        "manusear",
        "mapeado",
        "maquinar",
        "marcador",
        "maresia",
        "marfim",
        "margem",
        "marinho",
        "marmita",
        "maroto",
        "marquise",
        "marreco",
        "martelo",
        "marujo",
        "mascote",
        "masmorra",
        "massagem",
        "mastigar",
        "matagal",
        "materno",
        "matinal",
        "matutar",
        "maxilar",
        "medalha",
        "medida",
        "medusa",
        "megafone",
        "meiga",
        "melancia",
        "melhor",
        "membro",
        "memorial",
        "menino",
        "menos",
        "mensagem",
        "mental",
        "merecer",
        "mergulho",
        "mesada",
        "mesclar",
        "mesmo",
        "mesquita",
        "mestre",
        "metade",
        "meteoro",
        "metragem",
        "mexer",
        "mexicano",
        "micro",
        "migalha",
        "migrar",
        "milagre",
        "milenar",
        "milhar",
        "mimado",
        "minerar",
        "minhoca",
        "ministro",
        "minoria",
        "miolo",
        "mirante",
        "mirtilo",
        "misturar",
        "mocidade",
        "moderno",
        "modular",
        "moeda",
        "moer",
        "moinho",
        "moita",
        "moldura",
        "moleza",
        "molho",
        "molinete",
        "molusco",
        "montanha",
        "moqueca",
        "morango",
        "morcego",
        "mordomo",
        "morena",
        "mosaico",
        "mosquete",
        "mostarda",
        "motel",
        "motim",
        "moto",
        "motriz",
        "muda",
        "muito",
        "mulata",
        "mulher",
        "multar",
        "mundial",
        "munido",
        "muralha",
        "murcho",
        "muscular",
        "museu",
        "musical",
        "nacional",
        "nadador",
        "naja",
        "namoro",
        "narina",
        "narrado",
        "nascer",
        "nativa",
        "natureza",
        "navalha",
        "navegar",
        "navio",
        "neblina",
        "nebuloso",
        "negativa",
        "negociar",
        "negrito",
        "nervoso",
        "neta",
        "neural",
        "nevasca",
        "nevoeiro",
        "ninar",
        "ninho",
        "nitidez",
        "nivelar",
        "nobreza",
        "noite",
        "noiva",
        "nomear",
        "nominal",
        "nordeste",
        "nortear",
        "notar",
        "noticiar",
        "noturno",
        "novelo",
        "novilho",
        "novo",
        "nublado",
        "nudez",
        "numeral",
        "nupcial",
        "nutrir",
        "nuvem",
        "obcecado",
        "obedecer",
        "objetivo",
        "obrigado",
        "obscuro",
        "obstetra",
        "obter",
        "obturar",
        "ocidente",
        "ocioso",
        "ocorrer",
        "oculista",
        "ocupado",
        "ofegante",
        "ofensiva",
        "oferenda",
        "oficina",
        "ofuscado",
        "ogiva",
        "olaria",
        "oleoso",
        "olhar",
        "oliveira",
        "ombro",
        "omelete",
        "omisso",
        "omitir",
        "ondulado",
        "oneroso",
        "ontem",
        "opcional",
        "operador",
        "oponente",
        "oportuno",
        "oposto",
        "orar",
        "orbitar",
        "ordem",
        "ordinal",
        "orfanato",
        "orgasmo",
        "orgulho",
        "oriental",
        "origem",
        "oriundo",
        "orla",
        "ortodoxo",
        "orvalho",
        "oscilar",
        "ossada",
        "osso",
        "ostentar",
        "otimismo",
        "ousadia",
        "outono",
        "outubro",
        "ouvido",
        "ovelha",
        "ovular",
        "oxidar",
        "oxigenar",
        "pacato",
        "paciente",
        "pacote",
        "pactuar",
        "padaria",
        "padrinho",
        "pagar",
        "pagode",
        "painel",
        "pairar",
        "paisagem",
        "palavra",
        "palestra",
        "palheta",
        "palito",
        "palmada",
        "palpitar",
        "pancada",
        "panela",
        "panfleto",
        "panqueca",
        "pantanal",
        "papagaio",
        "papelada",
        "papiro",
        "parafina",
        "parcial",
        "pardal",
        "parede",
        "partida",
        "pasmo",
        "passado",
        "pastel",
        "patamar",
        "patente",
        "patinar",
        "patrono",
        "paulada",
        "pausar",
        "peculiar",
        "pedalar",
        "pedestre",
        "pediatra",
        "pedra",
        "pegada",
        "peitoral",
        "peixe",
        "pele",
        "pelicano",
        "penca",
        "pendurar",
        "peneira",
        "penhasco",
        "pensador",
        "pente",
        "perceber",
        "perfeito",
        "pergunta",
        "perito",
        "permitir",
        "perna",
        "perplexo",
        "persiana",
        "pertence",
        "peruca",
        "pescado",
        "pesquisa",
        "pessoa",
        "petiscar",
        "piada",
        "picado",
        "piedade",
        "pigmento",
        "pilastra",
        "pilhado",
        "pilotar",
        "pimenta",
        "pincel",
        "pinguim",
        "pinha",
        "pinote",
        "pintar",
        "pioneiro",
        "pipoca",
        "piquete",
        "piranha",
        "pires",
        "pirueta",
        "piscar",
        "pistola",
        "pitanga",
        "pivete",
        "planta",
        "plaqueta",
        "platina",
        "plebeu",
        "plumagem",
        "pluvial",
        "pneu",
        "poda",
        "poeira",
        "poetisa",
        "polegada",
        "policiar",
        "poluente",
        "polvilho",
        "pomar",
        "pomba",
        "ponderar",
        "pontaria",
        "populoso",
        "porta",
        "possuir",
        "postal",
        "pote",
        "poupar",
        "pouso",
        "povoar",
        "praia",
        "prancha",
        "prato",
        "praxe",
        "prece",
        "predador",
        "prefeito",
        "premiar",
        "prensar",
        "preparar",
        "presilha",
        "pretexto",
        "prevenir",
        "prezar",
        "primata",
        "princesa",
        "prisma",
        "privado",
        "processo",
        "produto",
        "profeta",
        "proibido",
        "projeto",
        "prometer",
        "propagar",
        "prosa",
        "protetor",
        "provador",
        "publicar",
        "pudim",
        "pular",
        "pulmonar",
        "pulseira",
        "punhal",
        "punir",
        "pupilo",
        "pureza",
        "puxador",
        "quadra",
        "quantia",
        "quarto",
        "quase",
        "quebrar",
        "queda",
        "queijo",
        "quente",
        "querido",
        "quimono",
        "quina",
        "quiosque",
        "rabanada",
        "rabisco",
        "rachar",
        "racionar",
        "radial",
        "raiar",
        "rainha",
        "raio",
        "raiva",
        "rajada",
        "ralado",
        "ramal",
        "ranger",
        "ranhura",
        "rapadura",
        "rapel",
        "rapidez",
        "raposa",
        "raquete",
        "raridade",
        "rasante",
        "rascunho",
        "rasgar",
        "raspador",
        "rasteira",
        "rasurar",
        "ratazana",
        "ratoeira",
        "realeza",
        "reanimar",
        "reaver",
        "rebaixar",
        "rebelde",
        "rebolar",
        "recado",
        "recente",
        "recheio",
        "recibo",
        "recordar",
        "recrutar",
        "recuar",
        "rede",
        "redimir",
        "redonda",
        "reduzida",
        "reenvio",
        "refinar",
        "refletir",
        "refogar",
        "refresco",
        "refugiar",
        "regalia",
        "regime",
        "regra",
        "reinado",
        "reitor",
        "rejeitar",
        "relativo",
        "remador",
        "remendo",
        "remorso",
        "renovado",
        "reparo",
        "repelir",
        "repleto",
        "repolho",
        "represa",
        "repudiar",
        "requerer",
        "resenha",
        "resfriar",
        "resgatar",
        "residir",
        "resolver",
        "respeito",
        "ressaca",
        "restante",
        "resumir",
        "retalho",
        "reter",
        "retirar",
        "retomada",
        "retratar",
        "revelar",
        "revisor",
        "revolta",
        "riacho",
        "rica",
        "rigidez",
        "rigoroso",
        "rimar",
        "ringue",
        "risada",
        "risco",
        "risonho",
        "robalo",
        "rochedo",
        "rodada",
        "rodeio",
        "rodovia",
        "roedor",
        "roleta",
        "romano",
        "roncar",
        "rosado",
        "roseira",
        "rosto",
        "rota",
        "roteiro",
        "rotina",
        "rotular",
        "rouco",
        "roupa",
        "roxo",
        "rubro",
        "rugido",
        "rugoso",
        "ruivo",
        "rumo",
        "rupestre",
        "russo",
        "sabor",
        "saciar",
        "sacola",
        "sacudir",
        "sadio",
        "safira",
        "saga",
        "sagrada",
        "saibro",
        "salada",
        "saleiro",
        "salgado",
        "saliva",
        "salpicar",
        "salsicha",
        "saltar",
        "salvador",
        "sambar",
        "samurai",
        "sanar",
        "sanfona",
        "sangue",
        "sanidade",
        "sapato",
        "sarda",
        "sargento",
        "sarjeta",
        "saturar",
        "saudade",
        "saxofone",
        "sazonal",
        "secar",
        "secular",
        "seda",
        "sedento",
        "sediado",
        "sedoso",
        "sedutor",
        "segmento",
        "segredo",
        "segundo",
        "seiva",
        "seleto",
        "selvagem",
        "semanal",
        "semente",
        "senador",
        "senhor",
        "sensual",
        "sentado",
        "separado",
        "sereia",
        "seringa",
        "serra",
        "servo",
        "setembro",
        "setor",
        "sigilo",
        "silhueta",
        "silicone",
        "simetria",
        "simpatia",
        "simular",
        "sinal",
        "sincero",
        "singular",
        "sinopse",
        "sintonia",
        "sirene",
        "siri",
        "situado",
        "soberano",
        "sobra",
        "socorro",
        "sogro",
        "soja",
        "solda",
        "soletrar",
        "solteiro",
        "sombrio",
        "sonata",
        "sondar",
        "sonegar",
        "sonhador",
        "sono",
        "soprano",
        "soquete",
        "sorrir",
        "sorteio",
        "sossego",
        "sotaque",
        "soterrar",
        "sovado",
        "sozinho",
        "suavizar",
        "subida",
        "submerso",
        "subsolo",
        "subtrair",
        "sucata",
        "sucesso",
        "suco",
        "sudeste",
        "sufixo",
        "sugador",
        "sugerir",
        "sujeito",
        "sulfato",
        "sumir",
        "suor",
        "superior",
        "suplicar",
        "suposto",
        "suprimir",
        "surdina",
        "surfista",
        "surpresa",
        "surreal",
        "surtir",
        "suspiro",
        "sustento",
        "tabela",
        "tablete",
        "tabuada",
        "tacho",
        "tagarela",
        "talher",
        "talo",
        "talvez",
        "tamanho",
        "tamborim",
        "tampa",
        "tangente",
        "tanto",
        "tapar",
        "tapioca",
        "tardio",
        "tarefa",
        "tarja",
        "tarraxa",
        "tatuagem",
        "taurino",
        "taxativo",
        "taxista",
        "teatral",
        "tecer",
        "tecido",
        "teclado",
        "tedioso",
        "teia",
        "teimar",
        "telefone",
        "telhado",
        "tempero",
        "tenente",
        "tensor",
        "tentar",
        "termal",
        "terno",
        "terreno",
        "tese",
        "tesoura",
        "testado",
        "teto",
        "textura",
        "texugo",
        "tiara",
        "tigela",
        "tijolo",
        "timbrar",
        "timidez",
        "tingido",
        "tinteiro",
        "tiragem",
        "titular",
        "toalha",
        "tocha",
        "tolerar",
        "tolice",
        "tomada",
        "tomilho",
        "tonel",
        "tontura",
        "topete",
        "tora",
        "torcido",
        "torneio",
        "torque",
        "torrada",
        "torto",
        "tostar",
        "touca",
        "toupeira",
        "toxina",
        "trabalho",
        "tracejar",
        "tradutor",
        "trafegar",
        "trajeto",
        "trama",
        "trancar",
        "trapo",
        "traseiro",
        "tratador",
        "travar",
        "treino",
        "tremer",
        "trepidar",
        "trevo",
        "triagem",
        "tribo",
        "triciclo",
        "tridente",
        "trilogia",
        "trindade",
        "triplo",
        "triturar",
        "triunfal",
        "trocar",
        "trombeta",
        "trova",
        "trunfo",
        "truque",
        "tubular",
        "tucano",
        "tudo",
        "tulipa",
        "tupi",
        "turbo",
        "turma",
        "turquesa",
        "tutelar",
        "tutorial",
        "uivar",
        "umbigo",
        "unha",
        "unidade",
        "uniforme",
        "urologia",
        "urso",
        "urtiga",
        "urubu",
        "usado",
        "usina",
        "usufruir",
        "vacina",
        "vadiar",
        "vagaroso",
        "vaidoso",
        "vala",
        "valente",
        "validade",
        "valores",
        "vantagem",
        "vaqueiro",
        "varanda",
        "vareta",
        "varrer",
        "vascular",
        "vasilha",
        "vassoura",
        "vazar",
        "vazio",
        "veado",
        "vedar",
        "vegetar",
        "veicular",
        "veleiro",
        "velhice",
        "veludo",
        "vencedor",
        "vendaval",
        "venerar",
        "ventre",
        "verbal",
        "verdade",
        "vereador",
        "vergonha",
        "vermelho",
        "verniz",
        "versar",
        "vertente",
        "vespa",
        "vestido",
        "vetorial",
        "viaduto",
        "viagem",
        "viajar",
        "viatura",
        "vibrador",
        "videira",
        "vidraria",
        "viela",
        "viga",
        "vigente",
        "vigiar",
        "vigorar",
        "vilarejo",
        "vinco",
        "vinheta",
        "vinil",
        "violeta",
        "virada",
        "virtude",
        "visitar",
        "visto",
        "vitral",
        "viveiro",
        "vizinho",
        "voador",
        "voar",
        "vogal",
        "volante",
        "voleibol",
        "voltagem",
        "volumoso",
        "vontade",
        "vulto",
        "vuvuzela",
        "xadrez",
        "xarope",
        "xeque",
        "xeretar",
        "xerife",
        "xingar",
        "zangado",
        "zarpar",
        "zebu",
        "zelador",
        "zombar",
        "zoologia",
        "zumbido"
      ];
    }
  });

  // node_modules/bip39/src/wordlists/english.json
  var require_english = __commonJS({
    "node_modules/bip39/src/wordlists/english.json"(exports9, module) {
      module.exports = [
        "abandon",
        "ability",
        "able",
        "about",
        "above",
        "absent",
        "absorb",
        "abstract",
        "absurd",
        "abuse",
        "access",
        "accident",
        "account",
        "accuse",
        "achieve",
        "acid",
        "acoustic",
        "acquire",
        "across",
        "act",
        "action",
        "actor",
        "actress",
        "actual",
        "adapt",
        "add",
        "addict",
        "address",
        "adjust",
        "admit",
        "adult",
        "advance",
        "advice",
        "aerobic",
        "affair",
        "afford",
        "afraid",
        "again",
        "age",
        "agent",
        "agree",
        "ahead",
        "aim",
        "air",
        "airport",
        "aisle",
        "alarm",
        "album",
        "alcohol",
        "alert",
        "alien",
        "all",
        "alley",
        "allow",
        "almost",
        "alone",
        "alpha",
        "already",
        "also",
        "alter",
        "always",
        "amateur",
        "amazing",
        "among",
        "amount",
        "amused",
        "analyst",
        "anchor",
        "ancient",
        "anger",
        "angle",
        "angry",
        "animal",
        "ankle",
        "announce",
        "annual",
        "another",
        "answer",
        "antenna",
        "antique",
        "anxiety",
        "any",
        "apart",
        "apology",
        "appear",
        "apple",
        "approve",
        "april",
        "arch",
        "arctic",
        "area",
        "arena",
        "argue",
        "arm",
        "armed",
        "armor",
        "army",
        "around",
        "arrange",
        "arrest",
        "arrive",
        "arrow",
        "art",
        "artefact",
        "artist",
        "artwork",
        "ask",
        "aspect",
        "assault",
        "asset",
        "assist",
        "assume",
        "asthma",
        "athlete",
        "atom",
        "attack",
        "attend",
        "attitude",
        "attract",
        "auction",
        "audit",
        "august",
        "aunt",
        "author",
        "auto",
        "autumn",
        "average",
        "avocado",
        "avoid",
        "awake",
        "aware",
        "away",
        "awesome",
        "awful",
        "awkward",
        "axis",
        "baby",
        "bachelor",
        "bacon",
        "badge",
        "bag",
        "balance",
        "balcony",
        "ball",
        "bamboo",
        "banana",
        "banner",
        "bar",
        "barely",
        "bargain",
        "barrel",
        "base",
        "basic",
        "basket",
        "battle",
        "beach",
        "bean",
        "beauty",
        "because",
        "become",
        "beef",
        "before",
        "begin",
        "behave",
        "behind",
        "believe",
        "below",
        "belt",
        "bench",
        "benefit",
        "best",
        "betray",
        "better",
        "between",
        "beyond",
        "bicycle",
        "bid",
        "bike",
        "bind",
        "biology",
        "bird",
        "birth",
        "bitter",
        "black",
        "blade",
        "blame",
        "blanket",
        "blast",
        "bleak",
        "bless",
        "blind",
        "blood",
        "blossom",
        "blouse",
        "blue",
        "blur",
        "blush",
        "board",
        "boat",
        "body",
        "boil",
        "bomb",
        "bone",
        "bonus",
        "book",
        "boost",
        "border",
        "boring",
        "borrow",
        "boss",
        "bottom",
        "bounce",
        "box",
        "boy",
        "bracket",
        "brain",
        "brand",
        "brass",
        "brave",
        "bread",
        "breeze",
        "brick",
        "bridge",
        "brief",
        "bright",
        "bring",
        "brisk",
        "broccoli",
        "broken",
        "bronze",
        "broom",
        "brother",
        "brown",
        "brush",
        "bubble",
        "buddy",
        "budget",
        "buffalo",
        "build",
        "bulb",
        "bulk",
        "bullet",
        "bundle",
        "bunker",
        "burden",
        "burger",
        "burst",
        "bus",
        "business",
        "busy",
        "butter",
        "buyer",
        "buzz",
        "cabbage",
        "cabin",
        "cable",
        "cactus",
        "cage",
        "cake",
        "call",
        "calm",
        "camera",
        "camp",
        "can",
        "canal",
        "cancel",
        "candy",
        "cannon",
        "canoe",
        "canvas",
        "canyon",
        "capable",
        "capital",
        "captain",
        "car",
        "carbon",
        "card",
        "cargo",
        "carpet",
        "carry",
        "cart",
        "case",
        "cash",
        "casino",
        "castle",
        "casual",
        "cat",
        "catalog",
        "catch",
        "category",
        "cattle",
        "caught",
        "cause",
        "caution",
        "cave",
        "ceiling",
        "celery",
        "cement",
        "census",
        "century",
        "cereal",
        "certain",
        "chair",
        "chalk",
        "champion",
        "change",
        "chaos",
        "chapter",
        "charge",
        "chase",
        "chat",
        "cheap",
        "check",
        "cheese",
        "chef",
        "cherry",
        "chest",
        "chicken",
        "chief",
        "child",
        "chimney",
        "choice",
        "choose",
        "chronic",
        "chuckle",
        "chunk",
        "churn",
        "cigar",
        "cinnamon",
        "circle",
        "citizen",
        "city",
        "civil",
        "claim",
        "clap",
        "clarify",
        "claw",
        "clay",
        "clean",
        "clerk",
        "clever",
        "click",
        "client",
        "cliff",
        "climb",
        "clinic",
        "clip",
        "clock",
        "clog",
        "close",
        "cloth",
        "cloud",
        "clown",
        "club",
        "clump",
        "cluster",
        "clutch",
        "coach",
        "coast",
        "coconut",
        "code",
        "coffee",
        "coil",
        "coin",
        "collect",
        "color",
        "column",
        "combine",
        "come",
        "comfort",
        "comic",
        "common",
        "company",
        "concert",
        "conduct",
        "confirm",
        "congress",
        "connect",
        "consider",
        "control",
        "convince",
        "cook",
        "cool",
        "copper",
        "copy",
        "coral",
        "core",
        "corn",
        "correct",
        "cost",
        "cotton",
        "couch",
        "country",
        "couple",
        "course",
        "cousin",
        "cover",
        "coyote",
        "crack",
        "cradle",
        "craft",
        "cram",
        "crane",
        "crash",
        "crater",
        "crawl",
        "crazy",
        "cream",
        "credit",
        "creek",
        "crew",
        "cricket",
        "crime",
        "crisp",
        "critic",
        "crop",
        "cross",
        "crouch",
        "crowd",
        "crucial",
        "cruel",
        "cruise",
        "crumble",
        "crunch",
        "crush",
        "cry",
        "crystal",
        "cube",
        "culture",
        "cup",
        "cupboard",
        "curious",
        "current",
        "curtain",
        "curve",
        "cushion",
        "custom",
        "cute",
        "cycle",
        "dad",
        "damage",
        "damp",
        "dance",
        "danger",
        "daring",
        "dash",
        "daughter",
        "dawn",
        "day",
        "deal",
        "debate",
        "debris",
        "decade",
        "december",
        "decide",
        "decline",
        "decorate",
        "decrease",
        "deer",
        "defense",
        "define",
        "defy",
        "degree",
        "delay",
        "deliver",
        "demand",
        "demise",
        "denial",
        "dentist",
        "deny",
        "depart",
        "depend",
        "deposit",
        "depth",
        "deputy",
        "derive",
        "describe",
        "desert",
        "design",
        "desk",
        "despair",
        "destroy",
        "detail",
        "detect",
        "develop",
        "device",
        "devote",
        "diagram",
        "dial",
        "diamond",
        "diary",
        "dice",
        "diesel",
        "diet",
        "differ",
        "digital",
        "dignity",
        "dilemma",
        "dinner",
        "dinosaur",
        "direct",
        "dirt",
        "disagree",
        "discover",
        "disease",
        "dish",
        "dismiss",
        "disorder",
        "display",
        "distance",
        "divert",
        "divide",
        "divorce",
        "dizzy",
        "doctor",
        "document",
        "dog",
        "doll",
        "dolphin",
        "domain",
        "donate",
        "donkey",
        "donor",
        "door",
        "dose",
        "double",
        "dove",
        "draft",
        "dragon",
        "drama",
        "drastic",
        "draw",
        "dream",
        "dress",
        "drift",
        "drill",
        "drink",
        "drip",
        "drive",
        "drop",
        "drum",
        "dry",
        "duck",
        "dumb",
        "dune",
        "during",
        "dust",
        "dutch",
        "duty",
        "dwarf",
        "dynamic",
        "eager",
        "eagle",
        "early",
        "earn",
        "earth",
        "easily",
        "east",
        "easy",
        "echo",
        "ecology",
        "economy",
        "edge",
        "edit",
        "educate",
        "effort",
        "egg",
        "eight",
        "either",
        "elbow",
        "elder",
        "electric",
        "elegant",
        "element",
        "elephant",
        "elevator",
        "elite",
        "else",
        "embark",
        "embody",
        "embrace",
        "emerge",
        "emotion",
        "employ",
        "empower",
        "empty",
        "enable",
        "enact",
        "end",
        "endless",
        "endorse",
        "enemy",
        "energy",
        "enforce",
        "engage",
        "engine",
        "enhance",
        "enjoy",
        "enlist",
        "enough",
        "enrich",
        "enroll",
        "ensure",
        "enter",
        "entire",
        "entry",
        "envelope",
        "episode",
        "equal",
        "equip",
        "era",
        "erase",
        "erode",
        "erosion",
        "error",
        "erupt",
        "escape",
        "essay",
        "essence",
        "estate",
        "eternal",
        "ethics",
        "evidence",
        "evil",
        "evoke",
        "evolve",
        "exact",
        "example",
        "excess",
        "exchange",
        "excite",
        "exclude",
        "excuse",
        "execute",
        "exercise",
        "exhaust",
        "exhibit",
        "exile",
        "exist",
        "exit",
        "exotic",
        "expand",
        "expect",
        "expire",
        "explain",
        "expose",
        "express",
        "extend",
        "extra",
        "eye",
        "eyebrow",
        "fabric",
        "face",
        "faculty",
        "fade",
        "faint",
        "faith",
        "fall",
        "false",
        "fame",
        "family",
        "famous",
        "fan",
        "fancy",
        "fantasy",
        "farm",
        "fashion",
        "fat",
        "fatal",
        "father",
        "fatigue",
        "fault",
        "favorite",
        "feature",
        "february",
        "federal",
        "fee",
        "feed",
        "feel",
        "female",
        "fence",
        "festival",
        "fetch",
        "fever",
        "few",
        "fiber",
        "fiction",
        "field",
        "figure",
        "file",
        "film",
        "filter",
        "final",
        "find",
        "fine",
        "finger",
        "finish",
        "fire",
        "firm",
        "first",
        "fiscal",
        "fish",
        "fit",
        "fitness",
        "fix",
        "flag",
        "flame",
        "flash",
        "flat",
        "flavor",
        "flee",
        "flight",
        "flip",
        "float",
        "flock",
        "floor",
        "flower",
        "fluid",
        "flush",
        "fly",
        "foam",
        "focus",
        "fog",
        "foil",
        "fold",
        "follow",
        "food",
        "foot",
        "force",
        "forest",
        "forget",
        "fork",
        "fortune",
        "forum",
        "forward",
        "fossil",
        "foster",
        "found",
        "fox",
        "fragile",
        "frame",
        "frequent",
        "fresh",
        "friend",
        "fringe",
        "frog",
        "front",
        "frost",
        "frown",
        "frozen",
        "fruit",
        "fuel",
        "fun",
        "funny",
        "furnace",
        "fury",
        "future",
        "gadget",
        "gain",
        "galaxy",
        "gallery",
        "game",
        "gap",
        "garage",
        "garbage",
        "garden",
        "garlic",
        "garment",
        "gas",
        "gasp",
        "gate",
        "gather",
        "gauge",
        "gaze",
        "general",
        "genius",
        "genre",
        "gentle",
        "genuine",
        "gesture",
        "ghost",
        "giant",
        "gift",
        "giggle",
        "ginger",
        "giraffe",
        "girl",
        "give",
        "glad",
        "glance",
        "glare",
        "glass",
        "glide",
        "glimpse",
        "globe",
        "gloom",
        "glory",
        "glove",
        "glow",
        "glue",
        "goat",
        "goddess",
        "gold",
        "good",
        "goose",
        "gorilla",
        "gospel",
        "gossip",
        "govern",
        "gown",
        "grab",
        "grace",
        "grain",
        "grant",
        "grape",
        "grass",
        "gravity",
        "great",
        "green",
        "grid",
        "grief",
        "grit",
        "grocery",
        "group",
        "grow",
        "grunt",
        "guard",
        "guess",
        "guide",
        "guilt",
        "guitar",
        "gun",
        "gym",
        "habit",
        "hair",
        "half",
        "hammer",
        "hamster",
        "hand",
        "happy",
        "harbor",
        "hard",
        "harsh",
        "harvest",
        "hat",
        "have",
        "hawk",
        "hazard",
        "head",
        "health",
        "heart",
        "heavy",
        "hedgehog",
        "height",
        "hello",
        "helmet",
        "help",
        "hen",
        "hero",
        "hidden",
        "high",
        "hill",
        "hint",
        "hip",
        "hire",
        "history",
        "hobby",
        "hockey",
        "hold",
        "hole",
        "holiday",
        "hollow",
        "home",
        "honey",
        "hood",
        "hope",
        "horn",
        "horror",
        "horse",
        "hospital",
        "host",
        "hotel",
        "hour",
        "hover",
        "hub",
        "huge",
        "human",
        "humble",
        "humor",
        "hundred",
        "hungry",
        "hunt",
        "hurdle",
        "hurry",
        "hurt",
        "husband",
        "hybrid",
        "ice",
        "icon",
        "idea",
        "identify",
        "idle",
        "ignore",
        "ill",
        "illegal",
        "illness",
        "image",
        "imitate",
        "immense",
        "immune",
        "impact",
        "impose",
        "improve",
        "impulse",
        "inch",
        "include",
        "income",
        "increase",
        "index",
        "indicate",
        "indoor",
        "industry",
        "infant",
        "inflict",
        "inform",
        "inhale",
        "inherit",
        "initial",
        "inject",
        "injury",
        "inmate",
        "inner",
        "innocent",
        "input",
        "inquiry",
        "insane",
        "insect",
        "inside",
        "inspire",
        "install",
        "intact",
        "interest",
        "into",
        "invest",
        "invite",
        "involve",
        "iron",
        "island",
        "isolate",
        "issue",
        "item",
        "ivory",
        "jacket",
        "jaguar",
        "jar",
        "jazz",
        "jealous",
        "jeans",
        "jelly",
        "jewel",
        "job",
        "join",
        "joke",
        "journey",
        "joy",
        "judge",
        "juice",
        "jump",
        "jungle",
        "junior",
        "junk",
        "just",
        "kangaroo",
        "keen",
        "keep",
        "ketchup",
        "key",
        "kick",
        "kid",
        "kidney",
        "kind",
        "kingdom",
        "kiss",
        "kit",
        "kitchen",
        "kite",
        "kitten",
        "kiwi",
        "knee",
        "knife",
        "knock",
        "know",
        "lab",
        "label",
        "labor",
        "ladder",
        "lady",
        "lake",
        "lamp",
        "language",
        "laptop",
        "large",
        "later",
        "latin",
        "laugh",
        "laundry",
        "lava",
        "law",
        "lawn",
        "lawsuit",
        "layer",
        "lazy",
        "leader",
        "leaf",
        "learn",
        "leave",
        "lecture",
        "left",
        "leg",
        "legal",
        "legend",
        "leisure",
        "lemon",
        "lend",
        "length",
        "lens",
        "leopard",
        "lesson",
        "letter",
        "level",
        "liar",
        "liberty",
        "library",
        "license",
        "life",
        "lift",
        "light",
        "like",
        "limb",
        "limit",
        "link",
        "lion",
        "liquid",
        "list",
        "little",
        "live",
        "lizard",
        "load",
        "loan",
        "lobster",
        "local",
        "lock",
        "logic",
        "lonely",
        "long",
        "loop",
        "lottery",
        "loud",
        "lounge",
        "love",
        "loyal",
        "lucky",
        "luggage",
        "lumber",
        "lunar",
        "lunch",
        "luxury",
        "lyrics",
        "machine",
        "mad",
        "magic",
        "magnet",
        "maid",
        "mail",
        "main",
        "major",
        "make",
        "mammal",
        "man",
        "manage",
        "mandate",
        "mango",
        "mansion",
        "manual",
        "maple",
        "marble",
        "march",
        "margin",
        "marine",
        "market",
        "marriage",
        "mask",
        "mass",
        "master",
        "match",
        "material",
        "math",
        "matrix",
        "matter",
        "maximum",
        "maze",
        "meadow",
        "mean",
        "measure",
        "meat",
        "mechanic",
        "medal",
        "media",
        "melody",
        "melt",
        "member",
        "memory",
        "mention",
        "menu",
        "mercy",
        "merge",
        "merit",
        "merry",
        "mesh",
        "message",
        "metal",
        "method",
        "middle",
        "midnight",
        "milk",
        "million",
        "mimic",
        "mind",
        "minimum",
        "minor",
        "minute",
        "miracle",
        "mirror",
        "misery",
        "miss",
        "mistake",
        "mix",
        "mixed",
        "mixture",
        "mobile",
        "model",
        "modify",
        "mom",
        "moment",
        "monitor",
        "monkey",
        "monster",
        "month",
        "moon",
        "moral",
        "more",
        "morning",
        "mosquito",
        "mother",
        "motion",
        "motor",
        "mountain",
        "mouse",
        "move",
        "movie",
        "much",
        "muffin",
        "mule",
        "multiply",
        "muscle",
        "museum",
        "mushroom",
        "music",
        "must",
        "mutual",
        "myself",
        "mystery",
        "myth",
        "naive",
        "name",
        "napkin",
        "narrow",
        "nasty",
        "nation",
        "nature",
        "near",
        "neck",
        "need",
        "negative",
        "neglect",
        "neither",
        "nephew",
        "nerve",
        "nest",
        "net",
        "network",
        "neutral",
        "never",
        "news",
        "next",
        "nice",
        "night",
        "noble",
        "noise",
        "nominee",
        "noodle",
        "normal",
        "north",
        "nose",
        "notable",
        "note",
        "nothing",
        "notice",
        "novel",
        "now",
        "nuclear",
        "number",
        "nurse",
        "nut",
        "oak",
        "obey",
        "object",
        "oblige",
        "obscure",
        "observe",
        "obtain",
        "obvious",
        "occur",
        "ocean",
        "october",
        "odor",
        "off",
        "offer",
        "office",
        "often",
        "oil",
        "okay",
        "old",
        "olive",
        "olympic",
        "omit",
        "once",
        "one",
        "onion",
        "online",
        "only",
        "open",
        "opera",
        "opinion",
        "oppose",
        "option",
        "orange",
        "orbit",
        "orchard",
        "order",
        "ordinary",
        "organ",
        "orient",
        "original",
        "orphan",
        "ostrich",
        "other",
        "outdoor",
        "outer",
        "output",
        "outside",
        "oval",
        "oven",
        "over",
        "own",
        "owner",
        "oxygen",
        "oyster",
        "ozone",
        "pact",
        "paddle",
        "page",
        "pair",
        "palace",
        "palm",
        "panda",
        "panel",
        "panic",
        "panther",
        "paper",
        "parade",
        "parent",
        "park",
        "parrot",
        "party",
        "pass",
        "patch",
        "path",
        "patient",
        "patrol",
        "pattern",
        "pause",
        "pave",
        "payment",
        "peace",
        "peanut",
        "pear",
        "peasant",
        "pelican",
        "pen",
        "penalty",
        "pencil",
        "people",
        "pepper",
        "perfect",
        "permit",
        "person",
        "pet",
        "phone",
        "photo",
        "phrase",
        "physical",
        "piano",
        "picnic",
        "picture",
        "piece",
        "pig",
        "pigeon",
        "pill",
        "pilot",
        "pink",
        "pioneer",
        "pipe",
        "pistol",
        "pitch",
        "pizza",
        "place",
        "planet",
        "plastic",
        "plate",
        "play",
        "please",
        "pledge",
        "pluck",
        "plug",
        "plunge",
        "poem",
        "poet",
        "point",
        "polar",
        "pole",
        "police",
        "pond",
        "pony",
        "pool",
        "popular",
        "portion",
        "position",
        "possible",
        "post",
        "potato",
        "pottery",
        "poverty",
        "powder",
        "power",
        "practice",
        "praise",
        "predict",
        "prefer",
        "prepare",
        "present",
        "pretty",
        "prevent",
        "price",
        "pride",
        "primary",
        "print",
        "priority",
        "prison",
        "private",
        "prize",
        "problem",
        "process",
        "produce",
        "profit",
        "program",
        "project",
        "promote",
        "proof",
        "property",
        "prosper",
        "protect",
        "proud",
        "provide",
        "public",
        "pudding",
        "pull",
        "pulp",
        "pulse",
        "pumpkin",
        "punch",
        "pupil",
        "puppy",
        "purchase",
        "purity",
        "purpose",
        "purse",
        "push",
        "put",
        "puzzle",
        "pyramid",
        "quality",
        "quantum",
        "quarter",
        "question",
        "quick",
        "quit",
        "quiz",
        "quote",
        "rabbit",
        "raccoon",
        "race",
        "rack",
        "radar",
        "radio",
        "rail",
        "rain",
        "raise",
        "rally",
        "ramp",
        "ranch",
        "random",
        "range",
        "rapid",
        "rare",
        "rate",
        "rather",
        "raven",
        "raw",
        "razor",
        "ready",
        "real",
        "reason",
        "rebel",
        "rebuild",
        "recall",
        "receive",
        "recipe",
        "record",
        "recycle",
        "reduce",
        "reflect",
        "reform",
        "refuse",
        "region",
        "regret",
        "regular",
        "reject",
        "relax",
        "release",
        "relief",
        "rely",
        "remain",
        "remember",
        "remind",
        "remove",
        "render",
        "renew",
        "rent",
        "reopen",
        "repair",
        "repeat",
        "replace",
        "report",
        "require",
        "rescue",
        "resemble",
        "resist",
        "resource",
        "response",
        "result",
        "retire",
        "retreat",
        "return",
        "reunion",
        "reveal",
        "review",
        "reward",
        "rhythm",
        "rib",
        "ribbon",
        "rice",
        "rich",
        "ride",
        "ridge",
        "rifle",
        "right",
        "rigid",
        "ring",
        "riot",
        "ripple",
        "risk",
        "ritual",
        "rival",
        "river",
        "road",
        "roast",
        "robot",
        "robust",
        "rocket",
        "romance",
        "roof",
        "rookie",
        "room",
        "rose",
        "rotate",
        "rough",
        "round",
        "route",
        "royal",
        "rubber",
        "rude",
        "rug",
        "rule",
        "run",
        "runway",
        "rural",
        "sad",
        "saddle",
        "sadness",
        "safe",
        "sail",
        "salad",
        "salmon",
        "salon",
        "salt",
        "salute",
        "same",
        "sample",
        "sand",
        "satisfy",
        "satoshi",
        "sauce",
        "sausage",
        "save",
        "say",
        "scale",
        "scan",
        "scare",
        "scatter",
        "scene",
        "scheme",
        "school",
        "science",
        "scissors",
        "scorpion",
        "scout",
        "scrap",
        "screen",
        "script",
        "scrub",
        "sea",
        "search",
        "season",
        "seat",
        "second",
        "secret",
        "section",
        "security",
        "seed",
        "seek",
        "segment",
        "select",
        "sell",
        "seminar",
        "senior",
        "sense",
        "sentence",
        "series",
        "service",
        "session",
        "settle",
        "setup",
        "seven",
        "shadow",
        "shaft",
        "shallow",
        "share",
        "shed",
        "shell",
        "sheriff",
        "shield",
        "shift",
        "shine",
        "ship",
        "shiver",
        "shock",
        "shoe",
        "shoot",
        "shop",
        "short",
        "shoulder",
        "shove",
        "shrimp",
        "shrug",
        "shuffle",
        "shy",
        "sibling",
        "sick",
        "side",
        "siege",
        "sight",
        "sign",
        "silent",
        "silk",
        "silly",
        "silver",
        "similar",
        "simple",
        "since",
        "sing",
        "siren",
        "sister",
        "situate",
        "six",
        "size",
        "skate",
        "sketch",
        "ski",
        "skill",
        "skin",
        "skirt",
        "skull",
        "slab",
        "slam",
        "sleep",
        "slender",
        "slice",
        "slide",
        "slight",
        "slim",
        "slogan",
        "slot",
        "slow",
        "slush",
        "small",
        "smart",
        "smile",
        "smoke",
        "smooth",
        "snack",
        "snake",
        "snap",
        "sniff",
        "snow",
        "soap",
        "soccer",
        "social",
        "sock",
        "soda",
        "soft",
        "solar",
        "soldier",
        "solid",
        "solution",
        "solve",
        "someone",
        "song",
        "soon",
        "sorry",
        "sort",
        "soul",
        "sound",
        "soup",
        "source",
        "south",
        "space",
        "spare",
        "spatial",
        "spawn",
        "speak",
        "special",
        "speed",
        "spell",
        "spend",
        "sphere",
        "spice",
        "spider",
        "spike",
        "spin",
        "spirit",
        "split",
        "spoil",
        "sponsor",
        "spoon",
        "sport",
        "spot",
        "spray",
        "spread",
        "spring",
        "spy",
        "square",
        "squeeze",
        "squirrel",
        "stable",
        "stadium",
        "staff",
        "stage",
        "stairs",
        "stamp",
        "stand",
        "start",
        "state",
        "stay",
        "steak",
        "steel",
        "stem",
        "step",
        "stereo",
        "stick",
        "still",
        "sting",
        "stock",
        "stomach",
        "stone",
        "stool",
        "story",
        "stove",
        "strategy",
        "street",
        "strike",
        "strong",
        "struggle",
        "student",
        "stuff",
        "stumble",
        "style",
        "subject",
        "submit",
        "subway",
        "success",
        "such",
        "sudden",
        "suffer",
        "sugar",
        "suggest",
        "suit",
        "summer",
        "sun",
        "sunny",
        "sunset",
        "super",
        "supply",
        "supreme",
        "sure",
        "surface",
        "surge",
        "surprise",
        "surround",
        "survey",
        "suspect",
        "sustain",
        "swallow",
        "swamp",
        "swap",
        "swarm",
        "swear",
        "sweet",
        "swift",
        "swim",
        "swing",
        "switch",
        "sword",
        "symbol",
        "symptom",
        "syrup",
        "system",
        "table",
        "tackle",
        "tag",
        "tail",
        "talent",
        "talk",
        "tank",
        "tape",
        "target",
        "task",
        "taste",
        "tattoo",
        "taxi",
        "teach",
        "team",
        "tell",
        "ten",
        "tenant",
        "tennis",
        "tent",
        "term",
        "test",
        "text",
        "thank",
        "that",
        "theme",
        "then",
        "theory",
        "there",
        "they",
        "thing",
        "this",
        "thought",
        "three",
        "thrive",
        "throw",
        "thumb",
        "thunder",
        "ticket",
        "tide",
        "tiger",
        "tilt",
        "timber",
        "time",
        "tiny",
        "tip",
        "tired",
        "tissue",
        "title",
        "toast",
        "tobacco",
        "today",
        "toddler",
        "toe",
        "together",
        "toilet",
        "token",
        "tomato",
        "tomorrow",
        "tone",
        "tongue",
        "tonight",
        "tool",
        "tooth",
        "top",
        "topic",
        "topple",
        "torch",
        "tornado",
        "tortoise",
        "toss",
        "total",
        "tourist",
        "toward",
        "tower",
        "town",
        "toy",
        "track",
        "trade",
        "traffic",
        "tragic",
        "train",
        "transfer",
        "trap",
        "trash",
        "travel",
        "tray",
        "treat",
        "tree",
        "trend",
        "trial",
        "tribe",
        "trick",
        "trigger",
        "trim",
        "trip",
        "trophy",
        "trouble",
        "truck",
        "true",
        "truly",
        "trumpet",
        "trust",
        "truth",
        "try",
        "tube",
        "tuition",
        "tumble",
        "tuna",
        "tunnel",
        "turkey",
        "turn",
        "turtle",
        "twelve",
        "twenty",
        "twice",
        "twin",
        "twist",
        "two",
        "type",
        "typical",
        "ugly",
        "umbrella",
        "unable",
        "unaware",
        "uncle",
        "uncover",
        "under",
        "undo",
        "unfair",
        "unfold",
        "unhappy",
        "uniform",
        "unique",
        "unit",
        "universe",
        "unknown",
        "unlock",
        "until",
        "unusual",
        "unveil",
        "update",
        "upgrade",
        "uphold",
        "upon",
        "upper",
        "upset",
        "urban",
        "urge",
        "usage",
        "use",
        "used",
        "useful",
        "useless",
        "usual",
        "utility",
        "vacant",
        "vacuum",
        "vague",
        "valid",
        "valley",
        "valve",
        "van",
        "vanish",
        "vapor",
        "various",
        "vast",
        "vault",
        "vehicle",
        "velvet",
        "vendor",
        "venture",
        "venue",
        "verb",
        "verify",
        "version",
        "very",
        "vessel",
        "veteran",
        "viable",
        "vibrant",
        "vicious",
        "victory",
        "video",
        "view",
        "village",
        "vintage",
        "violin",
        "virtual",
        "virus",
        "visa",
        "visit",
        "visual",
        "vital",
        "vivid",
        "vocal",
        "voice",
        "void",
        "volcano",
        "volume",
        "vote",
        "voyage",
        "wage",
        "wagon",
        "wait",
        "walk",
        "wall",
        "walnut",
        "want",
        "warfare",
        "warm",
        "warrior",
        "wash",
        "wasp",
        "waste",
        "water",
        "wave",
        "way",
        "wealth",
        "weapon",
        "wear",
        "weasel",
        "weather",
        "web",
        "wedding",
        "weekend",
        "weird",
        "welcome",
        "west",
        "wet",
        "whale",
        "what",
        "wheat",
        "wheel",
        "when",
        "where",
        "whip",
        "whisper",
        "wide",
        "width",
        "wife",
        "wild",
        "will",
        "win",
        "window",
        "wine",
        "wing",
        "wink",
        "winner",
        "winter",
        "wire",
        "wisdom",
        "wise",
        "wish",
        "witness",
        "wolf",
        "woman",
        "wonder",
        "wood",
        "wool",
        "word",
        "work",
        "world",
        "worry",
        "worth",
        "wrap",
        "wreck",
        "wrestle",
        "wrist",
        "write",
        "wrong",
        "yard",
        "year",
        "yellow",
        "you",
        "young",
        "youth",
        "zebra",
        "zero",
        "zone",
        "zoo"
      ];
    }
  });

  // node_modules/bip39/src/_wordlists.js
  var require_wordlists = __commonJS({
    "node_modules/bip39/src/_wordlists.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var wordlists = {};
      exports9.wordlists = wordlists;
      var _default;
      exports9._default = _default;
      try {
        exports9._default = _default = require_czech();
        wordlists.czech = _default;
      } catch (err) {
      }
      try {
        exports9._default = _default = require_chinese_simplified();
        wordlists.chinese_simplified = _default;
      } catch (err) {
      }
      try {
        exports9._default = _default = require_chinese_traditional();
        wordlists.chinese_traditional = _default;
      } catch (err) {
      }
      try {
        exports9._default = _default = require_korean();
        wordlists.korean = _default;
      } catch (err) {
      }
      try {
        exports9._default = _default = require_french();
        wordlists.french = _default;
      } catch (err) {
      }
      try {
        exports9._default = _default = require_italian();
        wordlists.italian = _default;
      } catch (err) {
      }
      try {
        exports9._default = _default = require_spanish();
        wordlists.spanish = _default;
      } catch (err) {
      }
      try {
        exports9._default = _default = require_japanese();
        wordlists.japanese = _default;
        wordlists.JA = _default;
      } catch (err) {
      }
      try {
        exports9._default = _default = require_portuguese();
        wordlists.portuguese = _default;
      } catch (err) {
      }
      try {
        exports9._default = _default = require_english();
        wordlists.english = _default;
        wordlists.EN = _default;
      } catch (err) {
      }
    }
  });

  // node_modules/bip39/src/index.js
  var require_src4 = __commonJS({
    "node_modules/bip39/src/index.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var sha256_1 = require_sha256();
      var sha512_1 = require_sha5122();
      var pbkdf2_1 = require_pbkdf2();
      var utils_1 = require_utils();
      var _wordlists_1 = require_wordlists();
      var DEFAULT_WORDLIST = _wordlists_1._default;
      var INVALID_MNEMONIC = "Invalid mnemonic";
      var INVALID_ENTROPY = "Invalid entropy";
      var INVALID_CHECKSUM = "Invalid mnemonic checksum";
      var WORDLIST_REQUIRED = "A wordlist is required but a default could not be found.\nPlease pass a 2048 word array explicitly.";
      function normalize(str) {
        return (str || "").normalize("NFKD");
      }
      function lpad(str, padString, length) {
        while (str.length < length) {
          str = padString + str;
        }
        return str;
      }
      function binaryToByte(bin) {
        return parseInt(bin, 2);
      }
      function bytesToBinary(bytes) {
        return bytes.map((x) => lpad(x.toString(2), "0", 8)).join("");
      }
      function deriveChecksumBits(entropyBuffer) {
        const ENT = entropyBuffer.length * 8;
        const CS = ENT / 32;
        const hash = sha256_1.sha256(Uint8Array.from(entropyBuffer));
        return bytesToBinary(Array.from(hash)).slice(0, CS);
      }
      function salt(password) {
        return "mnemonic" + (password || "");
      }
      function mnemonicToSeedSync(mnemonic, password) {
        const mnemonicBuffer = Uint8Array.from(Buffer2.from(normalize(mnemonic), "utf8"));
        const saltBuffer = Uint8Array.from(Buffer2.from(salt(normalize(password)), "utf8"));
        const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
          c: 2048,
          dkLen: 64
        });
        return Buffer2.from(res);
      }
      exports9.mnemonicToSeedSync = mnemonicToSeedSync;
      function mnemonicToSeed(mnemonic, password) {
        const mnemonicBuffer = Uint8Array.from(Buffer2.from(normalize(mnemonic), "utf8"));
        const saltBuffer = Uint8Array.from(Buffer2.from(salt(normalize(password)), "utf8"));
        return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
          c: 2048,
          dkLen: 64
        }).then((res) => Buffer2.from(res));
      }
      exports9.mnemonicToSeed = mnemonicToSeed;
      function mnemonicToEntropy(mnemonic, wordlist) {
        wordlist = wordlist || DEFAULT_WORDLIST;
        if (!wordlist) {
          throw new Error(WORDLIST_REQUIRED);
        }
        const words = normalize(mnemonic).split(" ");
        if (words.length % 3 !== 0) {
          throw new Error(INVALID_MNEMONIC);
        }
        const bits = words.map((word) => {
          const index = wordlist.indexOf(word);
          if (index === -1) {
            throw new Error(INVALID_MNEMONIC);
          }
          return lpad(index.toString(2), "0", 11);
        }).join("");
        const dividerIndex = Math.floor(bits.length / 33) * 32;
        const entropyBits = bits.slice(0, dividerIndex);
        const checksumBits = bits.slice(dividerIndex);
        const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
        if (entropyBytes.length < 16) {
          throw new Error(INVALID_ENTROPY);
        }
        if (entropyBytes.length > 32) {
          throw new Error(INVALID_ENTROPY);
        }
        if (entropyBytes.length % 4 !== 0) {
          throw new Error(INVALID_ENTROPY);
        }
        const entropy = Buffer2.from(entropyBytes);
        const newChecksum = deriveChecksumBits(entropy);
        if (newChecksum !== checksumBits) {
          throw new Error(INVALID_CHECKSUM);
        }
        return entropy.toString("hex");
      }
      exports9.mnemonicToEntropy = mnemonicToEntropy;
      function entropyToMnemonic(entropy, wordlist) {
        if (!Buffer2.isBuffer(entropy)) {
          entropy = Buffer2.from(entropy, "hex");
        }
        wordlist = wordlist || DEFAULT_WORDLIST;
        if (!wordlist) {
          throw new Error(WORDLIST_REQUIRED);
        }
        if (entropy.length < 16) {
          throw new TypeError(INVALID_ENTROPY);
        }
        if (entropy.length > 32) {
          throw new TypeError(INVALID_ENTROPY);
        }
        if (entropy.length % 4 !== 0) {
          throw new TypeError(INVALID_ENTROPY);
        }
        const entropyBits = bytesToBinary(Array.from(entropy));
        const checksumBits = deriveChecksumBits(entropy);
        const bits = entropyBits + checksumBits;
        const chunks = bits.match(/(.{1,11})/g);
        const words = chunks.map((binary) => {
          const index = binaryToByte(binary);
          return wordlist[index];
        });
        return wordlist[0] === "\u3042\u3044\u3053\u304F\u3057\u3093" ? words.join("\u3000") : words.join(" ");
      }
      exports9.entropyToMnemonic = entropyToMnemonic;
      function generateMnemonic(strength, rng, wordlist) {
        strength = strength || 128;
        if (strength % 32 !== 0) {
          throw new TypeError(INVALID_ENTROPY);
        }
        rng = rng || ((size) => Buffer2.from(utils_1.randomBytes(size)));
        return entropyToMnemonic(rng(strength / 8), wordlist);
      }
      exports9.generateMnemonic = generateMnemonic;
      function validateMnemonic(mnemonic, wordlist) {
        try {
          mnemonicToEntropy(mnemonic, wordlist);
        } catch (e) {
          return false;
        }
        return true;
      }
      exports9.validateMnemonic = validateMnemonic;
      function setDefaultWordlist(language) {
        const result = _wordlists_1.wordlists[language];
        if (result) {
          DEFAULT_WORDLIST = result;
        } else {
          throw new Error('Could not find wordlist for language "' + language + '"');
        }
      }
      exports9.setDefaultWordlist = setDefaultWordlist;
      function getDefaultWordlist() {
        if (!DEFAULT_WORDLIST) {
          throw new Error("No Default Wordlist set");
        }
        return Object.keys(_wordlists_1.wordlists).filter((lang) => {
          if (lang === "JA" || lang === "EN") {
            return false;
          }
          return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
        })[0];
      }
      exports9.getDefaultWordlist = getDefaultWordlist;
      var _wordlists_2 = require_wordlists();
      exports9.wordlists = _wordlists_2.wordlists;
    }
  });

  // node_modules/ecpair/src/cjs/networks.cjs
  var require_networks2 = __commonJS({
    "node_modules/ecpair/src/cjs/networks.cjs"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.testnet = exports9.bitcoin = void 0;
      exports9.bitcoin = {
        messagePrefix: "Bitcoin Signed Message:\n",
        bech32: "bc",
        bip32: {
          public: 76067358,
          private: 76066276
        },
        pubKeyHash: 0,
        scriptHash: 5,
        wif: 128
      };
      exports9.testnet = {
        messagePrefix: "Bitcoin Signed Message:\n",
        bech32: "tb",
        bip32: {
          public: 70617039,
          private: 70615956
        },
        pubKeyHash: 111,
        scriptHash: 196,
        wif: 239
      };
    }
  });

  // node_modules/ecpair/src/cjs/types.cjs
  var require_types3 = __commonJS({
    "node_modules/ecpair/src/cjs/types.cjs"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var __createBinding = exports9 && exports9.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            }
          };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports9 && exports9.__setModuleDefault || (Object.create ? function(o, v2) {
        Object.defineProperty(o, "default", { enumerable: true, value: v2 });
      } : function(o, v2) {
        o["default"] = v2;
      });
      var __importStar = exports9 && exports9.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.Buffer256Bit = exports9.NetworkSchema = void 0;
      var v = __importStar(require_dist2());
      var Uint32Schema = v.pipe(
        v.number(),
        v.integer(),
        v.minValue(0),
        v.maxValue(4294967295)
      );
      var Uint8Schema = v.pipe(
        v.number(),
        v.integer(),
        v.minValue(0),
        v.maxValue(255)
      );
      exports9.NetworkSchema = v.object({
        messagePrefix: v.union([v.string(), v.instance(Uint8Array)]),
        bech32: v.string(),
        bip32: v.object({
          public: Uint32Schema,
          private: Uint32Schema
        }),
        pubKeyHash: Uint8Schema,
        scriptHash: Uint8Schema,
        wif: Uint8Schema
      });
      exports9.Buffer256Bit = v.pipe(v.instance(Uint8Array), v.length(32));
    }
  });

  // node_modules/ecpair/src/cjs/testecc.cjs
  var require_testecc2 = __commonJS({
    "node_modules/ecpair/src/cjs/testecc.cjs"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.testEcc = testEcc;
      var h = (hex) => Buffer2.from(hex, "hex");
      function testEcc(ecc) {
        assert2(
          ecc.isPoint(
            h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
          )
        );
        assert2(
          !ecc.isPoint(
            h("030000000000000000000000000000000000000000000000000000000000000005")
          )
        );
        assert2(
          ecc.isPrivate(
            h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
          )
        );
        assert2(
          ecc.isPrivate(
            h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
          )
        );
        assert2(
          !ecc.isPrivate(
            h("0000000000000000000000000000000000000000000000000000000000000000")
          )
        );
        assert2(
          !ecc.isPrivate(
            h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
          )
        );
        assert2(
          !ecc.isPrivate(
            h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")
          )
        );
        assert2(
          Buffer2.from(
            ecc.privateAdd(
              h("0000000000000000000000000000000000000000000000000000000000000001"),
              h("0000000000000000000000000000000000000000000000000000000000000000")
            )
          ).equals(
            h("0000000000000000000000000000000000000000000000000000000000000001")
          )
        );
        assert2(
          ecc.privateAdd(
            h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"),
            h("0000000000000000000000000000000000000000000000000000000000000003")
          ) === null
        );
        assert2(
          Buffer2.from(
            ecc.privateAdd(
              h("e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500"),
              h("b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665")
            )
          ).equals(
            h("9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24")
          )
        );
        assert2(
          Buffer2.from(
            ecc.privateNegate(
              h("0000000000000000000000000000000000000000000000000000000000000001")
            )
          ).equals(
            h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
          )
        );
        assert2(
          Buffer2.from(
            ecc.privateNegate(
              h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")
            )
          ).equals(
            h("0000000000000000000000000000000000000000000000000000000000000003")
          )
        );
        assert2(
          Buffer2.from(
            ecc.privateNegate(
              h("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
            )
          ).equals(
            h("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")
          )
        );
        assert2(
          Buffer2.from(
            ecc.pointCompress(
              h(
                "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
              ),
              true
            )
          ).equals(
            h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
          )
        );
        assert2(
          Buffer2.from(
            ecc.pointCompress(
              h(
                "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
              ),
              false
            )
          ).equals(
            h(
              "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
            )
          )
        );
        assert2(
          Buffer2.from(
            ecc.pointCompress(
              h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
              true
            )
          ).equals(
            h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
          )
        );
        assert2(
          Buffer2.from(
            ecc.pointCompress(
              h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
              false
            )
          ).equals(
            h(
              "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
            )
          )
        );
        assert2(
          Buffer2.from(
            ecc.pointFromScalar(
              h("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
            )
          ).equals(
            h("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")
          )
        );
        assert2(
          ecc.xOnlyPointAddTweak(
            h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
            h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
          ) === null
        );
        let xOnlyRes = ecc.xOnlyPointAddTweak(
          h("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"),
          h("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac")
        );
        assert2(
          Buffer2.from(xOnlyRes.xOnlyPubkey).equals(
            h("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")
          ) && xOnlyRes.parity === 1
        );
        xOnlyRes = ecc.xOnlyPointAddTweak(
          h("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"),
          h("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47")
        );
        assert2(
          Buffer2.from(xOnlyRes.xOnlyPubkey).equals(
            h("9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c")
          ) && xOnlyRes.parity === 0
        );
        assert2(
          Buffer2.from(
            ecc.sign(
              h("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
              h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
            )
          ).equals(
            h(
              "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
            )
          )
        );
        assert2(
          ecc.verify(
            h("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
            h("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
            h(
              "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
            )
          )
        );
        if (ecc.signSchnorr) {
          assert2(
            Buffer2.from(
              ecc.signSchnorr(
                h("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
                h("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"),
                h("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")
              )
            ).equals(
              h(
                "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
              )
            )
          );
        }
        if (ecc.verifySchnorr) {
          assert2(
            ecc.verifySchnorr(
              h("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
              h("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"),
              h(
                "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
              )
            )
          );
        }
      }
      function assert2(bool) {
        if (!bool) throw new Error("ecc library invalid");
      }
    }
  });

  // node_modules/ecpair/src/cjs/ecpair.cjs
  var require_ecpair = __commonJS({
    "node_modules/ecpair/src/cjs/ecpair.cjs"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var __createBinding = exports9 && exports9.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            }
          };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports9 && exports9.__setModuleDefault || (Object.create ? function(o, v2) {
        Object.defineProperty(o, "default", { enumerable: true, value: v2 });
      } : function(o, v2) {
        o["default"] = v2;
      });
      var __importStar = exports9 && exports9.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.networks = void 0;
      exports9.ECPairFactory = ECPairFactory;
      var networks = __importStar(require_networks2());
      exports9.networks = networks;
      var types2 = __importStar(require_types3());
      var wif = __importStar(require_cjs4());
      var testecc_1 = require_testecc2();
      var v = __importStar(require_dist2());
      var tools = __importStar((init_browser(), __toCommonJS(browser_exports)));
      var ECPairOptionsSchema = v.optional(
        v.object({
          compressed: v.optional(v.boolean()),
          network: v.optional(types2.NetworkSchema),
          // https://github.com/fabian-hiller/valibot/issues/243#issuecomment-2182514063
          rng: v.optional(
            v.pipe(
              v.instance(Function),
              v.transform((func) => {
                return (arg) => {
                  const parsedArg = v.parse(v.optional(v.number()), arg);
                  const returnedValue = func(parsedArg);
                  const parsedReturn = v.parse(v.instance(Uint8Array), returnedValue);
                  return parsedReturn;
                };
              })
            )
          )
        })
      );
      var toXOnly = (pubKey) => pubKey.length === 32 ? pubKey : pubKey.subarray(1, 33);
      function ECPairFactory(ecc) {
        (0, testecc_1.testEcc)(ecc);
        function isPoint4(maybePoint) {
          return ecc.isPoint(maybePoint);
        }
        function fromPrivateKey(buffer, options) {
          v.parse(types2.Buffer256Bit, buffer);
          if (!ecc.isPrivate(buffer))
            throw new TypeError("Private key not in range [1, n)");
          v.parse(ECPairOptionsSchema, options);
          return new ECPair(buffer, void 0, options);
        }
        function fromPublicKey(buffer, options) {
          if (!ecc.isPoint(buffer)) {
            throw new Error("Point not on the curve");
          }
          v.parse(ECPairOptionsSchema, options);
          return new ECPair(void 0, buffer, options);
        }
        function fromWIF(wifString, network) {
          const decoded = wif.decode(wifString);
          const version2 = decoded.version;
          if (Array.isArray(network)) {
            network = network.filter((x) => {
              return version2 === x.wif;
            }).pop();
            if (!network) throw new Error("Unknown network version");
          } else {
            network = network || networks.bitcoin;
            if (version2 !== network.wif) throw new Error("Invalid network version");
          }
          return fromPrivateKey(decoded.privateKey, {
            compressed: decoded.compressed,
            network
          });
        }
        function makeRandom(options) {
          v.parse(ECPairOptionsSchema, options);
          if (options === void 0) options = {};
          const rng = options.rng || ((size) => crypto.getRandomValues(new Uint8Array(size)));
          let d;
          do {
            d = rng(32);
            v.parse(types2.Buffer256Bit, d);
          } while (!ecc.isPrivate(d));
          return fromPrivateKey(d, options);
        }
        class ECPair {
          __D;
          __Q;
          compressed;
          network;
          lowR;
          constructor(__D, __Q, options) {
            this.__D = __D;
            this.__Q = __Q;
            this.lowR = false;
            if (options === void 0) options = {};
            this.compressed = options.compressed === void 0 ? true : options.compressed;
            this.network = options.network || networks.bitcoin;
            if (__Q !== void 0) this.__Q = ecc.pointCompress(__Q, this.compressed);
          }
          get privateKey() {
            return this.__D;
          }
          get publicKey() {
            if (!this.__Q) {
              const p = ecc.pointFromScalar(this.__D, this.compressed);
              this.__Q = p;
            }
            return this.__Q;
          }
          toWIF() {
            if (!this.__D) throw new Error("Missing private key");
            return wif.encode({
              compressed: this.compressed,
              privateKey: this.__D,
              version: this.network.wif
            });
          }
          tweak(t) {
            if (this.privateKey) return this.tweakFromPrivateKey(t);
            return this.tweakFromPublicKey(t);
          }
          sign(hash, lowR) {
            if (!this.__D) throw new Error("Missing private key");
            if (lowR === void 0) lowR = this.lowR;
            if (lowR === false) {
              return ecc.sign(hash, this.__D);
            } else {
              let sig = ecc.sign(hash, this.__D);
              const extraData = new Uint8Array(32);
              let counter = 0;
              while (sig[0] > 127) {
                counter++;
                tools.writeUInt32(extraData, 0, counter, "LE");
                sig = ecc.sign(hash, this.__D, extraData);
              }
              return sig;
            }
          }
          signSchnorr(hash) {
            if (!this.privateKey) throw new Error("Missing private key");
            if (!ecc.signSchnorr)
              throw new Error("signSchnorr not supported by ecc library");
            return ecc.signSchnorr(hash, this.privateKey);
          }
          verify(hash, signature) {
            return ecc.verify(hash, this.publicKey, signature);
          }
          verifySchnorr(hash, signature) {
            if (!ecc.verifySchnorr)
              throw new Error("verifySchnorr not supported by ecc library");
            return ecc.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature);
          }
          tweakFromPublicKey(t) {
            const xOnlyPubKey = toXOnly(this.publicKey);
            const tweakedPublicKey = ecc.xOnlyPointAddTweak(xOnlyPubKey, t);
            if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null)
              throw new Error("Cannot tweak public key!");
            const parityByte = Uint8Array.from([
              tweakedPublicKey.parity === 0 ? 2 : 3
            ]);
            return fromPublicKey(
              tools.concat([parityByte, tweakedPublicKey.xOnlyPubkey]),
              {
                network: this.network,
                compressed: this.compressed
              }
            );
          }
          tweakFromPrivateKey(t) {
            const hasOddY = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1;
            const privateKey = hasOddY ? ecc.privateNegate(this.privateKey) : this.privateKey;
            const tweakedPrivateKey = ecc.privateAdd(privateKey, t);
            if (!tweakedPrivateKey) throw new Error("Invalid tweaked private key!");
            return fromPrivateKey(tweakedPrivateKey, {
              network: this.network,
              compressed: this.compressed
            });
          }
        }
        return {
          isPoint: isPoint4,
          fromPrivateKey,
          fromPublicKey,
          fromWIF,
          makeRandom
        };
      }
    }
  });

  // node_modules/ecpair/src/cjs/index.cjs
  var require_cjs6 = __commonJS({
    "node_modules/ecpair/src/cjs/index.cjs"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.networks = exports9.ECPairFactory = exports9.default = void 0;
      var ecpair_1 = require_ecpair();
      Object.defineProperty(exports9, "default", {
        enumerable: true,
        get: function() {
          return ecpair_1.ECPairFactory;
        }
      });
      Object.defineProperty(exports9, "ECPairFactory", {
        enumerable: true,
        get: function() {
          return ecpair_1.ECPairFactory;
        }
      });
      Object.defineProperty(exports9, "networks", {
        enumerable: true,
        get: function() {
          return ecpair_1.networks;
        }
      });
    }
  });

  // node_modules/@bitcoin-js/tiny-secp256k1-asmjs/node_modules/uint8array-tools/src/mjs/browser.js
  function compare2(v1, v2) {
    const minLength = Math.min(v1.length, v2.length);
    for (let i = 0; i < minLength; ++i) {
      if (v1[i] !== v2[i]) {
        return v1[i] < v2[i] ? -1 : 1;
      }
    }
    return v1.length === v2.length ? 0 : v1.length > v2.length ? 1 : -1;
  }
  var HEX_STRINGS2, HEX_CODES2, HEX_CODEPOINTS2, ENCODER2, DECODER2;
  var init_browser2 = __esm({
    "node_modules/@bitcoin-js/tiny-secp256k1-asmjs/node_modules/uint8array-tools/src/mjs/browser.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      HEX_STRINGS2 = "0123456789abcdefABCDEF";
      HEX_CODES2 = HEX_STRINGS2.split("").map((c) => c.codePointAt(0));
      HEX_CODEPOINTS2 = Array(256).fill(true).map((_, i) => {
        const s = String.fromCodePoint(i);
        const index = HEX_STRINGS2.indexOf(s);
        return index < 0 ? void 0 : index < 16 ? index : index - 6;
      });
      ENCODER2 = new TextEncoder();
      DECODER2 = new TextDecoder("ascii");
    }
  });

  // node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/validate_error.js
  var validate_error_exports = {};
  __export(validate_error_exports, {
    ERROR_BAD_EXTRA_DATA: () => ERROR_BAD_EXTRA_DATA,
    ERROR_BAD_HASH: () => ERROR_BAD_HASH,
    ERROR_BAD_PARITY: () => ERROR_BAD_PARITY,
    ERROR_BAD_POINT: () => ERROR_BAD_POINT,
    ERROR_BAD_PRIVATE: () => ERROR_BAD_PRIVATE,
    ERROR_BAD_RECOVERY_ID: () => ERROR_BAD_RECOVERY_ID,
    ERROR_BAD_SIGNATURE: () => ERROR_BAD_SIGNATURE,
    ERROR_BAD_TWEAK: () => ERROR_BAD_TWEAK,
    throwError: () => throwError
  });
  function throwError(errcode) {
    const message = ERRORS_MESSAGES[errcode.toString()] || `Unknow error code: ${errcode}`;
    throw new TypeError(message);
  }
  var ERROR_BAD_PRIVATE, ERROR_BAD_POINT, ERROR_BAD_TWEAK, ERROR_BAD_HASH, ERROR_BAD_SIGNATURE, ERROR_BAD_EXTRA_DATA, ERROR_BAD_PARITY, ERROR_BAD_RECOVERY_ID, ERRORS_MESSAGES;
  var init_validate_error = __esm({
    "node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/validate_error.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      ERROR_BAD_PRIVATE = 0;
      ERROR_BAD_POINT = 1;
      ERROR_BAD_TWEAK = 2;
      ERROR_BAD_HASH = 3;
      ERROR_BAD_SIGNATURE = 4;
      ERROR_BAD_EXTRA_DATA = 5;
      ERROR_BAD_PARITY = 6;
      ERROR_BAD_RECOVERY_ID = 7;
      ERRORS_MESSAGES = {
        [ERROR_BAD_PRIVATE.toString()]: "Expected Private",
        [ERROR_BAD_POINT.toString()]: "Expected Point",
        [ERROR_BAD_TWEAK.toString()]: "Expected Tweak",
        [ERROR_BAD_HASH.toString()]: "Expected Hash",
        [ERROR_BAD_SIGNATURE.toString()]: "Expected Signature",
        [ERROR_BAD_EXTRA_DATA.toString()]: "Expected Extra Data (32 bytes)",
        [ERROR_BAD_PARITY.toString()]: "Expected Parity (1 | 0)",
        [ERROR_BAD_RECOVERY_ID.toString()]: "Bad Recovery Id"
      };
    }
  });

  // node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/validate.js
  function isUint8Array(value) {
    return value instanceof Uint8Array;
  }
  function cmpBN32(data1, data2) {
    for (let i = 0; i < 32; ++i) {
      if (data1[i] !== data2[i]) {
        return data1[i] < data2[i] ? -1 : 1;
      }
    }
    return 0;
  }
  function isZero(x) {
    return cmpBN32(x, BN32_ZERO) === 0;
  }
  function isPrivate(x) {
    return isUint8Array(x) && x.length === PRIVATE_KEY_SIZE && cmpBN32(x, BN32_ZERO) > 0 && cmpBN32(x, BN32_N) < 0;
  }
  function isPoint(p) {
    return isUint8Array(p) && (p.length === PUBLIC_KEY_COMPRESSED_SIZE || p.length === PUBLIC_KEY_UNCOMPRESSED_SIZE || p.length === X_ONLY_PUBLIC_KEY_SIZE);
  }
  function isXOnlyPoint(p) {
    return isUint8Array(p) && p.length === X_ONLY_PUBLIC_KEY_SIZE;
  }
  function isDERPoint(p) {
    return isUint8Array(p) && (p.length === PUBLIC_KEY_COMPRESSED_SIZE || p.length === PUBLIC_KEY_UNCOMPRESSED_SIZE);
  }
  function isPointCompressed(p) {
    return isUint8Array(p) && p.length === PUBLIC_KEY_COMPRESSED_SIZE;
  }
  function isTweak(tweak) {
    return isUint8Array(tweak) && tweak.length === TWEAK_SIZE && cmpBN32(tweak, BN32_N) < 0;
  }
  function isHash(h) {
    return isUint8Array(h) && h.length === HASH_SIZE;
  }
  function isExtraData(e) {
    return e === void 0 || isUint8Array(e) && e.length === EXTRA_DATA_SIZE;
  }
  function isSignature(signature) {
    return isUint8Array(signature) && signature.length === 64 && cmpBN32(signature.subarray(0, 32), BN32_N) < 0 && cmpBN32(signature.subarray(32, 64), BN32_N) < 0;
  }
  function isSigrLessThanPMinusN(signature) {
    return isUint8Array(signature) && signature.length === 64 && cmpBN32(signature.subarray(0, 32), BN32_P_MINUS_N) < 0;
  }
  function validateParity(p) {
    if (p !== 0 && p !== 1)
      throwError(ERROR_BAD_PARITY);
  }
  function validatePrivate(d) {
    if (!isPrivate(d))
      throwError(ERROR_BAD_PRIVATE);
  }
  function validatePoint(p) {
    if (!isPoint(p))
      throwError(ERROR_BAD_POINT);
  }
  function validateXOnlyPoint(p) {
    if (!isXOnlyPoint(p))
      throwError(ERROR_BAD_POINT);
  }
  function validateTweak(tweak) {
    if (!isTweak(tweak))
      throwError(ERROR_BAD_TWEAK);
  }
  function validateHash(h) {
    if (!isHash(h))
      throwError(ERROR_BAD_HASH);
  }
  function validateExtraData(e) {
    if (!isExtraData(e))
      throwError(ERROR_BAD_EXTRA_DATA);
  }
  function validateSignature(signature) {
    if (!isSignature(signature))
      throwError(ERROR_BAD_SIGNATURE);
  }
  function validateSignatureCustom(validatorFn) {
    if (!validatorFn())
      throwError(ERROR_BAD_SIGNATURE);
  }
  function validateSignatureNonzeroRS(signature) {
    if (isZero(signature.subarray(0, 32)))
      throwError(ERROR_BAD_SIGNATURE);
    if (isZero(signature.subarray(32, 64)))
      throwError(ERROR_BAD_SIGNATURE);
  }
  function validateSigrPMinusN(signature) {
    if (!isSigrLessThanPMinusN(signature))
      throwError(ERROR_BAD_RECOVERY_ID);
  }
  var PRIVATE_KEY_SIZE, PUBLIC_KEY_COMPRESSED_SIZE, PUBLIC_KEY_UNCOMPRESSED_SIZE, X_ONLY_PUBLIC_KEY_SIZE, TWEAK_SIZE, HASH_SIZE, EXTRA_DATA_SIZE, SIGNATURE_SIZE, BN32_ZERO, BN32_N, BN32_P_MINUS_N;
  var init_validate = __esm({
    "node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/validate.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_validate_error();
      PRIVATE_KEY_SIZE = 32;
      PUBLIC_KEY_COMPRESSED_SIZE = 33;
      PUBLIC_KEY_UNCOMPRESSED_SIZE = 65;
      X_ONLY_PUBLIC_KEY_SIZE = 32;
      TWEAK_SIZE = 32;
      HASH_SIZE = 32;
      EXTRA_DATA_SIZE = 32;
      SIGNATURE_SIZE = 64;
      BN32_ZERO = new Uint8Array(32);
      BN32_N = new Uint8Array([
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        254,
        186,
        174,
        220,
        230,
        175,
        72,
        160,
        59,
        191,
        210,
        94,
        140,
        208,
        54,
        65,
        65
      ]);
      BN32_P_MINUS_N = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        69,
        81,
        35,
        25,
        80,
        183,
        95,
        196,
        64,
        45,
        161,
        114,
        47,
        201,
        186,
        238
      ]);
    }
  });

  // node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/rand.browser.js
  var rand_browser_exports = {};
  __export(rand_browser_exports, {
    generateInt32: () => generateInt32
  });
  function get4RandomBytes() {
    const bytes = new Uint8Array(4);
    if (typeof crypto === "undefined") {
      throw new Error("The crypto object is unavailable. This may occur if your environment does not support the Web Cryptography API.");
    }
    crypto.getRandomValues(bytes);
    return bytes;
  }
  function generateInt32() {
    const array = get4RandomBytes();
    return (array[0] << 3 * 8) + (array[1] << 2 * 8) + (array[2] << 1 * 8) + array[3];
  }
  var init_rand_browser = __esm({
    "node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/rand.browser.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/secp256k1.asm.js
  var secp256k1_asm_exports = {};
  __export(secp256k1_asm_exports, {
    EXTRA_DATA_INPUT: () => EXTRA_DATA_INPUT,
    HASH_INPUT: () => HASH_INPUT,
    PRIVATE_INPUT: () => PRIVATE_INPUT,
    PUBLIC_KEY_INPUT: () => PUBLIC_KEY_INPUT,
    PUBLIC_KEY_INPUT2: () => PUBLIC_KEY_INPUT2,
    SIGNATURE_INPUT: () => SIGNATURE_INPUT,
    TWEAK_INPUT: () => TWEAK_INPUT,
    X_ONLY_PUBLIC_KEY_INPUT: () => X_ONLY_PUBLIC_KEY_INPUT,
    X_ONLY_PUBLIC_KEY_INPUT2: () => X_ONLY_PUBLIC_KEY_INPUT2,
    __data_end: () => __data_end,
    __heap_base: () => __heap_base,
    initializeContext: () => initializeContext,
    isPoint: () => isPoint2,
    memory: () => memory,
    pointAdd: () => pointAdd,
    pointAddScalar: () => pointAddScalar,
    pointCompress: () => pointCompress,
    pointFromScalar: () => pointFromScalar,
    pointMultiply: () => pointMultiply,
    privateAdd: () => privateAdd,
    privateNegate: () => privateNegate,
    privateSub: () => privateSub,
    recover: () => recover,
    rustsecp256k1_v0_8_1_default_error_callback_fn: () => rustsecp256k1_v0_8_1_default_error_callback_fn,
    rustsecp256k1_v0_8_1_default_illegal_callback_fn: () => rustsecp256k1_v0_8_1_default_illegal_callback_fn,
    sign: () => sign,
    signRecoverable: () => signRecoverable,
    signSchnorr: () => signSchnorr,
    verify: () => verify,
    verifySchnorr: () => verifySchnorr,
    xOnlyPointAddTweak: () => xOnlyPointAddTweak,
    xOnlyPointAddTweakCheck: () => xOnlyPointAddTweakCheck,
    xOnlyPointFromPoint: () => xOnlyPointFromPoint,
    xOnlyPointFromScalar: () => xOnlyPointFromScalar
  });
  function base64DecodeToExistingUint8Array(uint8Array, offset, b64) {
    var b1, b2, i = 0, j = offset, bLength = b64.length, end = offset + (bLength * 3 >> 2) - (b64[bLength - 2] == "=") - (b64[bLength - 1] == "=");
    for (; i < bLength; i += 4) {
      b1 = base64ReverseLookup[b64.charCodeAt(i + 1)];
      b2 = base64ReverseLookup[b64.charCodeAt(i + 2)];
      uint8Array[j++] = base64ReverseLookup[b64.charCodeAt(i)] << 2 | b1 >> 4;
      if (j < end) uint8Array[j++] = b1 << 4 | b2 >> 2;
      if (j < end) uint8Array[j++] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i + 3)];
    }
  }
  function initActiveSegments(imports) {
    base64DecodeToExistingUint8Array(bufferView, 655360, "AQAAAAQAAAAEAAAAAgAAAAEAAAAEAAAABAAAAAM=");
    base64DecodeToExistingUint8Array(bufferView, 655716, "MHgwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OQAAmBf4FluB8lnZKM4t2/ybAgcLh86VYqBVrLvc+X5mvnm41BD7j9BHnBlUhaZItBf9qAgRDvz7pF1lxKMmd9o6SPk24LwT8QGGsJlvg0XIMbUpUp34hU80SRDDWJIBijD5cua4hHX9uWwbI8I0makAZVbzNyrmN+MPFOgtYw97jzjk70CyadWoy7eaYdy9hIvoKFFcCiWntFWTIAcaTd6LL9ZirKY6fajcQGgNqxsniPcmxMmm3anb1Nbj5TYmIqzYvPnEyu3dK+mc4zADfptBPQ566vJl85ij6rRdbmTwvVzaZHIIKCYIpbXn/RO40BOo21Qahm2NF6NgWSW6QMrratrAxJ5MRHsbNaM+cnhWjOguFh+YrcE5kjNfO/bSuWiPgv8fUHm/PPL9C1GV/izqu10hvrbCkB3ehjkGui2fKmb6CTjS7bjiGL5U2VGzXIT9CB9F8mMzqYsin1Auvh04OFLtHzMYdXC9TfLYMsv8gTbMsQ5SpQWUsNwXuQ8KLaPkEKPCl0gmpD4wJhJApa6G8aGZRqqCG5L25io35CQnJknQ3idegbZBDM74X6cSNhZtOzAUl1b6LFr5q6e8c+c3EzEtvc55sIQTjdsG/1YazE344nfks1Pi1ZAMJBqMVgbjRG5UkoNAK2kmODe+QoC8/7YNfX8QK4+IYEKTeONvrA61SwS6SOXO+9Bs3ggfe4FWUka1IcBa65rsPu1uc9OeOkqXx0UMAULSwQ5gjpgXdatpaU+euGPG3yPAyb0oWcx7WO+rUE98P2ARl3hK+ITmXPxKT6cBPBNOVyjLw3V2TeRL+xsenEtXtaMgU7Ib0mSMIG4ACmzYahniLC7+L7a8JXBHje6bJFAzcGJpSbFgS5Eepc3WkSUI528WGIGkmNpq6zrsoxod3wAHDE0IAN/dHIW6LRHavKegd3iE863fNMJDVz96KlVh7dGVOp8t+YZPfsrpTJXqELn7TSZj6EqpACMIBDfOF3HtD2xVGc96VUFnBNgGFDPnFY/Q0mrx91N/gU9lTXPsZQnD1ibLn8AHq3n0wc4vLze4svfNHOtihBslkMwMBxjRo5JDwKIYpO7kM33D+ydk3lUdiae0VWcvBrvSCyaNvjpZ7dDP8cHRcMyFxwC+KU/LDzwR2ZyZX7XDqhUQbXeYJ/ZxggbfMvPizV4Iax1FH2ocWiKWVgt5RYm5sKrWa9LD0di9Mq+m9c2j3M9sCU0UYu5CUSUaQRu0pMM07gCUAuDWVaOhLs0d22LSRqFyrcqfKWzlnilqf9466L+atwke32JNjXVD8dky5Fv6PTTlH2JKMH/5dcZnr9QhGbYSpZbONbDzGWwg5bloqdRBH1+ekjOFGoUqAKf+0BPPzQvSenGq+aSBGYe5mcJy6zWnTxlgAUmLQRjekelqP5FLAk3JGzBm+9qJfMyHJ3NRAJct3Qrl8oTzQBoB6H5LeVK056gw2AEAnRCjyM5nvpT5EMrdi3dZMvngpgOCwhTL+7vZCOi9nlXXQXqgmhbkBXbd7LbEKhO3JOxCOt8YN6o1VlcBmEsciALMGQXhi+ud9s8DtkW31ww1sLatSEhcyibWNhGwvoNRMlTPQVQykDv4smW+0IS5134YdkCBeq7lPNdnchkPk358vlKdha+Kfrfh9+S5mz3adPJ/SV1R8HhGtIXIQiy/uUi0YekfLYeWP+nhVa0/dtReClSHZNqGVn9xF3NFOwfL2xKZXszs9wdHTuBX+ixECod2BAqFZMxvZUZVoWLAoLLMaC5XN7z10Ms7uXyDofveppHSrF98dUQGPp+JN2rZRFgNwIoHmRlH5rWxOoZEK/LloyxBrsNUCp4jLDMqWiUtmIxH4qAPNeusewFu2VBDBIuzntiR5JXj2NdBHuUBDcY7fnA53ck1UHspg4g0QtvzdKcEOCznV7T7YX4RuWEp2plPO2Nv/hCcBfrlyQIAq1nCw7tay+N0fyI2Ca2UjC1etOIYBrZ4xuuGNWHLMBvioBaN4Z17ao+RpHUIeWDX8IlMvea2Yw85w8uRj1+Z6zRtJgA1tx+sjR7lKuE54zGqIxVEqPcz4znZ4Yxe9gx+WQz9pJUxE5LPvPq4VUXsziGelYuiuKQsJL9UjEl/3oeeV316iKNWBZTpmimwjrDbM6W+5Fi1K2BRI4VAJZFkp6vL9Q2L5z4bqsekA5Y6F9A9jD9kfbGm18605bhU7cX6f3cSVWUhDJo5Kks8gwBvHSpS1aj0SK/NiRokPzU0zR6sZuscLd7ja39y7p+gO8x6f3duFV6NiQjCdc7hftugrVqPO+WgDeGIDez5WjaYI21g4Iwl8vZkYebmsXx66DJn21kFPuSCjLNTduQvBFZ2rbl68lfoZHprxfrpSdBbMtwzCySd9IcPnoNWTGsZ8JxI/m+R0oNGSjDfm2u3Z9Y2YsBsJekhsF+uljZg03RLm7I3fmISfdH+QeKTdNVQVeQYtjaNXGs2aOc584S12vu1FCu61xJCJuwUZ8/2/hmmZ4jdxm2p8Rb55P0xHHnLnpfJ6nh7wdiaCjQcoe7asQnxMbQZ3z3jVUi0ap74LpsjW97UZlf1c5dEMh2yMtfMbRTzxndzZDegrEsoIqc0oPw8nfvZmwDrLdt7UVAw+vre/w21yuO5RrC0UGPz050BwpMcHfClRFduxr87LE+dIjU2cemJQ3NEfX2GENK02C7IqSQfjeuQtU9lN1jIyP8GIj9lZeucswdDuem7usEm+KnBhvP8QsDapInFhEGEV3su/94uMnDZmlwteAbrAPLTQmVVE+OvViCLwxtS9a/Lly12ZJKzXEBlpbsnQAmDAAZc8+m50HQPMqE+ln05Sk3nYGFN3ZRmu3brBw0X8Eer7m3f36Uyp8L6gI5/CVNDLYz889YDcsZiAvm3AkjvXznAIh58Ro57zjwUjrzhHesLgcRfKIhzULfU7q82l2qBVPXCh2T9gOiiidfg2UGOyT9V/+/OqHFhaMnnGFNgQXmrq2Hu0jRJhKI7aVaGTRTtenQ7SwIR2Zb8FFbCzxTA9lyGBN2f0E5S393vehgn/zCxl8Neg+I/E76bUp76S1vGh+rxZWMP3g5ZKHQ89zWs/1q9/IUA+k55jtMZwesGim6vHbns0rO+Mo2ZdK9S4bZnNuoPm82xsRE5kpk6GGdRDt1X6kwQHQFt97yEJFnSi2PpRhttMwwpOcLD+m1FSQBQleYZFCT8r7h2oYSJNwejGhKkigoXSY/mjVVFJmJW9/CTsktG43IWWIrwL0w4upSZCw9C8Sn4MAulBIoQcfS/fPLa/jOwsUyi3At7Yg3+U49FgHbhek+7UOssQGr/OZ8hC/mP5hPsY0fBPrB0o7BTxc4B7RP7JguX6o4dJvgHJOovyNbaNXi/ppYdsjrkYf0z/UCeSWiYR2hu+3fuPN518iF78fMAXg+oqR8hCGtCRnxmm9xmXJ+gKimmuUu8B2u32U0FAxazekDZKZ+9zgm8EW9ylWS57GKoOZIEDl1zXGM/oRI6p+cdb4kAsGBQWDjqRe4Snv25lk1Dr9nzzCFeT9E1klpdnGp99/AS9M/Zktn8DItADa+TOIoVdP5+q9HK+R3f3f6uBMr9OKtpuu7WwM/wIVatnwHjHnPkrRjwzL3DyVRkRPSttiQPYelJpEOrwlQc0en7y/Fj0+SmHhTCHBOOrEAxDoTuWNO4CujpZ36Dve6ZWlG0ExtjVcCLmnl7CkGG5qk4rdO0yY6BuychwTA27/FOkWobsbo63s7wiHQwi4JjiBfKd5TlYAcNOhG5gWdbNx8TSW9m0pXlyJZlMZydnQiOMJDhJ0gqNSyB3RK8S6AjXBOvI9ip8iyo7jCJNC2UARX5n2Awsck3dlUSPvw5orsGFJpx/zvAlNHBwdEoaHtxcmExtEeCDlMAJtXGxkGByjnecrxL1oeTXjG2OHUljC64ntPxHks8y1H0VboovAwi4StduFRgh+XP6kv/lCadETFXWKGnM90bq7sKJbC9xs21SEBW80prYadCrCTkwIYxjD49h+T5KoBaDmH0UzfvjVc5VjFYPnYKGe1AiItn9F8YktAYW8JZoTTXjnFfflz4g6YvRriF2laxeLHTsmkUL51L9IWO3W68qWrb/lOo6Rc/+XvZ4JtC50n/j1Z0D8VzAEwhdaCsuo/AMayLV50DJpieZ0Yn/F2e/wdieTacC6dhUg59I8ZHa8Ip48p4ar8RAOZ2JmiUqO0rFr4W3fTJqJZTwNHtnNSF8Z9Ng5Ybyikh0Fp4ptkYOhDrnER7A8O5+9vCW+Couv/lG+vTbDIqvXAKFuD8igUClluUU8wUTzLer2XNuEMF+n6oXLoCEHkjK8iTI2gcF/oBMavnu7cuj8ZHbLuLaCSfgIidn6RnSYa20twY9FILjRF4Fl4A/bZmSUCgqjP5EhUr7XubR41Wv1cCrAu6MPvrMApAZzAKS3AJKmK0vLw+tHYmCwz3oD6N39EeJFO/tx2aUu9ccdB9m8a5pkfGj47tVHrFldQeLltFBQV0ldKKY+Oa40soXs1npawr3ZHeC10zWZJD8E6AAJtKLWvIpVPDteFiBUrJhNkt0RchE6XK75rrc95STTgeAg1efYcen7pb7V92ShxbwtWKJfuY1hBQOENVMMLb/PUoYP25YkICejMTsNyEmIvtFn++43nmyqtXfMn6SIkNBTZY4XHW+8F54RgPaz7ochb20GWYV+0oZWhmdBRYCzLi9zbJDmTKJMDs6yRw7gyBLY1cdIoV5IcPJ3kGJ4FMDtQkWRmx3XdbM6EAeGxyrVWA0OGghoKM89Va/+qsYZstu5hFfX2ZFi7NUDtzI+tEiMDPi3DcX7u7AmT69UFZ4Z2PCJeNi8A7nNENgiP7gVfKcYf5md6XqRteTzt54F4GrWqu6fU7c7an1jTZy1Usj9tZpwiV3b2/8FXibW3y2/FM5lOoA3Lc9sb4IuMu0oVb2fS5goXzVbfWWDmAiPPiScExh4XLLJhstViEBcsAP0S/pNmyJnstsc8Em0lz0LWFa7CleWelLV38uLVKqHNvTaxsNwj8PhckebxROx5FjTbOY8FJ3YgzJxO/zSodlqYP9JGtbroz5UU9QvFcCYFeBLt4GaeV+hhXR4XSZ8pMpqmy/DoQCj7YIWILxVRYjr3c2AbLeQhzSr1m0ktjCGWTWVmT39Gx43jlEpKQScVoFwByh1rwUVqDHUplpCxyhiwevPVZUc1YFHVRcxZoxm1Ztp6cYKJRTcCY8GZme+SpYtfJDyZh+9jYGSeylWm+June16qFtnwCRcr65UyreYxImuN5rUeB0lkDByD8GDjleUV/CDFQJz5usFm0h4gkTYIzkZd27qJcHMA5aBZg2n20HJgOuSEHPNNNuVYmPPh2f7XOXwWka64HeiaN7/pmMMoJNB0PzZ+pwCjPCoOnWDoZ87R0rlrqzibcZPSpF+KNohj0OaNDHTZRmMBOqv+qG6pLWAP7XrvXuUtRPCDYz4/cw42dy97oRwpb3hcC7WQo8ZsovBG4Adib7Zn5Z4aBvRnHUS6RY17xOsDde8ekpyVkjob/7jrXpPCeE6vvAc6NsWcgd7b+cEecRPGr5YgBM9XXBr2UtSlqeZBp6oEUA3N3CBrNS43qfVlH/GK6Vg9ti+EYC+Jj86qn4Tr5Rdc4M0yYaouHJAsyO80gnmnSNk8JwrXtz8OwrAD4m87vZUquukUc7oMzwe9lDTcCZtxJNLikEOTfAwIx7Siu9ge9zSafBkUYMuyL9dZ4bvVsyCGgbZw3tzqbIn7BCZr4NDFlpYl24gppFFyN95HMJEzGu+mw+ostPws574eJ95lhGTUC6TfzMeH1oRY5QascdpG9bfKOsg/ww9MmBZe3570RMP0XhdplNUAc6fffcgLxrsKdrl3Xn2d9PefZkQELj76ISy7F0w0if1IRMvLOReyeMHY/zy9rZLIYHEQK4Ul3BuO1QpbjAI+EiM/HL0AHrJteYYXsnDZVYjXtAAUoZ70mybeagVpSoZng8mEyTiNwYGOwyQ4L5Lh8wjJp7sqNIPkiWQMys/PMjzpn8pNsWnhrtCsMO2nJSfJrI57vPlmA2bWA3geDukiaL2nDzaDJpzw9oGLXkrynkjAlqfGsPj5FyJ5ulGZjCaKcC3mzWELUetrdH4ST4QYVFVEB7PYvP5eGUEAlp4vnHXjPJWcQsGDrlowJtwtmRvxj5t+O+yBdeLhNbcT7Lgi5Iezwh89MYjiJt2yE9HIHPGpVRA4twEKRImvwOdUZlGwyv16dWCRdoKVZ1GnZJ6omtJlMQq/uviVCBkMhfSVXt7+ddbvmti8BN7GboKQ4ujqrmKYPQJA8tAuYOGODJJMVZH95edvUQ/1fxjj4Rt9+jWJWcmT97ru34I5nN+Gw79oXRbi/z7risj3F+BPU+8/zJwZNJFw7RUh+Aoo8b1l4JTNf2TFcDusLSk1jEgmjXyzHWFPhvx2KbHx8GjBaC8zalzx8AGA4KVAGigzfUk9wmurGP0JB8JFEm3LOPOrcfnVcFonE7wenkiz6dG8Hpd0J+Lj3Y21ByVtia9CQWhzAlIRhbHxl5/LG1HpFWyPDlempmMvizitQK6jdcrqJtYBt842mjAuTC/aLHjpAm1VGQqRuvQMQP/1oiGL3rroSGrTxcJk3/497UrXWwKZCpVmCS7Sit4gIqkRHSNS8N6LuHADh9zMybQoMpwaSs++mMeRRu69CGFWU5tDAPFLSeXHAy8IBclcvDarLAzN7PmX05cfeG1Ii0K/6HLuYd6EIK1A/3OW1fd3BvNMZVlvzfhUH6LnLUPyBqSLRnS4D2WvEuF3iAMN2hlV4UvM/UYt/TGJIufXJrBTvxJQ3BgB62Qs58tSuYIf9bpf51xfB6sior1rYxtP8aaKKBuryNxsiqgdTTGkprKx0Veld0B6hMMp5ojcyUreimkjotB+xA/eIghH9yTV01s3zdpTzPV1X4BiXBdolaIel8dxTvf3fUL0tTttJPBGeFA0oEIRS1KQLPTdQ41bnvDZH0LrbuG2zi/mfUJx4z/2wnnx0IQVGsNwSficq584wtuk1s4Qg2HGrxcqykVB1inzyYaGqNMey8+ZFFeL+BeOYcY6rhL8mHK6dVvF3rVPKtTTbrCXhT7WgqTBXrozeWUZQbboL0yOEzEEd7YLdbskOqPA5AW7BpRinXiYjm71fmPiosAG253c2P88GeWd+7y1Mx1l8MlaSxvH4e5sMeCmlJ+iNVef6ZNMmg4zfu4kKZYug9bOh5A9k/uweggNxsJfb4meRdgL/QNMwD/PC7HyEQD00u4GHRw1mPHdZEtGvffYSueXGAEsM2/ShPlDEWQ6lnq+pr3pHtgSnC6LIvzVWARWqltZZuZw7BKpLS2ZXQeppL9TWvOUV8bLqKP4vUgCBdnhKBodCl1tOK0MRTeQDShKxQYOcf6oLFakOCYRBMapW8yDr1cC7gRNDMraJU2edBbiFxQTNjn1Wk6OcfLO5cDBxrktvht4cmhZ60kWWmfpJLWW5QY9SsdHbD4xoDDAQi8+mpEfMuix9XPdv1QWXmBsghEMoGHCJJORDhp3fxVYIySzXfZX82y5viRF/P8WZYYt6OaZEdpGHisADkkDSeXCb6YhQb054GxVVkCc27aHKRjrR+nMewhDNwQQZPl2NbSklbBkDsJwQoGKM+q+E49A7e3xIYZZIqqoJ+MM8ApnvB3bhUQPDb8reuClyIiEhf0OnBbT7iLTVOqrhlh2x7PvXpTRCvfiLVqv8R0oFCn3wkDBRdlHw7Qk+dzFDTNZ95JODU9aamSShrzJ8IvJZcgQ74Ga/YXBnCaAOb34pqN5/tM+I8XBDEq2t2N//SBOiZkh13WotSrLqP9qrQ4MCpg6WmoZkf7qp8ETGwa4nW0MLKMr8S5GKJe+YKYWsG111YptCeRgvqx5s7ipcNh89/FOS8ZIzSWwjvtfNz+9hk3lnnnuARLTiOnZwo6898Cf/tUSMLwUYwR8P68yAaJUxVjxyYsVIF53wPY/Nh/jt7kvgVUhYUw7o1fvjxe6GjS46bH0flc+YMs8TdI3C2AHTpSJL2bUqqWPXecH9UI+YomGJf4uctlxGOneUXvHXVmgHhM6bx4AtEnNsKchnE0xIGa2ZUgM0l1/IAv1yC2eIi9TFBXquZI5OREzNkv7krWOUB8kyDVyXMkRcDTssWovJLxPnnCVX5cE2MalH5vlPfA+IAtp/FcyCFJllSiEqUVPTmTwLFoOiE7HmsiLnp+a4Ll/1gBfgslr6QMwTW8fKPEe+cWczNn+NIhetTtp9oMRcyMHfZlYf7Hq3+4zmIB4qiqAysy/qlI5PL56jT/XoSHEfxqinmBgm/1BmPyt19bEtZnR5X1Ap/Kkb8Suo/CljXw+dqlYgUuiOX04124YNVng4sVNWeOG1lbxvAufuQ5F5qngL2i+JhI2dL/RgKNW/fSADR4bxzT5mm4ZoeTduJ5VhTeY5Y0HQlHkE3wvEwySc8s02UtKP73fLxwKiZKz4z/lo27s6qlCC5tzIGAk7ZNj5aOwN9mHi3lZ8m0I/Qdx3Ji/EFrVwSbtAob7Y6TQFuhw7B5+Oxih6EFQmFJUQ2nnELbbNejfqqbCYEJD/WuWzDQPdJ+lh8OuqstiGddoTnuIoYHWtAYNQJRIK/ffsKGIZZjdunDf5hgqtdXtWn0qn3HXPPZ8niIsh9A3TCD68IQ9ey/soRC7WVCLeKY3piu5mQ196UhiD0IPuN7+jGoVUB4IHgIpmljWaBSO0ShFeh6jd6xzfoa3nFniT45MzQhfIrrEyd/teA2ZdSuVQn/YO8M5p+j8mpm9NZ51V9Gx+os5w98gk086p4dx8MBdaEC+6i+JEwEccIwasx9sMbTwxJ5QLbFHfG6j+DPSykEi+M25thR+b6znnFT4KogN13XdMpYM7LRpmyPe2sovbigugCD6VGbiIULSaeMNO0JzKU14qd+JsOZ0GpmsOmWBcR0wflPdK1vAJwlHSMzHAUJjbGhwuf+VPuGQwCBXpnZyJoOXWNM7fmyD5r7WyIDGtrJfXeB2Oaj4/I3CMtv883b5gNrgMIUdXBISCY1N4RRkUViXvKFc5/2eIZG7bmxcesYZzl3zA+1XIyi/l9BB6TQkDxoWa3rJ+KT0PqCeVp+11XwJH7Hl/Wybw5fbRyZBawzj4Yz+SuKq0lJ7dxLEu4LchJF6HkwmqX+SHUQ3tazOUK/okVcLG9vF3WlcHC65rv/ZEuEYVcpUkxnKNH2BrEci91tHd2QvCQL8sgu0TLzdTG4JGOmUsiDTfBCDepnxHt9wDGRt0PVgr2XtzEE4NEAbzNoLAbGmREjFpATvXgQ8QdgnJtqVzI13+Y4Ex1wp4fmhpvjhM1vq8IvZ6pjcMdIBSMf3mdSmBH+VdymwZPB1JdAVdDCsMYIrFnnyKyOXTF5oLvDY5jyMDIZYyLTUz30NJecUim+br+LWC8J6wu3ZmdVQKWQi/c8wR5fAsd/IoZKlEBH4h15Sm6QPVba+2zPf4bKwoPWXk/bX5TB3OSS0JpDUqdwOjOvIGcToAT699gWbAaXOxPBjvHlPHD9Lp/7k2D6w3tWfJBUZYvYNcjf/nqDDM2wqwBV8bILomeVQW3g6pPoT6adz2GwOC5Es8nJraX4trAoqX3lVK8UUv3/AOOhO+1nopVG73lR/dxRY72jJhHKpur2F6+he1/asyvu0QKy70Ez9XcAp0B81qwhJnFf8CTob2ldI6vZohO+Lc8MhFw21byKzic3Js/q8V5RgV1fxjCUll/6985PPyv85oHjhe8pCCdPodvLHwjoSfM4vfLowIcxBmDpG+jANAwbvfynfAJlVzMu81CYzu671mUHoMUzvG5H+sjFsng5jUXpSa3S/lb2wNnrUROb9bypEO8OdpeE+SrdvIx8tGVDemz+fICrWjBltVGObsGI3w2G5gRgYXktHXnaBnL3AF6ixUmYNzJAaD2+tXCZEjHalGVJukx4/V+imXqO2iTzFOU7VvPpHHUM/tc+gAtyte9joojruUheAZdyDs/WjzuNbP1uWmku+dFfu253B96OD+2spB8aZ/VdJRNBy3Z7omOQG6j6TRxH0PZgCQAIvxF9sQTKy9mshLm6Mcv4Tsq4JfgNRFiCfgdPXVQVpEUTTMWy+Z8Nif371Cci9xHBh5M9+GOnqHNhrBUpEtl8tVwbYYqyni4Lrly44qXPnaHdVqkHLP5GMAuy0R/MCa/Nwb9Li4r9rp7m47UrPjsJWYJX2xRnyq7fk1EMx1X/2ez44APMrS9HI1XIsMbQRtQHconRdyD2u53jT8jxK76TwAqa52pqrwcIQQSEZxAP9vbFVtESU6WMPsBPCrRuF/vxHE8wPPv+c5SynxmQzwqROBjytHxy70J1WzajO/13J91ZcBDKomi56D0MANyHNNiG+XOB7FtkBS01ZT5smHWYfLHjd4XXO/oLKl5roxZQeAoZ3Vzyy2Bi5B130Bd2h0nVxIG0V2zLqiwdHP3Y8jhmhD4DJ08ya1bkapw0oqL7oBYOYL38FgkGJczwlVdVooWQ0o/74zp0Z8fEyfhOVGzz4r1Xa2qCQApOY6VO32PBEk76wzgqeFB8llAJVVuF2HMzWRlk6K9LwlaaYVTE1LV9oYdnxa1DSJ+MN/bC5g+R0JjUSUfQXHDH0ETJBswPf/ZHrb204lTY9lQYVPGu0JB5S7kNavAi88I/ZKwHqD7/lX0FC1l1iz+qZixJohvAzFzTtwcBfS+py7R4Jf4ZPXbUjf15snwv3dm2ZaLng4TbgGhEZmrQrlr6G11/s5rYKqy06ofP0r/kR6X+mVhfOt62UgtmgKXLtMHAZNtB/lK3MhyxwNQFrfnOloBmSbqDWNUBsgJ31KvQ8rI5e7wcdGcwD0pJvQ1FLNUuhotoJNbANZnclMcQ1X2HMhjppPr9Mv0gpqx48Ol2LKQsdGIF28jO+cv42PRSCY8lahDA7nZQXQCI2gEk22xz1uF0WSBl9roxSPTAdXpMnyVzPW6FMx+yWi2RI0LSvt1h0jDMELRHubt/QiApdXk0/kf4ugzpoz6eXtvPBQcCIf3SqkU2YZS4zySglRUaDPMt9HF3kfZyIEyNWRWjzg+aFyYD9N3QOpRQZ/Ef1e84OE+0djZPzDAgyviu4rEcP/ATjTX3prxuxEm2zdCndlUxzFU4MjMFWcF1eH22T1X1DQ0kOeWy2AUrsq2qjm/3HLA7PdmKqaIwHEUBjwhPrlO5GLGQfUZeFxQQD1ABpPd9PfP2im6QlskheXTMS2GVtBONCu65nd0tvPnt70/9KL+masZwWItiMWHRKrfBUNN9V9e8xmpcw8foeJi+/op3RFSp4coQ0LMonrGSjiTMnRKKXGoSjZdSLXw05BMa9aa6eNkUlLhC4yEsEZngg4pRvkMed81X9b7VSww99uSV1YgrYxm4ikQmvxWhTU4X77YM7ZgX4IXtYu7qMNcIl5BR2EZzCT38VAV5Wb3LCJ8JoUOzsUW/UkYxbXsrBHuo+KRQ1CTxELr/qdl48mnq/fKOowHcByQH1tJunP+SjggrRx/0pFfU5NYkANphlDFHKCukf8UQgiok9zIrp8C6Hf7eAyFinLFlUP86reze6DJqCIqng8YcB8v1zOYRMvQrWzVnE0lHpuA42AgahZ5TvHhin/SsR86cLHCnYszFDLkBcLXitIvUhXRNKYoFDx7PzSsMd0VVtErOo/sztfR5Y1NKXPWDrIzD28BBA6biKbvvd/T3AGx6s2apWUo0ry+K58+jjWS8zrP1cgs669gSVcXqJcPKB7Z5FPTDmBbgsxAFAytVaA4rvmu2CR/Z+De1rEBuGAHF1tUiX2LnUGdIYjHAKc6ltaM/YgrbEzj9qvQXSQWZwER8C1raz6nhvAOoS+sAh4MvXHcx3KJYaDdmVvxDLEmvojWhZseQqvC3TQFB2+/XtENGpDomR7AVYBj6BpZ28iRnVPUasDqgzBOtMBLjZ4IAmOSerxY3d6PsASK4jm4SnPN8moYO/yYSyhd7317AyiqiYcHisReqteSSs2LbRvnu0vbeP0W0xZcAJEEMg0XMaztpgr5oOSJHeVilOYj1FiY3Kfh1OjvFXbtEGXk8A+Tu2QE2/XNeRr7XE8/SiEx93X95j+8czIm6eiOIBAuidA58gwPVin2Ed+Af2xLboYBB8TAmn5xlij9EVzvC2DdoWMlvxFajNyeS3Hc3ofFBvCqK3t8IakUtdQUWsOj83DtUdKnZXxcOWLOYw8JEbqolqtKbaGfZESHwIY/tE8hpJpwHtBpO0h9GZjccExA1nbeCQkieLRCJ63YOMHSJPvAj/iJEOoM50ZXBlw18KyWFhHf2gOdi9+p+dQJjz4953yjyDRk9nfTokUdKR22ObBdMioDwP8HPp64HqSNcJz9bGL+cLdRFKJAiaRRglibryA19WHKGA6eLDc5oaAFcKELmET1e1efrMSvUP2XEFBasP0Fw84AEc8P7BuOteI5VMXzwv+/r3pe8IG/fSmhNA1UK8/46nflpJM3yLtwxw6PT1qzw03IPEKZkN/Qr+EGaO4kN57R65COFZaSAZJ4n/VfgrzCd1Sl5rlPlgC+PumdpMDJpgSBaZSjANF2ie/Fmtm/rl+OKjtsB6arOeD2qCF1PG+5IvY778JZ6pwoM6s44BgGYET9QfuPtqOPYygX0Ij3ZQOde9g+f/Y/p0c/JOYBk0fo/yAnCBvwi6qGTWyFhVYw2+/BPQtMAr56YIsQStXLqQu9xKGaUmns7RlnH/ScM9Zu5NteRUMPkm4u7Ix/9a9vPn97/kMKg4ZbE1Ro1NRL17YNVZ5uRmxUhMDzsCyzu6RsIvbZfMQ3m9/WkhxYESrAb6k5iv1GmfUvWnvtJqqZxbBhyPqA6GeiKpADhhsnOIJagAgN3vH46sQNaK3seiMGH8BAQX/fTTHMycBsqTXXaGVZePXZ3Lv+jeIP4bybjPuHD0sEq6YURfHV5bNtaJLdUj3JVJ75fMrg49ICiGQfoLckxK9n+OpRNdIK1zKHzlVMiW0LWnyjGRAbTJOUp4bUjILBBHtVJWxTvZbBBKSGzZijT37f3Fcp+InYr+jWVR/y3G8IwLFfGiqkbqcoKsM+UtMC/mFjPhB/SaYIHBfueJ50CQYXbgJpkGLaxCOTIBaqum5VJuX1pCOyuzA/8SMuDk0JaYJeNkV71gRsSly144AzGCWR/9uKzhR6Rw6yw0jA7ouEJyyN0J2c6BU31leWRfbrN0PnwYG4WFIPVHrPSbo2Tg9b0fiqFTJ1m///BbT10ZwE8tZ5JAho19DMcHmcWOI2pAmW7PhPRWBPyPqjRZz1Y82emZUpUbec6TsvNsTT560WBVq+K6B1k+HiqBI3un5K3o22a6SYrSgS0jRwsVhXA6+ceFup4lYnHFaXc23LRLscq4vBk9O5FpDgPNEILSV+Ti2mcy42Q4UhbulhLMpkrU5g9WvH5TEptQx7rRWzElgiaKKZQGRzudJk5C2CtqPmxUM9L+PS+lwwZLpiV2mwVZU4aNYpUWz7CZ/MdhpeuKFcKq6AuYEVrQZlfMal8lEQcmtWRFkbhW+iYwvv7Nni6MZQyni9WE7BCqc647EW6pZPzdOUckaasqL182j2RH7DL5Wcgls4cfXF+Ar4PgGRqyf/RoMOOE0tEhdJ+8U9GeSKXF6FzWke21Hwu1W9/N3PNMtkUYbJW1eabl0dx10ZU3BRwSmV/pVEn+KgKJ9ojxRMLzTXbFzH/c8fy/MhKNGrKR8+uOqVclLrAmYlfzXql6FlUcdtanMFS7lWpYZOv1fSsRF+W/o5E5pLeL+aUG6+oMVO8ufajxF38LGM87V1sUC1l/OJeT2tENMLkOjwO1+Z3q81HBDYomzvPt5eAbEvB9P5y5XZA7a393KqXV+2mZ5GCAR0BxzfOMeKKnOg81pJe5w2pYl3cDiB2WLgzOZjC+dK7/7WThUYC/1ryvsOb74BqYg7fjse/ihs9+B6ZRVMQLQTGctMd6wMulBmCEBYhITDfu3TKtiT0+D4jVHmOiRvych/yzSaFnZu/w5DJsSqVNm0cXY/UUR6RtfhlY50f74gWo88CSo66iQYIOKZYjkaAAUrZ6lLMqzcA2dXF8JhKH9xowg43XU4Ju3g/4dcOQDkJyO+Ybi+EvF03XSfnuOm/QgWkXvByqR3aYzdbr8X5k0AY3QdefqVfjR2H/N8j2eBSIIL00ivBrOIKV+bOgya9EL3VanS6p4iWT0mV4eya16zSlcSx0QclqWeirYCw5xEK68FGxW2+Gwuvw1/rDRRYz8JY8xIPkDtV6uO2r9OjIEullQkVZ4Y/I2oh9EMznD9HwGYW69aM7HBdVxh+RRxjiRSKcFDxEWOwrp9t+TT3lNiSc1+BAveHAt0AGVGPZcDY0XLWVhB2+L9DOBvugNZIq6GPYKj36WmfqApiasc/RTGcOqGQR+j2M4XBaoWa/MKaLYPvwl8ERxrWOG63TnTamCW9ZL77bIzqzHBX5JEAROrDfbYU+Eodl0yBzznGB9VkRgbMIM7I66usgZJpSy7A6Rdcfa7NHBnYPsSE0UgQ4nfT94SAAgzCZWVUzLPss8qOH8vt1m4yub+nYBF0sECvlsbWWyK5SnQFyq6ZDf8QuIlmiYRaoUBloY+xcUYDGOXYMqNi5+4FsOtk9XLD40Z+1xxbJy+/IZt+0iZUZ20k6hOWojQh8IS3402HqWd3NJRbsuAQYfUpGTEp+MuuhRAl4dbOUO8TSwL0I7NJSQ9kBHPXKo+5x+Sj8IUEOc8WuGmsS1VsKD+dXYu/UbiSm8FsAbH7k/9lCF54C+0t111seIxRZ/LN0R7TbJKIPnzQBtnEUslfwouZJA2I6NwnGoaAaplZkU/DffFhOkJjdnF95GEC/vYGfDfxHQvG0DWUQuRMJv+3yw4HWhlFA+t8M61ira26w1uJFdDC9o0nwA+vOUZZEugvxPQ3iS3PxbyRGLAM3WdwpayRgu+lrk7YatDemuV/sy9z9jIi+aLjeX9Mt0HlN+RwmCLyH28oDO6i+pyr2ze/LILZAHNRCzurRkl83NLNSrT/x2d/T+uoCh/+5btZanY+t/94yT01fn1oKfyI3GEpWDvzpPv1/ZIYYmyMJ32MTUlcN6mnc3xuoznQlNhHNari6JWZiF38OZRyAjMuekRKQ3C3600sgdvpzF2fzwaLFCwmq0T9yr+HRWOTAqTrS4VBTTgk0a41ckkcdfSvB0UlvnFHpEz0sS3oKUzXWHb+TLpMVyIkWfohLhsoLZi60Eg56CtVp93WSkebKEQOegbLczwYBLQ7bGAG+Ts/9QYcmleqVpJRtkUe+7kwG2sGURRMQ75NdK+C8RWVJ/mjtRv+apOFMPQToG+QyBXPA++lNQjRGSnjAG0TlgqC2g8YT66jKdSuTkMkLI1icoJRjJm/xxo1JBWhgwbIUzgu7zHRzTivV5LsTv96Zgdu/JVxQNH/Ep8JvZahAMQV869wUeWw8pDcj8i1r7GXJlJmNQWusszGDVgjDfoKZ8coEjOJLqNddnr7h4OS88SSOeBvR6Onp1q0H94NsOE64InX+qg0LjxvhfxRV9e2qpgXGswhqNQV4z92ByR6S72op2hM1e8owNoCQ88x516tAUUHUZC7YP6TeuuypylFYyAUoLyJSKpYgLBPFxUDZAiD6vvhN2c03OkJuZTx50bbCtOwC7OMr9R6j4AeIUZu70Ti55tC0qPotWfOr/4aXl2W7Qp4uTUScd2UBMWiDtPthJ5MzLYZWzNHP/QHq4rAJvuol0Anq05fXIBAKU9pzGJj9n+pLoHRg3jslRen1eifAO45HplPb3p9+2alzUr4hjh9ONQb/QOhqcc5ahVQHUMj2qCpCEO3o9CK7kZZ52crLP8BNHEzBjLs9T5Hfss4mwBfJxRHJrBbtD7wR4dopEIwnDF7vryqWguLmwCnTtuOI/6Yj5gY3zsbx4G1V2rCi95rJa1tI3+Q2sJexAKyK9Or9UTau1BhROg+sBzEkYD09ski4LEvL6RvW73E79+ctu22QatDHA983ULV4xLfVP/ETHXDAT1/wyfPRryHsb2TGKNOnLWRMekPs+mCIZK09KCvS44bj3KwB/+53zyXMYNlOyKIVTe0dGjd4wRyJkV9iT3hxA8EDmcgy+jztYSegxnn8TfQo5PoLcvJCooTkYVGNEgna1sgAXV3BUAEmp0evIOioFH+P8mp1tUnFiuOodHJ4cCYPsz/Y73kULuHDwfGbKv1bpa6B5ABdmWVB9bX4ZuxN9vEf/+zUY+CunEMQdEIN+6xrns2ySXBQLUEfWpXdrLCxs09kWNMx1oYyBt7EiINxt9lhDvHvv8Tmez4azMLC4CHTEoIXHbkTKs1u3sGVrQZis2/gNs6vbuUIVwZPilkwJkqUN1ymZB8cxYsaA/3+Uij9oxqHvcrejh5idit2WlSbDPKqlqCfYM52msM4AwtiEenqqcSpRKNh52OnwXelrQB4iA6+8OUJPqRI2nW71mzm+Db79sTclbNxbr6LA8K2w71zPnnqyOaNFGPzTTf7J0/8owMm55SC+cNFcrs14wqjWffMkehvutci6im5TUTVjg77MEnDBm7qrYMA4eBR63NA6k19wlz3IoxfSgeE0z+befpldeCsXcqmRqtyTnT5KqvP+X8NxlXeWvfkdVpKKD900FCgGZ2epvdnQWhypBb235TgmEnomUiXCNctF8upgHbZst6P1BDwPWGZb9OZqGSV5u4V4p1WFLiLM86IQGQMvh9KI3SGoadI6nREaAd7ZtOKqOZinHketRPK+IFCcDoj7n4bhc8KYNE6JRktetVkmBfgltH5agpMYKhQ0e7Vunb0XWltzjG8KB/34qLYiZA9H5r2w3yNAqI6ARCrfWzze+Zyw9YnbWMOXLwyngrGTdUxe3MxUKKeK/GqlQ/HNqMdPm7kaARESwv2t6/puUXrfQ7UEgG1XbyQP1qWr0a6cF4SfXK5ozqKueCQ525itHjOpQV/Vo8arrQ0pvpiR8kTWwn2+aRhv9pIAcqmNObzIYSnV7kNA2UJykeKpYC9rq6ixdYHsweQVcCIzI6/fxFEfKfAiBC5CH5ygLROdxSsFTrZoGhhZPTYNNxTW4Z3T1Q6wMq5RxFjMgCk9/ph59Tl1Uj99KSJElNYA/wqbQ5b88A+ShzKahrdfDXZizoelNGne/k7zaY8iUlNkuGzhL1YNczSr6kHGu4SssFwC2G+/WZ7Qiyi5BCt6bD9t4986cCx2N86pidr5AndjqPadEtxPu6E4I2gEmpqAD2jQhaHprQOOnh4ETgzyVxnf/C3KVT1fPzmOkUeTUCMrZBHUAbe6YgJIp9RgdFZsvPWkTtfkptNbupxYC+jR35GE7mu9r6fgdQhGk4oCFLv+fl7SjPJ1oU/2k0wUTFlABhgCfBVy43Miz0NOnQWUbd74BjJJBgZvQ9Y3BP3qEHQjeDMAxqtMLQmLH59ZOYMl01uyVfbPZV6ONTYKDOnqcyxTif3vID3+5SfjlgkF77uLOmuFEQpGdtMUAIUlh9lyqWvPOD9MjqoyGTG6ReXGYClzR9g8n++qa+ZWjh+e0ucWBOqUmelic4zgX4Ct1y9Cfw0oLqfeTccOHFNTZG1Ij9vgzRYINFp2Pzf5CYZIMqweU70AXDv5GtwXQHdc36LQ9xnA8Pa3dKT1MlyTMY0Yx4ayT5i2iLPPoCUVxqZVlE0b87hd64Y96wjKlL1AelSdIpMsF2dems+Kn5EtuhnYPPU7I6Cfe1qnqxCfYSO/0AB6ERG4PzOW4TUXszIf0tqqZbCHVkRKJZVSSIVIPjr7rejizsZj4lukeNXocaJ755kBVCF25E4RAKdttf02dcHLELwqr94jZiwEmbDwisy4P426lpkSbCPEh+wjCWvpk5jOxDk+/nBIkCbhB6CoYbDWY4Vatwq+pfdP2am+5otw7PEbnjzkXP9ePvtylAHBn31hG6YlbTagKBsbjezo7xAUOPrPsLPSTWWi16YH+pGZsgf0uPjSHjj1o5/79Nk+gHB5frG6NsXaoMG6vwEOtD+yK7Jr8LdCv2eRm45ECilc9mQWzsZXnqgY0oDwa8U4Ite2c8FBoxzSSc5lswTPBMMCQKzSiYn1YIuPYAbEXUs7cl8E1DFl0nXdNXnnVegX6g428fbSFDWMxBu4qiArK/f+3ywrEXHA3hPaEvW+im3YuEM+Cn66vRNqH0skYPIr+hsXu3dykCaHW7M0OaY1Q+Xr+fpNu7Br108W0ICEV72Sygj31/3l37oIBwA+gJ27WtjpNs+ERWweK9N+UoUrI2xH6hFxOh0bfMkVOXE0mbQOK37HTQ/xPyDOoOTvQAJ6j5fqiEnvCvAXCHLpxtQDrufLkwk0/8KroQ350YMUX/0A/UhQmLSZ5PDXwnzUKr+dsTDePxY526gte1c3IJoE3sZtP09VWLGSYB1qGDjIQ2zL7zIvRCYjJ+u1yob5VG1WR/QBXUGKon6cRfCMCq1Xyu0uNa+7IdAtPhctuxvOyC575xp/UYOiWB9XGpGsOktzKakO8b9hBsR6sTuaKZIhKg1wHIVmO0Z48vOF6ckWRS3jU4DQdHvcp9qO9g24xRVN8GfeiXHyjG4vBBJpmssaYvSTn/vdWXCCdMaoeBUFH7Uy/OlJPSb8SGS9egqm2tG4VSQEh4vhXKnehlWOYbQ4B1s3/Hu+/Bm15eTPbo74HjRqqVzMBUfhwJ+7DyODJ7/Ww+2Ks0PDXs9TU5lFTXLiniImx8oNtLALFKAaAH1srapACMr4jFohUsG68+XYgbN0cY3LVVV8T1ed0C92yrbfJqRYsj/li2DoIaiQk+VX/W3zt7trQo/bY33Za5zy4cuDJSKaC11yuAb/8hUcKPF7yKjOeRStbn0p28xgvH6omTpbwJ429Yj9Sv0AKkXKXB5azLU/uJ3etFFeauz6PHJjuB9hewg2KhIauTMZxml4fUOXwQQeWP/lN/XxNPvdCnCmLhlplJDaMtZ0bX6xGLheqyqZhgYcTPk5tf2C/BYnsf6ep2saQrNcxpvQOHvpqOHJv12HuVBSLdhkDkuxt9OluEqr/eupcpmJLXFDJEOwVHe0G9gVEVPK1BxftdIiDHpMrxyDfnQzkfTgsNIb9KNPjLZqmXwpwRaNmSO147ynkw7ptp56xXto1CbXhZSG+XyXypKVREdMynM/7EVp3NThIBK1wPyu42JQuWUWFrae079EgRyBHRXeweFsVTur4os20LyPcX2+Sd3mI1/q7bFjeqE+C2cbZhqzS1gOuMeK2+nKRGE6hs3TQzfURaLva9lff1vpIr01D4scp0oXtiJNwn7994E34xdhgNILucwUGScMjH/qYecT+wl/0LkoXXIp2P2y4BXOwwD8imhZ/8YFqZVRHI18jFrAUmj+KcNIqHc4SLvEtC18SKof3XmXyTdTbXkRCGCPT3eGK0NGVo0g9rHMaK+KxWEc58tSxGcKjJOb34GhtmVPuX5nl0/vo08LtcvH3BHiriWh3ln41Y6xQTjqJQ5kMg+ohNmSqVkArZG35hQCWOjNP0oXHnwkxBX7QtMw8jDKmXFF5DyUBi8CM8I8OwgOSYoidIpjnxqMSQotx8QRaBqEgtb51krAmEhfFep2hq/WHRJmdzlu0/HrN6nORPHVx1As1IhazLV4eKXgy81t3Zid2yQtccBhI94zCx26Dc+9KSOjP6on4t/HZN2gB4pltlStLB8vpbAxrb9xk1Wu1j3QaBT9iu0lOFMlRiF60cedL+KbL4Ngx5uO5BneF/3A+JkDvMgHNbeqsGulz1YZDwyP3gwUl9BWD7kK74i2DfXrMwzfBwBfbBG5n4pZkN5xuqYMtDEfLtbQfZxzt/4wozhs1qXEWM1uq9cAaL/PUNQGKvvsUrNwoJ/opB/b8pY33le3ENLlV8n1QL9Lfw5g2zVLB4sUjW4iP33LXWUN2mW51fyJa+Ggd61+ihYGP9hp/EmNnNRu8qxtEhFUu5EqYYPXR2FeOHyY6Cwu3/KS/89PAv1bMUaJVMHg9dsu8EqIVOPLB1DriPvegIEWlSwKSrvGyvvpRLkzYnz4kGDXltAlsiYuVP2t9eaoAAFrEuvfskY2jD/nDQolYgJMImfz81WIoP8dGGDQkea8fNxNDOyFjItlRVAJMQwhfFRArZt5uFfUSwEbM0tvwcuaO+e2ruccIxwnxYyayZhJKE5FaP7KM5iE2gLrS7qVRiVITcqZs7D53cwvR0iZJIXDw/+2sXKB0LRxRoq1sX+2IGP+odLaT+WDRgOKoFRgGa8qzPxh1kLDFBIcC64bl2tLYhb/u+cy1uLoyMsiPe8RwcRHegYyb0AEN0bsAXpcHPFjocVuHMpDmMJhrh8yHMiNZ1rWIB3YLRj47HDS7yxvchcVTv6wnpwIj7YkUJwB2csLPSWnjaGxP8d73qDXsRb8FgWcrELJdkrUaSiV3ynl7RtiPnwWwrrZM9fVLadj11UjqIjM3CeB41w3NNryjOLS73oVQeQcYiwlpwRcTZAHoPLhlYDSUxPbeWVCE/V+WlGES0dePAAOXHQIRQ9W5dzhEc6fZYRdfZNpb6cMOUlGxfoA6b8VujMmilJWQeqJU3uNDSnRZT4ep0IA4dI7uanI/VYeixZNO86nZiDkLeJQlwzqzz0HgfmSeFN6jQNXBtaBGZoE+Tklka6waYEmtbeO4b3ujoMLXQvZqjLKx2lIYbkze/Y+33dgb7rRIm2kpROmBhw97l0IUQqnjNXb+4LuhKBm7iMowdcCx6J2sMNxk/6fq5MJFhxFVi0hvYmHntMnLBeK+xbklheufwJQCItuH7mRrw3Es5x00g2olnhCry+CXVZcq1mqlsZ9Hc3mHM1SNrDhxZpR6eFhYUZ9/GyQPCodon8kt0gy/5RKeQKh55WFEQdks1qGYTUx4so2G7scgRRv8jUf4AfZZTB9lHB9ebRI8UwlIg10qPaaMBsP5UpiByjv0LA322HrIZfvkp7ZbM22quUpSkd5VtvjPOduMMTzc1bTL+8YTy0M5o/wHrIPtzu080X5W6AyEVNOCcgZEAYf+T0PxTkNWT/Y9DlfJZbIAVhE65/qaUU7j9283Zcflbk4kRqbL/4qycHaDGmIFvDBtnI/zzq++pdlx5Ip6FdB+G6ADmOh3Pc0R5ZGULije1u6wAjM9uPes+jiutlu+d1Z4Z55Mc7Wh9RjXzlYsmLbWb1MAGs8vyPVMzcS43A5dbh8CUA5hor9Ea4RwcUL6suT9qKA750exJMK7n9JmXDtqr9ki9tX8eVV7RVSXLbkW+6zZJSEtRulgzTnjHGzTvd2gyLt518hFttH3Q+jUZyjcuEUU2yLC8Jq8yavieDfLemUGuRKs5MwuIqiTNfbDe8V+DY4yqfPsHN5ZCp9cVG5kz3p7Cjj+JiD3dYHgKAQOcR9nZTc+Mg2dRAKN9iEEGYvrjWooZCERFjQu9y80XN5GFsVNiytFOJDIVBwKXmA4dreoeonsNRh5+sombrDxqz2M+PhaCAunN8tAxvaWhRgwKSrkLr5Wt5gwbbFqGCQ/jWRf5NuW0UfSe5tNwkJCJTmOKm5KFnCXXQILqYCJELspcCvXMkzEj/bFtdOjkLeFlSbqgfvxHMGiGUdoQE/iPCVSc0IKUs7kJQa6UhNFGYfilaR2fpxyIZZDGkgLH4hS4yfcSPJTqXtpLmm07qhwi95jLhQUVnE4C6RkMibej5nOjm5HedfanOHAhKWMBWAGpWsI5HaG71oPNV1/6oWOyZg2LE9rFpHog4+Ayn/qxLy+3SvdsFVhaRFr3CQRddlh+VzNWxxEjJyLqhNAEthtVzCcAxsvRslxRFQhgT1Fz5H7HTMe280qd+vOUqamWo/k/2G8gwKRsSleN3dzASUD3K4xs511SbsbrHflG4/3k+CyGuNxRO9nmNl6Vk5I6er01y59e2EBvYp5RBGMKtdfH/24K+PVdemoKcqH4eKrJQKIY6aKeVlTzWTDz1FL/r9gNMkLIBJbKq25/SC6kC4rqu6eZvfRzuKQ4Nz6xfr16v/vlSMPGHOl1c5j9HRFrJdAkZ8A6ziKUP9JUj/fPZP3XCQdS8JETkvl903uQT58c/cncr353ZP0LMwT7+NWK/5DRLt6yBwGI/DA/CUkUsiIVxkfirnMKJ2Abce4FNqOcSW6mmBKFbbLVr6Bu2393FpoRbj19lVxunpyB+KC5+y+7UJKsXescvgauAXSj4bXRV6ii31soxubvM7lvFm0KQJzlIAspEnoO7cIufP8tqbB5rhs/HmA9hVt7YlxOIOzFnB7vlkPdqzoXh/dYMzHkgICdq20VJuXBAPNc00pK8LgM1HV+2sEdikL78etHRr+L+Ny9kp/vOoaDNxc5HH6SjwDPuWFLhCxNlTtz0yaAmt9G+MWAf6pPzkmSqzL18A5Yq/t9UDuBjMUtOqB0yAOeHnlY38ZbEj0J+Knh7ooXECmK0CUI1/OQEk6ZflmGc4pvThiQVh/GoorX7dWJ8AqByugRDcgC1kEqtZtLig1RrQb0Y+LsTCwRl2aJ2RQ0EjEqeDCSeVaawICVoU4/gdw0BXsR/1BH9ognP6NKpoVH7J7GlUYkuK8Qb4F/NDpSX73yi6hX3qp26mVvev2WMVnjZE86e+0qkogv3smXY9ij/mF1CAAfbLtS6tRLN/P/+imoOi+zdn/bwjBieG86kmq1nmw4AmfyDNknXz1z4Ne9hikOiY65WUS9Io2XoJnmU5MxOoea4Gyf4GKqVG7PUd63etwiEPgIYaAV/nOhqqhAVtFNuEGp+MCbsmpn/vyXtEwgMXWgmrED2jmZWSRe0azWeyVDnd3I7uEyepyIQdlqpB6W6orB4FNS0EAmIV3M5fUzp51oVsCAPJQt6+W+u9JHufe8uwHgdvv1LNHcqLtYLOMcYvDHNXpouu5+CwDbWsPUMUGwBG2o1OEouo9TF1NvqtluxCtTcBrgHA2/rXX9Foz8m7gVsa005ZT+UFd20E+Y36xcPl0auePJzkM5dzD5cl2j2HSz0ordL15222sna90US4cgUSpe/imeHC9fNIE0+OW5hHrcP/VeZLEDO/C8VL4e7tHa+I88Mmmdn5KBbxsMAGUZbRlaiow6IVelpBgzrv7eimvtivTt8ZaLmP1ruWn3vLzLa0VzxQ1iKyR6bEDKXfd80Bn26vNm7HjqE8M2mri7zAAUem2l8Ut4fXZk6ps4qKpyoFTxqMmTPonSgde+gpOnvYEquXuZV2txCygkYL9b51XjWNImmgLqgZnBrbFAbLxNeVf8lzw5fV6yv6An4tvlkVF/bbiGM1YD5x7IvoPm7PXlDaPJXimL6zJytY4aeAmN2DfG7QsYjR7S0tWuyohCzDxEsZr+vBysCjNG6PeSCIPFJJRvJmJQQ5EWco4IV6b4u7V/bpCjWT0AFGuEoGaQTldN5gbeyQhHzqGIL9YyFrn76NWarml9OY92tItNGH/GdWOUR4Q4kp6+ZWXQkXa3t6YWz8A+bxDzamuWdKak6QOFdMO/Pcmc9AZJFVnYzdiu5AXYyyUDE1zfuQM1EGSqIqTpwvQowkBfKNTpvf4+CdJF8ALYv96w2dkZd5Zw95GD8swAkYAnOL+osGZeKi4nKG27NT5s6ZgmXhzgLihNMGwG/mt/RGeg5n+Jx6k2x/XtBQOPMgTMJs0jzp9i4rgojI1lgqndBCHeKbZi6By0NmdYpa3qQmlKya+uf/HVQCL9RmwGCToVh5itS/uHhKooq32SIgYXw22B/1asqlXPyaho6UOdI9P7busc7JMJEfLeHYXCj7lVkSw+JBR4E6TAku9rbI8VO1aIW0PFBIDUpTYVr/8Zu61d3d/VxoJPFOxONCnRMpkRYSHSQubkjqpHgBnX11b96ak9eggsPpEPh76OwffNI8l5iR/A9n6QuLr/NQKKf4sC4VQgtSlEPSO8RSGMiSYYDAs/eZtQkl/Fyo7Uhq2b4wL3ELXdM6s57AE6WFySkA4MMFoqcwFOUomXWp47RsDngukSN89YkcmDn7u8Hr+IO8iskrfv0qW0umgnc6wpReVDHDSYnYafQaGEIA/l0sKIUcptb7PLikC6Ai7aGjgUFymt8vSN1AQYvSxjJAXbDwiOplT5zglqSToHh2bRcrHBLNr7OeJncu0SWHGCaDwSaOaONyhIMl1ZlihKuoUyEelwinRfEX5INfgLCefpVNVwrvpWcPcnfY3uBVVQevJyZyWcuLB2l0FMOQQLqHfyxWftQxH0yYrh4zBn82LtqBZvyxHZZY+5P3FLSkbRrF/z5DQxz/wAFBG0YF9ArR49rHeBWAudKuPLIM5SvFYonOc7IWn5ejzLpcbIpMQlnO0EXxJWl2VxkQ9PeWmLlyOdS6ThFMw581rxNcxuGfUKGJKmQHZRZ9lP6xOCYg6CbpHDDcU2vKUptx21NHuehAe1fSEk9Q+8RCv+WmUmnJUqEwcgqg/frL4/CpamnTbtlO6qk/9yp6WxLH5YN+1X6pLNOfSv1vRdqKzy4Twoi6+gnpXSJKwizrnqr8y2xcnQuoyFlG1Jo5cXH/blDDbrtlJmWJlT8byE+yeA5bGPJQplG6iZFnoElg+LtZDYRd2Vx4cO5XKUvNTbRVX/Ve/tm2cHccmI923wAlVaWfKWXkeDwtdPdbZpU+j0aFDKlamgcsCUOAVV99SuCH/9PQykS0qX1YH+gSVDZfdbNJ8hSp7XXzTV1Mpdw9ulJFhS2izW5Utu1h5oy8auEp/HBZ+TPHbLnOxEo7bpzUEn30ruEavw1aP6u1VhI0e87ksj5QXPEKcRpsT3hvpJgleXAFyGpTksod9zbyEgwyluRjAZ4kVNP9L+/Z46E/YfdkXQDjzlUTD/ZoPoBkmRLNoZe2kVR53P0hsXb1KptqhQSngZmwsYpU1UPtrtjeSUbOObq8gYMh94GzvQITZ7MwzL/cu7oI8Udv8rPUcIJZpJYTvJPpCQMYQP1EFwulK19Ens8EO8UcfpjToPC8ELjjsLTqtbqKbsaIm72FW8910RQ5JW8ohSRStSASGfszjnflq6i53G/zjS8PUk6aIELzwjw2fw+8S7fx9i7j3Du07XXrN0d0poC6qD1nFK2itIVRghXEUkorZQC9h34NBaTi4x6U0bi9GTod1gLs/ItmZtVJM294wkHQjtd+Z4E9tLvUgudrcbPxeTeiY3kh9H7C4Ny43GSXnQzeZggsyip7vG7ZU4vzwwF9tTPjHKTtvwNWQJm5pYsVyfbBU7iiFlY7obztHON9hXmT4sMO2dSCwrKTh+GhofzVrH72OAa3iGMaNoaEUIhwCP+/14dhhxxTDqHN1wrGXX3XLyN67EW2NarZRxgQ1lBg6EJjBez9GQURTtk93Ujbbxb/2vZnTtmhxHmBq+C1QBEKDvKhLLiRTtNnWxcCmLj27fPMSDmajvAZ7lKyP6E74mwjZyZk+ZNLCZYi5ceiWgj06Vsz13BlRRULZK6KXBucVjvlhJKdzRu4CKD7VhVhsFplk5vAomrMMVinViko1fTKrjrpId+E5iBps/q3El7o0ML+8sbYAf7RIfBXw/ZfHt3v2mdF2FoY4+Dg70zS1pBI6ScgENzYG3y97qtZDm/2sp4ZmwYV1b/D7qtkuMY8be+xKK1xTLqLXC8WlhCypoA0EhjtVnVlxa2DWlvykXiBUBsA6XqdRn6xXz5iAfUWpHjhabOji9VuHa1zwF6bpmJn3VkEnsFaw1IElxqN5+YrceCD6LUWg0Z+2stOoGXoGRBUieykxx72TPTMqDtsCDskmcLgLd+LfVUZItdVC8OhP0DKV6UQUHMk1RSSq0yfGrWfcrOPgI/oEuf1ms+3wjUyEsoWP6kifqQvH+vuXOJhPMN0gqjwEme3nFwdmLQNIG+ZUj+yauErmaD4LTY6f+0tp/Pz4PbWdSml3pFREjs5ROE4WQY/4Oxp6E/PCZwtGkhGEsU9uvJypnQZ/TzW0GFqpkkh7PDNLCpB8B/4UDVZJHRv2JhCOsQbA8t1j/6q9LxdRK2FwhqLShH7Uif/SvvVtRnlh40JTFeSBOQUAht4sB9SwMA6YQYoyiY/brPLEC5viZJFvGSpUHJ9kv0sFTJkGsXLmc8mrqaTv69bokKsizDEq8H3jtwfC8O2t8JE2DvhQkLNHWy9gz0JVnIFS8U4q6eRpLzWZfOtOXQEqcbphkh1AUoc9AALvyRNgGfhP8azLpv4XMXj6E9ApV9uNea1k45MgPm5VyZu46OV2nelodAxtV0DXkyzcI0ahdJIzBXnMdOqbwTW+wNHvl9SBv0RURUVDUTK+MRZ7Uy9+l7OZUBtRDyhH19Q2QE5Pf+Q5v+WSvtpR6yTPTGM4nuZDi9ZSorHvllG1MmS4ScPO77yEry3MZwfndvpO3rVHSczuePI9qExsUOV9Gaf1vYBaBo/FLNhqyPy7+i0CgB5gOTUVt798JuYKwWcaEC2MGf1nMDt6hvJRxit91/g1vJtHxyOw4sVv1M9BvaP8t7e6pga8lcPxzc1kO+vckojNkJKIkrZ1eoCQf2Aenvd5i6WM8mmSwuEspiwvpb2pj398Ox9HDv8/fQ3wM20d41MQsivZEL4gkGTwYUKK4TATH87AZ2Dcyjd72f36Q8vAGWYefkZO238XqAKs7rRIEFM/WxgtqEqTvSOcvN7xjoM8AvJnL1hsjGSgdzRTHkGrwSJWY8oor4G0FgE13qX0nymzLrW++a5Hk9mz35y3KtC9n3b+luxc3W5KkiNeZbVgaLsKs9b/QuQXzKFdw7uyda+VW1Tpn5I9T5l+iwnBTtaoh2OPMHj8lYilxB8vd93E8hYLQ1fDLejJMsAlIeKEMxg7Gds48p7N6PLaRyfSSm63UP4GqGy3xub1GMIKDTbgZTw9B6kFxPtXuoRnjT+k3QDN1cPbi47VBLGZfWQnsQfAqkLwI6qKMoQnyPA4CrXEwU8YJLamNijAgBoT3z0iOtKbFvO5ZxadHgN3bzF3+o5A3rQ588NGpggBtfFvYJ5ST9F73BT0sGD1zwsqXZnhSyRP6Fdosjoa7Bh+VAlqO694vXKA6peVxZGYlAD9b/6RgNw+TOS9/gfgzmb8771eXxNbNqCKipz/91OHCxtrdV5b430yjbiky8mUd78JWZ1G37HmcGRALc91Vxpvsp21q6M7bPWySP23kTLfgo7P1AoAWA9XzQB0/IDYRcbyd2/58QKcnPpysneVTVjELBduf2YXW3ToI4z+1e+Y0eI5x8HPAQ805pS0tU4v/8kHduNHlSO4VNOnr03OGnLkDjeIvF4ku2wu/1t/BpcD/wpoxZoCB2FFAaFzzM/ngZNF7MjH1vInXz6plvYqTMRQR3a/Bjo2/jP3Wi3ftzKZT02og2EFFr7sDOpHXgjMxTqJqZzVJXmXrxeGePWi5KRUKeWicq1JOBKZHP/Prvok7tGH935Tf/nQ9qs0IAVKC4UOvP+e+hYVu2Kahrb1A2bwYPDbV83xWDsy0FXW8vmG/VfEnQE23p81VKRoYxj196WBFAke/JtKnLp6WaYcuWtsbAFy55orhEW1gFW4vSklXHvsblgZEzqm7xkfmKKdUKbZivkD2M3Fe+WCF32sfwjs0JIMoZJCWWy2EO/krTpY1kxaAbOS1ACL+19u2ps4d0EckFRGE0+UoYeYxeXXIENrARxY7RmGEhOnK8EPxRxJM9Ok01ZLGLkPgg6zPtGXw5HhO0bqtGNzU1RbpikdS/YLe6eItRc3QKBjNlpBt7pQ7L0A4FDU7fq10bcnDiwPiQgyqNkvBvpQCf9cn0sPLLKc27mLTe3vOU9SM0JtN6MVutbD19EGWYM0cD3dnrvg4cfIi3uMvTjKNZfW/uTgcddaNDSbhFES5nNIgRUdHUp1HwnqI7WF1isQcPCT9/8Wbfb+4frtTlw9nTVOGlT3pnz65MAYlLVBkbJF+mKgaBeGlEdltOoXGiDvHkmWtudgq4saP2wQGNWI0I0TPQ6cEjLaCb3/PWjdaCy0QoGGCjKwPqSeVgsA7nnyIw7dGF/eIco5XQ1fUW9Rti5S1PWoumUQfg7g31X4HTPKVpyIKixHTWmUVZd59hCX4dmHb54CsIUUs0pzMPiqV7rLo0ZrorX5tTjwnqHiCE90z6AOepZeze2sYTNGC7qnwuAu/z3P+IgVDRwMBuBBEEBQM8nGQnd9A8r1CJTiOMxNVAW34wXk2VomSku7i1yvKmMK1xJSGUcArMoB6Vkj/VigEJw/zqydbl2zcslmS+sEib/s5RZU3idLs9vtete2ORh9urXWw/z0CyNL3hGYC1QvOOHMVNSoyq1iZHHhSHkGY9t7uDMuXOzakyCnF5Kne05SCNDMCCXjv4Hcf8WqBhrC2LzkLoz//png3J0AAfZPmahMUWar7SZk8iUPTA40jFi8IZb3Vtp6/hG4vbeXhdL6gDH59PD5mv/2QGn1Z73NIwuRKY/+6Idc9q0MlZV4iHwqjukS3d2InA+ZKvvnZd78e0i8WVdJiGMVAtQkDt98N5i0Jp/6QSpwi0heqoFu5pkSd6pV64/kD3IZM0+vSt3qhywTniymD2J3aA88yecIwD7tvzwix+qq/8/jYnnzLbKuLAdCkvzKgZ9NyR2cwDkMVjxL7k5f5wcXDtdzM0HEYSWqKX23iq8TLCn4EolmVI2FAnhgAT98rLZUNiN3a8xuWONKDAwC6EXsnUX2Z4Be7TmQX5YNCIRewKcEgCB/Rfb3WHd/+aPLRGFdNWCd90PQYnVqM4hIqDMoA1QxUD006Si13vNXvUUjthLjfL2vljxlpbz/L2K7B0DKQ+L20Z/vK3NBnGD1+GaT/5kEneVtIvXwivAH0L+qm16pzp922YnJKymPd5IZP9YApy7ZhEXH4JMpRqvQs3EbaD1g39jf50P2g2mjieQME4kpStvq42P5s/HAtixkLOfP+Vz+GS3icCq/54do/ivgDl9dpQMfbZ6sUSg7BOqucfRR/uyIOmDf998I58SjV7JIL/KOnLFxNjo5AcHMt/RRSze4M+lmmDulQaw8FV6a7gri3kO5cZoCY6Jt9hYGesJHL7s0k+AoSe3gYrI2QTAF3N3qHOKhZJX/dU+bMozEa8ThsKLqfzHFhuLXMWmaF5X7wLVVymnkrcBDtIyYKCWf4+D7QSMf2197HxR3vGHDvJXAJcqARQKIx9GNy4KwyGviM8WTsLPxcJ+w0WS1DXTdAhK4zh4xuo/t7EpFp93tLEvaG2/TINsakJG3Z64/Qo9YGbsdUhDyUmaJN6F0g/dI3Gic3ZAgJQctYfYPllLFEojjk7xemLjQ5MCwM28J4ti6L6BZ5ktEgKtzkXGMC3Ne99prBU8+I8f9TwIck9asJEb332dQ7o2o83K5AfU964HXsNQ6d0FkOLKbHpHFWMk5wJMhaX8GZmpJJ3wNWvYzyt8hRjoBMFcmiSEBCB2JdsJyRz2bFVwHiG79CQDo/CAF33cVPMma9KnmEn25GRTYItJzIDUx/Kd9p8IIERG65JO0cAsshV2gm6EWZPww7PBbUdpJ4ZEjxt4Cb6bEtkmVvUCmNub4cK4c0l0zXrDgWDMHuvMPu9QmsQrJg8+IaPY5RnR3eTC+TIeqx3ds3yKqgWm2hqSFh0WYostNeUowB9YbqB4N3i26fwoMxUyuJ5Hq4EX1UlgW67q0M9wi6mvS/ifb9qdFSOXivyT53QwbXp10/NlmvFg05usgVDv/mXOL3ZFf4XPISCGj4VvD+ewgmMdhTdZ0Y1r0epfponiI6Evh0+Mwu/RVESjovmxLEo/VlR6dPRtPw+CSxJRW+YFbfSakqPNx0cOxxtLXdQ+vu0sD3trISEkqCcwbcqvSTfGyGFmv95ps34Uj1RiZ0W6E8PBXJYzZo7oN1+IxPR89yfNUIkc9BeVsmdf3eHHLNhCy5S/l/eIOlfC9y16xqOvtN2vhgi1giqoW7w0MXXP4Lw+cBf6Ig7f0DkruxZR+D4N1qeOqXUijA76o5y6I36tAPmdJe8/17YFOm2gX2pDOpJ0fwhymN+yA5lCy6CKW0VVSUaEQe+0bWhHYOO+auNplTjJHu4Wb09NL6/uoVZs+gFov1gZulgifJmS9H9jw/rol+wj7c1axqBwyc0A55aTfmmMyN9+UOWF7+1788hhQ7Y1MqCJihdsGyMXV0twnEf8kPd/ncPr+99+23OWBOIm3LXqvZu4jQYaNLgH3tSTFgHMSMbPxF3zkEcootbAtFB5oOLVEc4zEBVYax4bOnx+QphUDIeXmcOyUmxEmPJiNNtBPpXpy4GMiZzDICkfUgMAts0d5y1Nl/60na6N65mBJpCtxX8wvyff5W8qRIHmoX0bQWjgKB6S9/LgPlbY8gXLVDgYWwBWhu6K4My8reImOWny4JLxWp7WFwcV4dLf5Iaa6yFL4ClUH2+XSwlo/EvR+Dlalb/hxPAP9De5/BO+uUT5wAu2pnH3Xmle0ms0O1J3GLJmooHYdeLZEBe5TQJuVAhF5Mocim/hoF1jMltOJZeSxLi/7H2RUAsBGD4zlbmw/gB3waY0n3ioiLqMy24gCe2PSQDcQ05Zxu4eguEozgEzsRUQGgh5jcU62niD85SgyrUDncpBBxCtWypNjm9jYxfz8iXxBulz0KYQgrzldD1lWIiYbUP3Fe9g6N9w65DZWnPwoKRjgq3HhROFerTJ7QSaN7npTX2bLUi6ClvywC+NEse9873qXhyZlSX/tHKdk9piYC+KctyLfOX1PCoGMAHECzfLsO0bsOsL5mg6bQEhL/YI16J/KeQuL0QvIXl5Tw3YgK4CT9xNl1V7a7R329VtE48jv0L445onWEfVpdl8YTgb2yGNX847r13BYfq3TumKHGAz5f6FnaOVvR3Bx2peEPtPE38Mg5nfz4585iEzEFvZV/s0UmbdH/KWXFjogDIP8QjFhSk2FawIGrZ+x0zfqKgZ6KuFuQRaFbKAyKenU93j9Mao65P0OvSaRNb4BoruDVwVzb0gr11QgTBCfV8M8UJMYNj1Ip/8maEBeUG3G7pBdAqCvnq3IAr1Sr/Yjy3AYFDjrK8FiUHeRpHuuRfRHtS0VQOgXDmFvdVTP2MJRM9w6//HrEdgS6FnCj2boVdYzTXd0L2cN87d6G8x/AIvJsn7Rk5IrsvIhkwInUCsph/re5IENlN9wV1FrOmDmjRXOWbkN0ba0g4BqWCwCdK5ZhubUpJcwpaoH2V4JpAZ8GNPRmZ2EuIlQzrvpaw1G5baaRn9gaYagXJMblHSginbt2dL5qraWK1beeQFIEZ4CH03oMq+81tje5CvHIAdxcALOm2avFq0vaDO90BRcMZwtwdRoocau2SirB1gxLJJCO8V85imk7EqlLg9ZyML9918DzRAi8EYXhf5eQTPJIMJGWW5GPm0jPRAHwD9urzMAjNSED2uaZuQBEdgH8ktL8mWqgaZI31S9JoBnPnH6+1u6JqINljpFR71e3thMRsiwn41/XfUhaLCEPhUAtvb6STCPjEVZBiqL5shQIJZWlkphlckfdwqr6V+fQ/IBLv1ZNx7GAaQ4lDPLxJDJ6+wsUWkNnYdLO3GsmyyMtMK69sGFY5E+OrDcpE7i5lN3Bw5TfAqHyQ3/N9+n9VFpCjYSNTViPwfF/Yn5WnfOUjonGZhIlb1Q/SrnQ2HrFJ52TcgVMz0joMZIElw+AemQNiNXVVMnDNjtlq8sauEw2VH/UNk9+jlyAqnt90GuFLJ0JrYe34FbXFFFFPgmIZU7NSqwGBj96BOAZDGH7VToMifVblfmdIEnSQm3xbClPwtgmi3oxcH06M50KQYvbhE/cpl2NYZe8hQSc+7PxCEsHo7EZGBJGePHZ52YCWVZm3bQ+ps57lnYR+Ti2A7iDXpbejU5Bv5qmktfYrTzkga3p8tCzp06Lnr33mxFKBI48E4xuzb/U/ABkCuqQh5kFI8du308VA16DlDDbey9dQRo66LcR6BKUrNSvcwEK8n6iNH7oB6vPpEVN+AA+bzx12hwqHGL94qkQ0APwH8INtT75Z4K2lGUgqCP1IwbP2T7IErIB4zXtMSjFfNbRmyCOuDkMKlRkLAFGPQa/nz8tK80u/Vo1nN8p1bsv+MFFcmj1+Py/xWcF4wETfEEwI/yYaRiVtL28o8dRQcPRGa1I9mkscwP4bkpWc5QpHfLRMYUQrYBFyogas/I2fPo8+SrDO8S0khoOoeqdg+knLRJhlj/HEZqYgBi5rHTieZknb4tckOcFnF9iUuu6ekkZU3Z5o9K3GANgExGMlIDkeOK1ZsdiS4SDFFZpZ74wkufJfB8Ko2E1G9yt3Z0KK5AwBpTaJefnTiLQwgwHbTExnqROOY1K4AsAWbYMu/Zd/qlntz/eWrCuqKObfIo6P/3xti2SqnQntons1tdRrYLMTxFaUlJ87N7/fU4oEuO9RhdBeaQC7rlYbv7qVYpT/YaPh28D3S0ZP+F3dZPc193u4H3sqvA9TGfK4w5CSU6ZpnRmW+qwz6b7aQopFBbGaKDljvPpEY8lHbSU6CXIG1VVqW97leOpaZBs2qrXiITk39QscY4boVOTodPKeefe90hp5ItWohciZmHBn8esN00ed8vQySThYr09m3bDddQtdITr4mzvoLvBaOSxrDQv3kpkm8UzPSf63faVzeKejE/9jOZWVAA0tZHvbDWoweSvs/CDP4jb8JjuVPqNUOmLLV/80P7tiWw3upPim20nBUPDUf9L3XVqW0ajBlzv6neGb12ZIKRP9xORKVBop0VeBwIHyhA5nOwN3aZeHynVw0MjRHXH5b5Mw5rGJjKN0Phq1V/QVMQ5vGd0RIPeffnRcFO4z/fHTtKf8liqRoqBWJSctLnN8HXVphZr0ZgGnnmumrcuoHaRtjJtshOKkD6riIOR01EqgkNzWzH3k8EXE/mw/Ihnt2VLSjvJTaNhVgMzV1VKABQzzH+hdtC0w9Uz9JTA5eyJQcfMl6XuOrDcdv++EORDEs1ZOkIFJaEovaQ5eMKy/bZVPXxfh1raTuP/eX+YKC1wnUAcb/0P39cG6pcytsq9QBo1/HNPa3UJMlsyEccF0uUvcB+qX+zY3F61FNmfdqBGDQc8vHekK/3SUSoE9HCPRneFf9O8LP2DD3HHK9GsHXkd3msXa1VU0uvjZ+kodsHD3AzeSJEWyDuKrJ/WJU+vRkYxMtlodkNkBcASyqXgAKtOhdg80xJS/Vrfo9PPmeLqKIXxIFxbYmxK6UlqZ9uZ4d1BgJFegwbqdmOhSi/TRlFvoO1/cGW8bn45CkdeiazLZpu8ZXJfoqRphTB7xYZ5MVDG400pTO133+lY9l0YlJsytTpcZoHAweiZ4wRxKVEQI+s7pvQSyh5UjGEARqeSB23ysOQHGEKqmk+X5A4Py+Sdo96UpdpYNc1NCIeAnPIAtQnXvWiH56qr3RoWCBeXtSb3YPczd2bqUu9kkrjCGeMsA7tR/JJZh0SaGO/UdRxQUMo3tMT+M8xoBXiA29AIOliEuGgqL0OBy6zcQDVPcXrgFmcLLJT58kbJspHt121strIjIeHuhEr049FuaEPUAibz60TmQXoVeumoBAjctJgXlLwbckytTPdkF1T8YXSkEDXHbEtAMJ7hlaO9k9o/8UxLEYTY0KJvhnzj7CJiWiHY9aIqyvEQUZl9+v6CuCIHKP92z+fe4gWyKHRIuiXZVfGZc42KWvsrkun8ZyamjUK39V633mXW90V6xzOs8SIYM4RtNqGBNipeNtMtss6eGFDgoxUZmJc8kUdLl/PnLQBfWIrfhNjLAo6ApYzDqOmSIGuBqn8UShTT6OGMbNlYge3mcCthDGOVDi+bC3dCULgaASm/g16Yuw+zdg0V3EgXdqnPyEcNRLAPGusyV0zbctPkQDQt67nLD2Cuv0tlthRSUeSh2ygdOw/jMofU0Sxe8G+Z7SVxcinQPd54QSn2W9PbKDsS0rWzqmtMfkLOaQ64c+YXmv9iORLWVXRPjDeZENjXndY2o0W0987UbA/EqHUhrL8PFJ8sS0eTgM9q1iQeW22zL50gKinkRqvVLFIaXIFeIziIVcukxEquVvwfVn7ccOHfId3jKQtSeHHNpxMXdZ5mlyPFHnlRYaEffF1Qvs8vMifKZXbilCPoLvAPDFWxZP8wXjEo/V1BKdJN0JFOiSn2AGlSZx9QrK8WCgAxwvtXvZHG0dE8RN6vjtyyw0xg/6Ex8Ad6Xb5E5Ky7dvqEKUdimX4er5xMhgGXS7b3e3K1+zryUMNtmgyNf1Wz8hpjovmRv3op/yw8XeFGFZWgAPTsAvf83/i1bLUQSwC5BhWym/rxWtXzJOydVRpQl0Os4kaAaHGE8wgUzAsCXhm+Ulv7rPp+yD2s9M5Iwen/4YI4GU3aXkGESu0dwbqatHgVxkxt2e2c1dsLENYjLuoZnX3Lg3RpJuZ9tK6ZUUnWgb+ogrGEcJi5qPgfl1m7dDEZbXN5GW9wbs4+WFqjkliXqgJsfnAiEMIagHf/Aeta7TdB5xOGS5aDtmNWCJhn0xinjS4YL35V7VG0FjwsCTuttl8yeX+mdkmDAhO55nZfKomugmOVRrxrf10jfMJNMMdF9TjoHAYTXuJsev9P3M9t5eRYSUP88QaFlnoWBKR1bAZRCkDCgfK8xioc27+bglQXf6Zckl9bW/z0HQUIXGHCNPxg8i33O5XNDB1B1JAQiTumL9Pf4ZuOFXxzSDq5JIBE27eId9NGHN2sG7unKIoWbK2KNzRgDzEcJAxrH/sVXxhyIWOqcZVkDHFcAqTdZHlU4haBl5Jor5BcMKKkiKFkxapIghZgetHhGqywKhOZBpx8WWinuuV4JmCnY2mui+sllcCz+dLxJFThUbmiwwN2y4LdKAXtrCdKOBrGMn/yea7s8/25iVfKSwW9ZVDVKnC/D/tGKCHIfBunBX25SuJFVZO6nKQXJt+LtwzuCNuafzo5AjRxBCRPN0UoLRZOhtjnEavaWM2j5ogmIOAyfqwfKOJxaA5WKKHc0ylFYQkCGKk3eiKrb8u74grO4VDJ1I4iWsHgz/O0RcaH5cJop7jUA/h+49RCVzO0ZgaIAV9br9/liaDDbxajGC+jKVQuDSUOmbmaHuBhAvRFpRmUZeU297ipQzt2Flk5KHuVOGCTroV5RLeVIffodGIo69i8lrw6MEbu22XhaWPyqPYBNW+QUz+gsCakdNTVgT5d3JmxtMoe6xJA28ylcDTs9C4fl8UHMpxhnQOPrhZklZGng4NOSVE+9Przxlj8iQtRGK0V0zuqmierKPJDJbDDUZerD397w9fEnQaMMwOvG11mgmvBNISuFR1xl00cYLSqLyhOpY+O0II7j2cs5rg3Fa/VfKA8TKSPCkzziPiWMshyq5lHjI5wE2n7jBTfBWMftWsgr3nZFiyg2jrTht9K0dpFjB9Xc7qd9kx2Zy/ZYZSP5v9pds3CiE9714kEktJFlw5qTnLYJIw/RPgaALmQPmXLVxuu/iYD3CS5foe1PV8z4eMOwuUdALU80GqFbE/nFzCJ1mOL6LqUEdewqd4dGsIuMucN1gZic0bkIbr3e87bAgG5tCzO1DI2CKvKlvmJp7luRS1TciW2BZB2HWt5z4yRgJ40uGaqMGGFhdR5NBTO720B+9HNOq6xMUw1JyIW3Y9ILLanxkPpdGyY2IpzsFg4Z/ZU1r/NIghJyIOlrZF7bLyLIEysXggVvtClNAgV1mjedLi+37wqM8vTyX9NciKJy8RWo1Q24SD5HcE6/Nz1whA9MelNY4d9d8r87zjM6mqam7UejTX+OlwXh27rU8t9baUrAG3Zq9kM8sgj6Dp6vabDphf1O9jIKHSyIhG0euyqlnVXxwPawaDublWKIHLCxSkRGlCtTuumKevu7izUdybHbAAhK5TPLoR5M0DX22C9opQmhChLUHNLvD85R74kKbxhnNLqTl6QZIwVT2CjTODfzwDrQUds5pnxm5mEt/ktH41O/XwV9m0Aa5xcqJ80MvYr6GA1IpyUwGnmoWuKKJUaHtQLA12zalo4kN87HeEcudf4FUKZrLQl8TFqm57uwLvgO5u35UU0EAzpoHH05eMCQiiDMa1h68V503l+pLu3QQcqnpC2IivHc1bj5iPUEdyq7saVrX28MT2XoR/ODbUN7kTDwiOEgueqk09jqDwNIYHJm99M+n5pTl99swdN8biPbZLFGWv2OjKGwxQXfxW8tXEUw3DcMvItu1Wg8cSUqjYiV8lp6yZXwIIkI2YkmtLp4lIiJfN7RPAGJgylliW5/rvwJwGWKfDKWEM7Njvg9ctRxM4my2dYbxV18gfvjlVssXOIXBpiO1o6837HlCmGs0FAouX3MseaYBX6YtNoz8Ds+QWr32RZoqCDKbm9cajKPtuJZ8g/5QuTZa1A6l9umdXKDwgKR+cZP6++TwoS15lJEP97K9j+soswIta7WUmDrGl0YZ8fzNRNDXwVMUJzVheE7bG2YVhRZQXyR2zRDI0znoe1tJSnhw2kZ/8hRTVn51f0aOfqE8vBQOi7HSPCrS/h6kughplQPOA0AEDV8tW4ihiaZLb/+crCKbATDXYIdVJRx9AH3Hf+H86MuFtRjeHloDmTGaKMbX6d/ryMI3YhLL0lCiEVJzWi9z2uX63Gy48d5wdp9xdEQP62noW50ey+zeLBo/IFMJ44qYgvjY1swRyFppVTlb8v9VnaTEpLrSKI2UgAniZmboh2kQpUBAbAE6nteQXV+huAfbMVY7xqhmSPjAID2nOoJCc34bxqMDnTbN0XAjt+PefDWKXhHB2iiMnF+VQ+gcG094nqMkN3eOF+H2cezXRTHY10XbF2mNzF1EZUngSIZf8tT8rnkFCpdM+OYyI+l+zOHBBbt0h0cRzIwgPyP16v6M5QuxmB3LwMWBxfHC+z+oc7oH5nb3Q1e+91s+yOb2R/pyPXf33v0arR3BdmR2QYBJ6biP8sictnJZaNKBbAhCOtH5wsLrgsvzwYqqnnM/WquzFBO0AiNReSgIefOx4bDWOwAAkmP8SM6u4or+Bb273aF6mCheYNH5qPhX69CNX4LUmt0BKbqwhsp181MNHNQIpTBLHzw6p5vOkAuQ99rH0zqdErsRADsX/u7jfec7oeWRMwY0yQZGwkZgbVStKslogQvKrSVgUOJKuiwwRWieHysmjwKbJMkhZbQt0J6MKKaAbPJ5VOGjDRUz5Wk5PM5aSBl5oIoc1UZ8NzMwg+7jj8qIk7J7SRiYrBB103UMUINHKVVxu2sdTYFplT6UV/cBrrgaWkjbp4M7h9M1FTnelyKKZOxGmwigBWVtdRiBlaTjVIG51T3dI+Js4iuW2uBPJr9p3XOswajYZ7+e/ae6yE8Gtqn+E6eXcoguefxjhGfcPRdBMasqIVWVoex26gGD4oZhN1tNLKWO6j7Xrnu6s8VHyU4DV9eOMXOMc0CzyF3u8KzRLMHik55OaKfffVrRsxyEx+nBvn80GzflGig4vFz9Z0khx2DF0S54yPuPRCXorSGQ5xTIq7z6ki359Is6zduhHNqti/SVE2W5z8iwaEbsm0vd+FECGXtlxAzQa+VhnHfHFBUkkU2yr3yExCdxSA4+7BcLgQF0euOSENeE6Y3BAFvcAsJrqbOw5zgkRn8ksQIQLqYXSHNsp1i5TICy/NKPtUGu5ol+nS7U9a7MkAbE+0dEjngP+zmeDvZ1x64WHGh0nES3+xVhM0hVEplInitfwvmdwit5RvuQAQXReNhmB/oaCdbVxKa3z4SrqTN0L68TTHN284pE6V+Sd9bRCPdOJsLH7ELaNr88YmGQHHd8e0NV1siHmbOtJ+MeuLpWIN8HUfyUoCMAYXA1eoVKDdluo/fzqa0rpaPLZsRuBL5eaPbDRIW6nhLhn6x1kP0En+v697QRjdcoQUzWJQe4XbZ/sq1eHjzuP8S3+2IYB3MqKfTFqTERdUsJA7rqNmFYaI1Ti2JgMD33/9c7b+PAIEBazlfXpBRT1OsEkgZAJ21GTeCqZteDVZ70xkirnNbDnjbNkAoBfz29Xrs0Edi/+bZjyLH6tvHqZpTOqLc+ZPqedSS3sxTFDOAZfRYakAWh/qljeknnLAUap1rJsXV2Iy0eYRdcKwkfReHR2QDhHZxzJjAQ/sheuvn/JjJVo9m1TDDlAB6AKT31OTe9+vB4Rho2xtqLmPfWDzonrKx4zB4xf4xsRPisntAOdaUjzZ18AiQP1jnSCS+89+yZj3WojgIZgbovzibg1yDYjU6PQ1cFYKEKsEkh3KVwVqanGYQeihoP6MwbXZd0c30ZuYF8AgWJess5PA/WrUfiMsGHOP+tm4rwxM7EaIUbJKzk6JE6RaylSlAz+ZhVd7DgXYakkyg7tqThbxl4c3QYTseJlA+dXrsN+vMg2AjlX/c9wCAyhMj46VBO8W4x9xClqOavQACiKmls3G0KT/eUv7yqEssMuPHysTJohvwUAKbNHk4pHeu8hYsqU45XpzxuldKR0WU/YfW7ruMKsb9kgix1PEnNEa+V2G8GApkMLmFX1cXUgPqrxxzac4BVBkDB9R8u0HhY8evYjhXoegvysSlzQgcwNBmawcJ5Hlxh+02amjH5ikZrxqqCvPIs2irqvFzqt0UK97v65kt1ufGle9o5VtZiYl/rrIw5A36nj8ZAdQoMtpomNyr/31jWkLqeFRTmCYENE2AslyFw+XnG4xhpdKxru2F/pzXhZbMnmaKXRGWnAhtCuAxsdPoU/LlDyAvZxL4Z6A0WRXT7pS58Pk0NhMZ6FKKRCu4IFwK/mFm8XpWKo/ZVktqQvN57Vc8GVrWW2D5dQrLyH70Qh4KTAQnYcBYQ81wBLhJ62g8Tcr3NGtdJ88VE+2WYH1QmCzNDD30lAahWvaaMhY3OejSGEMy4/zylTh9xkwvRf8VkKT/BJgi0vKokgjOCXuUfg0Ubh5NUClwB4lUAm4hD+vnK/bUXjs35jyRVbNb5VIAabTwweVHcIjHEhm/wk+j0K2KfTOMW27F9TjGNInV8y1mC0RmD3vaW7mPM+WAWQuu4EhQU2T0E9hCAaznu3sqV4k7LzAV9hfkUL6EP4u6PaNUoZxHVXd9mYLe+E3eLb3JkeJcTHRDp+8ZpRReVisrxX7e62upeNkfXY70IenxuutmUAv0DMbqffcvDLyF9SnnWb/tuJ6YRlInCEeF84dVqKXBywaKeYtjgxAJX5maDPxn6uzMF+wkJLMM2xqKjIiBYdumisGvX2oJ2Q4pY6neih9oxYyCMdRzT2qzOzBw1wTlAVLckEyITozElcmTXHfBKHDGKFt+lsNveoQDZMudRo0S7ToWHAI0wXMpcJHLN4EPJbAOKfsQe8Me94P9Q5LrAWt+cyMuaWZE1vOp/3Gr9ksrtwhbqFD3Wpl+4qCCG6m77NUnlJ+lIrW0vXr3kO6b3IbvTMCXCLrLst6Kr7TrDK0pfXiUIsmLEIV15vjgVoAhQycLu6+IVJ63Ev3R5jNoIQOTLeQB+5StZGY4tkFGrXRO0ubL71cO9Sl0H6gOPNKv7f0nhqm/uzLbbqGURJHiDvsv2dPs1tlvSOnF+8+HKUK1MGeOfP8QlvKby3q5jXlpqlGBYH7gye+qv2JnrQ6SqMVrtucaA8JXfUodwa+G4b6wvK6ib4DzgbUqhEtVfCj6vFb/l9LVRD4khZs3+awcql0RMGcye97mixwee9RZ6fAxysEWPvFXyojB0RFGiBhUrg2q4hlwd1RW1j5L2kI2mVNesuK3hywWJRtTURLnUBoiq0xmJdDJDVo+EfTPlJ82HJUyKOGiSlVMmsN6tKqFrVaFRJPQTIMSvTZCeyLpxdPPkHFiqWt7r3lSzpvczdjLhnd8ppL8deGcpQIftnpX10FjwTKiheOYuawYVm7OR3VmTTjwKoWQY4VlKaIygn3C1wFSSF988iwVqntP1XlYFyE2iupymxq/4XCTlJr9RM5eJIEm0yekCI8Ixldbndqg/hLeL19DO0U3RvRGIT3Uf0G8npPlIRnMneOnVy1hqsUe7BS7ZrJXenckyzXxjl/jwjAl7BQWrYZvD8e1nsEgZBrbQBooTVen2DjPd0bmZLDJ3Th098gpyXtarzut8WYs6np/h+zwfOqg9MwtMj8qChhYrIjWNDW3Vv1wm9ygUPEazt2ykPTJB32QB2TuhIscLN3hyMVwXol3XKoSwW4PtMcbVzyt2BbQLM18Lsgc1igmK2pdEEZHT1AycebGmpRQGY8Dw2ug/mesw4qLZ/Hii7xoFXNdxypKYoNpQoWg38XbT5z2SAQVKIUKl+pYDDZ/dR1cmqw8S8eK6GHeBPkGJCwr9LyfL3RkgPAg9AbJ82zleL0EyClwY39l2K0yRoPxHfOhQYh1XFUXbtYf9xDuGbi+KkfYvNj/I054XU6DxeFMFb3a2GOKMh1QKiAeUc1y9HVWljpkorpPim4sGkjITyT4VkJqUP8rEU6Me0Da57Bv/pm2m4FpV6ESQyAQW9uMTqIVBRSL2UcTG5j+yv2WCgKEugmnS4FUuJr7gz3pvRiHNNqy3L2EL7U02mWpIBpraMAe8oLjXZJI1SJWVIDdJIt1Ui93pqZZPkMp+z0PPE6bY/3yvXf4R+qhgJTrTBm0g3AE8xW631JE/WFAZGSiEn672liPCGw2KMdG9PpFLYNoYvSSM+0Kr3CPt73YSx6xVJMOqNGWAp0fMvegYH4Gno9EU/+E+3H/QltnxjIQpmhr8TPLfEh1sJ/sIcsACRwMv6nGm0xBkMbUE9y3IfyIqPTbk4Hk2edQrXHb++Jcl3FUZb5kMFquUkPRhBe8tb+iUryMRwbJir2UgdgkpJH6cJ9rUVYMxmm6HUOnkxLL0yqhg0TkwNJTwpn1XyW2nqLV9SX8/0toI06wt0UYKEUtt5Ke49S+SwYjGkKk3kAVFPkC2ippTmbDEXvCjbIatLrHDQVmDlZ5cIu1XABe2MJ5IL7NIx2RMCgaFXecfz3tqt0t/MA+1HxitQhBBUUFqz+uMD7COW9yfyIZPTaptvqM7wgog/GklNVXEzwF5wDOj5j05ugd9sprKDWD9hVToOuTyEM/buG9H3cwpJUynnYYp/6ia3pDD/RcJTyUN33TmjI1E1Eh4ADmgw3pxPiQQc1ceATEmqQKKjuGnP2b9Jj2iAnKgOO+dcO3TluJ99xXia6ez8OSxfyuryyLpxLerT6qsV2D74xdGnq2hHfu7X9KVx6WvtElhQfdpfrddn2H4Bazn01tWXXIkiyMgLutWqYwowmsEO9ZmxpuRZgtOiyfX8AnnmjulN9YFTDdfLbOJBsk/xOTi9njRktMujYoVdFByiOQ1eVZdu16OmGgtWa3Ce4uA/2TxX9nyYH9eWxCwe0I3FJV5NT+QrrPzdkBYtu1jestKp+FTRneemWy1ip3UOoYZhsVMJ7h1sj0d6jsWZwJQa4l0YdxkTv7nrKiHrD2hABVFWOhVGGmkMKNYT3W13zmQ9dIYCRBcR5Hcr1re3tz7768E2mNrT/ekDgIdkX2j0XR2xk1LPXMBvjWZcFP+raxe4HNC7B1Z8amPRv3p2Ncv8CHJRl6UImdTFgHnLS0afGkr74WHzly5OCXtk9V3qMUW7aFW3hA/g7SDVRNURFut1m3P4wI/Ajvb6/FAwySi7z9tJH0VJX9FQB/BvBz8s8zmzC+/krNgKDul6y6ajDYPHS3e521/hbGT62DG4KxeoZeXnZNQ0V0+jjearaemSQKrd8/FyKe3wW1VyRQiWdRc53HEC+n9ZS7PcG0LSTV6H4+z85t11OA4TyFuhrLBB5YMTjwk7SSxxMhSfdmpVleB39U0vqORvBJgxkYsIsCbTaneiDUzXjKh2xvyJSTSy9hHC2dQr2MiAXwuz6AVJn9m37MBbU4GZ9Ol4bTY05VrgLELnk4uvefU54d5wo7Ilke7Z5CSZ7UuD7fyBbLOhIpd35IdK75JRv3QOyKh1WJHS/AqlorLo3UQWLO741l7WIkG6t1cWMolOH4C/Rm2cUAsWYa/A3ev9LLzL/AnnaXEHUOiDM4iKXO5MrKFexkqv0Q4kr1PnzizV1zol2Z4bkObUNmWsP8mAJMQlmeU//txKCroBMgXF/QUdU+8FYHNjDyq/IUWpdSnR7Cap4LW8Bm0Mnc59cShhM6wx0TXdsZ+OTKAuy1IAaGfgqCOKNIyup8HnKY2WVeqBX8/yKRiQGNLiNTAhvCG0xRzujpk+oU5Fxcrc9cinB2niD6CjXYm6ZPu746uhageYDjkQxk8HTFf6ni8RLFcFBsVvT/quKJ+LHdNYcp8JzvmIZAz7TqJ3bA8lXm/jHlXrUhZq8thAp/d6Kh/vVzdbyP1cxcphPlooylJJnTTZjzThgWZGtDC6AgsVEiNShPYbzd7VQ5jMwukoiaI0v+01AxuViM8v67kiR1iT0mc8t6ycyi/It245JxLuy98t4tlq0qgObZza6f8NERUXKroyE8nAWaJd09CF/jU+iKww8befKCH2yQqRFcjiq2WyjiqfCbApMK9FxUH929ic+7T5TfNdVal4jgVwk1n9Pw9pcOAEjJtetuilbIWL1vEc9RXGGGM8rcbNoPWTXaLoFWZrZyKyPCSvO1enGG1PiGis3rG5RQryPBT4esgeISMc/5sP6/SgWERNkuG9hHV7COj8rA4lpsK6OKMzHCs+B3he0x1O65iFmnXlyZFx2g8tGjGb2q5s+FGyEChnqaT9s6QzMelY6zKMTJj6YT+BxT0ZAXa4DEN8dbbHqsxGsaDf0+8kzCjCqfNlVnKl8de+IEbEdP3CF6ZBpCOJkbH8aem9JStv3ob736u+WRKznq29MIhuaB5hGEM9HfVHvwLhsVOIZ29KSj7uI8mLoooUgv/2Q1xEu4DUsPzwiMnqsvL/vSYpWy25P5rVT3QQ4MyMPM357d4UaC4yDho0SXdQuF+aXdMmf151++tciqgeo7ZPl6mWuXnoJvoB8MIOTubEmgWpwhChikpDI7U92CgIVP1xNRRvJWzYjVCiuN09E457WBt1kXpgcDHsRpdkjRi5WSw+hK3YvjFYyIwai3Q5gVBrLonw6e1YRauWN34juhLZbXyqVQqNAae0IAS2ckYo4NU4MeBeBohpgnrGb8r0yLUOWK5/uyZlrf9Fh7aiL8KRTI0z4LhjSGrv0F7zwO4P2bxPE/Lt6TH7DQWmW2+/jK0RftYAx2O3eJsCrPxl9q32pcunBNgM5idfxxOtBsOg6bOIg+PScT1pYgrosvH72FdV1B0+Pg2RJTmmDWtu9ZkHj5K863CQAoaYhjn0LV3Wy0YPPqaZIGi42AdtXkNBwyJehIaSvKg4riPcOtDLhdbaiP0RlS+nSlvRC5Z2XTMYDEtCsI9WS/U7Bn5gDBGFkrBYJEzI0g5Yz00jXJFumbGpg/WdVyddWmx4Q0gZSpaS3cvlGxliVqrByZ90IAU8UkaeMAOFi+iUWhRI+9+VOTwxDnkEx9mMjY8hFxROuPMD9pjAp/Fy65MYu6dJG/rbzD5R0hkvdS+iPXtevFY9MzZn2cqLvliOYvUUaLJ8HcM25Y0UJONIKN/Gh3eGdTbU25U2iskkEVLYQ6xJ0hfNVxUxycLWCoXmnMfqP/x33rT+bp+CKCKQYDvthnBBuaBmiBlZVbSH84GVIZFCbWQZbLaKm2CA5KTxRNh5UxAsN2cql5kTXG47i4bEOY71cqX4wP38DF7nX7WnZbg7WnUktJdWTlghEjwI7hVAyHF7oCVPJoCwsdTavSXYpGGp6AkbwADVZeHuv94AcWvepj6VwjRsk5Op3L2TcJJXEFTA+XUlcsmgqhrLC9dm7frycA1e+S7nWHabXuEKWj+YSZSOLiwaPRPvLsYT4FOTxbxKx7kwkvm5QwCz2nEbc8gcHfQprAcYoXF2uy9wZDLsVxq5+TLFKlL2BooAQRnxGMhe5l6ME4VsvIR6NqFqYBinkW5VbapZg3lDTai8BcHnL0aiM3Kmg8j07n2jXNMHxaYtBx9N9i5XNpNNR8DdRNxxe4LEOCQ5kFs6QqIRSL/TSAunSpOhCUlu6CxqtpflboYfasEAtBCxCQHyHkxtndnJOyEEkZTnCdQ/xDDGdbcsZAATmZSh6n5UV+plno8rL7c8xpNO0fDTvJ55lDr4zfjglkanFyehpzzmaGbKXZiaUDH+s1Z7lYpwv0BhVnVhRTGptwvu1Sg2m1KgZblmLU5ybQFbewlCmxE8/G0lFOND4ffvHz7IVdttxgoxBaKVE7RxIFQ7C3q5IMviSJ3qtHd+xwHVywynA4nutvxko83HgcedPLdnJTaBbUNiFCKM9ruKMsDWVE/ObiqevstHYRW4SZvYrmS+B/XhH0/pezMYbqM2Q==");
    base64DecodeToExistingUint8Array(bufferView, 689368, "BgAAAAAAAAAG");
    base64DecodeToExistingUint8Array(bufferView, 689392, "BgAAAAAAAAByZXQASW52YWxpZCBmbGFncwBzZWxmIHRlc3QgZmFpbGVkAEZvciB0aGlzIHNhbXBsZSwgdGhpcyA2My1ieXRlIHN0cmluZyB3aWxsIGJlIHVzZWQgYXMgaW5wdXQgZGF0YQAoZmxhZ3MgJiBTRUNQMjU2SzFfRkxBR1NfVFlQRV9NQVNLKSA9PSBTRUNQMjU2SzFfRkxBR1NfVFlQRV9DT01QUkVTU0lPTgBzZWNrZXkgIT0gTlVMTAB4b25seV9wdWJrZXkgIT0gTlVMTABvdXRwdXRfcHVia2V5ICE9IE5VTEwAaW50ZXJuYWxfcHVia2V5ICE9IE5VTEwAb3V0cHV0ICE9IE5VTEwAaW5wdXQgIT0gTlVMTABwdWJub25jZXMgIT0gTlVMTABrZXlwYWlyICE9IE5VTEwAc2lnaW4gIT0gTlVMTABvdXRwdXRsZW4gIT0gTlVMTABzaWcgIT0gTlVMTABzaWduYXR1cmUgIT0gTlVMTABwdWJub25jZSAhPSBOVUxMAHJlY2lkICE9IE5VTEwAcHVibm9uY2VzW2ldICE9IE5VTEwAb3V0cHV0NjQgIT0gTlVMTABpbnB1dDY0ICE9IE5VTEwAc2lnNjQgIT0gTlVMTABzZWNrZXkzMiAhPSBOVUxMAHR3ZWFrZWRfcHVia2V5MzIgIT0gTlVMTABvdXRwdXQzMiAhPSBOVUxMAGlucHV0MzIgIT0gTlVMTAB0d2VhazMyICE9IE5VTEwAbXNnaGFzaDMyICE9IE5VTEwAcmVjaWQgPj0gMCAmJiByZWNpZCA8PSAzAG4gPj0gMQBtc2cgIT0gTlVMTCB8fCBtc2dsZW4gPT0gMABydXN0c2VjcDI1NmsxX3YwXzhfMV9lY211bHRfZ2VuX2NvbnRleHRfaXNfYnVpbHQoJmN0eC0+ZWNtdWx0X2dlbl9jdHgpACFydXN0c2VjcDI1NmsxX3YwXzhfMV9mZV9pc196ZXJvKCZnZS0+eCkAKm91dHB1dGxlbiA+PSAoKGZsYWdzICYgU0VDUDI1NksxX0ZMQUdTX0JJVF9DT01QUkVTU0lPTikgPyAzM3UgOiA2NXUpAAAAAAAABgAAAAAAAAAEAAAAAAAAAAE=");
    base64DecodeToExistingUint8Array(bufferView, 690288, "8Ip4y7ruCCsFKuBwjzL6HlDFxCGqdyul27QGoupr40JBQTbQjF7SP+6AIr2ac7sq6/////////8=");
    base64DecodeToExistingUint8Array(bufferView, 690353, "AQAAAAAAAMFOd6qZAPI0AAEAAAAAAACYF/gWW4ECAJ+VjeLcsg0A/JsCBwuHDgBcKQZaxboLANz5fma+eQAAuNQQ+4/QBwDEmUFVaIoEALQX/agIEQ4AwL9P2lVGDACjJnfaOkg=");
    base64DecodeToExistingUint8Array(bufferView, 690464, "L/z///7///8=");
    base64DecodeToExistingUint8Array(bufferView, 690497, "AQAAAAAAAM/K2i3i9scngA==");
    base64DecodeToExistingUint8Array(bufferView, 690576, "w+S/Cql/VG8oiA4B1n5D5A==");
    base64DecodeToExistingUint8Array(bufferView, 690608, "LFaxPajNZddtNHQHxQooiv7///////////////////8xsNtFmiCT6H/K6HEUiqo9FeuEkuSQbOjNa9SnIdKGMHF/xIqutHEVxgb1nawIEiLE5L8KqX9UbyiIDgHWfkPkcr0jG3yWAt94ZoEg6iIuElpkEogCHCal4DBcwEytY1NCSVAwMzQwL25vbmNl");
    base64DecodeToExistingUint8Array(bufferView, 690752, "MIQK");
  }
  function wasm2js_trap() {
    throw new Error("abort");
  }
  function asmFunc(imports) {
    var buffer = new ArrayBuffer(720896);
    var HEAP8 = new Int8Array(buffer);
    var HEAP16 = new Int16Array(buffer);
    var HEAP32 = new Int32Array(buffer);
    var HEAPU8 = new Uint8Array(buffer);
    var HEAPU16 = new Uint16Array(buffer);
    var HEAPU32 = new Uint32Array(buffer);
    var HEAPF32 = new Float32Array(buffer);
    var HEAPF64 = new Float64Array(buffer);
    var Math_imul = Math.imul;
    var Math_fround = Math.fround;
    var Math_abs = Math.abs;
    var Math_clz32 = Math.clz32;
    var Math_min = Math.min;
    var Math_max = Math.max;
    var Math_floor = Math.floor;
    var Math_ceil = Math.ceil;
    var Math_trunc = Math.trunc;
    var Math_sqrt = Math.sqrt;
    var $_rand_js = imports["./rand.js"];
    var fimport$0 = $_rand_js.generateInt32;
    var $_validate_error_js = imports["./validate_error.js"];
    var fimport$1 = $_validate_error_js.throwError;
    var global$0 = 655360;
    var global$1 = 690820;
    var global$2 = 655584;
    var global$3 = 690949;
    var global$4 = 690885;
    var global$5 = 690917;
    var global$6 = 690788;
    var global$7 = 655649;
    var global$8 = 655681;
    var global$9 = 690981;
    var global$10 = 691052;
    var global$11 = 691056;
    var i64toi32_i32$HIGH_BITS = 0;
    function $0($0_1, $1_1) {
      $0_1 = $0_1 | 0;
      $1_1 = $1_1 | 0;
      var $2_1 = 0, $3_1 = 0, $4_1 = 0;
      $4_1 = global$0 - 128 | 0;
      global$0 = $4_1;
      $0_1 = HEAP32[$0_1 >> 2];
      label$1: {
        label$2: {
          label$3: {
            label$4: {
              $2_1 = HEAP32[$1_1 + 24 >> 2];
              if (!($2_1 & 16)) {
                if ($2_1 & 32) {
                  break label$4;
                }
                $0_1 = HEAP32[$0_1 >> 2];
                $2_1 = ($0_1 | 0) >= 0;
                $0_1 = $1($2_1 ? $0_1 : 0 - $0_1 | 0, $2_1 ? 0 : 0 - (($0_1 >> 31) + (($0_1 | 0) != 0) | 0) | 0, $2_1, $1_1);
                break label$3;
              }
              $0_1 = HEAP32[$0_1 >> 2];
              $2_1 = 0;
              while (1) {
                $3_1 = $0_1 & 15;
                HEAP8[($2_1 + $4_1 | 0) + 127 | 0] = $3_1 + ($3_1 >>> 0 < 10 ? 48 : 87);
                $2_1 = $2_1 - 1 | 0;
                $3_1 = $0_1 >>> 0 > 15;
                $0_1 = $0_1 >>> 4 | 0;
                if ($3_1) {
                  continue;
                }
                break;
              }
              ;
              if ($2_1 + 128 >>> 0 >= 129) {
                break label$2;
              }
              $0_1 = $2($1_1, 1, 2, ($2_1 + $4_1 | 0) + 128 | 0, 0 - $2_1 | 0);
              break label$3;
            }
            $0_1 = HEAP32[$0_1 >> 2];
            $2_1 = 0;
            while (1) {
              $3_1 = $0_1 & 15;
              HEAP8[($2_1 + $4_1 | 0) + 127 | 0] = $3_1 + ($3_1 >>> 0 < 10 ? 48 : 55);
              $2_1 = $2_1 - 1 | 0;
              $3_1 = $0_1 >>> 0 > 15;
              $0_1 = $0_1 >>> 4 | 0;
              if ($3_1) {
                continue;
              }
              break;
            }
            ;
            if ($2_1 + 128 >>> 0 >= 129) {
              break label$1;
            }
            $0_1 = $2($1_1, 1, 2, ($2_1 + $4_1 | 0) + 128 | 0, 0 - $2_1 | 0);
          }
          global$0 = $4_1 + 128 | 0;
          return $0_1 | 0;
        }
        wasm2js_trap();
      }
      wasm2js_trap();
    }
    function $1($0_1, $1_1, $2_1, $3_1) {
      var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0;
      $10_1 = global$0 - 48 | 0;
      global$0 = $10_1;
      $7_1 = 39;
      if (!(!$1_1 & $0_1 >>> 0 < 1e4)) {
        while (1) {
          $13_1 = ($10_1 + 9 | 0) + $7_1 | 0;
          $14_1 = $13_1 - 4 | 0;
          $5_1 = $0_1;
          $9_1 = 0;
          $11_1 = 0;
          __inlined_func$_ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E$2: {
            folding_inner0: {
              if (!$1_1) {
                $0_1 = ($5_1 >>> 0) / 1e4 | 0;
                break folding_inner0;
              }
              $6_1 = 51 - Math_clz32($1_1) | 0;
              $4_1 = 0 - $6_1 | 0;
              $8_1 = $6_1 & 63;
              $0_1 = $8_1 & 31;
              if ($8_1 >>> 0 >= 32) {
                $8_1 = $1_1 >>> $0_1 | 0;
              } else {
                $9_1 = $1_1 >>> $0_1 | 0;
                $8_1 = ((1 << $0_1) - 1 & $1_1) << 32 - $0_1 | $5_1 >>> $0_1;
              }
              $4_1 = $4_1 & 63;
              $0_1 = $4_1 & 31;
              if ($4_1 >>> 0 >= 32) {
                $4_1 = $5_1 << $0_1;
                $0_1 = 0;
              } else {
                $4_1 = (1 << $0_1) - 1 & $5_1 >>> 32 - $0_1 | $1_1 << $0_1;
                $0_1 = $5_1 << $0_1;
              }
              if ($6_1) {
                while (1) {
                  $15_1 = $9_1 << 1 | $8_1 >>> 31;
                  $12_1 = $8_1 << 1 | $4_1 >>> 31;
                  $16_1 = 0 - ($15_1 + ($12_1 >>> 0 > 9999) | 0) >> 31;
                  $9_1 = $16_1 & 1e4;
                  $8_1 = $12_1 - $9_1 | 0;
                  $9_1 = $15_1 - ($9_1 >>> 0 > $12_1 >>> 0) | 0;
                  $4_1 = $4_1 << 1 | $0_1 >>> 31;
                  $0_1 = $0_1 << 1 | $11_1;
                  $11_1 = $16_1 & 1;
                  $6_1 = $6_1 - 1 | 0;
                  if ($6_1) {
                    continue;
                  }
                  break;
                }
              }
              i64toi32_i32$HIGH_BITS = $4_1 << 1 | $0_1 >>> 31;
              $0_1 = $0_1 << 1 | $11_1;
              break __inlined_func$_ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E$2;
            }
            i64toi32_i32$HIGH_BITS = 0;
          }
          $8_1 = i64toi32_i32$HIGH_BITS;
          $4_1 = __wasm_i64_mul($0_1, $8_1, 55536, 0) + $5_1 | 0;
          $9_1 = (($4_1 & 65535) >>> 0) / 100 | 0;
          $6_1 = ($9_1 << 1) + 655718 | 0;
          $6_1 = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8;
          HEAP8[$14_1 | 0] = $6_1;
          HEAP8[$14_1 + 1 | 0] = $6_1 >>> 8;
          $6_1 = $13_1 - 2 | 0;
          $4_1 = ((Math_imul($9_1, -100) + $4_1 & 65535) << 1) + 655718 | 0;
          $4_1 = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8;
          HEAP8[$6_1 | 0] = $4_1;
          HEAP8[$6_1 + 1 | 0] = $4_1 >>> 8;
          $7_1 = $7_1 - 4 | 0;
          $5_1 = !$1_1 & $5_1 >>> 0 > 99999999 | ($1_1 | 0) != 0;
          $1_1 = $8_1;
          if ($5_1) {
            continue;
          }
          break;
        }
      }
      if ($0_1 >>> 0 > 99) {
        $7_1 = $7_1 - 2 | 0;
        $1_1 = $7_1 + ($10_1 + 9 | 0) | 0;
        $8_1 = $0_1;
        $0_1 = (($0_1 & 65535) >>> 0) / 100 | 0;
        $5_1 = (($8_1 + Math_imul($0_1, -100) & 65535) << 1) + 655718 | 0;
        $5_1 = HEAPU8[$5_1 | 0] | HEAPU8[$5_1 + 1 | 0] << 8;
        HEAP8[$1_1 | 0] = $5_1;
        HEAP8[$1_1 + 1 | 0] = $5_1 >>> 8;
      }
      label$5: {
        if ($0_1 >>> 0 >= 10) {
          $7_1 = $7_1 - 2 | 0;
          $1_1 = $7_1 + ($10_1 + 9 | 0) | 0;
          $0_1 = ($0_1 << 1) + 655718 | 0;
          $0_1 = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8;
          HEAP8[$1_1 | 0] = $0_1;
          HEAP8[$1_1 + 1 | 0] = $0_1 >>> 8;
          break label$5;
        }
        $7_1 = $7_1 - 1 | 0;
        HEAP8[$7_1 + ($10_1 + 9 | 0) | 0] = $0_1 + 48;
      }
      $0_1 = $2($3_1, $2_1, 0, ($10_1 + 9 | 0) + $7_1 | 0, 39 - $7_1 | 0);
      global$0 = $10_1 + 48 | 0;
      return $0_1;
    }
    function $2($0_1, $1_1, $2_1, $3_1, $4_1) {
      var $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0;
      $9_1 = 655716;
      label$1: {
        if ($1_1) {
          $5_1 = HEAP32[$0_1 + 24 >> 2];
          $1_1 = $5_1 & 1;
          $10_1 = $1_1 ? 43 : 1114112;
          $6_1 = $1_1 + $4_1 | 0;
          break label$1;
        }
        $5_1 = HEAP32[$0_1 + 24 >> 2];
        $10_1 = 45;
        $6_1 = $4_1 + 1 | 0;
      }
      label$3: {
        if (!($5_1 & 4)) {
          $9_1 = 0;
          break label$3;
        }
        label$5: {
          if (!$2_1) {
            break label$5;
          }
          $7_1 = $2_1 & 3;
          if (!$7_1) {
            break label$5;
          }
          $1_1 = 655716;
          while (1) {
            $8_1 = $8_1 + (HEAP8[$1_1 | 0] > -65) | 0;
            $1_1 = $1_1 + 1 | 0;
            $7_1 = $7_1 - 1 | 0;
            if ($7_1) {
              continue;
            }
            break;
          }
          ;
        }
        $6_1 = $6_1 + $8_1 | 0;
      }
      label$7: {
        label$8: {
          if (!HEAP32[$0_1 + 8 >> 2]) {
            $1_1 = 1;
            $6_1 = HEAP32[$0_1 >> 2];
            $0_1 = HEAP32[$0_1 + 4 >> 2];
            if ($27($6_1, $0_1, $10_1, $9_1, $2_1)) {
              break label$8;
            }
            break label$7;
          }
          label$10: {
            label$11: {
              label$12: {
                label$13: {
                  $7_1 = HEAP32[$0_1 + 12 >> 2];
                  if ($7_1 >>> 0 > $6_1 >>> 0) {
                    if ($5_1 & 8) {
                      break label$10;
                    }
                    $5_1 = $7_1 - $6_1 | 0;
                    $6_1 = $5_1;
                    $1_1 = HEAPU8[$0_1 + 32 | 0];
                    $1_1 = ($1_1 | 0) == 3 ? 1 : $1_1;
                    switch ($1_1 - 1 | 0) {
                      case 1:
                        break label$12;
                      case 0:
                        break label$13;
                      default:
                        break label$11;
                    }
                    ;
                  }
                  $1_1 = 1;
                  $6_1 = HEAP32[$0_1 >> 2];
                  $0_1 = HEAP32[$0_1 + 4 >> 2];
                  if ($27($6_1, $0_1, $10_1, $9_1, $2_1)) {
                    break label$8;
                  }
                  break label$7;
                }
                $6_1 = 0;
                $1_1 = $5_1;
                break label$11;
              }
              $1_1 = $5_1 >>> 1 | 0;
              $6_1 = $5_1 + 1 >>> 1 | 0;
            }
            $1_1 = $1_1 + 1 | 0;
            $5_1 = HEAP32[$0_1 + 4 >> 2];
            $8_1 = HEAP32[$0_1 + 28 >> 2];
            $7_1 = HEAP32[$0_1 >> 2];
            label$15: {
              while (1) {
                $1_1 = $1_1 - 1 | 0;
                if (!$1_1) {
                  break label$15;
                }
                if (!(FUNCTION_TABLE[HEAP32[$5_1 + 16 >> 2]]($7_1, $8_1) | 0)) {
                  continue;
                }
                break;
              }
              ;
              return 1;
            }
            $1_1 = 1;
            if (($8_1 | 0) == 1114112) {
              break label$8;
            }
            if ($27($7_1, $5_1, $10_1, $9_1, $2_1)) {
              break label$8;
            }
            if (FUNCTION_TABLE[HEAP32[$5_1 + 12 >> 2]]($7_1, $3_1, $4_1) | 0) {
              break label$8;
            }
            $1_1 = 0;
            label$17: {
              while (1) {
                $0_1 = $6_1;
                if (($0_1 | 0) == ($1_1 | 0)) {
                  break label$17;
                }
                $1_1 = $1_1 + 1 | 0;
                if (!(FUNCTION_TABLE[HEAP32[$5_1 + 16 >> 2]]($7_1, $8_1) | 0)) {
                  continue;
                }
                break;
              }
              ;
              $0_1 = $1_1 - 1 | 0;
            }
            $1_1 = $0_1 >>> 0 < $6_1 >>> 0;
            break label$8;
          }
          $11_1 = HEAP32[$0_1 + 28 >> 2];
          HEAP32[$0_1 + 28 >> 2] = 48;
          $12_1 = HEAPU8[$0_1 + 32 | 0];
          $1_1 = 1;
          HEAP8[$0_1 + 32 | 0] = 1;
          $5_1 = HEAP32[$0_1 >> 2];
          $8_1 = HEAP32[$0_1 + 4 >> 2];
          if ($27($5_1, $8_1, $10_1, $9_1, $2_1)) {
            break label$8;
          }
          $1_1 = ($7_1 - $6_1 | 0) + 1 | 0;
          label$19: {
            while (1) {
              $1_1 = $1_1 - 1 | 0;
              if (!$1_1) {
                break label$19;
              }
              if (!(FUNCTION_TABLE[HEAP32[$8_1 + 16 >> 2]]($5_1, 48) | 0)) {
                continue;
              }
              break;
            }
            ;
            return 1;
          }
          $1_1 = 1;
          if (FUNCTION_TABLE[HEAP32[$8_1 + 12 >> 2]]($5_1, $3_1, $4_1) | 0) {
            break label$8;
          }
          HEAP8[$0_1 + 32 | 0] = $12_1;
          HEAP32[$0_1 + 28 >> 2] = $11_1;
          return 0;
        }
        return $1_1;
      }
      return FUNCTION_TABLE[HEAP32[$0_1 + 12 >> 2]]($6_1, $3_1, $4_1) | 0;
    }
    function $3($0_1, $1_1) {
      $0_1 = $0_1 | 0;
      $1_1 = $1_1 | 0;
      var $2_1 = 0, $3_1 = 0, $4_1 = 0;
      $4_1 = global$0 - 128 | 0;
      global$0 = $4_1;
      $0_1 = HEAP32[$0_1 >> 2];
      label$1: {
        label$2: {
          label$3: {
            label$4: {
              $2_1 = HEAP32[$1_1 + 24 >> 2];
              if (!($2_1 & 16)) {
                if ($2_1 & 32) {
                  break label$4;
                }
                $0_1 = $1(HEAP32[$0_1 >> 2], 0, 1, $1_1);
                break label$3;
              }
              $0_1 = HEAP32[$0_1 >> 2];
              $2_1 = 0;
              while (1) {
                $3_1 = $0_1 & 15;
                HEAP8[($2_1 + $4_1 | 0) + 127 | 0] = $3_1 + ($3_1 >>> 0 < 10 ? 48 : 87);
                $2_1 = $2_1 - 1 | 0;
                $3_1 = $0_1 >>> 0 > 15;
                $0_1 = $0_1 >>> 4 | 0;
                if ($3_1) {
                  continue;
                }
                break;
              }
              ;
              if ($2_1 + 128 >>> 0 >= 129) {
                break label$2;
              }
              $0_1 = $2($1_1, 1, 2, ($2_1 + $4_1 | 0) + 128 | 0, 0 - $2_1 | 0);
              break label$3;
            }
            $0_1 = HEAP32[$0_1 >> 2];
            $2_1 = 0;
            while (1) {
              $3_1 = $0_1 & 15;
              HEAP8[($2_1 + $4_1 | 0) + 127 | 0] = $3_1 + ($3_1 >>> 0 < 10 ? 48 : 55);
              $2_1 = $2_1 - 1 | 0;
              $3_1 = $0_1 >>> 0 > 15;
              $0_1 = $0_1 >>> 4 | 0;
              if ($3_1) {
                continue;
              }
              break;
            }
            ;
            if ($2_1 + 128 >>> 0 >= 129) {
              break label$1;
            }
            $0_1 = $2($1_1, 1, 2, ($2_1 + $4_1 | 0) + 128 | 0, 0 - $2_1 | 0);
          }
          global$0 = $4_1 + 128 | 0;
          return $0_1 | 0;
        }
        wasm2js_trap();
      }
      wasm2js_trap();
    }
    function $4($0_1) {
      $0_1 = $0_1 | 0;
    }
    function $5($0_1) {
      var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0;
      $3_1 = global$0 - 32 | 0;
      global$0 = $3_1;
      $1_1 = $0_1 + 16 | 0;
      $4_1 = HEAP32[$1_1 + 4 >> 2];
      $2_1 = $3_1 + 8 | 0;
      $5_1 = $2_1 + 16 | 0;
      HEAP32[$5_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$5_1 + 4 >> 2] = $4_1;
      $1_1 = $0_1 + 8 | 0;
      $4_1 = HEAP32[$1_1 + 4 >> 2];
      $2_1 = $2_1 + 8 | 0;
      HEAP32[$2_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$2_1 + 4 >> 2] = $4_1;
      $1_1 = HEAP32[$0_1 + 4 >> 2];
      HEAP32[$3_1 + 8 >> 2] = HEAP32[$0_1 >> 2];
      HEAP32[$3_1 + 12 >> 2] = $1_1;
      wasm2js_trap();
    }
    function $6() {
      var $0_1 = 0, $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;
      $33_1 = global$0 - 32 | 0;
      global$0 = $33_1;
      label$1: {
        if (HEAPU8[690756]) {
          $47_1 = HEAP32[172762];
          break label$1;
        }
        HEAP32[$33_1 >> 2] = 192;
        HEAP32[$33_1 + 4 >> 2] = 192;
        $0_1 = global$0 - 144 | 0;
        global$0 = $0_1;
        HEAP32[$0_1 + 104 >> 2] = 0;
        HEAP32[$0_1 + 108 >> 2] = 0;
        HEAP32[$0_1 + 32 >> 2] = 528734635;
        HEAP32[$0_1 + 36 >> 2] = 1541459225;
        HEAP32[$0_1 + 24 >> 2] = 1359893119;
        HEAP32[$0_1 + 28 >> 2] = -1694144372;
        HEAP32[$0_1 + 16 >> 2] = 1013904242;
        HEAP32[$0_1 + 20 >> 2] = -1521486534;
        HEAP32[$0_1 + 8 >> 2] = 1779033703;
        HEAP32[$0_1 + 12 >> 2] = -1150833019;
        $1_1 = $0_1 + 8 | 0;
        $29($1_1, 689435, 63);
        $30($1_1, $0_1 + 112 | 0);
        while (1) {
          $4_1 = HEAPU8[($0_1 + 112 | 0) + $3_1 | 0] - HEAPU8[$3_1 + 690288 | 0] | 0;
          if (!$4_1) {
            $1_1 = ($3_1 | 0) != 31;
            $3_1 = $3_1 + 1 | 0;
            if ($1_1) {
              continue;
            }
          }
          break;
        }
        ;
        if ($4_1) {
          $28(689418, 0);
        }
        HEAP32[163880] = 0;
        HEAP32[163881] = 0;
        HEAP32[163878] = 1;
        HEAP32[163879] = 0;
        $1_1 = HEAP32[172349];
        HEAP32[163892] = HEAP32[172348];
        HEAP32[163893] = $1_1;
        $1_1 = HEAP32[172559];
        HEAP32[163890] = HEAP32[172558];
        HEAP32[163891] = $1_1;
        $1_1 = HEAP32[172595];
        HEAP32[163858] = HEAP32[172594];
        HEAP32[163859] = $1_1;
        $1_1 = HEAP32[172597];
        HEAP32[163860] = HEAP32[172596];
        HEAP32[163861] = $1_1;
        $1_1 = HEAP32[172599];
        HEAP32[163862] = HEAP32[172598];
        HEAP32[163863] = $1_1;
        $1_1 = HEAP32[172601];
        HEAP32[163864] = HEAP32[172600];
        HEAP32[163865] = $1_1;
        $1_1 = HEAP32[172603];
        HEAP32[163866] = HEAP32[172602];
        HEAP32[163867] = $1_1;
        HEAP32[163882] = 0;
        HEAP32[163883] = 0;
        HEAP32[163884] = 0;
        HEAP32[163885] = 0;
        HEAP32[163886] = 0;
        HEAP32[163887] = 0;
        HEAP32[163888] = 0;
        HEAP32[163876] = 629725529;
        HEAP32[163877] = 243653;
        HEAP32[163874] = 632307772;
        HEAP32[163875] = 3389866;
        HEAP32[163872] = 1459808328;
        HEAP32[163873] = 3272439;
        HEAP32[163870] = -1430362568;
        HEAP32[163871] = 3896727;
        HEAP32[163868] = 82779140;
        HEAP32[163869] = 3682156;
        HEAP32[163856] = 0;
        HEAP32[163857] = 0;
        HEAP32[163850] = 1;
        HEAP32[163851] = 0;
        HEAP32[163854] = 0;
        HEAP32[163855] = 0;
        HEAP32[163852] = 0;
        HEAP32[163853] = 0;
        HEAP32[163894] = 0;
        HEAP32[163848] = 1;
        global$0 = $0_1 + 144 | 0;
        $47_1 = 655392;
        wasm2js_i32$0 = 690756, wasm2js_i32$1 = fimport$0() | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
        wasm2js_i32$0 = 690760, wasm2js_i32$1 = fimport$0() | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
        wasm2js_i32$0 = 690764, wasm2js_i32$1 = fimport$0() | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
        wasm2js_i32$0 = 690768, wasm2js_i32$1 = fimport$0() | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
        wasm2js_i32$0 = 690772, wasm2js_i32$1 = fimport$0() | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
        wasm2js_i32$0 = 690776, wasm2js_i32$1 = fimport$0() | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
        wasm2js_i32$0 = 690780, wasm2js_i32$1 = fimport$0() | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
        wasm2js_i32$0 = 690784, wasm2js_i32$1 = fimport$0() | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
        $14_1 = global$0 - 720 | 0;
        global$0 = $14_1;
        if (HEAP32[163848]) {
          $0_1 = HEAPU8[690760] | HEAPU8[690761] << 8 | (HEAPU8[690762] << 16 | HEAPU8[690763] << 24);
          $12_1 = $14_1 + 336 | 0;
          $13_1 = $12_1 + 32 | 0;
          HEAP32[$13_1 >> 2] = HEAPU8[690756] | HEAPU8[690757] << 8 | (HEAPU8[690758] << 16 | HEAPU8[690759] << 24);
          HEAP32[$13_1 + 4 >> 2] = $0_1;
          $0_1 = HEAPU8[690768] | HEAPU8[690769] << 8 | (HEAPU8[690770] << 16 | HEAPU8[690771] << 24);
          $10_1 = $12_1 + 40 | 0;
          HEAP32[$10_1 >> 2] = HEAPU8[690764] | HEAPU8[690765] << 8 | (HEAPU8[690766] << 16 | HEAPU8[690767] << 24);
          HEAP32[$10_1 + 4 >> 2] = $0_1;
          $0_1 = HEAPU8[690776] | HEAPU8[690777] << 8 | (HEAPU8[690778] << 16 | HEAPU8[690779] << 24);
          $7_1 = $14_1 + 384 | 0;
          HEAP32[$7_1 >> 2] = HEAPU8[690772] | HEAPU8[690773] << 8 | (HEAPU8[690774] << 16 | HEAPU8[690775] << 24);
          HEAP32[$7_1 + 4 >> 2] = $0_1;
          $0_1 = HEAPU8[690784] | HEAPU8[690785] << 8 | (HEAPU8[690786] << 16 | HEAPU8[690787] << 24);
          $8_1 = $14_1 + 392 | 0;
          HEAP32[$8_1 >> 2] = HEAPU8[690780] | HEAPU8[690781] << 8 | (HEAPU8[690782] << 16 | HEAPU8[690783] << 24);
          HEAP32[$8_1 + 4 >> 2] = $0_1;
          $4_1 = HEAP32[163850];
          $5_1 = $4_1 << 8 & 16711680 | $4_1 << 24;
          $2_1 = $4_1 >>> 8 | 0;
          $1_1 = HEAP32[163851];
          $3_1 = ($2_1 | $1_1 << 24) & 65280;
          $4_1 = $4_1 >>> 24 | 0;
          $5_1 = $5_1 | ($3_1 | ($4_1 | $1_1 << 8) & 255);
          $0_1 = $1_1;
          $3_1 = ($2_1 | ($0_1 & 255) << 24) & -16777216;
          $3_1 = $3_1 | ($4_1 | ($0_1 & 16777215) << 8) & 16711680;
          $9_1 = $12_1 + 24 | 0;
          HEAP32[$9_1 >> 2] = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $3_1;
          HEAP32[$9_1 + 4 >> 2] = $5_1;
          $4_1 = HEAP32[163852];
          $5_1 = $4_1 << 8 & 16711680 | $4_1 << 24;
          $1_1 = HEAP32[163853];
          $3_1 = ($1_1 << 24 | $4_1 >>> 8) & 65280;
          $5_1 = $5_1 | ($3_1 | ($1_1 << 8 | $4_1 >>> 24) & 255);
          $0_1 = $1_1;
          $3_1 = (($0_1 & 255) << 24 | $4_1 >>> 8) & -16777216;
          $3_1 = $3_1 | (($0_1 & 16777215) << 8 | $4_1 >>> 24) & 16711680;
          $11_1 = $12_1 + 16 | 0;
          HEAP32[$11_1 >> 2] = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $3_1;
          HEAP32[$11_1 + 4 >> 2] = $5_1;
          $4_1 = HEAP32[163856];
          $5_1 = $4_1 << 8 & 16711680 | $4_1 << 24;
          $1_1 = HEAP32[163857];
          $3_1 = ($1_1 << 24 | $4_1 >>> 8) & 65280;
          $5_1 = $5_1 | ($3_1 | ($1_1 << 8 | $4_1 >>> 24) & 255);
          $0_1 = $1_1;
          $3_1 = (($0_1 & 255) << 24 | $4_1 >>> 8) & -16777216;
          $3_1 = $3_1 | (($0_1 & 16777215) << 8 | $4_1 >>> 24) & 16711680;
          $2_1 = $14_1;
          HEAP32[$2_1 + 336 >> 2] = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $3_1;
          HEAP32[$2_1 + 340 >> 2] = $5_1;
          $4_1 = HEAP32[163854];
          $5_1 = $4_1 << 8 & 16711680 | $4_1 << 24;
          $1_1 = HEAP32[163855];
          $3_1 = ($1_1 << 24 | $4_1 >>> 8) & 65280;
          $5_1 = $5_1 | ($3_1 | ($1_1 << 8 | $4_1 >>> 24) & 255);
          $0_1 = $1_1;
          $3_1 = (($0_1 & 255) << 24 | $4_1 >>> 8) & -16777216;
          $3_1 = $3_1 | (($0_1 & 16777215) << 8 | $4_1 >>> 24) & 16711680;
          HEAP32[$2_1 + 344 >> 2] = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $3_1;
          HEAP32[$2_1 + 348 >> 2] = $5_1;
          $39_1 = $2_1 + 408 | 0;
          $45($39_1, $12_1, 64);
          HEAP32[$8_1 >> 2] = 0;
          HEAP32[$8_1 + 4 >> 2] = 0;
          HEAP32[$7_1 >> 2] = 0;
          HEAP32[$7_1 + 4 >> 2] = 0;
          HEAP32[$10_1 >> 2] = 0;
          HEAP32[$10_1 + 4 >> 2] = 0;
          HEAP32[$13_1 >> 2] = 0;
          HEAP32[$13_1 + 4 >> 2] = 0;
          HEAP32[$9_1 >> 2] = 0;
          HEAP32[$9_1 + 4 >> 2] = 0;
          HEAP32[$11_1 >> 2] = 0;
          HEAP32[$11_1 + 4 >> 2] = 0;
          HEAP32[$2_1 + 344 >> 2] = 0;
          HEAP32[$2_1 + 348 >> 2] = 0;
          HEAP32[$2_1 + 336 >> 2] = 0;
          HEAP32[$2_1 + 340 >> 2] = 0;
          $34_1 = $2_1 + 480 | 0;
          $46($39_1, $34_1);
          $1_1 = HEAPU8[$2_1 + 497 | 0];
          $0_1 = $1_1 >>> 24 | 0;
          $3_1 = HEAPU8[$2_1 + 498 | 0] | $1_1 << 8;
          $1_1 = $0_1;
          $45_1 = $34_1 + 16 | 0;
          $4_1 = HEAPU8[$45_1 | 0];
          $0_1 = $4_1 >>> 16 | 0;
          $3_1 = $4_1 << 16 | $3_1;
          $4_1 = $0_1 | $1_1;
          $1_1 = HEAPU8[$2_1 + 495 | 0];
          $0_1 = $1_1 >>> 8 | 0;
          $3_1 = $3_1 | $1_1 << 24;
          $11_1 = HEAPU8[$2_1 + 492 | 0];
          $4_1 = HEAPU8[$2_1 + 494 | 0] | ($0_1 | $4_1) | HEAPU8[$2_1 + 493 | 0] << 8 | ($11_1 & 15) << 16;
          $1_1 = HEAPU8[$2_1 + 484 | 0];
          $0_1 = $1_1 >>> 24 | 0;
          $6_1 = HEAPU8[$2_1 + 485 | 0] | $1_1 << 8;
          $1_1 = $0_1;
          $5_1 = HEAPU8[$2_1 + 483 | 0];
          $0_1 = $5_1 >>> 16 | 0;
          $6_1 = $5_1 << 16 | $6_1;
          $5_1 = $0_1 | $1_1;
          $1_1 = HEAPU8[$2_1 + 482 | 0];
          $0_1 = $1_1 >>> 8 | 0;
          $12_1 = $1_1 << 24 | $6_1;
          $13_1 = HEAPU8[$2_1 + 481 | 0] | ($0_1 | $5_1) | HEAPU8[$2_1 + 480 | 0] << 8;
          $1_1 = HEAPU8[$2_1 + 491 | 0];
          $0_1 = $1_1 >>> 28 | 0;
          $6_1 = $1_1 << 4 | $11_1 >>> 4;
          $1_1 = $0_1;
          $5_1 = HEAPU8[$2_1 + 490 | 0];
          $0_1 = $5_1 >>> 20 | 0;
          $6_1 = $5_1 << 12 | $6_1;
          $5_1 = $0_1 | $1_1;
          $1_1 = HEAPU8[$2_1 + 489 | 0];
          $0_1 = $1_1 >>> 12 | 0;
          $6_1 = $1_1 << 20 | $6_1;
          $5_1 = $0_1 | $5_1;
          $1_1 = HEAPU8[$2_1 + 488 | 0];
          $0_1 = $1_1 >>> 4 | 0;
          $10_1 = $1_1 << 28 | $6_1;
          $7_1 = $0_1 | $5_1 | HEAPU8[$2_1 + 487 | 0] << 4 | HEAPU8[$2_1 + 486 | 0] << 12;
          $46_1 = $34_1 + 24 | 0;
          $1_1 = HEAPU8[$46_1 | 0];
          $0_1 = $1_1 >>> 28 | 0;
          $8_1 = HEAPU8[$2_1 + 505 | 0];
          $6_1 = $1_1 << 4 | $8_1 >>> 4;
          $1_1 = $0_1;
          $5_1 = HEAPU8[$2_1 + 503 | 0];
          $0_1 = $5_1 >>> 20 | 0;
          $6_1 = $5_1 << 12 | $6_1;
          $5_1 = $0_1 | $1_1;
          $1_1 = HEAPU8[$2_1 + 502 | 0];
          $0_1 = $1_1 >>> 12 | 0;
          $6_1 = $1_1 << 20 | $6_1;
          $5_1 = $0_1 | $5_1;
          $1_1 = HEAPU8[$2_1 + 501 | 0];
          $0_1 = $1_1 >>> 4 | 0;
          $9_1 = $1_1 << 28 | $6_1;
          $20_1 = $0_1 | $5_1 | HEAPU8[$2_1 + 500 | 0] << 4 | HEAPU8[$2_1 + 499 | 0] << 12;
          $11_1 = $20_1;
          $1_1 = HEAPU8[$2_1 + 510 | 0];
          $0_1 = $1_1 >>> 24 | 0;
          $6_1 = HEAPU8[$2_1 + 511 | 0] | $1_1 << 8;
          $1_1 = $0_1;
          $5_1 = HEAPU8[$2_1 + 509 | 0];
          $0_1 = $5_1 >>> 16 | 0;
          $6_1 = $5_1 << 16 | $6_1;
          $5_1 = $0_1 | $1_1;
          $1_1 = HEAPU8[$2_1 + 508 | 0];
          $0_1 = $1_1 >>> 8 | 0;
          $29_1 = $2_1 + 520 | 0;
          $40_1 = $29_1 + 32 | 0;
          $1_1 = $6_1 | $1_1 << 24;
          $8_1 = HEAPU8[$2_1 + 507 | 0] | ($0_1 | $5_1) | HEAPU8[$2_1 + 506 | 0] << 8 | ($8_1 & 15) << 16;
          $0_1 = !($12_1 | ($10_1 | ($3_1 | ($1_1 | $9_1))) | ($13_1 | ($7_1 | ($4_1 | ($8_1 | $11_1))))) | ($3_1 & $9_1 & $10_1) == -1 & ($4_1 & $11_1 & $7_1) == 1048575 & (($12_1 | 0) == -1 & ($13_1 | 0) == 65535) & (($8_1 | 0) == 1048574 & $1_1 >>> 0 > 4294966318 | $8_1 >>> 0 > 1048574);
          $5_1 = $0_1 - 1 | 0;
          $11_1 = $5_1 & $12_1;
          HEAP32[$40_1 >> 2] = $11_1;
          $6_1 = $13_1;
          $13_1 = 0 - !$0_1 | 0;
          $6_1 = $6_1 & $13_1;
          HEAP32[$40_1 + 4 >> 2] = $6_1;
          $41_1 = $29_1 + 24 | 0;
          $23_1 = $5_1 & $10_1;
          HEAP32[$41_1 >> 2] = $23_1;
          $24_1 = $7_1 & $13_1;
          HEAP32[$41_1 + 4 >> 2] = $24_1;
          $42_1 = $29_1 + 16 | 0;
          $18_1 = $3_1 & $5_1;
          HEAP32[$42_1 >> 2] = $18_1;
          $15_1 = $4_1 & $13_1;
          HEAP32[$42_1 + 4 >> 2] = $15_1;
          $43_1 = $29_1 + 8 | 0;
          $21_1 = $5_1 & $9_1;
          HEAP32[$43_1 >> 2] = $21_1;
          $16_1 = $13_1 & $20_1;
          HEAP32[$43_1 + 4 >> 2] = $16_1;
          $5_1 = $1_1 & $5_1 | $0_1;
          HEAP32[$2_1 + 520 >> 2] = $5_1;
          $0_1 = $8_1 & $13_1;
          $20_1 = $0_1;
          HEAP32[$2_1 + 524 >> 2] = $0_1;
          $12_1 = $2_1 + 128 | 0;
          $30_1 = $5_1 << 1;
          $25_1 = $0_1 << 1 | $5_1 >>> 31;
          $69($12_1, $30_1, $25_1, 0, 0, $23_1, $24_1, 0, 0);
          $13_1 = $2_1 + 192 | 0;
          $4_1 = $21_1 << 1;
          $3_1 = $16_1 << 1 | $21_1 >>> 31;
          $69($13_1, $4_1, $3_1, 0, 0, $18_1, $15_1, 0, 0);
          $7_1 = $2_1 + 320 | 0;
          $69($7_1, $11_1, $6_1, 0, 0, $11_1, $6_1, 0, 0);
          $8_1 = $2_1 + 304 | 0;
          $69($8_1, HEAP32[$2_1 + 320 >> 2], HEAP32[$2_1 + 324 >> 2], 0, 0, 15632, 16, 0, 0);
          $1_1 = $11_1;
          $0_1 = $6_1 << 1 | $1_1 >>> 31;
          $35_1 = $2_1 + 80 | 0;
          $44_1 = $1_1 << 1;
          $26_1 = $0_1;
          $69($35_1, $44_1, $0_1, 0, 0, $5_1, $20_1, 0, 0);
          $36_1 = $2_1 + 176 | 0;
          $69($36_1, $4_1, $3_1, 0, 0, $23_1, $24_1, 0, 0);
          $37_1 = $2_1 + 240 | 0;
          $69($37_1, $18_1, $15_1, 0, 0, $18_1, $15_1, 0, 0);
          $10_1 = $2_1 + 288 | 0;
          $0_1 = $7_1 + 8 | 0;
          $69($10_1, HEAP32[$0_1 >> 2], HEAP32[$0_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
          $69($2_1, $5_1, $20_1, 0, 0, $5_1, $20_1, 0, 0);
          $48_1 = $2_1 + 160 | 0;
          $69($48_1, $44_1, $26_1, 0, 0, $21_1, $16_1, 0, 0);
          $31_1 = $2_1 + 208 | 0;
          $69($31_1, $18_1 << 1, $15_1 << 1 | $18_1 >>> 31, 0, 0, $23_1, $24_1, 0, 0);
          $7_1 = HEAP32[$2_1 + 132 >> 2];
          $0_1 = $7_1 + HEAP32[$2_1 + 196 >> 2] | 0;
          $5_1 = HEAP32[$2_1 + 128 >> 2];
          $4_1 = HEAP32[$2_1 + 192 >> 2];
          $1_1 = $5_1 + $4_1 | 0;
          $3_1 = HEAP32[$2_1 + 304 >> 2];
          $20_1 = $1_1 + $3_1 | 0;
          $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $0_1 = $4_1 + HEAP32[$2_1 + 308 >> 2] | 0;
          $3_1 = $3_1 >>> 0 > $20_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $9_1 = ($4_1 | 0) == ($3_1 | 0) & $1_1 >>> 0 > $20_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
          $0_1 = $8_1 + 8 | 0;
          $11_1 = HEAP32[$0_1 >> 2];
          $6_1 = HEAP32[$0_1 + 4 >> 2];
          $5_1 = ($4_1 | 0) == ($7_1 | 0) & $1_1 >>> 0 < $5_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
          $4_1 = $13_1 + 8 | 0;
          $1_1 = HEAP32[$4_1 >> 2];
          $0_1 = $12_1 + 8 | 0;
          $8_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
          $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
          $0_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $1_1 = $5_1 + $8_1 | 0;
          $0_1 = ($1_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $6_1 | 0;
          $4_1 = $1_1;
          $1_1 = $1_1 + $11_1 | 0;
          $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $4_1 = $1_1;
          $1_1 = $1_1 + $9_1 | 0;
          $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $12_1 = $3_1;
          $11_1 = $1_1 << 12 | $3_1 >>> 20;
          $4_1 = $0_1;
          $5_1 = $0_1 << 12 | $1_1 >>> 20;
          $38_1 = HEAP32[$2_1 + 176 >> 2];
          $1_1 = HEAP32[$2_1 + 240 >> 2];
          $9_1 = $38_1 + $1_1 | 0;
          $32_1 = HEAP32[$2_1 + 180 >> 2];
          $0_1 = $32_1 + HEAP32[$2_1 + 244 >> 2] | 0;
          $0_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $1_1 = HEAP32[$2_1 + 80 >> 2];
          $6_1 = $1_1 + $9_1 | 0;
          $7_1 = $0_1;
          $0_1 = $0_1 + HEAP32[$2_1 + 84 >> 2] | 0;
          $0_1 = $1_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $1_1 = HEAP32[$2_1 + 288 >> 2];
          $3_1 = $1_1 + $6_1 | 0;
          $8_1 = $0_1;
          $0_1 = $0_1 + HEAP32[$2_1 + 292 >> 2] | 0;
          $1_1 = $1_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $0_1 = $1_1 + $5_1 | 0;
          $27_1 = $2_1 + 16 | 0;
          $11_1 = $3_1 + $11_1 | 0;
          $5_1 = $11_1 >>> 0 < $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $22_1 = ($1_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
          $28_1 = ($1_1 | 0) == ($8_1 | 0) & $6_1 >>> 0 > $3_1 >>> 0 | $1_1 >>> 0 < $8_1 >>> 0;
          $0_1 = $10_1 + 8 | 0;
          $17_1 = HEAP32[$0_1 >> 2];
          $19_1 = HEAP32[$0_1 + 4 >> 2];
          $13_1 = ($7_1 | 0) == ($8_1 | 0) & $6_1 >>> 0 < $9_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
          $0_1 = $35_1 + 8 | 0;
          $10_1 = HEAP32[$0_1 >> 2];
          $8_1 = HEAP32[$0_1 + 4 >> 2];
          $6_1 = ($7_1 | 0) == ($32_1 | 0) & $9_1 >>> 0 < $38_1 >>> 0 | $7_1 >>> 0 < $32_1 >>> 0;
          $3_1 = $37_1 + 8 | 0;
          $1_1 = HEAP32[$3_1 >> 2];
          $0_1 = $36_1 + 8 | 0;
          $9_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
          $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
          $0_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $1_1 = $6_1 + $9_1 | 0;
          $0_1 = ($1_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $8_1 | 0;
          $3_1 = $1_1;
          $1_1 = $1_1 + $10_1 | 0;
          $0_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $3_1 = $1_1;
          $1_1 = $1_1 + $13_1 | 0;
          $0_1 = ($3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $19_1 | 0;
          $3_1 = $1_1;
          $1_1 = $1_1 + $17_1 | 0;
          $0_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $3_1 = $1_1 + $28_1 | 0;
          $0_1 = $3_1 >>> 0 < $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $4_1 = $4_1 >>> 20 | 0;
          $1_1 = $3_1 + $4_1 | 0;
          $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $4_1 = $1_1;
          $1_1 = $1_1 + $22_1 | 0;
          $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $4_1 = $5_1;
          $6_1 = $1_1 << 12 | $4_1 >>> 20;
          $3_1 = $0_1;
          $9_1 = $0_1 << 12 | $1_1 >>> 20;
          $17_1 = HEAP32[$2_1 + 164 >> 2];
          $0_1 = $17_1 + HEAP32[$2_1 + 212 >> 2] | 0;
          $10_1 = HEAP32[$2_1 + 160 >> 2];
          $1_1 = HEAP32[$2_1 + 208 >> 2];
          $5_1 = $10_1 + $1_1 | 0;
          $8_1 = $5_1;
          $6_1 = $5_1 + $6_1 | 0;
          $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $0_1 = $1_1 + $9_1 | 0;
          $7_1 = $6_1 << 4 & -16;
          $5_1 = $6_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $9_1 = ($5_1 << 4 | $6_1 >>> 28) & 16777215;
          $13_1 = $4_1;
          $69($27_1, $7_1 | $4_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
          $22_1 = HEAP32[$2_1 + 20 >> 2];
          $0_1 = $22_1 + HEAP32[$2_1 + 4 >> 2] | 0;
          $28_1 = HEAP32[$2_1 + 16 >> 2];
          $4_1 = HEAP32[$2_1 >> 2];
          $9_1 = $28_1 + $4_1 | 0;
          HEAP32[$2_1 + 560 >> 2] = $9_1;
          $4_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          HEAP32[$2_1 + 564 >> 2] = $4_1 & 1048575;
          $35_1 = $2_1 + 112 | 0;
          $69($35_1, $30_1, $25_1, 0, 0, $21_1, $16_1, 0, 0);
          $36_1 = $2_1 + 224 | 0;
          $69($36_1, $44_1, $26_1, 0, 0, $18_1, $15_1, 0, 0);
          $37_1 = $2_1 + 272 | 0;
          $69($37_1, $23_1, $24_1, 0, 0, $23_1, $24_1, 0, 0);
          $38_1 = $2_1 - -64 | 0;
          $19_1 = $38_1;
          $7_1 = ($1_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $8_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
          $8_1 = ($1_1 | 0) == ($17_1 | 0) & $8_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
          $6_1 = $31_1 + 8 | 0;
          $1_1 = HEAP32[$6_1 >> 2];
          $0_1 = $48_1 + 8 | 0;
          $10_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
          $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$6_1 + 4 >> 2] | 0;
          $0_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $6_1 = $8_1 + $10_1 | 0;
          $0_1 = $6_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $3_1 = $3_1 >>> 20 | 0;
          $1_1 = $6_1 + $3_1 | 0;
          $0_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $3_1 = $1_1;
          $1_1 = $1_1 + $7_1 | 0;
          $0_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $8_1 = $1_1 << 12 | $5_1 >>> 20;
          $6_1 = $0_1;
          $5_1 = $0_1 << 12 | $1_1 >>> 20;
          $32_1 = HEAP32[$2_1 + 224 >> 2];
          $1_1 = HEAP32[$2_1 + 272 >> 2];
          $17_1 = $32_1 + $1_1 | 0;
          $31_1 = HEAP32[$2_1 + 228 >> 2];
          $0_1 = $31_1 + HEAP32[$2_1 + 276 >> 2] | 0;
          $3_1 = $1_1 >>> 0 > $17_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $0_1 = $3_1 + $5_1 | 0;
          $10_1 = $8_1 + $17_1 | 0;
          $0_1 = $10_1 >>> 0 < $17_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $8_1 = $0_1;
          $69($19_1, $10_1, $0_1 & 1048575, 0, 0, 15632, 16, 0, 0);
          $9_1 = ($4_1 | 0) == ($22_1 | 0) & $9_1 >>> 0 < $28_1 >>> 0 | $4_1 >>> 0 < $22_1 >>> 0;
          $5_1 = $2_1 + 8 | 0;
          $1_1 = HEAP32[$5_1 >> 2];
          $0_1 = $27_1 + 8 | 0;
          $7_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
          $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
          $0_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $1_1 = $7_1 + $9_1 | 0;
          $0_1 = $1_1 >>> 0 < $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $7_1 = $1_1 << 12 | $4_1 >>> 20;
          $5_1 = $0_1;
          $9_1 = $0_1 << 12 | $1_1 >>> 20;
          $22_1 = HEAP32[$2_1 + 64 >> 2];
          $1_1 = HEAP32[$2_1 + 112 >> 2];
          $19_1 = $22_1 + $1_1 | 0;
          $27_1 = HEAP32[$2_1 + 68 >> 2];
          $0_1 = $27_1 + HEAP32[$2_1 + 116 >> 2] | 0;
          $4_1 = $1_1 >>> 0 > $19_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $0_1 = $4_1 + $9_1 | 0;
          $7_1 = $7_1 + $19_1 | 0;
          $0_1 = $7_1 >>> 0 < $19_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          HEAP32[$2_1 + 568 >> 2] = $7_1;
          $9_1 = $0_1;
          HEAP32[$2_1 + 572 >> 2] = $0_1 & 1048575;
          $28_1 = $2_1 + 96 | 0;
          $69($28_1, $30_1, $25_1, 0, 0, $18_1, $15_1, 0, 0);
          $30_1 = $2_1 + 144 | 0;
          $69($30_1, $21_1, $16_1, 0, 0, $21_1, $16_1, 0, 0);
          $21_1 = $2_1 + 256 | 0;
          $69($21_1, $44_1, $26_1, 0, 0, $23_1, $24_1, 0, 0);
          $18_1 = $2_1 + 48 | 0;
          $15_1 = ($3_1 | 0) == ($8_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
          $10_1 = ($3_1 | 0) == ($31_1 | 0) & $17_1 >>> 0 < $32_1 >>> 0 | $3_1 >>> 0 < $31_1 >>> 0;
          $3_1 = $37_1 + 8 | 0;
          $1_1 = HEAP32[$3_1 >> 2];
          $0_1 = $36_1 + 8 | 0;
          $16_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
          $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
          $0_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $3_1 = $10_1 + $16_1 | 0;
          $0_1 = $3_1 >>> 0 < $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $6_1 = $6_1 >>> 20 | 0;
          $1_1 = $6_1 + $3_1 | 0;
          $0_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $3_1 = $1_1;
          $1_1 = $1_1 + $15_1 | 0;
          $0_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $16_1 = $1_1 << 12 | $8_1 >>> 20;
          $6_1 = HEAP32[$2_1 + 256 >> 2];
          $8_1 = $16_1 + $6_1 | 0;
          $3_1 = $0_1;
          $25_1 = $0_1 << 12 | $1_1 >>> 20;
          $0_1 = $25_1 + HEAP32[$2_1 + 260 >> 2] | 0;
          $10_1 = $6_1 >>> 0 > $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $69($18_1, $8_1, $10_1, 0, 0, 15632, 16, 0, 0);
          $6_1 = $2_1;
          $7_1 = ($4_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $19_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
          $2_1 = ($4_1 | 0) == ($27_1 | 0) & $19_1 >>> 0 < $22_1 >>> 0 | $4_1 >>> 0 < $27_1 >>> 0;
          $4_1 = $35_1 + 8 | 0;
          $1_1 = HEAP32[$4_1 >> 2];
          $0_1 = $38_1 + 8 | 0;
          $15_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
          $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
          $0_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $4_1 = $2_1 + $15_1 | 0;
          $0_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $5_1 = $5_1 >>> 20 | 0;
          $1_1 = $5_1 + $4_1 | 0;
          $0_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $4_1 = $1_1;
          $1_1 = $1_1 + $7_1 | 0;
          $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $2_1 = $1_1 << 12 | $9_1 >>> 20;
          $4_1 = $0_1;
          $5_1 = $0_1 << 12 | $1_1 >>> 20;
          $17_1 = HEAP32[$6_1 + 96 >> 2];
          $1_1 = HEAP32[$6_1 + 144 >> 2];
          $7_1 = $17_1 + $1_1 | 0;
          $26_1 = HEAP32[$6_1 + 100 >> 2];
          $0_1 = $26_1 + HEAP32[$6_1 + 148 >> 2] | 0;
          $0_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $1_1 = HEAP32[$6_1 + 48 >> 2];
          $9_1 = $1_1 + $7_1 | 0;
          $15_1 = $0_1;
          $0_1 = $0_1 + HEAP32[$6_1 + 52 >> 2] | 0;
          $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $0_1 = $1_1 + $5_1 | 0;
          $2_1 = $2_1 + $9_1 | 0;
          $0_1 = $2_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          HEAP32[$6_1 + 576 >> 2] = $2_1;
          $5_1 = $0_1;
          HEAP32[$6_1 + 580 >> 2] = $0_1 & 1048575;
          $19_1 = $6_1 + 32 | 0;
          $16_1 = ($10_1 | 0) == ($25_1 | 0) & $8_1 >>> 0 < $16_1 >>> 0 | $10_1 >>> 0 < $25_1 >>> 0;
          $0_1 = $21_1 + 8 | 0;
          $10_1 = HEAP32[$0_1 >> 2];
          $0_1 = HEAP32[$0_1 + 4 >> 2];
          $3_1 = $3_1 >>> 20 | 0;
          $8_1 = $3_1;
          $3_1 = $3_1 + $10_1 | 0;
          $0_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $8_1 = $3_1;
          $3_1 = $3_1 + $16_1 | 0;
          $0_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $69($19_1, $3_1, $0_1, 0, 0, 64028672, 65536, 0, 0);
          $3_1 = $6_1;
          $16_1 = ($1_1 | 0) == ($5_1 | 0) & $2_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
          $10_1 = ($1_1 | 0) == ($15_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
          $0_1 = $18_1 + 8 | 0;
          $8_1 = HEAP32[$0_1 >> 2];
          $9_1 = HEAP32[$0_1 + 4 >> 2];
          $2_1 = ($15_1 | 0) == ($26_1 | 0) & $7_1 >>> 0 < $17_1 >>> 0 | $15_1 >>> 0 < $26_1 >>> 0;
          $6_1 = $30_1 + 8 | 0;
          $1_1 = HEAP32[$6_1 >> 2];
          $0_1 = $28_1 + 8 | 0;
          $7_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
          $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$6_1 + 4 >> 2] | 0;
          $0_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $1_1 = $2_1 + $7_1 | 0;
          $0_1 = ($1_1 >>> 0 < $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $9_1 | 0;
          $6_1 = $1_1;
          $1_1 = $1_1 + $8_1 | 0;
          $0_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $6_1 = $1_1 + $10_1 | 0;
          $0_1 = $6_1 >>> 0 < $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $4_1 = $4_1 >>> 20 | 0;
          $1_1 = $6_1 + $4_1 | 0;
          $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $4_1 = $1_1;
          $1_1 = $1_1 + $16_1 | 0;
          $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $9_1 = $1_1 << 12 | $5_1 >>> 20;
          $4_1 = $0_1;
          $5_1 = $0_1 << 12 | $1_1 >>> 20;
          $7_1 = HEAP32[$3_1 + 32 >> 2];
          $1_1 = $20_1 & -2;
          $6_1 = $7_1 + $1_1 | 0;
          $10_1 = HEAP32[$3_1 + 36 >> 2];
          $0_1 = $10_1 + ($12_1 & 1048575) | 0;
          $2_1 = $1_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $0_1 = $2_1 + $5_1 | 0;
          $5_1 = $6_1 + $9_1 | 0;
          $0_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          HEAP32[$3_1 + 584 >> 2] = $5_1;
          $1_1 = $0_1;
          HEAP32[$3_1 + 588 >> 2] = $0_1 & 1048575;
          $8_1 = $13_1 & 65535;
          $9_1 = ($0_1 | 0) == ($2_1 | 0) & $6_1 >>> 0 > $5_1 >>> 0 | $0_1 >>> 0 < $2_1 >>> 0;
          $3_1 = ($2_1 | 0) == ($10_1 | 0) & $6_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $10_1 >>> 0;
          $0_1 = $19_1 + 8 | 0;
          $5_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
          $0_1 = HEAP32[$0_1 + 4 >> 2];
          $0_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $4_1 = $4_1 >>> 20 | 0;
          $3_1 = $4_1;
          $4_1 = $5_1 + $4_1 | 0;
          $0_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $3_1 = $4_1;
          $4_1 = $4_1 + $9_1 | 0;
          $0_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $1_1 = $4_1 << 12 | $1_1 >>> 20;
          $3_1 = $1_1 + $11_1 | 0;
          $0_1 = $8_1 + ($0_1 << 12 | $4_1 >>> 20) | 0;
          HEAP32[$14_1 + 592 >> 2] = $3_1;
          HEAP32[$14_1 + 596 >> 2] = $1_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $18_1 = $14_1 + 560 | 0;
          $34(655432, 655432, $18_1);
          $34(655472, 655472, $18_1);
          $34(655472, 655472, $29_1);
          $34(655512, 655512, $29_1);
          HEAP32[$43_1 >> 2] = 0;
          HEAP32[$43_1 + 4 >> 2] = 0;
          HEAP32[$42_1 >> 2] = 0;
          HEAP32[$42_1 + 4 >> 2] = 0;
          HEAP32[$41_1 >> 2] = 0;
          HEAP32[$41_1 + 4 >> 2] = 0;
          HEAP32[$40_1 >> 2] = 0;
          HEAP32[$40_1 + 4 >> 2] = 0;
          HEAP32[$14_1 + 520 >> 2] = 0;
          HEAP32[$14_1 + 524 >> 2] = 0;
          $46($39_1, $34_1);
          $17_1 = $14_1 + 688 | 0;
          $38($17_1, $34_1, 0);
          $1_1 = $17_1 + 24 | 0;
          $7_1 = HEAP32[$1_1 >> 2];
          $4_1 = $17_1 + 16 | 0;
          $10_1 = HEAP32[$4_1 >> 2];
          $3_1 = $17_1 + 8 | 0;
          $12_1 = HEAP32[$3_1 >> 2];
          $13_1 = HEAP32[$14_1 + 688 >> 2];
          $8_1 = $7_1 | ($10_1 | ($12_1 | $13_1));
          $6_1 = HEAP32[$1_1 + 4 >> 2];
          $11_1 = HEAP32[$4_1 + 4 >> 2];
          $9_1 = HEAP32[$3_1 + 4 >> 2];
          $2_1 = HEAP32[$14_1 + 692 >> 2];
          $5_1 = $6_1 | ($11_1 | ($9_1 | $2_1));
          $0_1 = $8_1 | $5_1 ? -1 : 0;
          $19_1 = $0_1 & $7_1;
          HEAP32[$1_1 >> 2] = $19_1;
          $16_1 = $0_1 & $6_1;
          HEAP32[$1_1 + 4 >> 2] = $16_1;
          $15_1 = $0_1 & $10_1;
          HEAP32[$4_1 >> 2] = $15_1;
          $20_1 = $0_1 & $11_1;
          HEAP32[$4_1 + 4 >> 2] = $20_1;
          $12_1 = $0_1 & $12_1;
          HEAP32[$3_1 >> 2] = $12_1;
          $10_1 = $0_1 & $9_1;
          HEAP32[$3_1 + 4 >> 2] = $10_1;
          $5_1 = !($5_1 | $8_1) | $0_1 & $13_1;
          HEAP32[$14_1 + 688 >> 2] = $5_1;
          $6_1 = $0_1 & $2_1;
          HEAP32[$14_1 + 692 >> 2] = $6_1;
          $68($39_1, 68);
          HEAP32[$46_1 >> 2] = 0;
          HEAP32[$46_1 + 4 >> 2] = 0;
          HEAP32[$45_1 >> 2] = 0;
          HEAP32[$45_1 + 4 >> 2] = 0;
          HEAP32[$14_1 + 488 >> 2] = 0;
          HEAP32[$14_1 + 492 >> 2] = 0;
          HEAP32[$14_1 + 480 >> 2] = 0;
          HEAP32[$14_1 + 484 >> 2] = 0;
          $48(655392, $18_1, $17_1);
          $0_1 = $12_1 | $15_1 | $19_1 | $5_1 | ($10_1 | $20_1 | $16_1 | $6_1) ? -1 : 0;
          $7_1 = $5_1 ^ -1;
          $2_1 = $7_1 - 801750718 | 0;
          $5_1 = $0_1;
          $11_1 = $6_1 ^ -1;
          $6_1 = $11_1 - (($7_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
          $0_1 = $0_1 & $6_1;
          $8_1 = $0_1;
          $9_1 = $2_1 & $5_1;
          HEAP32[163850] = $9_1;
          HEAP32[163851] = $0_1;
          $10_1 = $10_1 ^ -1;
          $0_1 = $10_1;
          $13_1 = $12_1 ^ -1;
          $12_1 = $13_1 + (($6_1 | 0) == ($11_1 | 0) & $2_1 >>> 0 < $7_1 >>> 0 | $6_1 >>> 0 < $11_1 >>> 0) | 0;
          $2_1 = $12_1 - 1354194885 | 0;
          $11_1 = $2_1 & $5_1;
          HEAP32[$3_1 >> 2] = $11_1;
          $0_1 = $12_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $7_1 = $0_1 - (($12_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
          $6_1 = $7_1 & $5_1;
          HEAP32[$3_1 + 4 >> 2] = $6_1;
          HEAP32[163852] = $11_1;
          HEAP32[163853] = $6_1;
          $6_1 = ($0_1 | 0) == ($7_1 | 0) & $2_1 >>> 0 < $12_1 >>> 0 | $0_1 >>> 0 > $7_1 >>> 0;
          $11_1 = $6_1 + (($0_1 | 0) == ($10_1 | 0) & $12_1 >>> 0 < $13_1 >>> 0 | $0_1 >>> 0 < $10_1 >>> 0) | 0;
          $13_1 = $15_1 ^ -1;
          $12_1 = $13_1 + $11_1 | 0;
          $10_1 = $20_1 ^ -1;
          $0_1 = $10_1 + ($6_1 >>> 0 > $11_1 >>> 0) | 0;
          $2_1 = $12_1 - 2 | 0;
          $11_1 = $2_1 & $5_1;
          HEAP32[$4_1 >> 2] = $11_1;
          $0_1 = $12_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $7_1 = $0_1 - ($12_1 >>> 0 < 2) | 0;
          $6_1 = $7_1 & $5_1;
          HEAP32[$4_1 + 4 >> 2] = $6_1;
          HEAP32[163854] = $11_1;
          HEAP32[163855] = $6_1;
          $6_1 = ($0_1 | 0) == ($7_1 | 0) & $2_1 >>> 0 < $12_1 >>> 0 | $0_1 >>> 0 > $7_1 >>> 0;
          $2_1 = $6_1 + (($0_1 | 0) == ($10_1 | 0) & $12_1 >>> 0 < $13_1 >>> 0 | $0_1 >>> 0 < $10_1 >>> 0) | 0;
          $0_1 = $2_1 >>> 0 < $6_1 >>> 0;
          $11_1 = $2_1 - $19_1 | 0;
          $6_1 = $11_1 - 2 & $5_1;
          HEAP32[$1_1 >> 2] = $6_1;
          $0_1 = ($0_1 - (($2_1 >>> 0 < $19_1 >>> 0) + $16_1 | 0) | 0) - ($11_1 >>> 0 < 2) & $5_1;
          HEAP32[$1_1 + 4 >> 2] = $0_1;
          HEAP32[163856] = $6_1;
          HEAP32[163857] = $0_1;
          HEAP32[$14_1 + 688 >> 2] = $9_1;
          HEAP32[$14_1 + 692 >> 2] = $8_1;
          $70(655432, $18_1, 128);
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          HEAP32[$4_1 >> 2] = 0;
          HEAP32[$4_1 + 4 >> 2] = 0;
          HEAP32[$3_1 >> 2] = 0;
          HEAP32[$3_1 + 4 >> 2] = 0;
          HEAP32[$14_1 + 688 >> 2] = 0;
          HEAP32[$14_1 + 692 >> 2] = 0;
          $68($18_1, 124);
        }
        global$0 = $14_1 + 720 | 0;
        HEAP8[690757] = 0;
        HEAP8[690758] = 0;
        HEAP8[690759] = 0;
        HEAP8[690760] = 0;
        HEAP8[690761] = 0;
        HEAP8[690762] = 0;
        HEAP8[690763] = 0;
        HEAP8[690764] = 0;
        HEAP8[690756] = 1;
        HEAP8[690765] = 0;
        HEAP8[690766] = 0;
        HEAP8[690767] = 0;
        HEAP8[690768] = 0;
        HEAP8[690769] = 0;
        HEAP8[690770] = 0;
        HEAP8[690771] = 0;
        HEAP8[690772] = 0;
        HEAP8[690773] = 0;
        HEAP8[690774] = 0;
        HEAP8[690775] = 0;
        HEAP8[690776] = 0;
        HEAP8[690777] = 0;
        HEAP8[690778] = 0;
        HEAP8[690779] = 0;
        HEAP8[690780] = 0;
        HEAP8[690780] = 0;
        HEAP8[690781] = 0;
        HEAP8[690782] = 0;
        HEAP8[690783] = 0;
        HEAP8[690784] = 0;
        HEAP8[690785] = 0;
        HEAP8[690786] = 0;
        HEAP8[690787] = 0;
        HEAP32[$33_1 + 4 >> 2] = 1;
        HEAP32[172762] = 655392;
      }
      global$0 = $33_1 + 32 | 0;
      return $47_1;
    }
    function $7() {
      $6();
    }
    function $8($0_1) {
      $0_1 = $0_1 | 0;
      var $1_1 = 0, $2_1 = 0;
      $1_1 = global$0 + -64 | 0;
      global$0 = $1_1;
      label$1: {
        if (($0_1 | 0) != 32) {
          $2_1 = $1_1 + 56 | 0;
          HEAP32[$2_1 >> 2] = 0;
          HEAP32[$2_1 + 4 >> 2] = 0;
          $2_1 = $1_1 + 48 | 0;
          HEAP32[$2_1 >> 2] = 0;
          HEAP32[$2_1 + 4 >> 2] = 0;
          $2_1 = $1_1 + 40 | 0;
          HEAP32[$2_1 >> 2] = 0;
          HEAP32[$2_1 + 4 >> 2] = 0;
          $2_1 = $1_1 + 32 | 0;
          HEAP32[$2_1 >> 2] = 0;
          HEAP32[$2_1 + 4 >> 2] = 0;
          $2_1 = $1_1 + 24 | 0;
          HEAP32[$2_1 >> 2] = 0;
          HEAP32[$2_1 + 4 >> 2] = 0;
          $2_1 = $1_1 + 16 | 0;
          HEAP32[$2_1 >> 2] = 0;
          HEAP32[$2_1 + 4 >> 2] = 0;
          $2_1 = $1_1 + 8 | 0;
          HEAP32[$2_1 >> 2] = 0;
          HEAP32[$2_1 + 4 >> 2] = 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          $0_1 = $31(HEAP32[172688], $1_1, 690820, $0_1);
          break label$1;
        }
        $0_1 = $1_1 + 56 | 0;
        HEAP32[$0_1 >> 2] = 0;
        HEAP32[$0_1 + 4 >> 2] = 0;
        $0_1 = $1_1 + 48 | 0;
        HEAP32[$0_1 >> 2] = 0;
        HEAP32[$0_1 + 4 >> 2] = 0;
        $0_1 = $1_1 + 40 | 0;
        HEAP32[$0_1 >> 2] = 0;
        HEAP32[$0_1 + 4 >> 2] = 0;
        $0_1 = $1_1 + 32 | 0;
        HEAP32[$0_1 >> 2] = 0;
        HEAP32[$0_1 + 4 >> 2] = 0;
        $0_1 = $1_1 + 24 | 0;
        HEAP32[$0_1 >> 2] = 0;
        HEAP32[$0_1 + 4 >> 2] = 0;
        $0_1 = $1_1 + 16 | 0;
        HEAP32[$0_1 >> 2] = 0;
        HEAP32[$0_1 + 4 >> 2] = 0;
        $0_1 = $1_1 + 8 | 0;
        HEAP32[$0_1 >> 2] = 0;
        HEAP32[$0_1 + 4 >> 2] = 0;
        HEAP32[$1_1 >> 2] = 0;
        HEAP32[$1_1 + 4 >> 2] = 0;
        $0_1 = $57(HEAP32[172688], $1_1, 690820);
      }
      global$0 = $1_1 - -64 | 0;
      return ($0_1 | 0) == 1 | 0;
    }
    function $9($0_1, $1_1, $2_1) {
      $0_1 = $0_1 | 0;
      $1_1 = $1_1 | 0;
      $2_1 = $2_1 | 0;
      var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0;
      $5_1 = global$0 - 272 | 0;
      global$0 = $5_1;
      $3_1 = $5_1 + 200 | 0;
      $26_1 = $3_1 + 56 | 0;
      HEAP32[$26_1 >> 2] = 0;
      HEAP32[$26_1 + 4 >> 2] = 0;
      $9_1 = $3_1 + 48 | 0;
      HEAP32[$9_1 >> 2] = 0;
      HEAP32[$9_1 + 4 >> 2] = 0;
      $16_1 = $3_1 + 40 | 0;
      HEAP32[$16_1 >> 2] = 0;
      HEAP32[$16_1 + 4 >> 2] = 0;
      $18_1 = $3_1 + 32 | 0;
      HEAP32[$18_1 >> 2] = 0;
      HEAP32[$18_1 + 4 >> 2] = 0;
      $17_1 = $3_1 + 24 | 0;
      HEAP32[$17_1 >> 2] = 0;
      HEAP32[$17_1 + 4 >> 2] = 0;
      $19_1 = $3_1 + 16 | 0;
      HEAP32[$19_1 >> 2] = 0;
      HEAP32[$19_1 + 4 >> 2] = 0;
      $25_1 = $3_1 + 8 | 0;
      HEAP32[$25_1 >> 2] = 0;
      HEAP32[$25_1 + 4 >> 2] = 0;
      HEAP32[$5_1 + 200 >> 2] = 0;
      HEAP32[$5_1 + 204 >> 2] = 0;
      label$1: {
        label$2: {
          if (($31(HEAP32[172688], $3_1, 690820, $0_1) | 0) == 1) {
            $20_1 = $5_1 + 200 | 0;
            $14_1 = $20_1 + 15 | 0;
            $3_1 = $14_1;
            $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
            $10_1 = $5_1 - -64 | 0;
            $22_1 = $10_1 + 8 | 0;
            HEAP32[$22_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
            HEAP32[$22_1 + 4 >> 2] = $0_1;
            $13_1 = $20_1 + 23 | 0;
            $3_1 = $13_1;
            $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
            $23_1 = $10_1 + 16 | 0;
            HEAP32[$23_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
            HEAP32[$23_1 + 4 >> 2] = $0_1;
            $11_1 = $20_1 + 31 | 0;
            $3_1 = $11_1;
            $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
            $24_1 = $10_1 + 24 | 0;
            HEAP32[$24_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
            HEAP32[$24_1 + 4 >> 2] = $0_1;
            $12_1 = $20_1 + 39 | 0;
            $3_1 = $12_1;
            $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
            $27_1 = $10_1 + 32 | 0;
            HEAP32[$27_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
            HEAP32[$27_1 + 4 >> 2] = $0_1;
            $6_1 = $20_1 + 47 | 0;
            $3_1 = $6_1;
            $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
            $4_1 = $10_1 + 40 | 0;
            HEAP32[$4_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
            HEAP32[$4_1 + 4 >> 2] = $0_1;
            $3_1 = $20_1 + 55 | 0;
            $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
            $7_1 = $10_1 + 48 | 0;
            HEAP32[$7_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
            HEAP32[$7_1 + 4 >> 2] = $0_1;
            $8_1 = $10_1 + 56 | 0;
            $10_1 = $20_1 + 63 | 0;
            HEAP8[$8_1 | 0] = HEAPU8[$10_1 | 0];
            HEAP8[$5_1 + 2 | 0] = HEAPU8[$5_1 + 202 | 0];
            HEAP16[$5_1 >> 1] = HEAPU16[$5_1 + 200 >> 1];
            $0_1 = HEAPU8[$5_1 + 211 | 0] | HEAPU8[$5_1 + 212 | 0] << 8 | (HEAPU8[$5_1 + 213 | 0] << 16 | HEAPU8[$5_1 + 214 | 0] << 24);
            HEAP32[$5_1 + 64 >> 2] = HEAPU8[$5_1 + 207 | 0] | HEAPU8[$5_1 + 208 | 0] << 8 | (HEAPU8[$5_1 + 209 | 0] << 16 | HEAPU8[$5_1 + 210 | 0] << 24);
            HEAP32[$5_1 + 68 >> 2] = $0_1;
            $0_1 = HEAPU8[$5_1 + 203 | 0] | HEAPU8[$5_1 + 204 | 0] << 8 | (HEAPU8[$5_1 + 205 | 0] << 16 | HEAPU8[$5_1 + 206 | 0] << 24);
            HEAP8[$5_1 + 63 | 0] = HEAPU8[$8_1 | 0];
            $15_1 = HEAP32[$7_1 + 4 >> 2];
            $21_1 = $5_1 + 55 | 0;
            $8_1 = HEAP32[$7_1 >> 2];
            HEAP8[$21_1 | 0] = $8_1;
            HEAP8[$21_1 + 1 | 0] = $8_1 >>> 8;
            HEAP8[$21_1 + 2 | 0] = $8_1 >>> 16;
            HEAP8[$21_1 + 3 | 0] = $8_1 >>> 24;
            HEAP8[$21_1 + 4 | 0] = $15_1;
            HEAP8[$21_1 + 5 | 0] = $15_1 >>> 8;
            HEAP8[$21_1 + 6 | 0] = $15_1 >>> 16;
            HEAP8[$21_1 + 7 | 0] = $15_1 >>> 24;
            $7_1 = HEAP32[$4_1 + 4 >> 2];
            $15_1 = $5_1 + 47 | 0;
            $8_1 = HEAP32[$4_1 >> 2];
            HEAP8[$15_1 | 0] = $8_1;
            HEAP8[$15_1 + 1 | 0] = $8_1 >>> 8;
            HEAP8[$15_1 + 2 | 0] = $8_1 >>> 16;
            HEAP8[$15_1 + 3 | 0] = $8_1 >>> 24;
            HEAP8[$15_1 + 4 | 0] = $7_1;
            HEAP8[$15_1 + 5 | 0] = $7_1 >>> 8;
            HEAP8[$15_1 + 6 | 0] = $7_1 >>> 16;
            HEAP8[$15_1 + 7 | 0] = $7_1 >>> 24;
            $7_1 = HEAP32[$27_1 + 4 >> 2];
            $4_1 = $5_1 + 39 | 0;
            $8_1 = HEAP32[$27_1 >> 2];
            HEAP8[$4_1 | 0] = $8_1;
            HEAP8[$4_1 + 1 | 0] = $8_1 >>> 8;
            HEAP8[$4_1 + 2 | 0] = $8_1 >>> 16;
            HEAP8[$4_1 + 3 | 0] = $8_1 >>> 24;
            HEAP8[$4_1 + 4 | 0] = $7_1;
            HEAP8[$4_1 + 5 | 0] = $7_1 >>> 8;
            HEAP8[$4_1 + 6 | 0] = $7_1 >>> 16;
            HEAP8[$4_1 + 7 | 0] = $7_1 >>> 24;
            $7_1 = HEAP32[$24_1 + 4 >> 2];
            $4_1 = $5_1 + 31 | 0;
            $8_1 = HEAP32[$24_1 >> 2];
            HEAP8[$4_1 | 0] = $8_1;
            HEAP8[$4_1 + 1 | 0] = $8_1 >>> 8;
            HEAP8[$4_1 + 2 | 0] = $8_1 >>> 16;
            HEAP8[$4_1 + 3 | 0] = $8_1 >>> 24;
            HEAP8[$4_1 + 4 | 0] = $7_1;
            HEAP8[$4_1 + 5 | 0] = $7_1 >>> 8;
            HEAP8[$4_1 + 6 | 0] = $7_1 >>> 16;
            HEAP8[$4_1 + 7 | 0] = $7_1 >>> 24;
            $7_1 = HEAP32[$23_1 + 4 >> 2];
            $4_1 = $5_1 + 23 | 0;
            $8_1 = HEAP32[$23_1 >> 2];
            HEAP8[$4_1 | 0] = $8_1;
            HEAP8[$4_1 + 1 | 0] = $8_1 >>> 8;
            HEAP8[$4_1 + 2 | 0] = $8_1 >>> 16;
            HEAP8[$4_1 + 3 | 0] = $8_1 >>> 24;
            HEAP8[$4_1 + 4 | 0] = $7_1;
            HEAP8[$4_1 + 5 | 0] = $7_1 >>> 8;
            HEAP8[$4_1 + 6 | 0] = $7_1 >>> 16;
            HEAP8[$4_1 + 7 | 0] = $7_1 >>> 24;
            $7_1 = HEAP32[$22_1 + 4 >> 2];
            $4_1 = $5_1 + 15 | 0;
            $8_1 = HEAP32[$22_1 >> 2];
            HEAP8[$4_1 | 0] = $8_1;
            HEAP8[$4_1 + 1 | 0] = $8_1 >>> 8;
            HEAP8[$4_1 + 2 | 0] = $8_1 >>> 16;
            HEAP8[$4_1 + 3 | 0] = $8_1 >>> 24;
            HEAP8[$4_1 + 4 | 0] = $7_1;
            HEAP8[$4_1 + 5 | 0] = $7_1 >>> 8;
            HEAP8[$4_1 + 6 | 0] = $7_1 >>> 16;
            HEAP8[$4_1 + 7 | 0] = $7_1 >>> 24;
            HEAP8[$5_1 + 3 | 0] = $0_1;
            HEAP8[$5_1 + 4 | 0] = $0_1 >>> 8;
            HEAP8[$5_1 + 5 | 0] = $0_1 >>> 16;
            HEAP8[$5_1 + 6 | 0] = $0_1 >>> 24;
            $8_1 = HEAP32[$5_1 + 68 >> 2];
            $0_1 = HEAP32[$5_1 + 64 >> 2];
            HEAP8[$5_1 + 7 | 0] = $0_1;
            HEAP8[$5_1 + 8 | 0] = $0_1 >>> 8;
            HEAP8[$5_1 + 9 | 0] = $0_1 >>> 16;
            HEAP8[$5_1 + 10 | 0] = $0_1 >>> 24;
            HEAP8[$5_1 + 11 | 0] = $8_1;
            HEAP8[$5_1 + 12 | 0] = $8_1 >>> 8;
            HEAP8[$5_1 + 13 | 0] = $8_1 >>> 16;
            HEAP8[$5_1 + 14 | 0] = $8_1 >>> 24;
            HEAP32[$26_1 >> 2] = 0;
            HEAP32[$26_1 + 4 >> 2] = 0;
            HEAP32[$9_1 >> 2] = 0;
            HEAP32[$9_1 + 4 >> 2] = 0;
            HEAP32[$16_1 >> 2] = 0;
            HEAP32[$16_1 + 4 >> 2] = 0;
            HEAP32[$18_1 >> 2] = 0;
            HEAP32[$18_1 + 4 >> 2] = 0;
            HEAP32[$17_1 >> 2] = 0;
            HEAP32[$17_1 + 4 >> 2] = 0;
            HEAP32[$19_1 >> 2] = 0;
            HEAP32[$19_1 + 4 >> 2] = 0;
            HEAP32[$25_1 >> 2] = 0;
            HEAP32[$25_1 + 4 >> 2] = 0;
            HEAP32[$5_1 + 200 >> 2] = 0;
            HEAP32[$5_1 + 204 >> 2] = 0;
            $15_1 = 0;
            if (($31(HEAP32[172688], $20_1, 655584, $1_1) | 0) == 1) {
              $0_1 = HEAPU8[$14_1 + 4 | 0] | HEAPU8[$14_1 + 5 | 0] << 8 | (HEAPU8[$14_1 + 6 | 0] << 16 | HEAPU8[$14_1 + 7 | 0] << 24);
              $1_1 = $5_1 + 128 | 0;
              $8_1 = $1_1 + 8 | 0;
              HEAP32[$8_1 >> 2] = HEAPU8[$14_1 | 0] | HEAPU8[$14_1 + 1 | 0] << 8 | (HEAPU8[$14_1 + 2 | 0] << 16 | HEAPU8[$14_1 + 3 | 0] << 24);
              HEAP32[$8_1 + 4 >> 2] = $0_1;
              $0_1 = HEAPU8[$13_1 + 4 | 0] | HEAPU8[$13_1 + 5 | 0] << 8 | (HEAPU8[$13_1 + 6 | 0] << 16 | HEAPU8[$13_1 + 7 | 0] << 24);
              $14_1 = $1_1 + 16 | 0;
              HEAP32[$14_1 >> 2] = HEAPU8[$13_1 | 0] | HEAPU8[$13_1 + 1 | 0] << 8 | (HEAPU8[$13_1 + 2 | 0] << 16 | HEAPU8[$13_1 + 3 | 0] << 24);
              HEAP32[$14_1 + 4 >> 2] = $0_1;
              $0_1 = HEAPU8[$11_1 + 4 | 0] | HEAPU8[$11_1 + 5 | 0] << 8 | (HEAPU8[$11_1 + 6 | 0] << 16 | HEAPU8[$11_1 + 7 | 0] << 24);
              $13_1 = $1_1 + 24 | 0;
              HEAP32[$13_1 >> 2] = HEAPU8[$11_1 | 0] | HEAPU8[$11_1 + 1 | 0] << 8 | (HEAPU8[$11_1 + 2 | 0] << 16 | HEAPU8[$11_1 + 3 | 0] << 24);
              HEAP32[$13_1 + 4 >> 2] = $0_1;
              $0_1 = HEAPU8[$12_1 + 4 | 0] | HEAPU8[$12_1 + 5 | 0] << 8 | (HEAPU8[$12_1 + 6 | 0] << 16 | HEAPU8[$12_1 + 7 | 0] << 24);
              $11_1 = $1_1 + 32 | 0;
              HEAP32[$11_1 >> 2] = HEAPU8[$12_1 | 0] | HEAPU8[$12_1 + 1 | 0] << 8 | (HEAPU8[$12_1 + 2 | 0] << 16 | HEAPU8[$12_1 + 3 | 0] << 24);
              HEAP32[$11_1 + 4 >> 2] = $0_1;
              $0_1 = HEAPU8[$6_1 + 4 | 0] | HEAPU8[$6_1 + 5 | 0] << 8 | (HEAPU8[$6_1 + 6 | 0] << 16 | HEAPU8[$6_1 + 7 | 0] << 24);
              $12_1 = $1_1 + 40 | 0;
              HEAP32[$12_1 >> 2] = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8 | (HEAPU8[$6_1 + 2 | 0] << 16 | HEAPU8[$6_1 + 3 | 0] << 24);
              HEAP32[$12_1 + 4 >> 2] = $0_1;
              $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
              $6_1 = $1_1 + 48 | 0;
              HEAP32[$6_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
              HEAP32[$6_1 + 4 >> 2] = $0_1;
              $1_1 = $1_1 + 56 | 0;
              HEAP8[$1_1 | 0] = HEAPU8[$10_1 | 0];
              HEAP8[$5_1 + 66 | 0] = HEAPU8[$5_1 + 202 | 0];
              HEAP16[$5_1 + 64 >> 1] = HEAPU16[$5_1 + 200 >> 1];
              $0_1 = HEAPU8[$5_1 + 211 | 0] | HEAPU8[$5_1 + 212 | 0] << 8 | (HEAPU8[$5_1 + 213 | 0] << 16 | HEAPU8[$5_1 + 214 | 0] << 24);
              HEAP32[$5_1 + 128 >> 2] = HEAPU8[$5_1 + 207 | 0] | HEAPU8[$5_1 + 208 | 0] << 8 | (HEAPU8[$5_1 + 209 | 0] << 16 | HEAPU8[$5_1 + 210 | 0] << 24);
              HEAP32[$5_1 + 132 >> 2] = $0_1;
              $0_1 = HEAPU8[$5_1 + 203 | 0] | HEAPU8[$5_1 + 204 | 0] << 8 | (HEAPU8[$5_1 + 205 | 0] << 16 | HEAPU8[$5_1 + 206 | 0] << 24);
              $7_1 = $5_1 - -64 | 0;
              HEAP8[$7_1 + 63 | 0] = HEAPU8[$1_1 | 0];
              $3_1 = HEAP32[$6_1 + 4 >> 2];
              $10_1 = $7_1 + 55 | 0;
              $1_1 = HEAP32[$6_1 >> 2];
              HEAP8[$10_1 | 0] = $1_1;
              HEAP8[$10_1 + 1 | 0] = $1_1 >>> 8;
              HEAP8[$10_1 + 2 | 0] = $1_1 >>> 16;
              HEAP8[$10_1 + 3 | 0] = $1_1 >>> 24;
              HEAP8[$10_1 + 4 | 0] = $3_1;
              HEAP8[$10_1 + 5 | 0] = $3_1 >>> 8;
              HEAP8[$10_1 + 6 | 0] = $3_1 >>> 16;
              HEAP8[$10_1 + 7 | 0] = $3_1 >>> 24;
              $3_1 = HEAP32[$12_1 + 4 >> 2];
              $6_1 = $7_1 + 47 | 0;
              $1_1 = HEAP32[$12_1 >> 2];
              HEAP8[$6_1 | 0] = $1_1;
              HEAP8[$6_1 + 1 | 0] = $1_1 >>> 8;
              HEAP8[$6_1 + 2 | 0] = $1_1 >>> 16;
              HEAP8[$6_1 + 3 | 0] = $1_1 >>> 24;
              HEAP8[$6_1 + 4 | 0] = $3_1;
              HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
              HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
              HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
              $3_1 = HEAP32[$11_1 + 4 >> 2];
              $6_1 = $7_1 + 39 | 0;
              $1_1 = HEAP32[$11_1 >> 2];
              HEAP8[$6_1 | 0] = $1_1;
              HEAP8[$6_1 + 1 | 0] = $1_1 >>> 8;
              HEAP8[$6_1 + 2 | 0] = $1_1 >>> 16;
              HEAP8[$6_1 + 3 | 0] = $1_1 >>> 24;
              HEAP8[$6_1 + 4 | 0] = $3_1;
              HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
              HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
              HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
              $3_1 = HEAP32[$13_1 + 4 >> 2];
              $6_1 = $7_1 + 31 | 0;
              $1_1 = HEAP32[$13_1 >> 2];
              HEAP8[$6_1 | 0] = $1_1;
              HEAP8[$6_1 + 1 | 0] = $1_1 >>> 8;
              HEAP8[$6_1 + 2 | 0] = $1_1 >>> 16;
              HEAP8[$6_1 + 3 | 0] = $1_1 >>> 24;
              HEAP8[$6_1 + 4 | 0] = $3_1;
              HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
              HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
              HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
              $3_1 = HEAP32[$14_1 + 4 >> 2];
              $6_1 = $7_1 + 23 | 0;
              $1_1 = HEAP32[$14_1 >> 2];
              HEAP8[$6_1 | 0] = $1_1;
              HEAP8[$6_1 + 1 | 0] = $1_1 >>> 8;
              HEAP8[$6_1 + 2 | 0] = $1_1 >>> 16;
              HEAP8[$6_1 + 3 | 0] = $1_1 >>> 24;
              HEAP8[$6_1 + 4 | 0] = $3_1;
              HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
              HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
              HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
              $3_1 = HEAP32[$8_1 + 4 >> 2];
              $6_1 = $7_1 + 15 | 0;
              $1_1 = HEAP32[$8_1 >> 2];
              HEAP8[$6_1 | 0] = $1_1;
              HEAP8[$6_1 + 1 | 0] = $1_1 >>> 8;
              HEAP8[$6_1 + 2 | 0] = $1_1 >>> 16;
              HEAP8[$6_1 + 3 | 0] = $1_1 >>> 24;
              HEAP8[$6_1 + 4 | 0] = $3_1;
              HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
              HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
              HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
              HEAP8[$5_1 + 67 | 0] = $0_1;
              HEAP8[$5_1 + 68 | 0] = $0_1 >>> 8;
              HEAP8[$5_1 + 69 | 0] = $0_1 >>> 16;
              HEAP8[$5_1 + 70 | 0] = $0_1 >>> 24;
              $1_1 = HEAP32[$5_1 + 132 >> 2];
              $0_1 = HEAP32[$5_1 + 128 >> 2];
              HEAP8[$5_1 + 71 | 0] = $0_1;
              HEAP8[$5_1 + 72 | 0] = $0_1 >>> 8;
              HEAP8[$5_1 + 73 | 0] = $0_1 >>> 16;
              HEAP8[$5_1 + 74 | 0] = $0_1 >>> 24;
              HEAP8[$5_1 + 75 | 0] = $1_1;
              HEAP8[$5_1 + 76 | 0] = $1_1 >>> 8;
              HEAP8[$5_1 + 77 | 0] = $1_1 >>> 16;
              HEAP8[$5_1 + 78 | 0] = $1_1 >>> 24;
              $9_1 = $5_1 + 200 | 0;
              $0_1 = $9_1 + 56 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              $0_1 = $9_1 + 48 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              $0_1 = $9_1 + 40 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              $0_1 = $9_1 + 32 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              $0_1 = $9_1 + 24 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              $0_1 = $9_1 + 16 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              $0_1 = $9_1 + 8 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              HEAP32[$5_1 + 200 >> 2] = 0;
              HEAP32[$5_1 + 204 >> 2] = 0;
              HEAP32[$5_1 + 196 >> 2] = $7_1;
              HEAP32[$5_1 + 192 >> 2] = $5_1;
              $16_1 = HEAP32[172688];
              $17_1 = $5_1 + 192 | 0;
              $19_1 = 2;
              $7_1 = global$0 - 224 | 0;
              global$0 = $7_1;
              label$5: {
                if (!$9_1) {
                  FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](689778, HEAP32[$16_1 + 172 >> 2]);
                  $0_1 = 0;
                  break label$5;
                }
                HEAP8[$9_1 | 0] = 0;
                HEAP8[$9_1 + 1 | 0] = 0;
                HEAP8[$9_1 + 2 | 0] = 0;
                HEAP8[$9_1 + 3 | 0] = 0;
                HEAP8[$9_1 + 4 | 0] = 0;
                HEAP8[$9_1 + 5 | 0] = 0;
                HEAP8[$9_1 + 6 | 0] = 0;
                HEAP8[$9_1 + 7 | 0] = 0;
                $0_1 = $9_1 + 56 | 0;
                HEAP8[$0_1 | 0] = 0;
                HEAP8[$0_1 + 1 | 0] = 0;
                HEAP8[$0_1 + 2 | 0] = 0;
                HEAP8[$0_1 + 3 | 0] = 0;
                HEAP8[$0_1 + 4 | 0] = 0;
                HEAP8[$0_1 + 5 | 0] = 0;
                HEAP8[$0_1 + 6 | 0] = 0;
                HEAP8[$0_1 + 7 | 0] = 0;
                $0_1 = $9_1 + 48 | 0;
                HEAP8[$0_1 | 0] = 0;
                HEAP8[$0_1 + 1 | 0] = 0;
                HEAP8[$0_1 + 2 | 0] = 0;
                HEAP8[$0_1 + 3 | 0] = 0;
                HEAP8[$0_1 + 4 | 0] = 0;
                HEAP8[$0_1 + 5 | 0] = 0;
                HEAP8[$0_1 + 6 | 0] = 0;
                HEAP8[$0_1 + 7 | 0] = 0;
                $0_1 = $9_1 + 40 | 0;
                HEAP8[$0_1 | 0] = 0;
                HEAP8[$0_1 + 1 | 0] = 0;
                HEAP8[$0_1 + 2 | 0] = 0;
                HEAP8[$0_1 + 3 | 0] = 0;
                HEAP8[$0_1 + 4 | 0] = 0;
                HEAP8[$0_1 + 5 | 0] = 0;
                HEAP8[$0_1 + 6 | 0] = 0;
                HEAP8[$0_1 + 7 | 0] = 0;
                $0_1 = $9_1 + 32 | 0;
                HEAP8[$0_1 | 0] = 0;
                HEAP8[$0_1 + 1 | 0] = 0;
                HEAP8[$0_1 + 2 | 0] = 0;
                HEAP8[$0_1 + 3 | 0] = 0;
                HEAP8[$0_1 + 4 | 0] = 0;
                HEAP8[$0_1 + 5 | 0] = 0;
                HEAP8[$0_1 + 6 | 0] = 0;
                HEAP8[$0_1 + 7 | 0] = 0;
                $0_1 = $9_1 + 24 | 0;
                HEAP8[$0_1 | 0] = 0;
                HEAP8[$0_1 + 1 | 0] = 0;
                HEAP8[$0_1 + 2 | 0] = 0;
                HEAP8[$0_1 + 3 | 0] = 0;
                HEAP8[$0_1 + 4 | 0] = 0;
                HEAP8[$0_1 + 5 | 0] = 0;
                HEAP8[$0_1 + 6 | 0] = 0;
                HEAP8[$0_1 + 7 | 0] = 0;
                $0_1 = $9_1 + 16 | 0;
                HEAP8[$0_1 | 0] = 0;
                HEAP8[$0_1 + 1 | 0] = 0;
                HEAP8[$0_1 + 2 | 0] = 0;
                HEAP8[$0_1 + 3 | 0] = 0;
                HEAP8[$0_1 + 4 | 0] = 0;
                HEAP8[$0_1 + 5 | 0] = 0;
                HEAP8[$0_1 + 6 | 0] = 0;
                HEAP8[$0_1 + 7 | 0] = 0;
                $0_1 = $9_1 + 8 | 0;
                HEAP8[$0_1 | 0] = 0;
                HEAP8[$0_1 + 1 | 0] = 0;
                HEAP8[$0_1 + 2 | 0] = 0;
                HEAP8[$0_1 + 3 | 0] = 0;
                HEAP8[$0_1 + 4 | 0] = 0;
                HEAP8[$0_1 + 5 | 0] = 0;
                HEAP8[$0_1 + 6 | 0] = 0;
                HEAP8[$0_1 + 7 | 0] = 0;
                if (!$17_1) {
                  FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](689682, HEAP32[$16_1 + 172 >> 2]);
                  $0_1 = 0;
                  break label$5;
                }
                HEAP32[$7_1 + 216 >> 2] = 1;
                $68($7_1 + 96 | 0, 120);
                $25_1 = $16_1 + 172 | 0;
                while (1) {
                  $4_1 = HEAP32[$17_1 >> 2];
                  if (!$4_1) {
                    FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](689809, HEAP32[$16_1 + 172 >> 2]);
                    $0_1 = 0;
                    break label$5;
                  }
                  HEAP32[$7_1 + 88 >> 2] = 0;
                  $1_1 = HEAPU8[$4_1 + 60 | 0] | HEAPU8[$4_1 + 61 | 0] << 8 | (HEAPU8[$4_1 + 62 | 0] << 16 | HEAPU8[$4_1 + 63 | 0] << 24);
                  $11_1 = $1_1 >>> 16 | 0;
                  $0_1 = $7_1;
                  $3_1 = HEAPU8[$4_1 + 56 | 0] | HEAPU8[$4_1 + 57 | 0] << 8 | (HEAPU8[$4_1 + 58 | 0] << 16 | HEAPU8[$4_1 + 59 | 0] << 24);
                  HEAP32[$0_1 + 80 >> 2] = ($1_1 & 65535) << 16 | $3_1 >>> 16;
                  HEAP32[$0_1 + 84 >> 2] = $11_1;
                  $6_1 = HEAPU8[$4_1 + 36 | 0] | HEAPU8[$4_1 + 37 | 0] << 8 | (HEAPU8[$4_1 + 38 | 0] << 16 | HEAPU8[$4_1 + 39 | 0] << 24);
                  HEAP32[$0_1 + 48 >> 2] = HEAPU8[$4_1 + 32 | 0] | HEAPU8[$4_1 + 33 | 0] << 8 | (HEAPU8[$4_1 + 34 | 0] << 16 | HEAPU8[$4_1 + 35 | 0] << 24);
                  HEAP32[$0_1 + 52 >> 2] = $6_1 & 1048575;
                  $11_1 = $3_1 << 4 & 1048560;
                  $1_1 = HEAPU8[$4_1 + 52 | 0] | HEAPU8[$4_1 + 53 | 0] << 8 | (HEAPU8[$4_1 + 54 | 0] << 16 | HEAPU8[$4_1 + 55 | 0] << 24);
                  $8_1 = $1_1 >>> 28 | 0;
                  $3_1 = HEAPU8[$4_1 + 48 | 0] | HEAPU8[$4_1 + 49 | 0] << 8 | (HEAPU8[$4_1 + 50 | 0] << 16 | HEAPU8[$4_1 + 51 | 0] << 24);
                  HEAP32[$0_1 + 72 >> 2] = ($1_1 & 268435455) << 4 | $3_1 >>> 28;
                  HEAP32[$0_1 + 76 >> 2] = $8_1 | $11_1;
                  $11_1 = $1_1 << 24 | $3_1 >>> 8;
                  $13_1 = $3_1 << 24 & -16777216;
                  $3_1 = HEAPU8[$4_1 + 40 | 0] | HEAPU8[$4_1 + 41 | 0] << 8 | (HEAPU8[$4_1 + 42 | 0] << 16 | HEAPU8[$4_1 + 43 | 0] << 24);
                  $1_1 = HEAPU8[$4_1 + 44 | 0] | HEAPU8[$4_1 + 45 | 0] << 8 | (HEAPU8[$4_1 + 46 | 0] << 16 | HEAPU8[$4_1 + 47 | 0] << 24);
                  HEAP32[$0_1 + 64 >> 2] = $1_1 >>> 8 | $13_1;
                  HEAP32[$0_1 + 68 >> 2] = $11_1 & 1048575;
                  $18_1 = $1_1 << 12 | $3_1 >>> 20;
                  HEAP32[$0_1 + 56 >> 2] = $3_1 << 12 & -4096 | $6_1 >>> 20;
                  HEAP32[$0_1 + 60 >> 2] = $18_1 & 1048575;
                  $3_1 = HEAPU8[$4_1 + 12 | 0] | HEAPU8[$4_1 + 13 | 0] << 8 | (HEAPU8[$4_1 + 14 | 0] << 16 | HEAPU8[$4_1 + 15 | 0] << 24);
                  $10_1 = $3_1;
                  $1_1 = HEAPU8[$4_1 + 8 | 0] | HEAPU8[$4_1 + 9 | 0] << 8 | (HEAPU8[$4_1 + 10 | 0] << 16 | HEAPU8[$4_1 + 11 | 0] << 24);
                  $18_1 = $3_1 << 12 | $1_1 >>> 20;
                  $12_1 = $1_1 << 12 & -4096;
                  $14_1 = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
                  $1_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
                  $3_1 = $1_1;
                  $22_1 = $3_1 >>> 20 | $12_1;
                  HEAP32[$0_1 + 16 >> 2] = $22_1;
                  $23_1 = $18_1 & 1048575;
                  HEAP32[$0_1 + 20 >> 2] = $23_1;
                  HEAP32[$0_1 + 8 >> 2] = $14_1;
                  $24_1 = $3_1 & 1048575;
                  HEAP32[$0_1 + 12 >> 2] = $24_1;
                  $1_1 = HEAPU8[$4_1 + 24 | 0] | HEAPU8[$4_1 + 25 | 0] << 8 | (HEAPU8[$4_1 + 26 | 0] << 16 | HEAPU8[$4_1 + 27 | 0] << 24);
                  $13_1 = $1_1;
                  $3_1 = HEAPU8[$4_1 + 28 | 0] | HEAPU8[$4_1 + 29 | 0] << 8 | (HEAPU8[$4_1 + 30 | 0] << 16 | HEAPU8[$4_1 + 31 | 0] << 24);
                  $6_1 = ($3_1 & 65535) << 16 | $1_1 >>> 16;
                  HEAP32[$0_1 + 40 >> 2] = $6_1;
                  $12_1 = $3_1 >>> 16 | 0;
                  HEAP32[$0_1 + 44 >> 2] = $12_1;
                  $1_1 = HEAPU8[$4_1 + 16 | 0] | HEAPU8[$4_1 + 17 | 0] << 8 | (HEAPU8[$4_1 + 18 | 0] << 16 | HEAPU8[$4_1 + 19 | 0] << 24);
                  $3_1 = HEAPU8[$4_1 + 20 | 0] | HEAPU8[$4_1 + 21 | 0] << 8 | (HEAPU8[$4_1 + 22 | 0] << 16 | HEAPU8[$4_1 + 23 | 0] << 24);
                  $8_1 = $3_1 << 24 | $1_1 >>> 8;
                  $4_1 = $1_1 << 24 & -16777216 | $10_1 >>> 8;
                  HEAP32[$0_1 + 24 >> 2] = $4_1;
                  $10_1 = $8_1 & 1048575;
                  HEAP32[$0_1 + 28 >> 2] = $10_1;
                  $11_1 = $13_1 << 4 & 1048560;
                  $1_1 = ($3_1 & 268435455) << 4 | $1_1 >>> 28;
                  HEAP32[$0_1 + 32 >> 2] = $1_1;
                  $0_1 = $3_1 >>> 28 | $11_1;
                  HEAP32[$7_1 + 36 >> 2] = $0_1;
                  if (!($14_1 | $22_1 | $6_1 | $4_1 | $1_1 | ($23_1 | $24_1 | $12_1 | $10_1 | $0_1))) {
                    FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](690116, HEAP32[$25_1 >> 2]);
                  }
                  $17_1 = $17_1 + 4 | 0;
                  $0_1 = $7_1 + 96 | 0;
                  $53($0_1, $0_1, $7_1 + 8 | 0);
                  $19_1 = $19_1 - 1 | 0;
                  if ($19_1) {
                    continue;
                  }
                  break;
                }
                ;
                $0_1 = 0;
                if (HEAP32[$7_1 + 216 >> 2]) {
                  break label$5;
                }
                $0_1 = $7_1 + 8 | 0;
                $49($0_1, $7_1 + 96 | 0);
                $35($9_1, $0_1);
                $0_1 = 1;
              }
              global$0 = $7_1 + 224 | 0;
              if (!$0_1) {
                break label$1;
              }
              HEAP32[$5_1 + 264 >> 2] = $2_1;
              $0_1 = $36(HEAP32[172688], $5_1 + 264 | 0, $5_1 + 200 | 0, ($2_1 | 0) == 33 ? 258 : 2);
              HEAP32[$5_1 + 268 >> 2] = $0_1;
              if (($0_1 | 0) != 1) {
                break label$2;
              }
              $15_1 = 1;
              break label$1;
            }
            fimport$1(1);
            break label$1;
          }
          fimport$1(1);
          break label$1;
        }
        HEAP32[$5_1 + 136 >> 2] = 0;
        $5($5_1 + 128 | 0);
        wasm2js_trap();
      }
      global$0 = $5_1 + 272 | 0;
      return $15_1 | 0;
    }
    function $10($0_1, $1_1) {
      $0_1 = $0_1 | 0;
      $1_1 = $1_1 | 0;
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0;
      $6_1 = global$0 - 208 | 0;
      global$0 = $6_1;
      $2_1 = $6_1 + 136 | 0;
      $3_1 = $2_1 + 56 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $3_1 = $2_1 + 48 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $3_1 = $2_1 + 40 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $3_1 = $2_1 + 32 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $3_1 = $2_1 + 24 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $3_1 = $2_1 + 16 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $3_1 = $2_1 + 8 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      HEAP32[$6_1 + 136 >> 2] = 0;
      HEAP32[$6_1 + 140 >> 2] = 0;
      label$1: {
        if (($31(HEAP32[172688], $2_1, 690820, $0_1) | 0) == 1) {
          $9_1 = $6_1 + 136 | 0;
          $2_1 = $9_1 + 15 | 0;
          $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
          $3_1 = $6_1 + 72 | 0;
          $13_1 = $3_1 + 8 | 0;
          HEAP32[$13_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
          HEAP32[$13_1 + 4 >> 2] = $0_1;
          $2_1 = $9_1 + 23 | 0;
          $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
          $11_1 = $3_1 + 16 | 0;
          HEAP32[$11_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
          HEAP32[$11_1 + 4 >> 2] = $0_1;
          $2_1 = $9_1 + 31 | 0;
          $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
          $12_1 = $3_1 + 24 | 0;
          HEAP32[$12_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
          HEAP32[$12_1 + 4 >> 2] = $0_1;
          $2_1 = $9_1 + 39 | 0;
          $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
          $10_1 = $3_1 + 32 | 0;
          HEAP32[$10_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
          HEAP32[$10_1 + 4 >> 2] = $0_1;
          $2_1 = $9_1 + 47 | 0;
          $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
          $7_1 = $3_1 + 40 | 0;
          HEAP32[$7_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
          HEAP32[$7_1 + 4 >> 2] = $0_1;
          $8_1 = $9_1 + 55 | 0;
          $0_1 = HEAPU8[$8_1 + 4 | 0] | HEAPU8[$8_1 + 5 | 0] << 8 | (HEAPU8[$8_1 + 6 | 0] << 16 | HEAPU8[$8_1 + 7 | 0] << 24);
          $2_1 = $3_1 + 48 | 0;
          HEAP32[$2_1 >> 2] = HEAPU8[$8_1 | 0] | HEAPU8[$8_1 + 1 | 0] << 8 | (HEAPU8[$8_1 + 2 | 0] << 16 | HEAPU8[$8_1 + 3 | 0] << 24);
          HEAP32[$2_1 + 4 >> 2] = $0_1;
          $3_1 = $3_1 + 56 | 0;
          HEAP8[$3_1 | 0] = HEAPU8[$9_1 + 63 | 0];
          HEAP8[$6_1 + 10 | 0] = HEAPU8[$6_1 + 138 | 0];
          HEAP16[$6_1 + 8 >> 1] = HEAPU16[$6_1 + 136 >> 1];
          $0_1 = HEAPU8[$6_1 + 147 | 0] | HEAPU8[$6_1 + 148 | 0] << 8 | (HEAPU8[$6_1 + 149 | 0] << 16 | HEAPU8[$6_1 + 150 | 0] << 24);
          HEAP32[$6_1 + 72 >> 2] = HEAPU8[$6_1 + 143 | 0] | HEAPU8[$6_1 + 144 | 0] << 8 | (HEAPU8[$6_1 + 145 | 0] << 16 | HEAPU8[$6_1 + 146 | 0] << 24);
          HEAP32[$6_1 + 76 >> 2] = $0_1;
          $9_1 = HEAPU8[$6_1 + 139 | 0] | HEAPU8[$6_1 + 140 | 0] << 8 | (HEAPU8[$6_1 + 141 | 0] << 16 | HEAPU8[$6_1 + 142 | 0] << 24);
          $4_1 = $6_1 + 8 | 0;
          HEAP8[$4_1 + 63 | 0] = HEAPU8[$3_1 | 0];
          $3_1 = HEAP32[$2_1 + 4 >> 2];
          $8_1 = $4_1 + 55 | 0;
          $0_1 = HEAP32[$2_1 >> 2];
          HEAP8[$8_1 | 0] = $0_1;
          HEAP8[$8_1 + 1 | 0] = $0_1 >>> 8;
          HEAP8[$8_1 + 2 | 0] = $0_1 >>> 16;
          HEAP8[$8_1 + 3 | 0] = $0_1 >>> 24;
          HEAP8[$8_1 + 4 | 0] = $3_1;
          HEAP8[$8_1 + 5 | 0] = $3_1 >>> 8;
          HEAP8[$8_1 + 6 | 0] = $3_1 >>> 16;
          HEAP8[$8_1 + 7 | 0] = $3_1 >>> 24;
          $3_1 = HEAP32[$7_1 + 4 >> 2];
          $2_1 = $4_1 + 47 | 0;
          $0_1 = HEAP32[$7_1 >> 2];
          HEAP8[$2_1 | 0] = $0_1;
          HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $3_1;
          HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
          $3_1 = HEAP32[$10_1 + 4 >> 2];
          $2_1 = $4_1 + 39 | 0;
          $0_1 = HEAP32[$10_1 >> 2];
          HEAP8[$2_1 | 0] = $0_1;
          HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $3_1;
          HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
          $3_1 = HEAP32[$12_1 + 4 >> 2];
          $2_1 = $4_1 + 31 | 0;
          $0_1 = HEAP32[$12_1 >> 2];
          HEAP8[$2_1 | 0] = $0_1;
          HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $3_1;
          HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
          $3_1 = HEAP32[$11_1 + 4 >> 2];
          $2_1 = $4_1 + 23 | 0;
          $0_1 = HEAP32[$11_1 >> 2];
          HEAP8[$2_1 | 0] = $0_1;
          HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $3_1;
          HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
          $3_1 = HEAP32[$13_1 + 4 >> 2];
          $2_1 = $4_1 + 15 | 0;
          $0_1 = HEAP32[$13_1 >> 2];
          HEAP8[$2_1 | 0] = $0_1;
          HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $3_1;
          HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
          HEAP8[$6_1 + 11 | 0] = $9_1;
          HEAP8[$6_1 + 12 | 0] = $9_1 >>> 8;
          HEAP8[$6_1 + 13 | 0] = $9_1 >>> 16;
          HEAP8[$6_1 + 14 | 0] = $9_1 >>> 24;
          $3_1 = HEAP32[$6_1 + 76 >> 2];
          $0_1 = HEAP32[$6_1 + 72 >> 2];
          HEAP8[$6_1 + 15 | 0] = $0_1;
          HEAP8[$6_1 + 16 | 0] = $0_1 >>> 8;
          HEAP8[$6_1 + 17 | 0] = $0_1 >>> 16;
          HEAP8[$6_1 + 18 | 0] = $0_1 >>> 24;
          HEAP8[$6_1 + 19 | 0] = $3_1;
          HEAP8[$6_1 + 20 | 0] = $3_1 >>> 8;
          HEAP8[$6_1 + 21 | 0] = $3_1 >>> 16;
          HEAP8[$6_1 + 22 | 0] = $3_1 >>> 24;
          $14_1 = $6();
          $5_1 = global$0 - 288 | 0;
          global$0 = $5_1;
          label$3: {
            if (!$4_1) {
              FUNCTION_TABLE[HEAP32[$14_1 + 168 >> 2]](689638, HEAP32[$14_1 + 172 >> 2]);
              break label$3;
            }
            $0_1 = HEAPU8[$4_1 + 60 | 0] | HEAPU8[$4_1 + 61 | 0] << 8 | (HEAPU8[$4_1 + 62 | 0] << 16 | HEAPU8[$4_1 + 63 | 0] << 24);
            $11_1 = $0_1 >>> 16 | 0;
            $7_1 = $5_1 + 72 | 0;
            $3_1 = HEAPU8[$4_1 + 56 | 0] | HEAPU8[$4_1 + 57 | 0] << 8 | (HEAPU8[$4_1 + 58 | 0] << 16 | HEAPU8[$4_1 + 59 | 0] << 24);
            HEAP32[$7_1 >> 2] = ($0_1 & 65535) << 16 | $3_1 >>> 16;
            HEAP32[$7_1 + 4 >> 2] = $11_1;
            $7_1 = $3_1 << 4 & 1048560;
            $0_1 = HEAPU8[$4_1 + 52 | 0] | HEAPU8[$4_1 + 53 | 0] << 8 | (HEAPU8[$4_1 + 54 | 0] << 16 | HEAPU8[$4_1 + 55 | 0] << 24);
            $8_1 = $0_1 >>> 28 | 0;
            $10_1 = $5_1 - -64 | 0;
            $3_1 = HEAPU8[$4_1 + 48 | 0] | HEAPU8[$4_1 + 49 | 0] << 8 | (HEAPU8[$4_1 + 50 | 0] << 16 | HEAPU8[$4_1 + 51 | 0] << 24);
            HEAP32[$10_1 >> 2] = ($0_1 & 268435455) << 4 | $3_1 >>> 28;
            HEAP32[$10_1 + 4 >> 2] = $7_1 | $8_1;
            $11_1 = $0_1 << 24 | $3_1 >>> 8;
            $10_1 = $3_1 << 24 & -16777216;
            $3_1 = HEAPU8[$4_1 + 40 | 0] | HEAPU8[$4_1 + 41 | 0] << 8 | (HEAPU8[$4_1 + 42 | 0] << 16 | HEAPU8[$4_1 + 43 | 0] << 24);
            $12_1 = $5_1 + 56 | 0;
            $0_1 = HEAPU8[$4_1 + 44 | 0] | HEAPU8[$4_1 + 45 | 0] << 8 | (HEAPU8[$4_1 + 46 | 0] << 16 | HEAPU8[$4_1 + 47 | 0] << 24);
            HEAP32[$12_1 >> 2] = $0_1 >>> 8 | $10_1;
            HEAP32[$12_1 + 4 >> 2] = $11_1 & 1048575;
            $11_1 = $0_1 << 12 | $3_1 >>> 20;
            $10_1 = $3_1 << 12 & -4096;
            $2_1 = HEAPU8[$4_1 + 32 | 0] | HEAPU8[$4_1 + 33 | 0] << 8 | (HEAPU8[$4_1 + 34 | 0] << 16 | HEAPU8[$4_1 + 35 | 0] << 24);
            $0_1 = HEAPU8[$4_1 + 36 | 0] | HEAPU8[$4_1 + 37 | 0] << 8 | (HEAPU8[$4_1 + 38 | 0] << 16 | HEAPU8[$4_1 + 39 | 0] << 24);
            $12_1 = $5_1 + 48 | 0;
            HEAP32[$12_1 >> 2] = $0_1 >>> 20 | $10_1;
            HEAP32[$12_1 + 4 >> 2] = $11_1 & 1048575;
            HEAP32[$5_1 + 80 >> 2] = 0;
            HEAP32[$5_1 + 40 >> 2] = $2_1;
            HEAP32[$5_1 + 44 >> 2] = $0_1 & 1048575;
            $2_1 = HEAPU8[$4_1 + 12 | 0] | HEAPU8[$4_1 + 13 | 0] << 8 | (HEAPU8[$4_1 + 14 | 0] << 16 | HEAPU8[$4_1 + 15 | 0] << 24);
            $9_1 = $2_1;
            $3_1 = HEAPU8[$4_1 + 8 | 0] | HEAPU8[$4_1 + 9 | 0] << 8 | (HEAPU8[$4_1 + 10 | 0] << 16 | HEAPU8[$4_1 + 11 | 0] << 24);
            $11_1 = $2_1 << 12 | $3_1 >>> 20;
            $10_1 = $3_1 << 12 & -4096;
            $13_1 = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
            $3_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
            $2_1 = $3_1;
            $0_1 = $5_1;
            $15_1 = $2_1 >>> 20 | $10_1;
            HEAP32[$0_1 + 8 >> 2] = $15_1;
            $16_1 = $11_1 & 1048575;
            HEAP32[$0_1 + 12 >> 2] = $16_1;
            HEAP32[$0_1 >> 2] = $13_1;
            $17_1 = $2_1 & 1048575;
            HEAP32[$0_1 + 4 >> 2] = $17_1;
            $3_1 = HEAPU8[$4_1 + 24 | 0] | HEAPU8[$4_1 + 25 | 0] << 8 | (HEAPU8[$4_1 + 26 | 0] << 16 | HEAPU8[$4_1 + 27 | 0] << 24);
            $11_1 = $3_1;
            $2_1 = HEAPU8[$4_1 + 28 | 0] | HEAPU8[$4_1 + 29 | 0] << 8 | (HEAPU8[$4_1 + 30 | 0] << 16 | HEAPU8[$4_1 + 31 | 0] << 24);
            $7_1 = ($2_1 & 65535) << 16 | $3_1 >>> 16;
            HEAP32[$0_1 + 32 >> 2] = $7_1;
            $10_1 = $2_1 >>> 16 | 0;
            HEAP32[$0_1 + 36 >> 2] = $10_1;
            $3_1 = HEAPU8[$4_1 + 16 | 0] | HEAPU8[$4_1 + 17 | 0] << 8 | (HEAPU8[$4_1 + 18 | 0] << 16 | HEAPU8[$4_1 + 19 | 0] << 24);
            $2_1 = HEAPU8[$4_1 + 20 | 0] | HEAPU8[$4_1 + 21 | 0] << 8 | (HEAPU8[$4_1 + 22 | 0] << 16 | HEAPU8[$4_1 + 23 | 0] << 24);
            $8_1 = $2_1 << 24 | $3_1 >>> 8;
            $18_1 = $3_1 << 24 & -16777216 | $9_1 >>> 8;
            HEAP32[$0_1 + 16 >> 2] = $18_1;
            $9_1 = $8_1 & 1048575;
            HEAP32[$0_1 + 20 >> 2] = $9_1;
            $12_1 = $11_1 << 4 & 1048560;
            $3_1 = ($2_1 & 268435455) << 4 | $3_1 >>> 28;
            HEAP32[$0_1 + 24 >> 2] = $3_1;
            $0_1 = $2_1 >>> 28 | $12_1;
            HEAP32[$5_1 + 28 >> 2] = $0_1;
            if (!($13_1 | $15_1 | $7_1 | $18_1 | $3_1 | ($16_1 | $17_1 | $10_1 | $9_1 | $0_1))) {
              FUNCTION_TABLE[HEAP32[$14_1 + 168 >> 2]](690116, HEAP32[$14_1 + 172 >> 2]);
              $0_1 = $4_1 + 56 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $4_1 + 48 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $4_1 + 40 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $4_1 + 32 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $4_1 + 24 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $4_1 + 16 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $4_1 + 8 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              HEAP8[$4_1 | 0] = 0;
              HEAP8[$4_1 + 1 | 0] = 0;
              HEAP8[$4_1 + 2 | 0] = 0;
              HEAP8[$4_1 + 3 | 0] = 0;
              HEAP8[$4_1 + 4 | 0] = 0;
              HEAP8[$4_1 + 5 | 0] = 0;
              HEAP8[$4_1 + 6 | 0] = 0;
              HEAP8[$4_1 + 7 | 0] = 0;
              break label$3;
            }
            HEAP8[$4_1 | 0] = 0;
            HEAP8[$4_1 + 1 | 0] = 0;
            HEAP8[$4_1 + 2 | 0] = 0;
            HEAP8[$4_1 + 3 | 0] = 0;
            HEAP8[$4_1 + 4 | 0] = 0;
            HEAP8[$4_1 + 5 | 0] = 0;
            HEAP8[$4_1 + 6 | 0] = 0;
            HEAP8[$4_1 + 7 | 0] = 0;
            $0_1 = $4_1 + 56 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $4_1 + 48 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $4_1 + 40 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $4_1 + 32 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $4_1 + 24 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $4_1 + 16 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $4_1 + 8 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            HEAP32[$5_1 + 92 >> 2] = 0;
            $38($5_1 + 96 | 0, 690949, $5_1 + 92 | 0);
            if (HEAP32[$5_1 + 92 >> 2]) {
              break label$3;
            }
            $2_1 = $5_1 + 8 | 0;
            $3_1 = HEAP32[$2_1 + 4 >> 2];
            $7_1 = $5_1 + 160 | 0;
            $0_1 = $7_1 + 8 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $3_1;
            $2_1 = $5_1 + 16 | 0;
            $3_1 = HEAP32[$2_1 + 4 >> 2];
            $0_1 = $7_1 + 16 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $3_1;
            $2_1 = $5_1 + 24 | 0;
            $3_1 = HEAP32[$2_1 + 4 >> 2];
            $0_1 = $7_1 + 24 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $3_1;
            $2_1 = $5_1 + 32 | 0;
            $3_1 = HEAP32[$2_1 + 4 >> 2];
            $0_1 = $7_1 + 32 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $3_1;
            $2_1 = $5_1 + 48 | 0;
            $3_1 = HEAP32[$2_1 + 4 >> 2];
            $0_1 = $7_1 + 48 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $3_1;
            $2_1 = $5_1 + 56 | 0;
            $3_1 = HEAP32[$2_1 + 4 >> 2];
            $0_1 = $7_1 + 56 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $3_1;
            $2_1 = $5_1 - -64 | 0;
            $3_1 = HEAP32[$2_1 + 4 >> 2];
            $0_1 = $7_1 - -64 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $3_1;
            $2_1 = $5_1 + 72 | 0;
            $3_1 = HEAP32[$2_1 + 4 >> 2];
            $0_1 = $7_1 + 72 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $3_1;
            HEAP32[$5_1 + 280 >> 2] = 0;
            $0_1 = HEAP32[$5_1 + 4 >> 2];
            HEAP32[$5_1 + 160 >> 2] = HEAP32[$5_1 >> 2];
            HEAP32[$5_1 + 164 >> 2] = $0_1;
            $0_1 = HEAP32[$5_1 + 44 >> 2];
            HEAP32[$5_1 + 200 >> 2] = HEAP32[$5_1 + 40 >> 2];
            HEAP32[$5_1 + 204 >> 2] = $0_1;
            $0_1 = $5_1 + 248 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $5_1 + 256 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $5_1 + 264 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $5_1 + 272 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $3_1 = $5_1 + 128 | 0;
            $0_1 = $3_1 + 16 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $3_1 + 24 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            HEAP32[$5_1 + 240 >> 2] = 1;
            HEAP32[$5_1 + 244 >> 2] = 0;
            HEAP32[$5_1 + 136 >> 2] = 0;
            HEAP32[$5_1 + 140 >> 2] = 0;
            HEAP32[$5_1 + 128 >> 2] = 1;
            HEAP32[$5_1 + 132 >> 2] = 0;
            $42($7_1, $7_1, $3_1, $5_1 + 96 | 0);
            if (HEAP32[$5_1 + 280 >> 2]) {
              break label$3;
            }
            $49($5_1, $5_1 + 160 | 0);
            $35($4_1, $5_1);
            $19_1 = 1;
          }
          global$0 = $5_1 + 288 | 0;
          if (!$19_1) {
            break label$1;
          }
          HEAP32[$6_1 + 204 >> 2] = $1_1;
          $0_1 = $36(HEAP32[172688], $6_1 + 204 | 0, $6_1 + 8 | 0, ($1_1 | 0) == 33 ? 258 : 2);
          HEAP32[$6_1 + 72 >> 2] = $0_1;
          $20_1 = 1;
          if (($0_1 | 0) == 1) {
            break label$1;
          }
          HEAP32[$6_1 + 144 >> 2] = 0;
          $5($6_1 + 136 | 0);
          wasm2js_trap();
        }
        fimport$1(1);
      }
      global$0 = $6_1 + 208 | 0;
      return $20_1 | 0;
    }
    function $11() {
      var $0_1 = 0, $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0;
      $6_1 = global$0 - 208 | 0;
      global$0 = $6_1;
      $2_1 = $6_1 + 136 | 0;
      $16_1 = $2_1 + 56 | 0;
      HEAP32[$16_1 >> 2] = 0;
      HEAP32[$16_1 + 4 >> 2] = 0;
      $17_1 = $2_1 + 48 | 0;
      HEAP32[$17_1 >> 2] = 0;
      HEAP32[$17_1 + 4 >> 2] = 0;
      $12_1 = $2_1 + 40 | 0;
      HEAP32[$12_1 >> 2] = 0;
      HEAP32[$12_1 + 4 >> 2] = 0;
      $18_1 = $2_1 + 32 | 0;
      HEAP32[$18_1 >> 2] = 0;
      HEAP32[$18_1 + 4 >> 2] = 0;
      $5_1 = $2_1 + 24 | 0;
      HEAP32[$5_1 >> 2] = 0;
      HEAP32[$5_1 + 4 >> 2] = 0;
      $15_1 = $2_1 + 16 | 0;
      HEAP32[$15_1 >> 2] = 0;
      HEAP32[$15_1 + 4 >> 2] = 0;
      $14_1 = $2_1 + 8 | 0;
      HEAP32[$14_1 >> 2] = 0;
      HEAP32[$14_1 + 4 >> 2] = 0;
      HEAP32[$6_1 + 136 >> 2] = 0;
      HEAP32[$6_1 + 140 >> 2] = 0;
      label$1: {
        label$2: {
          if (($57(HEAP32[172688], $2_1, 690885) | 0) == 1) {
            $8_1 = $6_1 + 136 | 0;
            $1_1 = $8_1 + 15 | 0;
            $0_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
            $2_1 = $6_1 + 72 | 0;
            $19_1 = $2_1 + 8 | 0;
            HEAP32[$19_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
            HEAP32[$19_1 + 4 >> 2] = $0_1;
            $1_1 = $8_1 + 23 | 0;
            $0_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
            $10_1 = $2_1 + 16 | 0;
            HEAP32[$10_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
            HEAP32[$10_1 + 4 >> 2] = $0_1;
            $1_1 = $8_1 + 31 | 0;
            $0_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
            $11_1 = $2_1 + 24 | 0;
            HEAP32[$11_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
            HEAP32[$11_1 + 4 >> 2] = $0_1;
            $1_1 = $8_1 + 39 | 0;
            $0_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
            $9_1 = $2_1 + 32 | 0;
            HEAP32[$9_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
            HEAP32[$9_1 + 4 >> 2] = $0_1;
            $1_1 = $8_1 + 47 | 0;
            $0_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
            $4_1 = $2_1 + 40 | 0;
            HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
            HEAP32[$4_1 + 4 >> 2] = $0_1;
            $7_1 = $8_1 + 55 | 0;
            $0_1 = HEAPU8[$7_1 + 4 | 0] | HEAPU8[$7_1 + 5 | 0] << 8 | (HEAPU8[$7_1 + 6 | 0] << 16 | HEAPU8[$7_1 + 7 | 0] << 24);
            $1_1 = $2_1 + 48 | 0;
            HEAP32[$1_1 >> 2] = HEAPU8[$7_1 | 0] | HEAPU8[$7_1 + 1 | 0] << 8 | (HEAPU8[$7_1 + 2 | 0] << 16 | HEAPU8[$7_1 + 3 | 0] << 24);
            HEAP32[$1_1 + 4 >> 2] = $0_1;
            $2_1 = $2_1 + 56 | 0;
            HEAP8[$2_1 | 0] = HEAPU8[$8_1 + 63 | 0];
            HEAP8[$6_1 + 10 | 0] = HEAPU8[$6_1 + 138 | 0];
            HEAP16[$6_1 + 8 >> 1] = HEAPU16[$6_1 + 136 >> 1];
            $0_1 = HEAPU8[$6_1 + 147 | 0] | HEAPU8[$6_1 + 148 | 0] << 8 | (HEAPU8[$6_1 + 149 | 0] << 16 | HEAPU8[$6_1 + 150 | 0] << 24);
            HEAP32[$6_1 + 72 >> 2] = HEAPU8[$6_1 + 143 | 0] | HEAPU8[$6_1 + 144 | 0] << 8 | (HEAPU8[$6_1 + 145 | 0] << 16 | HEAPU8[$6_1 + 146 | 0] << 24);
            HEAP32[$6_1 + 76 >> 2] = $0_1;
            $0_1 = HEAPU8[$6_1 + 139 | 0] | HEAPU8[$6_1 + 140 | 0] << 8 | (HEAPU8[$6_1 + 141 | 0] << 16 | HEAPU8[$6_1 + 142 | 0] << 24);
            $3_1 = $6_1 + 8 | 0;
            HEAP8[$3_1 + 63 | 0] = HEAPU8[$2_1 | 0];
            $7_1 = HEAP32[$1_1 + 4 >> 2];
            $13_1 = $3_1 + 55 | 0;
            $2_1 = HEAP32[$1_1 >> 2];
            HEAP8[$13_1 | 0] = $2_1;
            HEAP8[$13_1 + 1 | 0] = $2_1 >>> 8;
            HEAP8[$13_1 + 2 | 0] = $2_1 >>> 16;
            HEAP8[$13_1 + 3 | 0] = $2_1 >>> 24;
            HEAP8[$13_1 + 4 | 0] = $7_1;
            HEAP8[$13_1 + 5 | 0] = $7_1 >>> 8;
            HEAP8[$13_1 + 6 | 0] = $7_1 >>> 16;
            HEAP8[$13_1 + 7 | 0] = $7_1 >>> 24;
            $1_1 = HEAP32[$4_1 + 4 >> 2];
            $7_1 = $3_1 + 47 | 0;
            $2_1 = HEAP32[$4_1 >> 2];
            HEAP8[$7_1 | 0] = $2_1;
            HEAP8[$7_1 + 1 | 0] = $2_1 >>> 8;
            HEAP8[$7_1 + 2 | 0] = $2_1 >>> 16;
            HEAP8[$7_1 + 3 | 0] = $2_1 >>> 24;
            HEAP8[$7_1 + 4 | 0] = $1_1;
            HEAP8[$7_1 + 5 | 0] = $1_1 >>> 8;
            HEAP8[$7_1 + 6 | 0] = $1_1 >>> 16;
            HEAP8[$7_1 + 7 | 0] = $1_1 >>> 24;
            $1_1 = HEAP32[$9_1 + 4 >> 2];
            $4_1 = $3_1 + 39 | 0;
            $2_1 = HEAP32[$9_1 >> 2];
            HEAP8[$4_1 | 0] = $2_1;
            HEAP8[$4_1 + 1 | 0] = $2_1 >>> 8;
            HEAP8[$4_1 + 2 | 0] = $2_1 >>> 16;
            HEAP8[$4_1 + 3 | 0] = $2_1 >>> 24;
            HEAP8[$4_1 + 4 | 0] = $1_1;
            HEAP8[$4_1 + 5 | 0] = $1_1 >>> 8;
            HEAP8[$4_1 + 6 | 0] = $1_1 >>> 16;
            HEAP8[$4_1 + 7 | 0] = $1_1 >>> 24;
            $1_1 = HEAP32[$11_1 + 4 >> 2];
            $4_1 = $3_1 + 31 | 0;
            $2_1 = HEAP32[$11_1 >> 2];
            HEAP8[$4_1 | 0] = $2_1;
            HEAP8[$4_1 + 1 | 0] = $2_1 >>> 8;
            HEAP8[$4_1 + 2 | 0] = $2_1 >>> 16;
            HEAP8[$4_1 + 3 | 0] = $2_1 >>> 24;
            HEAP8[$4_1 + 4 | 0] = $1_1;
            HEAP8[$4_1 + 5 | 0] = $1_1 >>> 8;
            HEAP8[$4_1 + 6 | 0] = $1_1 >>> 16;
            HEAP8[$4_1 + 7 | 0] = $1_1 >>> 24;
            $1_1 = HEAP32[$10_1 + 4 >> 2];
            $4_1 = $3_1 + 23 | 0;
            $2_1 = HEAP32[$10_1 >> 2];
            HEAP8[$4_1 | 0] = $2_1;
            HEAP8[$4_1 + 1 | 0] = $2_1 >>> 8;
            HEAP8[$4_1 + 2 | 0] = $2_1 >>> 16;
            HEAP8[$4_1 + 3 | 0] = $2_1 >>> 24;
            HEAP8[$4_1 + 4 | 0] = $1_1;
            HEAP8[$4_1 + 5 | 0] = $1_1 >>> 8;
            HEAP8[$4_1 + 6 | 0] = $1_1 >>> 16;
            HEAP8[$4_1 + 7 | 0] = $1_1 >>> 24;
            $1_1 = HEAP32[$19_1 + 4 >> 2];
            $4_1 = $3_1 + 15 | 0;
            $2_1 = HEAP32[$19_1 >> 2];
            HEAP8[$4_1 | 0] = $2_1;
            HEAP8[$4_1 + 1 | 0] = $2_1 >>> 8;
            HEAP8[$4_1 + 2 | 0] = $2_1 >>> 16;
            HEAP8[$4_1 + 3 | 0] = $2_1 >>> 24;
            HEAP8[$4_1 + 4 | 0] = $1_1;
            HEAP8[$4_1 + 5 | 0] = $1_1 >>> 8;
            HEAP8[$4_1 + 6 | 0] = $1_1 >>> 16;
            HEAP8[$4_1 + 7 | 0] = $1_1 >>> 24;
            HEAP8[$6_1 + 11 | 0] = $0_1;
            HEAP8[$6_1 + 12 | 0] = $0_1 >>> 8;
            HEAP8[$6_1 + 13 | 0] = $0_1 >>> 16;
            HEAP8[$6_1 + 14 | 0] = $0_1 >>> 24;
            $2_1 = HEAP32[$6_1 + 76 >> 2];
            $0_1 = HEAP32[$6_1 + 72 >> 2];
            HEAP8[$6_1 + 15 | 0] = $0_1;
            HEAP8[$6_1 + 16 | 0] = $0_1 >>> 8;
            HEAP8[$6_1 + 17 | 0] = $0_1 >>> 16;
            HEAP8[$6_1 + 18 | 0] = $0_1 >>> 24;
            HEAP8[$6_1 + 19 | 0] = $2_1;
            HEAP8[$6_1 + 20 | 0] = $2_1 >>> 8;
            HEAP8[$6_1 + 21 | 0] = $2_1 >>> 16;
            HEAP8[$6_1 + 22 | 0] = $2_1 >>> 24;
            HEAP32[$16_1 >> 2] = 0;
            HEAP32[$16_1 + 4 >> 2] = 0;
            HEAP32[$17_1 >> 2] = 0;
            HEAP32[$17_1 + 4 >> 2] = 0;
            HEAP32[$12_1 >> 2] = 0;
            HEAP32[$12_1 + 4 >> 2] = 0;
            HEAP32[$18_1 >> 2] = 0;
            HEAP32[$18_1 + 4 >> 2] = 0;
            HEAP32[$5_1 >> 2] = 0;
            HEAP32[$5_1 + 4 >> 2] = 0;
            HEAP32[$15_1 >> 2] = 0;
            HEAP32[$15_1 + 4 >> 2] = 0;
            HEAP32[$14_1 >> 2] = 0;
            HEAP32[$14_1 + 4 >> 2] = 0;
            HEAP32[$6_1 + 136 >> 2] = 0;
            HEAP32[$6_1 + 140 >> 2] = 0;
            $12_1 = $6();
            $13_1 = 0;
            $5_1 = global$0 - 288 | 0;
            global$0 = $5_1;
            label$4: {
              if (!$8_1) {
                FUNCTION_TABLE[HEAP32[$12_1 + 168 >> 2]](689607, HEAP32[$12_1 + 172 >> 2]);
                break label$4;
              }
              HEAP8[$8_1 | 0] = 0;
              HEAP8[$8_1 + 1 | 0] = 0;
              HEAP8[$8_1 + 2 | 0] = 0;
              HEAP8[$8_1 + 3 | 0] = 0;
              HEAP8[$8_1 + 4 | 0] = 0;
              HEAP8[$8_1 + 5 | 0] = 0;
              HEAP8[$8_1 + 6 | 0] = 0;
              HEAP8[$8_1 + 7 | 0] = 0;
              $0_1 = $8_1 + 56 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $8_1 + 48 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $8_1 + 40 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $8_1 + 32 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $8_1 + 24 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $8_1 + 16 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $8_1 + 8 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              if (!$3_1) {
                FUNCTION_TABLE[HEAP32[$12_1 + 168 >> 2]](689629, HEAP32[$12_1 + 172 >> 2]);
                break label$4;
              }
              $0_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
              $10_1 = $0_1 >>> 16 | 0;
              $4_1 = $5_1 + 72 | 0;
              $2_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
              HEAP32[$4_1 >> 2] = ($0_1 & 65535) << 16 | $2_1 >>> 16;
              HEAP32[$4_1 + 4 >> 2] = $10_1;
              $4_1 = $2_1 << 4 & 1048560;
              $0_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
              $15_1 = $0_1 >>> 28 | 0;
              $9_1 = $5_1 - -64 | 0;
              $2_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
              HEAP32[$9_1 >> 2] = ($0_1 & 268435455) << 4 | $2_1 >>> 28;
              HEAP32[$9_1 + 4 >> 2] = $4_1 | $15_1;
              $10_1 = $0_1 << 24 | $2_1 >>> 8;
              $9_1 = $2_1 << 24 & -16777216;
              $2_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
              $11_1 = $5_1 + 56 | 0;
              $0_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
              HEAP32[$11_1 >> 2] = $0_1 >>> 8 | $9_1;
              HEAP32[$11_1 + 4 >> 2] = $10_1 & 1048575;
              $10_1 = $0_1 << 12 | $2_1 >>> 20;
              $9_1 = $2_1 << 12 & -4096;
              $1_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
              $0_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
              $11_1 = $5_1 + 48 | 0;
              HEAP32[$11_1 >> 2] = $0_1 >>> 20 | $9_1;
              HEAP32[$11_1 + 4 >> 2] = $10_1 & 1048575;
              HEAP32[$5_1 + 80 >> 2] = 0;
              HEAP32[$5_1 + 40 >> 2] = $1_1;
              HEAP32[$5_1 + 44 >> 2] = $0_1 & 1048575;
              $1_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
              $14_1 = $1_1;
              $2_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
              $10_1 = $1_1 << 12 | $2_1 >>> 20;
              $9_1 = $2_1 << 12 & -4096;
              $19_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
              $2_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
              $1_1 = $2_1;
              $0_1 = $5_1;
              $7_1 = $1_1 >>> 20 | $9_1;
              HEAP32[$0_1 + 8 >> 2] = $7_1;
              $16_1 = $10_1 & 1048575;
              HEAP32[$0_1 + 12 >> 2] = $16_1;
              HEAP32[$0_1 >> 2] = $19_1;
              $17_1 = $1_1 & 1048575;
              HEAP32[$0_1 + 4 >> 2] = $17_1;
              $2_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
              $10_1 = $2_1;
              $1_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
              $4_1 = ($1_1 & 65535) << 16 | $2_1 >>> 16;
              HEAP32[$0_1 + 32 >> 2] = $4_1;
              $9_1 = $1_1 >>> 16 | 0;
              HEAP32[$0_1 + 36 >> 2] = $9_1;
              $2_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
              $1_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
              $15_1 = $1_1 << 24 | $2_1 >>> 8;
              $18_1 = $2_1 << 24 & -16777216 | $14_1 >>> 8;
              HEAP32[$0_1 + 16 >> 2] = $18_1;
              $14_1 = $15_1 & 1048575;
              HEAP32[$0_1 + 20 >> 2] = $14_1;
              $11_1 = $10_1 << 4 & 1048560;
              $2_1 = ($1_1 & 268435455) << 4 | $2_1 >>> 28;
              HEAP32[$0_1 + 24 >> 2] = $2_1;
              $0_1 = $1_1 >>> 28 | $11_1;
              HEAP32[$5_1 + 28 >> 2] = $0_1;
              if (!($7_1 | $19_1 | $4_1 | $18_1 | $2_1 | ($16_1 | $17_1 | $9_1 | $14_1 | $0_1))) {
                FUNCTION_TABLE[HEAP32[$12_1 + 168 >> 2]](690116, HEAP32[$12_1 + 172 >> 2]);
                break label$4;
              }
              HEAP32[$5_1 + 92 >> 2] = 0;
              $38($5_1 + 96 | 0, 690949, $5_1 + 92 | 0);
              if (HEAP32[$5_1 + 92 >> 2]) {
                break label$4;
              }
              $1_1 = $5_1 + 8 | 0;
              $2_1 = HEAP32[$1_1 + 4 >> 2];
              $4_1 = $5_1 + 160 | 0;
              $0_1 = $4_1 + 8 | 0;
              HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
              HEAP32[$0_1 + 4 >> 2] = $2_1;
              $1_1 = $5_1 + 16 | 0;
              $2_1 = HEAP32[$1_1 + 4 >> 2];
              $0_1 = $4_1 + 16 | 0;
              HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
              HEAP32[$0_1 + 4 >> 2] = $2_1;
              $1_1 = $5_1 + 24 | 0;
              $2_1 = HEAP32[$1_1 + 4 >> 2];
              $0_1 = $4_1 + 24 | 0;
              HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
              HEAP32[$0_1 + 4 >> 2] = $2_1;
              $1_1 = $5_1 + 32 | 0;
              $2_1 = HEAP32[$1_1 + 4 >> 2];
              $0_1 = $4_1 + 32 | 0;
              HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
              HEAP32[$0_1 + 4 >> 2] = $2_1;
              $1_1 = $5_1 + 48 | 0;
              $2_1 = HEAP32[$1_1 + 4 >> 2];
              $0_1 = $4_1 + 48 | 0;
              HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
              HEAP32[$0_1 + 4 >> 2] = $2_1;
              $1_1 = $5_1 + 56 | 0;
              $2_1 = HEAP32[$1_1 + 4 >> 2];
              $0_1 = $4_1 + 56 | 0;
              HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
              HEAP32[$0_1 + 4 >> 2] = $2_1;
              $1_1 = $5_1 - -64 | 0;
              $2_1 = HEAP32[$1_1 + 4 >> 2];
              $0_1 = $4_1 - -64 | 0;
              HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
              HEAP32[$0_1 + 4 >> 2] = $2_1;
              $1_1 = $5_1 + 72 | 0;
              $2_1 = HEAP32[$1_1 + 4 >> 2];
              $0_1 = $4_1 + 72 | 0;
              HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
              HEAP32[$0_1 + 4 >> 2] = $2_1;
              HEAP32[$5_1 + 280 >> 2] = 0;
              $0_1 = HEAP32[$5_1 + 4 >> 2];
              HEAP32[$5_1 + 160 >> 2] = HEAP32[$5_1 >> 2];
              HEAP32[$5_1 + 164 >> 2] = $0_1;
              $0_1 = HEAP32[$5_1 + 44 >> 2];
              HEAP32[$5_1 + 200 >> 2] = HEAP32[$5_1 + 40 >> 2];
              HEAP32[$5_1 + 204 >> 2] = $0_1;
              $0_1 = $5_1 + 248 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              $0_1 = $5_1 + 256 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              $0_1 = $5_1 + 264 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              $0_1 = $5_1 + 272 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              $2_1 = $5_1 + 128 | 0;
              $0_1 = $2_1 + 16 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              $0_1 = $2_1 + 24 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              HEAP32[$5_1 + 240 >> 2] = 1;
              HEAP32[$5_1 + 244 >> 2] = 0;
              HEAP32[$5_1 + 136 >> 2] = 0;
              HEAP32[$5_1 + 140 >> 2] = 0;
              HEAP32[$5_1 + 128 >> 2] = 1;
              HEAP32[$5_1 + 132 >> 2] = 0;
              $42($4_1, $4_1, $2_1, $5_1 + 96 | 0);
              if (HEAP32[$5_1 + 280 >> 2]) {
                break label$4;
              }
              $49($5_1, $5_1 + 160 | 0);
              $35($8_1, $5_1);
              $13_1 = 1;
            }
            global$0 = $5_1 + 288 | 0;
            if ($13_1) {
              HEAP32[$6_1 + 132 >> 2] = 0;
              $0_1 = $59($6(), $6_1 + 8 | 0, $6_1 + 132 | 0, $6_1 + 136 | 0);
              HEAP32[$6_1 + 204 >> 2] = $0_1;
              if (($0_1 | 0) != 1) {
                break label$1;
              }
              $0_1 = $58(HEAP32[172688], $6_1 + 8 | 0);
              HEAP32[$6_1 + 204 >> 2] = $0_1;
              if (($0_1 | 0) != 1) {
                break label$1;
              }
              $0_1 = HEAP32[$6_1 + 132 >> 2];
              break label$2;
            }
            $0_1 = -1;
            break label$2;
          }
          fimport$1(1);
        }
        global$0 = $6_1 + 208 | 0;
        return $0_1 | 0;
      }
      HEAP32[$6_1 + 80 >> 2] = 0;
      $5($6_1 + 72 | 0);
      wasm2js_trap();
    }
    function $12($0_1) {
      $0_1 = $0_1 | 0;
      var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0;
      $3_1 = global$0 - 192 | 0;
      global$0 = $3_1;
      $2_1 = $3_1 + 128 | 0;
      $9_1 = $2_1 + 56 | 0;
      HEAP32[$9_1 >> 2] = 0;
      HEAP32[$9_1 + 4 >> 2] = 0;
      $10_1 = $2_1 + 48 | 0;
      HEAP32[$10_1 >> 2] = 0;
      HEAP32[$10_1 + 4 >> 2] = 0;
      $7_1 = $2_1 + 40 | 0;
      HEAP32[$7_1 >> 2] = 0;
      HEAP32[$7_1 + 4 >> 2] = 0;
      $13_1 = $2_1 + 32 | 0;
      HEAP32[$13_1 >> 2] = 0;
      HEAP32[$13_1 + 4 >> 2] = 0;
      $18_1 = $2_1 + 24 | 0;
      HEAP32[$18_1 >> 2] = 0;
      HEAP32[$18_1 + 4 >> 2] = 0;
      $19_1 = $2_1 + 16 | 0;
      HEAP32[$19_1 >> 2] = 0;
      HEAP32[$19_1 + 4 >> 2] = 0;
      $17_1 = $2_1 + 8 | 0;
      HEAP32[$17_1 >> 2] = 0;
      HEAP32[$17_1 + 4 >> 2] = 0;
      HEAP32[$3_1 + 128 >> 2] = 0;
      HEAP32[$3_1 + 132 >> 2] = 0;
      label$1: {
        if (($57(HEAP32[172688], $2_1, 690885) | 0) == 1) {
          $2_1 = $3_1 + 128 | 0;
          $1_1 = $2_1 + 15 | 0;
          $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
          $5_1 = $3_1 - -64 | 0;
          $11_1 = $5_1 + 8 | 0;
          HEAP32[$11_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
          HEAP32[$11_1 + 4 >> 2] = $4_1;
          $1_1 = $2_1 + 23 | 0;
          $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
          $14_1 = $5_1 + 16 | 0;
          HEAP32[$14_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
          HEAP32[$14_1 + 4 >> 2] = $4_1;
          $1_1 = $2_1 + 31 | 0;
          $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
          $12_1 = $5_1 + 24 | 0;
          HEAP32[$12_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
          HEAP32[$12_1 + 4 >> 2] = $4_1;
          $1_1 = $2_1 + 39 | 0;
          $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
          $15_1 = $5_1 + 32 | 0;
          HEAP32[$15_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
          HEAP32[$15_1 + 4 >> 2] = $4_1;
          $1_1 = $2_1 + 47 | 0;
          $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
          $16_1 = $5_1 + 40 | 0;
          HEAP32[$16_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
          HEAP32[$16_1 + 4 >> 2] = $4_1;
          $1_1 = $2_1 + 55 | 0;
          $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
          $8_1 = $5_1 + 48 | 0;
          HEAP32[$8_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
          HEAP32[$8_1 + 4 >> 2] = $4_1;
          $1_1 = $5_1 + 56 | 0;
          HEAP8[$1_1 | 0] = HEAPU8[$2_1 + 63 | 0];
          HEAP8[$3_1 + 2 | 0] = HEAPU8[$3_1 + 130 | 0];
          HEAP16[$3_1 >> 1] = HEAPU16[$3_1 + 128 >> 1];
          $5_1 = HEAPU8[$3_1 + 139 | 0] | HEAPU8[$3_1 + 140 | 0] << 8 | (HEAPU8[$3_1 + 141 | 0] << 16 | HEAPU8[$3_1 + 142 | 0] << 24);
          HEAP32[$3_1 + 64 >> 2] = HEAPU8[$3_1 + 135 | 0] | HEAPU8[$3_1 + 136 | 0] << 8 | (HEAPU8[$3_1 + 137 | 0] << 16 | HEAPU8[$3_1 + 138 | 0] << 24);
          HEAP32[$3_1 + 68 >> 2] = $5_1;
          $5_1 = HEAPU8[$3_1 + 131 | 0] | HEAPU8[$3_1 + 132 | 0] << 8 | (HEAPU8[$3_1 + 133 | 0] << 16 | HEAPU8[$3_1 + 134 | 0] << 24);
          HEAP8[$3_1 + 63 | 0] = HEAPU8[$1_1 | 0];
          $4_1 = HEAP32[$8_1 + 4 >> 2];
          $1_1 = $3_1 + 55 | 0;
          $8_1 = HEAP32[$8_1 >> 2];
          HEAP8[$1_1 | 0] = $8_1;
          HEAP8[$1_1 + 1 | 0] = $8_1 >>> 8;
          HEAP8[$1_1 + 2 | 0] = $8_1 >>> 16;
          HEAP8[$1_1 + 3 | 0] = $8_1 >>> 24;
          HEAP8[$1_1 + 4 | 0] = $4_1;
          HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$16_1 + 4 >> 2];
          $1_1 = $3_1 + 47 | 0;
          $16_1 = HEAP32[$16_1 >> 2];
          HEAP8[$1_1 | 0] = $16_1;
          HEAP8[$1_1 + 1 | 0] = $16_1 >>> 8;
          HEAP8[$1_1 + 2 | 0] = $16_1 >>> 16;
          HEAP8[$1_1 + 3 | 0] = $16_1 >>> 24;
          HEAP8[$1_1 + 4 | 0] = $4_1;
          HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$15_1 + 4 >> 2];
          $1_1 = $3_1 + 39 | 0;
          $15_1 = HEAP32[$15_1 >> 2];
          HEAP8[$1_1 | 0] = $15_1;
          HEAP8[$1_1 + 1 | 0] = $15_1 >>> 8;
          HEAP8[$1_1 + 2 | 0] = $15_1 >>> 16;
          HEAP8[$1_1 + 3 | 0] = $15_1 >>> 24;
          HEAP8[$1_1 + 4 | 0] = $4_1;
          HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$12_1 + 4 >> 2];
          $1_1 = $3_1 + 31 | 0;
          $12_1 = HEAP32[$12_1 >> 2];
          HEAP8[$1_1 | 0] = $12_1;
          HEAP8[$1_1 + 1 | 0] = $12_1 >>> 8;
          HEAP8[$1_1 + 2 | 0] = $12_1 >>> 16;
          HEAP8[$1_1 + 3 | 0] = $12_1 >>> 24;
          HEAP8[$1_1 + 4 | 0] = $4_1;
          HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$14_1 + 4 >> 2];
          $1_1 = $3_1 + 23 | 0;
          $14_1 = HEAP32[$14_1 >> 2];
          HEAP8[$1_1 | 0] = $14_1;
          HEAP8[$1_1 + 1 | 0] = $14_1 >>> 8;
          HEAP8[$1_1 + 2 | 0] = $14_1 >>> 16;
          HEAP8[$1_1 + 3 | 0] = $14_1 >>> 24;
          HEAP8[$1_1 + 4 | 0] = $4_1;
          HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$11_1 + 4 >> 2];
          $1_1 = $3_1 + 15 | 0;
          $11_1 = HEAP32[$11_1 >> 2];
          HEAP8[$1_1 | 0] = $11_1;
          HEAP8[$1_1 + 1 | 0] = $11_1 >>> 8;
          HEAP8[$1_1 + 2 | 0] = $11_1 >>> 16;
          HEAP8[$1_1 + 3 | 0] = $11_1 >>> 24;
          HEAP8[$1_1 + 4 | 0] = $4_1;
          HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
          HEAP8[$3_1 + 3 | 0] = $5_1;
          HEAP8[$3_1 + 4 | 0] = $5_1 >>> 8;
          HEAP8[$3_1 + 5 | 0] = $5_1 >>> 16;
          HEAP8[$3_1 + 6 | 0] = $5_1 >>> 24;
          $1_1 = HEAP32[$3_1 + 68 >> 2];
          $5_1 = HEAP32[$3_1 + 64 >> 2];
          HEAP8[$3_1 + 7 | 0] = $5_1;
          HEAP8[$3_1 + 8 | 0] = $5_1 >>> 8;
          HEAP8[$3_1 + 9 | 0] = $5_1 >>> 16;
          HEAP8[$3_1 + 10 | 0] = $5_1 >>> 24;
          HEAP8[$3_1 + 11 | 0] = $1_1;
          HEAP8[$3_1 + 12 | 0] = $1_1 >>> 8;
          HEAP8[$3_1 + 13 | 0] = $1_1 >>> 16;
          HEAP8[$3_1 + 14 | 0] = $1_1 >>> 24;
          HEAP32[$9_1 >> 2] = 0;
          HEAP32[$9_1 + 4 >> 2] = 0;
          HEAP32[$10_1 >> 2] = 0;
          HEAP32[$10_1 + 4 >> 2] = 0;
          HEAP32[$7_1 >> 2] = 0;
          HEAP32[$7_1 + 4 >> 2] = 0;
          HEAP32[$13_1 >> 2] = 0;
          HEAP32[$13_1 + 4 >> 2] = 0;
          HEAP32[$18_1 >> 2] = 0;
          HEAP32[$18_1 + 4 >> 2] = 0;
          HEAP32[$19_1 >> 2] = 0;
          HEAP32[$19_1 + 4 >> 2] = 0;
          HEAP32[$17_1 >> 2] = 0;
          HEAP32[$17_1 + 4 >> 2] = 0;
          HEAP32[$3_1 + 128 >> 2] = 0;
          HEAP32[$3_1 + 132 >> 2] = 0;
          if (($57(HEAP32[172688], $2_1, 690917) | 0) == 1) {
            $17_1 = $6();
            $6_1 = global$0 - 288 | 0;
            global$0 = $6_1;
            label$4: {
              if (!$3_1) {
                FUNCTION_TABLE[HEAP32[$17_1 + 168 >> 2]](689629, HEAP32[$17_1 + 172 >> 2]);
                break label$4;
              }
              $5_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
              $2_1 = $5_1 >>> 16 | 0;
              $4_1 = $6_1 + 72 | 0;
              $1_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
              HEAP32[$4_1 >> 2] = ($5_1 & 65535) << 16 | $1_1 >>> 16;
              HEAP32[$4_1 + 4 >> 2] = $2_1;
              $9_1 = $1_1 << 4 & 1048560;
              $5_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
              $2_1 = $5_1 >>> 28 | 0;
              $4_1 = $6_1 - -64 | 0;
              $1_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
              HEAP32[$4_1 >> 2] = ($5_1 & 268435455) << 4 | $1_1 >>> 28;
              HEAP32[$4_1 + 4 >> 2] = $2_1 | $9_1;
              $2_1 = $5_1 << 24 | $1_1 >>> 8;
              $9_1 = $1_1 << 24 & -16777216;
              $1_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
              $4_1 = $6_1 + 56 | 0;
              $5_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
              HEAP32[$4_1 >> 2] = $5_1 >>> 8 | $9_1;
              HEAP32[$4_1 + 4 >> 2] = $2_1 & 1048575;
              $5_1 = ($5_1 << 12 | $1_1 >>> 20) & 1048575;
              $9_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
              $4_1 = $6_1 + 48 | 0;
              $10_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
              HEAP32[$4_1 >> 2] = $1_1 << 12 & -4096 | $10_1 >>> 20;
              HEAP32[$4_1 + 4 >> 2] = $5_1;
              HEAP32[$6_1 + 40 >> 2] = $9_1;
              HEAP32[$6_1 + 44 >> 2] = $10_1 & 1048575;
              $2_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
              $4_1 = $2_1;
              $5_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
              $2_1 = $2_1 << 12 | $5_1 >>> 20;
              $9_1 = $5_1 << 12 & -4096;
              $5_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
              $1_1 = $6_1;
              $7_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
              $11_1 = $7_1 >>> 20 | $9_1;
              HEAP32[$1_1 + 8 >> 2] = $11_1;
              $14_1 = $2_1 & 1048575;
              HEAP32[$1_1 + 12 >> 2] = $14_1;
              $9_1 = $5_1;
              HEAP32[$1_1 >> 2] = $5_1;
              $12_1 = $7_1 & 1048575;
              HEAP32[$1_1 + 4 >> 2] = $12_1;
              $5_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
              $2_1 = $5_1 >>> 16 | 0;
              $10_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
              $18_1 = ($5_1 & 65535) << 16 | $10_1 >>> 16;
              HEAP32[$1_1 + 32 >> 2] = $18_1;
              $13_1 = $2_1;
              HEAP32[$1_1 + 36 >> 2] = $2_1;
              $2_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
              $5_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
              $16_1 = ($2_1 << 24 | $5_1 >>> 8) & 1048575;
              $4_1 = $5_1 << 24 & -16777216 | $4_1 >>> 8;
              HEAP32[$1_1 + 16 >> 2] = $4_1;
              $15_1 = $16_1;
              HEAP32[$1_1 + 20 >> 2] = $15_1;
              $10_1 = $10_1 << 4 & 1048560;
              $1_1 = $2_1;
              $2_1 = $1_1 >>> 28 | 0;
              $1_1 = ($1_1 & 268435455) << 4 | $5_1 >>> 28;
              HEAP32[$6_1 + 24 >> 2] = $1_1;
              $2_1 = $2_1 | $10_1;
              HEAP32[$6_1 + 28 >> 2] = $2_1;
              if (!($9_1 | $11_1 | $18_1 | $4_1 | $1_1 | ($14_1 | $12_1 | $13_1 | $15_1 | $2_1))) {
                FUNCTION_TABLE[HEAP32[$17_1 + 168 >> 2]](690116, HEAP32[$17_1 + 172 >> 2]);
                break label$4;
              }
              HEAP32[$6_1 + 92 >> 2] = 0;
              $38($6_1 + 96 | 0, 690949, $6_1 + 92 | 0);
              if (HEAP32[$6_1 + 92 >> 2]) {
                break label$4;
              }
              $1_1 = $6_1 + 8 | 0;
              $5_1 = HEAP32[$1_1 + 4 >> 2];
              $2_1 = $6_1 + 160 | 0;
              $4_1 = $2_1 + 8 | 0;
              HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
              HEAP32[$4_1 + 4 >> 2] = $5_1;
              $1_1 = $6_1 + 16 | 0;
              $5_1 = HEAP32[$1_1 + 4 >> 2];
              $4_1 = $2_1 + 16 | 0;
              HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
              HEAP32[$4_1 + 4 >> 2] = $5_1;
              $1_1 = $6_1 + 24 | 0;
              $5_1 = HEAP32[$1_1 + 4 >> 2];
              $4_1 = $2_1 + 24 | 0;
              HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
              HEAP32[$4_1 + 4 >> 2] = $5_1;
              $1_1 = $6_1 + 32 | 0;
              $5_1 = HEAP32[$1_1 + 4 >> 2];
              $4_1 = $2_1 + 32 | 0;
              HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
              HEAP32[$4_1 + 4 >> 2] = $5_1;
              $1_1 = $6_1 + 48 | 0;
              $5_1 = HEAP32[$1_1 + 4 >> 2];
              $4_1 = $2_1 + 48 | 0;
              HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
              HEAP32[$4_1 + 4 >> 2] = $5_1;
              $1_1 = $6_1 + 56 | 0;
              $5_1 = HEAP32[$1_1 + 4 >> 2];
              $4_1 = $2_1 + 56 | 0;
              HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
              HEAP32[$4_1 + 4 >> 2] = $5_1;
              $1_1 = $6_1 - -64 | 0;
              $5_1 = HEAP32[$1_1 + 4 >> 2];
              $4_1 = $2_1 - -64 | 0;
              HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
              HEAP32[$4_1 + 4 >> 2] = $5_1;
              $1_1 = $6_1 + 72 | 0;
              $5_1 = HEAP32[$1_1 + 4 >> 2];
              $4_1 = $2_1 + 72 | 0;
              HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
              HEAP32[$4_1 + 4 >> 2] = $5_1;
              HEAP32[$6_1 + 280 >> 2] = 0;
              $1_1 = HEAP32[$6_1 + 4 >> 2];
              HEAP32[$6_1 + 160 >> 2] = HEAP32[$6_1 >> 2];
              HEAP32[$6_1 + 164 >> 2] = $1_1;
              $1_1 = HEAP32[$6_1 + 44 >> 2];
              HEAP32[$6_1 + 200 >> 2] = HEAP32[$6_1 + 40 >> 2];
              HEAP32[$6_1 + 204 >> 2] = $1_1;
              $1_1 = $6_1 + 248 | 0;
              HEAP32[$1_1 >> 2] = 0;
              HEAP32[$1_1 + 4 >> 2] = 0;
              $1_1 = $6_1 + 256 | 0;
              HEAP32[$1_1 >> 2] = 0;
              HEAP32[$1_1 + 4 >> 2] = 0;
              $1_1 = $6_1 + 264 | 0;
              HEAP32[$1_1 >> 2] = 0;
              HEAP32[$1_1 + 4 >> 2] = 0;
              $1_1 = $6_1 + 272 | 0;
              HEAP32[$1_1 >> 2] = 0;
              HEAP32[$1_1 + 4 >> 2] = 0;
              $1_1 = $6_1 + 128 | 0;
              $5_1 = $1_1 + 16 | 0;
              HEAP32[$5_1 >> 2] = 0;
              HEAP32[$5_1 + 4 >> 2] = 0;
              $5_1 = $1_1 + 24 | 0;
              HEAP32[$5_1 >> 2] = 0;
              HEAP32[$5_1 + 4 >> 2] = 0;
              HEAP32[$6_1 + 240 >> 2] = 1;
              HEAP32[$6_1 + 244 >> 2] = 0;
              HEAP32[$6_1 + 136 >> 2] = 0;
              HEAP32[$6_1 + 140 >> 2] = 0;
              HEAP32[$6_1 + 128 >> 2] = 1;
              HEAP32[$6_1 + 132 >> 2] = 0;
              $42($2_1, $2_1, $1_1, $6_1 + 96 | 0);
              if (HEAP32[$6_1 + 280 >> 2]) {
                break label$4;
              }
              $49($6_1, $6_1 + 160 | 0);
              $5_1 = HEAP32[$6_1 + 8 >> 2];
              $4_1 = HEAP32[$6_1 + 12 >> 2];
              $9_1 = HEAP32[$6_1 + 4 >> 2];
              $7_1 = HEAP32[$6_1 + 32 >> 2];
              $10_1 = HEAP32[$6_1 + 36 >> 2];
              $18_1 = $10_1;
              $2_1 = HEAP32[$6_1 >> 2];
              $1_1 = __wasm_i64_mul($10_1 >>> 16 | 0, 0, 977, 1);
              $15_1 = $2_1 + $1_1 | 0;
              $2_1 = $9_1 + i64toi32_i32$HIGH_BITS | 0;
              $13_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
              $2_1 = $4_1;
              $1_1 = $13_1 >>> 20 | 0;
              $4_1 = $1_1;
              $1_1 = $1_1 + $5_1 | 0;
              $4_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
              $17_1 = $4_1 & 1048575;
              $19_1 = HEAP32[$6_1 + 24 >> 2];
              $11_1 = HEAP32[$6_1 + 28 >> 2];
              $2_1 = HEAP32[$6_1 + 20 >> 2];
              $5_1 = $4_1 >>> 20 | 0;
              $10_1 = $5_1 + HEAP32[$6_1 + 16 >> 2] | 0;
              $9_1 = $5_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
              $2_1 = $11_1;
              $5_1 = $9_1 >>> 20 | 0;
              $8_1 = $5_1;
              $5_1 = $5_1 + $19_1 | 0;
              $2_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
              $11_1 = $2_1 & 1048575;
              $9_1 = $9_1 & 1048575;
              $19_1 = ($1_1 & $10_1 & $5_1) == -1 & ($4_1 & $9_1 & $2_1) == 1048575;
              $4_1 = $2_1;
              $2_1 = $18_1 & 65535;
              $4_1 = $4_1 >>> 20 | 0;
              $12_1 = $4_1 + $7_1 | 0;
              $2_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
              $4_1 = $2_1;
              $14_1 = $13_1 & 1048575;
              if ($19_1 & (($12_1 | 0) == -1 & ($2_1 | 0) == 65535) & (($14_1 | 0) == 1048574 & $15_1 >>> 0 > 4294966318 | $14_1 >>> 0 > 1048574) | $2_1 >>> 16) {
                $2_1 = $14_1 + 1 | 0;
                $15_1 = $15_1 + 977 | 0;
                $2_1 = $15_1 >>> 0 < 977 ? $2_1 + 1 | 0 : $2_1;
                $14_1 = $2_1 & 1048575;
                $7_1 = $2_1;
                $2_1 = $17_1;
                $7_1 = $7_1 >>> 20 | 0;
                $1_1 = $1_1 + $7_1 | 0;
                $2_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
                $17_1 = $2_1 & 1048575;
                $7_1 = $2_1;
                $2_1 = $9_1;
                $7_1 = $7_1 >>> 20 | 0;
                $10_1 = $7_1 + $10_1 | 0;
                $2_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
                $9_1 = $2_1 & 1048575;
                $7_1 = $2_1;
                $2_1 = $11_1;
                $7_1 = $7_1 >>> 20 | 0;
                $5_1 = $5_1 + $7_1 | 0;
                $2_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
                $11_1 = $2_1 & 1048575;
                $7_1 = $2_1;
                $2_1 = $4_1;
                $4_1 = $12_1;
                $12_1 = ($7_1 >>> 20 | 0) + $12_1 | 0;
                $4_1 = ($4_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) & 65535;
              }
              HEAP32[$6_1 + 32 >> 2] = $12_1;
              HEAP32[$6_1 + 36 >> 2] = $4_1;
              HEAP32[$6_1 + 24 >> 2] = $5_1;
              HEAP32[$6_1 + 28 >> 2] = $11_1;
              HEAP32[$6_1 + 16 >> 2] = $10_1;
              HEAP32[$6_1 + 20 >> 2] = $9_1;
              HEAP32[$6_1 + 8 >> 2] = $1_1;
              HEAP32[$6_1 + 12 >> 2] = $17_1;
              HEAP32[$6_1 >> 2] = $15_1;
              HEAP32[$6_1 + 4 >> 2] = $14_1;
              $18_1 = HEAP32[$6_1 + 48 >> 2];
              $19_1 = HEAP32[$6_1 + 52 >> 2];
              $8_1 = HEAP32[$6_1 + 44 >> 2];
              $7_1 = HEAP32[$6_1 + 72 >> 2];
              $16_1 = HEAP32[$6_1 + 76 >> 2];
              $23_1 = $16_1;
              $2_1 = HEAP32[$6_1 + 40 >> 2];
              $13_1 = __wasm_i64_mul($16_1 >>> 16 | 0, 0, 977, 1);
              $16_1 = $2_1 + $13_1 | 0;
              $2_1 = $8_1 + i64toi32_i32$HIGH_BITS | 0;
              $21_1 = $13_1 >>> 0 > $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
              $2_1 = $19_1;
              $13_1 = $21_1 >>> 20 | 0;
              $18_1 = $13_1 + $18_1 | 0;
              $8_1 = $13_1 >>> 0 > $18_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
              $24_1 = $8_1 & 1048575;
              $22_1 = $7_1;
              $25_1 = $23_1 & 65535;
              $13_1 = HEAP32[$6_1 + 64 >> 2];
              $20_1 = HEAP32[$6_1 + 68 >> 2];
              $2_1 = HEAP32[$6_1 + 60 >> 2];
              $7_1 = $8_1 >>> 20 | 0;
              $19_1 = $7_1 + HEAP32[$6_1 + 56 >> 2] | 0;
              $23_1 = $7_1 >>> 0 > $19_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
              $2_1 = $20_1;
              $7_1 = $23_1 >>> 20 | 0;
              $20_1 = $7_1;
              $7_1 = $7_1 + $13_1 | 0;
              $13_1 = $20_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
              $2_1 = $25_1;
              $20_1 = $13_1 >>> 20 | 0;
              $25_1 = $20_1;
              $20_1 = $22_1 + $20_1 | 0;
              $2_1 = $25_1 >>> 0 > $20_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
              $22_1 = $23_1 & 1048575;
              $21_1 = $21_1 & 1048575;
              if (($19_1 & $18_1 & $7_1) == -1 & ($8_1 & $22_1 & $13_1) == 1048575 & (($20_1 | 0) == -1 & ($2_1 | 0) == 65535) & (($21_1 | 0) == 1048574 & $16_1 >>> 0 > 4294966318 | $21_1 >>> 0 > 1048574) | $2_1 >>> 16) {
                $2_1 = $21_1 + 1 | 0;
                $16_1 = $16_1 + 977 | 0;
                $2_1 = $16_1 >>> 0 < 977 ? $2_1 + 1 | 0 : $2_1;
                $21_1 = $2_1 & 1048575;
                $8_1 = $2_1;
                $2_1 = $24_1;
                $8_1 = $8_1 >>> 20 | 0;
                $18_1 = $8_1 + $18_1 | 0;
                $2_1 = $8_1 >>> 0 > $18_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
                $24_1 = $2_1 & 1048575;
                $8_1 = $2_1;
                $2_1 = $22_1;
                $8_1 = $8_1 >>> 20 | 0;
                $19_1 = $8_1 + $19_1 | 0;
                $2_1 = $8_1 >>> 0 > $19_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
                $22_1 = $2_1 & 1048575;
                $8_1 = $2_1;
                $2_1 = $13_1;
                $8_1 = $8_1 >>> 20 | 0;
                $7_1 = $7_1 + $8_1 | 0;
                $13_1 = $8_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
              }
              HEAP32[$6_1 + 56 >> 2] = $19_1;
              HEAP32[$6_1 + 60 >> 2] = $22_1;
              HEAP32[$6_1 + 48 >> 2] = $18_1;
              HEAP32[$6_1 + 52 >> 2] = $24_1;
              HEAP32[$6_1 + 40 >> 2] = $16_1;
              HEAP32[$6_1 + 44 >> 2] = $21_1;
              HEAP32[$6_1 + 64 >> 2] = $7_1;
              HEAP32[$6_1 + 68 >> 2] = $13_1 & 1048575;
              if (HEAPU8[690917] != ($4_1 >>> 8 & 255)) {
                break label$4;
              }
              if (HEAPU8[690918] != ($4_1 & 255)) {
                break label$4;
              }
              if (HEAPU8[690919] != ((($4_1 & 16777215) << 8 | $12_1 >>> 24) & 255)) {
                break label$4;
              }
              if (HEAPU8[690920] != ((($4_1 & 65535) << 16 | $12_1 >>> 16) & 255)) {
                break label$4;
              }
              if (HEAPU8[690921] != ((($4_1 & 255) << 24 | $12_1 >>> 8) & 255)) {
                break label$4;
              }
              if (HEAPU8[690922] != ($12_1 & 255)) {
                break label$4;
              }
              if (HEAPU8[690923] != ($11_1 >>> 12 | 0)) {
                break label$4;
              }
              if (HEAPU8[690924] != ($11_1 >>> 4 & 255)) {
                break label$4;
              }
              if (HEAPU8[690925] != ((($11_1 & 268435455) << 4 | $5_1 >>> 28) & 255)) {
                break label$4;
              }
              if (HEAPU8[690926] != ((($11_1 & 1048575) << 12 | $5_1 >>> 20) & 255)) {
                break label$4;
              }
              if (HEAPU8[690927] != ((($11_1 & 4095) << 20 | $5_1 >>> 12) & 255)) {
                break label$4;
              }
              if (HEAPU8[690928] != ((($11_1 & 15) << 28 | $5_1 >>> 4) & 255)) {
                break label$4;
              }
              if (HEAPU8[690929] != (($5_1 << 4 | $9_1 >>> 16) & 255)) {
                break label$4;
              }
              $2_1 = $9_1;
              if (HEAPU8[690930] != ($2_1 >>> 8 & 255)) {
                break label$4;
              }
              if (HEAPU8[690931] != ($2_1 & 255)) {
                break label$4;
              }
              if (HEAPU8[690932] != ((($9_1 & 16777215) << 8 | $10_1 >>> 24) & 255)) {
                break label$4;
              }
              if (HEAPU8[690933] != ((($9_1 & 65535) << 16 | $10_1 >>> 16) & 255)) {
                break label$4;
              }
              if (HEAPU8[690934] != ((($9_1 & 255) << 24 | $10_1 >>> 8) & 255)) {
                break label$4;
              }
              if (HEAPU8[690935] != ($10_1 & 255)) {
                break label$4;
              }
              if (HEAPU8[690936] != ($17_1 >>> 12 | 0)) {
                break label$4;
              }
              if (HEAPU8[690937] != ($17_1 >>> 4 & 255)) {
                break label$4;
              }
              if (HEAPU8[690938] != ((($17_1 & 268435455) << 4 | $1_1 >>> 28) & 255)) {
                break label$4;
              }
              if (HEAPU8[690939] != ((($17_1 & 1048575) << 12 | $1_1 >>> 20) & 255)) {
                break label$4;
              }
              if (HEAPU8[690940] != ((($17_1 & 4095) << 20 | $1_1 >>> 12) & 255)) {
                break label$4;
              }
              if (HEAPU8[690941] != ((($17_1 & 15) << 28 | $1_1 >>> 4) & 255)) {
                break label$4;
              }
              if (HEAPU8[690942] != (($1_1 << 4 | $14_1 >>> 16) & 255)) {
                break label$4;
              }
              $2_1 = $14_1;
              if (HEAPU8[690943] != ($2_1 >>> 8 & 255)) {
                break label$4;
              }
              if (HEAPU8[690944] != ($2_1 & 255)) {
                break label$4;
              }
              if (HEAPU8[690945] != ((($14_1 & 16777215) << 8 | $15_1 >>> 24) & 255)) {
                break label$4;
              }
              if (HEAPU8[690946] != ((($14_1 & 65535) << 16 | $15_1 >>> 16) & 255)) {
                break label$4;
              }
              if (HEAPU8[690947] != ((($14_1 & 255) << 24 | $15_1 >>> 8) & 255)) {
                break label$4;
              }
              if (HEAPU8[690948] != ($15_1 & 255)) {
                break label$4;
              }
              $26_1 = ($16_1 & 1) == ($0_1 | 0);
            }
            global$0 = $6_1 + 288 | 0;
            break label$1;
          }
          fimport$1(1);
          break label$1;
        }
        fimport$1(1);
      }
      global$0 = $3_1 + 192 | 0;
      return $26_1 | 0;
    }
    function $13($0_1, $1_1) {
      $0_1 = $0_1 | 0;
      $1_1 = $1_1 | 0;
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0;
      $3_1 = global$0 - 208 | 0;
      global$0 = $3_1;
      $2_1 = $3_1 + 136 | 0;
      $5_1 = $2_1 + 56 | 0;
      HEAP32[$5_1 >> 2] = 0;
      HEAP32[$5_1 + 4 >> 2] = 0;
      $5_1 = $2_1 + 48 | 0;
      HEAP32[$5_1 >> 2] = 0;
      HEAP32[$5_1 + 4 >> 2] = 0;
      $5_1 = $2_1 + 40 | 0;
      HEAP32[$5_1 >> 2] = 0;
      HEAP32[$5_1 + 4 >> 2] = 0;
      $5_1 = $2_1 + 32 | 0;
      HEAP32[$5_1 >> 2] = 0;
      HEAP32[$5_1 + 4 >> 2] = 0;
      $5_1 = $2_1 + 24 | 0;
      HEAP32[$5_1 >> 2] = 0;
      HEAP32[$5_1 + 4 >> 2] = 0;
      $5_1 = $2_1 + 16 | 0;
      HEAP32[$5_1 >> 2] = 0;
      HEAP32[$5_1 + 4 >> 2] = 0;
      $5_1 = $2_1 + 8 | 0;
      HEAP32[$5_1 >> 2] = 0;
      HEAP32[$5_1 + 4 >> 2] = 0;
      HEAP32[$3_1 + 136 >> 2] = 0;
      HEAP32[$3_1 + 140 >> 2] = 0;
      label$1: {
        if (($31(HEAP32[172688], $2_1, 690820, $0_1) | 0) == 1) {
          $2_1 = $3_1 + 136 | 0;
          $0_1 = $2_1 + 15 | 0;
          $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $5_1 = $3_1 + 72 | 0;
          $6_1 = $5_1 + 8 | 0;
          HEAP32[$6_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$6_1 + 4 >> 2] = $4_1;
          $0_1 = $2_1 + 23 | 0;
          $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $7_1 = $5_1 + 16 | 0;
          HEAP32[$7_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$7_1 + 4 >> 2] = $4_1;
          $0_1 = $2_1 + 31 | 0;
          $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $8_1 = $5_1 + 24 | 0;
          HEAP32[$8_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$8_1 + 4 >> 2] = $4_1;
          $0_1 = $2_1 + 39 | 0;
          $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $9_1 = $5_1 + 32 | 0;
          HEAP32[$9_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$9_1 + 4 >> 2] = $4_1;
          $0_1 = $2_1 + 47 | 0;
          $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $10_1 = $5_1 + 40 | 0;
          HEAP32[$10_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$10_1 + 4 >> 2] = $4_1;
          $0_1 = $2_1 + 55 | 0;
          $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $11_1 = $5_1 + 48 | 0;
          HEAP32[$11_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$11_1 + 4 >> 2] = $4_1;
          $4_1 = $5_1 + 56 | 0;
          HEAP8[$4_1 | 0] = HEAPU8[$2_1 + 63 | 0];
          HEAP8[$3_1 + 10 | 0] = HEAPU8[$3_1 + 138 | 0];
          HEAP16[$3_1 + 8 >> 1] = HEAPU16[$3_1 + 136 >> 1];
          $0_1 = HEAPU8[$3_1 + 147 | 0] | HEAPU8[$3_1 + 148 | 0] << 8 | (HEAPU8[$3_1 + 149 | 0] << 16 | HEAPU8[$3_1 + 150 | 0] << 24);
          HEAP32[$3_1 + 72 >> 2] = HEAPU8[$3_1 + 143 | 0] | HEAPU8[$3_1 + 144 | 0] << 8 | (HEAPU8[$3_1 + 145 | 0] << 16 | HEAPU8[$3_1 + 146 | 0] << 24);
          HEAP32[$3_1 + 76 >> 2] = $0_1;
          $5_1 = HEAPU8[$3_1 + 139 | 0] | HEAPU8[$3_1 + 140 | 0] << 8 | (HEAPU8[$3_1 + 141 | 0] << 16 | HEAPU8[$3_1 + 142 | 0] << 24);
          $0_1 = $3_1 + 8 | 0;
          HEAP8[$0_1 + 63 | 0] = HEAPU8[$4_1 | 0];
          $4_1 = HEAP32[$11_1 + 4 >> 2];
          $2_1 = $0_1 + 55 | 0;
          $11_1 = HEAP32[$11_1 >> 2];
          HEAP8[$2_1 | 0] = $11_1;
          HEAP8[$2_1 + 1 | 0] = $11_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $11_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $11_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $4_1;
          HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$10_1 + 4 >> 2];
          $2_1 = $0_1 + 47 | 0;
          $10_1 = HEAP32[$10_1 >> 2];
          HEAP8[$2_1 | 0] = $10_1;
          HEAP8[$2_1 + 1 | 0] = $10_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $10_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $10_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $4_1;
          HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$9_1 + 4 >> 2];
          $2_1 = $0_1 + 39 | 0;
          $9_1 = HEAP32[$9_1 >> 2];
          HEAP8[$2_1 | 0] = $9_1;
          HEAP8[$2_1 + 1 | 0] = $9_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $9_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $9_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $4_1;
          HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$8_1 + 4 >> 2];
          $2_1 = $0_1 + 31 | 0;
          $8_1 = HEAP32[$8_1 >> 2];
          HEAP8[$2_1 | 0] = $8_1;
          HEAP8[$2_1 + 1 | 0] = $8_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $8_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $8_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $4_1;
          HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$7_1 + 4 >> 2];
          $2_1 = $0_1 + 23 | 0;
          $7_1 = HEAP32[$7_1 >> 2];
          HEAP8[$2_1 | 0] = $7_1;
          HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $4_1;
          HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$6_1 + 4 >> 2];
          $2_1 = $0_1 + 15 | 0;
          $6_1 = HEAP32[$6_1 >> 2];
          HEAP8[$2_1 | 0] = $6_1;
          HEAP8[$2_1 + 1 | 0] = $6_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $6_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $6_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $4_1;
          HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
          HEAP8[$3_1 + 11 | 0] = $5_1;
          HEAP8[$3_1 + 12 | 0] = $5_1 >>> 8;
          HEAP8[$3_1 + 13 | 0] = $5_1 >>> 16;
          HEAP8[$3_1 + 14 | 0] = $5_1 >>> 24;
          $2_1 = HEAP32[$3_1 + 76 >> 2];
          $5_1 = HEAP32[$3_1 + 72 >> 2];
          HEAP8[$3_1 + 15 | 0] = $5_1;
          HEAP8[$3_1 + 16 | 0] = $5_1 >>> 8;
          HEAP8[$3_1 + 17 | 0] = $5_1 >>> 16;
          HEAP8[$3_1 + 18 | 0] = $5_1 >>> 24;
          HEAP8[$3_1 + 19 | 0] = $2_1;
          HEAP8[$3_1 + 20 | 0] = $2_1 >>> 8;
          HEAP8[$3_1 + 21 | 0] = $2_1 >>> 16;
          HEAP8[$3_1 + 22 | 0] = $2_1 >>> 24;
          HEAP32[$3_1 + 204 >> 2] = $1_1;
          $0_1 = $36(HEAP32[172688], $3_1 + 204 | 0, $0_1, ($1_1 | 0) == 33 ? 258 : 2);
          HEAP32[$3_1 + 72 >> 2] = $0_1;
          if (($0_1 | 0) == 1) {
            break label$1;
          }
          HEAP32[$3_1 + 144 >> 2] = 0;
          $5($3_1 + 136 | 0);
          wasm2js_trap();
        }
        fimport$1(1);
      }
      global$0 = $3_1 + 208 | 0;
    }
    function $14($0_1) {
      $0_1 = $0_1 | 0;
      var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0;
      $2_1 = global$0 - 96 | 0;
      global$0 = $2_1;
      $1_1 = $2_1 + 56 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $2_1 + 48 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $2_1 + 40 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $2_1 + 32 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $2_1 + 24 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $2_1 + 16 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $2_1 + 8 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $4_1 = $6();
      $3_1 = global$0 - 256 | 0;
      global$0 = $3_1;
      label$1: {
        if (!$2_1) {
          FUNCTION_TABLE[HEAP32[$4_1 + 168 >> 2]](689638, HEAP32[$4_1 + 172 >> 2]);
          $1_1 = 0;
          break label$1;
        }
        HEAP8[$2_1 | 0] = 0;
        HEAP8[$2_1 + 1 | 0] = 0;
        HEAP8[$2_1 + 2 | 0] = 0;
        HEAP8[$2_1 + 3 | 0] = 0;
        HEAP8[$2_1 + 4 | 0] = 0;
        HEAP8[$2_1 + 5 | 0] = 0;
        HEAP8[$2_1 + 6 | 0] = 0;
        HEAP8[$2_1 + 7 | 0] = 0;
        $1_1 = $2_1 + 56 | 0;
        HEAP8[$1_1 | 0] = 0;
        HEAP8[$1_1 + 1 | 0] = 0;
        HEAP8[$1_1 + 2 | 0] = 0;
        HEAP8[$1_1 + 3 | 0] = 0;
        HEAP8[$1_1 + 4 | 0] = 0;
        HEAP8[$1_1 + 5 | 0] = 0;
        HEAP8[$1_1 + 6 | 0] = 0;
        HEAP8[$1_1 + 7 | 0] = 0;
        $1_1 = $2_1 + 48 | 0;
        HEAP8[$1_1 | 0] = 0;
        HEAP8[$1_1 + 1 | 0] = 0;
        HEAP8[$1_1 + 2 | 0] = 0;
        HEAP8[$1_1 + 3 | 0] = 0;
        HEAP8[$1_1 + 4 | 0] = 0;
        HEAP8[$1_1 + 5 | 0] = 0;
        HEAP8[$1_1 + 6 | 0] = 0;
        HEAP8[$1_1 + 7 | 0] = 0;
        $1_1 = $2_1 + 40 | 0;
        HEAP8[$1_1 | 0] = 0;
        HEAP8[$1_1 + 1 | 0] = 0;
        HEAP8[$1_1 + 2 | 0] = 0;
        HEAP8[$1_1 + 3 | 0] = 0;
        HEAP8[$1_1 + 4 | 0] = 0;
        HEAP8[$1_1 + 5 | 0] = 0;
        HEAP8[$1_1 + 6 | 0] = 0;
        HEAP8[$1_1 + 7 | 0] = 0;
        $1_1 = $2_1 + 32 | 0;
        HEAP8[$1_1 | 0] = 0;
        HEAP8[$1_1 + 1 | 0] = 0;
        HEAP8[$1_1 + 2 | 0] = 0;
        HEAP8[$1_1 + 3 | 0] = 0;
        HEAP8[$1_1 + 4 | 0] = 0;
        HEAP8[$1_1 + 5 | 0] = 0;
        HEAP8[$1_1 + 6 | 0] = 0;
        HEAP8[$1_1 + 7 | 0] = 0;
        $1_1 = $2_1 + 24 | 0;
        HEAP8[$1_1 | 0] = 0;
        HEAP8[$1_1 + 1 | 0] = 0;
        HEAP8[$1_1 + 2 | 0] = 0;
        HEAP8[$1_1 + 3 | 0] = 0;
        HEAP8[$1_1 + 4 | 0] = 0;
        HEAP8[$1_1 + 5 | 0] = 0;
        HEAP8[$1_1 + 6 | 0] = 0;
        HEAP8[$1_1 + 7 | 0] = 0;
        $1_1 = $2_1 + 16 | 0;
        HEAP8[$1_1 | 0] = 0;
        HEAP8[$1_1 + 1 | 0] = 0;
        HEAP8[$1_1 + 2 | 0] = 0;
        HEAP8[$1_1 + 3 | 0] = 0;
        HEAP8[$1_1 + 4 | 0] = 0;
        HEAP8[$1_1 + 5 | 0] = 0;
        HEAP8[$1_1 + 6 | 0] = 0;
        HEAP8[$1_1 + 7 | 0] = 0;
        $1_1 = $2_1 + 8 | 0;
        HEAP8[$1_1 | 0] = 0;
        HEAP8[$1_1 + 1 | 0] = 0;
        HEAP8[$1_1 + 2 | 0] = 0;
        HEAP8[$1_1 + 3 | 0] = 0;
        HEAP8[$1_1 + 4 | 0] = 0;
        HEAP8[$1_1 + 5 | 0] = 0;
        HEAP8[$1_1 + 6 | 0] = 0;
        HEAP8[$1_1 + 7 | 0] = 0;
        if (!HEAP32[$4_1 >> 2]) {
          FUNCTION_TABLE[HEAP32[$4_1 + 168 >> 2]](690045, HEAP32[$4_1 + 172 >> 2]);
          $1_1 = 0;
          break label$1;
        }
        $8_1 = $3_1 + 8 | 0;
        $6_1 = $3_1 + 128 | 0;
        $38($8_1, 690788, $6_1);
        $9_1 = HEAP32[$3_1 + 32 >> 2];
        $10_1 = HEAP32[$3_1 + 24 >> 2];
        $5_1 = HEAP32[$3_1 + 16 >> 2];
        $11_1 = HEAP32[$3_1 + 8 >> 2];
        $12_1 = HEAP32[$3_1 + 36 >> 2];
        $13_1 = HEAP32[$3_1 + 28 >> 2];
        $14_1 = HEAP32[$3_1 + 20 >> 2];
        $15_1 = HEAP32[$3_1 + 12 >> 2];
        $7_1 = HEAP32[$3_1 + 128 >> 2] | !($9_1 | ($10_1 | ($5_1 | $11_1)) | ($12_1 | ($13_1 | ($14_1 | $15_1))));
        $1_1 = $7_1 ? 0 : -1;
        HEAP32[$3_1 + 32 >> 2] = $1_1 & $9_1;
        HEAP32[$3_1 + 36 >> 2] = $1_1 & $12_1;
        HEAP32[$3_1 + 24 >> 2] = $1_1 & $10_1;
        HEAP32[$3_1 + 28 >> 2] = $1_1 & $13_1;
        HEAP32[$3_1 + 16 >> 2] = $1_1 & $5_1;
        HEAP32[$3_1 + 20 >> 2] = $1_1 & $14_1;
        $5_1 = ($7_1 | 0) != 0;
        HEAP32[$3_1 + 8 >> 2] = $5_1 | $1_1 & $11_1;
        HEAP32[$3_1 + 12 >> 2] = $1_1 & $15_1;
        $48($4_1, $6_1, $8_1);
        $1_1 = $3_1 + 40 | 0;
        $49($1_1, $6_1);
        $35($2_1, $1_1);
        HEAP32[$3_1 + 128 >> 2] = $5_1;
        $1_1 = HEAP32[$3_1 + 128 >> 2] - 1 | 0;
        HEAP8[$2_1 | 0] = $1_1 & HEAPU8[$2_1 | 0];
        HEAP8[$2_1 + 1 | 0] = HEAPU8[$2_1 + 1 | 0] & $1_1;
        HEAP8[$2_1 + 2 | 0] = HEAPU8[$2_1 + 2 | 0] & $1_1;
        HEAP8[$2_1 + 3 | 0] = HEAPU8[$2_1 + 3 | 0] & $1_1;
        HEAP8[$2_1 + 4 | 0] = HEAPU8[$2_1 + 4 | 0] & $1_1;
        HEAP8[$2_1 + 5 | 0] = HEAPU8[$2_1 + 5 | 0] & $1_1;
        HEAP8[$2_1 + 6 | 0] = HEAPU8[$2_1 + 6 | 0] & $1_1;
        HEAP8[$2_1 + 7 | 0] = HEAPU8[$2_1 + 7 | 0] & $1_1;
        HEAP8[$2_1 + 8 | 0] = HEAPU8[$2_1 + 8 | 0] & $1_1;
        HEAP8[$2_1 + 9 | 0] = HEAPU8[$2_1 + 9 | 0] & $1_1;
        HEAP8[$2_1 + 10 | 0] = HEAPU8[$2_1 + 10 | 0] & $1_1;
        HEAP8[$2_1 + 11 | 0] = HEAPU8[$2_1 + 11 | 0] & $1_1;
        HEAP8[$2_1 + 12 | 0] = HEAPU8[$2_1 + 12 | 0] & $1_1;
        HEAP8[$2_1 + 13 | 0] = HEAPU8[$2_1 + 13 | 0] & $1_1;
        HEAP8[$2_1 + 14 | 0] = HEAPU8[$2_1 + 14 | 0] & $1_1;
        HEAP8[$2_1 + 15 | 0] = HEAPU8[$2_1 + 15 | 0] & $1_1;
        HEAP8[$2_1 + 16 | 0] = HEAPU8[$2_1 + 16 | 0] & $1_1;
        HEAP8[$2_1 + 17 | 0] = HEAPU8[$2_1 + 17 | 0] & $1_1;
        HEAP8[$2_1 + 18 | 0] = HEAPU8[$2_1 + 18 | 0] & $1_1;
        HEAP8[$2_1 + 19 | 0] = HEAPU8[$2_1 + 19 | 0] & $1_1;
        HEAP8[$2_1 + 20 | 0] = HEAPU8[$2_1 + 20 | 0] & $1_1;
        HEAP8[$2_1 + 21 | 0] = HEAPU8[$2_1 + 21 | 0] & $1_1;
        HEAP8[$2_1 + 22 | 0] = HEAPU8[$2_1 + 22 | 0] & $1_1;
        HEAP8[$2_1 + 23 | 0] = HEAPU8[$2_1 + 23 | 0] & $1_1;
        HEAP8[$2_1 + 24 | 0] = HEAPU8[$2_1 + 24 | 0] & $1_1;
        HEAP8[$2_1 + 25 | 0] = HEAPU8[$2_1 + 25 | 0] & $1_1;
        HEAP8[$2_1 + 26 | 0] = HEAPU8[$2_1 + 26 | 0] & $1_1;
        HEAP8[$2_1 + 27 | 0] = HEAPU8[$2_1 + 27 | 0] & $1_1;
        HEAP8[$2_1 + 28 | 0] = HEAPU8[$2_1 + 28 | 0] & $1_1;
        HEAP8[$2_1 + 29 | 0] = HEAPU8[$2_1 + 29 | 0] & $1_1;
        HEAP8[$2_1 + 30 | 0] = HEAPU8[$2_1 + 30 | 0] & $1_1;
        HEAP8[$2_1 + 31 | 0] = HEAPU8[$2_1 + 31 | 0] & $1_1;
        HEAP8[$2_1 + 32 | 0] = HEAPU8[$2_1 + 32 | 0] & $1_1;
        HEAP8[$2_1 + 33 | 0] = HEAPU8[$2_1 + 33 | 0] & $1_1;
        HEAP8[$2_1 + 34 | 0] = HEAPU8[$2_1 + 34 | 0] & $1_1;
        HEAP8[$2_1 + 35 | 0] = HEAPU8[$2_1 + 35 | 0] & $1_1;
        HEAP8[$2_1 + 36 | 0] = HEAPU8[$2_1 + 36 | 0] & $1_1;
        HEAP8[$2_1 + 37 | 0] = HEAPU8[$2_1 + 37 | 0] & $1_1;
        HEAP8[$2_1 + 38 | 0] = HEAPU8[$2_1 + 38 | 0] & $1_1;
        HEAP8[$2_1 + 39 | 0] = HEAPU8[$2_1 + 39 | 0] & $1_1;
        HEAP8[$2_1 + 40 | 0] = HEAPU8[$2_1 + 40 | 0] & $1_1;
        HEAP8[$2_1 + 41 | 0] = HEAPU8[$2_1 + 41 | 0] & $1_1;
        HEAP8[$2_1 + 42 | 0] = HEAPU8[$2_1 + 42 | 0] & $1_1;
        HEAP8[$2_1 + 43 | 0] = HEAPU8[$2_1 + 43 | 0] & $1_1;
        HEAP8[$2_1 + 44 | 0] = HEAPU8[$2_1 + 44 | 0] & $1_1;
        HEAP8[$2_1 + 45 | 0] = HEAPU8[$2_1 + 45 | 0] & $1_1;
        HEAP8[$2_1 + 46 | 0] = HEAPU8[$2_1 + 46 | 0] & $1_1;
        HEAP8[$2_1 + 47 | 0] = HEAPU8[$2_1 + 47 | 0] & $1_1;
        HEAP8[$2_1 + 48 | 0] = HEAPU8[$2_1 + 48 | 0] & $1_1;
        HEAP8[$2_1 + 49 | 0] = HEAPU8[$2_1 + 49 | 0] & $1_1;
        HEAP8[$2_1 + 50 | 0] = HEAPU8[$2_1 + 50 | 0] & $1_1;
        HEAP8[$2_1 + 51 | 0] = HEAPU8[$2_1 + 51 | 0] & $1_1;
        HEAP8[$2_1 + 52 | 0] = HEAPU8[$2_1 + 52 | 0] & $1_1;
        HEAP8[$2_1 + 53 | 0] = HEAPU8[$2_1 + 53 | 0] & $1_1;
        HEAP8[$2_1 + 54 | 0] = HEAPU8[$2_1 + 54 | 0] & $1_1;
        HEAP8[$2_1 + 55 | 0] = HEAPU8[$2_1 + 55 | 0] & $1_1;
        HEAP8[$2_1 + 56 | 0] = HEAPU8[$2_1 + 56 | 0] & $1_1;
        HEAP8[$2_1 + 57 | 0] = HEAPU8[$2_1 + 57 | 0] & $1_1;
        HEAP8[$2_1 + 58 | 0] = HEAPU8[$2_1 + 58 | 0] & $1_1;
        HEAP8[$2_1 + 59 | 0] = HEAPU8[$2_1 + 59 | 0] & $1_1;
        HEAP8[$2_1 + 60 | 0] = HEAPU8[$2_1 + 60 | 0] & $1_1;
        HEAP8[$2_1 + 61 | 0] = HEAPU8[$2_1 + 61 | 0] & $1_1;
        HEAP8[$2_1 + 62 | 0] = HEAPU8[$2_1 + 62 | 0] & $1_1;
        HEAP8[$2_1 + 63 | 0] = HEAPU8[$2_1 + 63 | 0] & $1_1;
        $1_1 = !$7_1;
      }
      global$0 = $3_1 + 256 | 0;
      label$4: {
        if ($1_1) {
          HEAP32[$2_1 + 64 >> 2] = $0_1;
          $0_1 = $36(HEAP32[172688], $2_1 - -64 | 0, $2_1, ($0_1 | 0) == 33 ? 258 : 2);
          HEAP32[$2_1 + 68 >> 2] = $0_1;
          if (($0_1 | 0) != 1) {
            break label$4;
          }
          $16_1 = 1;
        }
        global$0 = $2_1 + 96 | 0;
        return $16_1 | 0;
      }
      HEAP32[$2_1 + 80 >> 2] = 0;
      $5($2_1 + 72 | 0);
      wasm2js_trap();
    }
    function $15() {
      var $0_1 = 0, $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0;
      $3_1 = global$0 - 304 | 0;
      global$0 = $3_1;
      $2_1 = $3_1 + 200 | 0;
      $68($2_1, 96);
      label$1: {
        label$2: {
          label$3: {
            if (($60($6(), $2_1) | 0) == 1) {
              HEAP8[$3_1 + 10 | 0] = HEAPU8[$3_1 + 202 | 0];
              HEAP16[$3_1 + 8 >> 1] = HEAPU16[$3_1 + 200 >> 1];
              $2_1 = HEAPU8[$3_1 + 203 | 0] | HEAPU8[$3_1 + 204 | 0] << 8 | (HEAPU8[$3_1 + 205 | 0] << 16 | HEAPU8[$3_1 + 206 | 0] << 24);
              $0_1 = $3_1 + 104 | 0;
              $5_1 = $3_1 + 200 | 0;
              $70($0_1, $5_1 | 7, 89);
              $1_1 = $3_1 + 8 | 0;
              $70($1_1 | 7, $0_1, 89);
              HEAP8[$3_1 + 11 | 0] = $2_1;
              HEAP8[$3_1 + 12 | 0] = $2_1 >>> 8;
              HEAP8[$3_1 + 13 | 0] = $2_1 >>> 16;
              HEAP8[$3_1 + 14 | 0] = $2_1 >>> 24;
              $2_1 = $3_1 + 256 | 0;
              HEAP32[$2_1 >> 2] = 0;
              HEAP32[$2_1 + 4 >> 2] = 0;
              $2_1 = $3_1 + 248 | 0;
              HEAP32[$2_1 >> 2] = 0;
              HEAP32[$2_1 + 4 >> 2] = 0;
              $2_1 = $3_1 + 240 | 0;
              HEAP32[$2_1 >> 2] = 0;
              HEAP32[$2_1 + 4 >> 2] = 0;
              $2_1 = $3_1 + 232 | 0;
              HEAP32[$2_1 >> 2] = 0;
              HEAP32[$2_1 + 4 >> 2] = 0;
              $2_1 = $3_1 + 224 | 0;
              HEAP32[$2_1 >> 2] = 0;
              HEAP32[$2_1 + 4 >> 2] = 0;
              $2_1 = $3_1 + 216 | 0;
              HEAP32[$2_1 >> 2] = 0;
              HEAP32[$2_1 + 4 >> 2] = 0;
              $2_1 = $3_1 + 208 | 0;
              HEAP32[$2_1 >> 2] = 0;
              HEAP32[$2_1 + 4 >> 2] = 0;
              HEAP32[$3_1 + 200 >> 2] = 0;
              HEAP32[$3_1 + 204 >> 2] = 0;
              HEAP32[$3_1 + 196 >> 2] = 0;
              $10_1 = $6();
              $15_1 = $3_1 + 196 | 0;
              $2_1 = global$0 - 96 | 0;
              global$0 = $2_1;
              label$5: {
                if (!$5_1) {
                  FUNCTION_TABLE[HEAP32[$10_1 + 168 >> 2]](689638, HEAP32[$10_1 + 172 >> 2]);
                  $0_1 = 0;
                  break label$5;
                }
                HEAP8[$5_1 | 0] = 0;
                HEAP8[$5_1 + 1 | 0] = 0;
                HEAP8[$5_1 + 2 | 0] = 0;
                HEAP8[$5_1 + 3 | 0] = 0;
                HEAP8[$5_1 + 4 | 0] = 0;
                HEAP8[$5_1 + 5 | 0] = 0;
                HEAP8[$5_1 + 6 | 0] = 0;
                HEAP8[$5_1 + 7 | 0] = 0;
                $0_1 = $5_1 + 56 | 0;
                HEAP8[$0_1 | 0] = 0;
                HEAP8[$0_1 + 1 | 0] = 0;
                HEAP8[$0_1 + 2 | 0] = 0;
                HEAP8[$0_1 + 3 | 0] = 0;
                HEAP8[$0_1 + 4 | 0] = 0;
                HEAP8[$0_1 + 5 | 0] = 0;
                HEAP8[$0_1 + 6 | 0] = 0;
                HEAP8[$0_1 + 7 | 0] = 0;
                $0_1 = $5_1 + 48 | 0;
                HEAP8[$0_1 | 0] = 0;
                HEAP8[$0_1 + 1 | 0] = 0;
                HEAP8[$0_1 + 2 | 0] = 0;
                HEAP8[$0_1 + 3 | 0] = 0;
                HEAP8[$0_1 + 4 | 0] = 0;
                HEAP8[$0_1 + 5 | 0] = 0;
                HEAP8[$0_1 + 6 | 0] = 0;
                HEAP8[$0_1 + 7 | 0] = 0;
                $0_1 = $5_1 + 40 | 0;
                HEAP8[$0_1 | 0] = 0;
                HEAP8[$0_1 + 1 | 0] = 0;
                HEAP8[$0_1 + 2 | 0] = 0;
                HEAP8[$0_1 + 3 | 0] = 0;
                HEAP8[$0_1 + 4 | 0] = 0;
                HEAP8[$0_1 + 5 | 0] = 0;
                HEAP8[$0_1 + 6 | 0] = 0;
                HEAP8[$0_1 + 7 | 0] = 0;
                $0_1 = $5_1 + 32 | 0;
                HEAP8[$0_1 | 0] = 0;
                HEAP8[$0_1 + 1 | 0] = 0;
                HEAP8[$0_1 + 2 | 0] = 0;
                HEAP8[$0_1 + 3 | 0] = 0;
                HEAP8[$0_1 + 4 | 0] = 0;
                HEAP8[$0_1 + 5 | 0] = 0;
                HEAP8[$0_1 + 6 | 0] = 0;
                HEAP8[$0_1 + 7 | 0] = 0;
                $0_1 = $5_1 + 24 | 0;
                HEAP8[$0_1 | 0] = 0;
                HEAP8[$0_1 + 1 | 0] = 0;
                HEAP8[$0_1 + 2 | 0] = 0;
                HEAP8[$0_1 + 3 | 0] = 0;
                HEAP8[$0_1 + 4 | 0] = 0;
                HEAP8[$0_1 + 5 | 0] = 0;
                HEAP8[$0_1 + 6 | 0] = 0;
                HEAP8[$0_1 + 7 | 0] = 0;
                $0_1 = $5_1 + 16 | 0;
                HEAP8[$0_1 | 0] = 0;
                HEAP8[$0_1 + 1 | 0] = 0;
                HEAP8[$0_1 + 2 | 0] = 0;
                HEAP8[$0_1 + 3 | 0] = 0;
                HEAP8[$0_1 + 4 | 0] = 0;
                HEAP8[$0_1 + 5 | 0] = 0;
                HEAP8[$0_1 + 6 | 0] = 0;
                HEAP8[$0_1 + 7 | 0] = 0;
                $0_1 = $5_1 + 8 | 0;
                HEAP8[$0_1 | 0] = 0;
                HEAP8[$0_1 + 1 | 0] = 0;
                HEAP8[$0_1 + 2 | 0] = 0;
                HEAP8[$0_1 + 3 | 0] = 0;
                HEAP8[$0_1 + 4 | 0] = 0;
                HEAP8[$0_1 + 5 | 0] = 0;
                HEAP8[$0_1 + 6 | 0] = 0;
                HEAP8[$0_1 + 7 | 0] = 0;
                if (!$1_1) {
                  FUNCTION_TABLE[HEAP32[$10_1 + 168 >> 2]](689700, HEAP32[$10_1 + 172 >> 2]);
                  $0_1 = 0;
                  break label$5;
                }
                $11_1 = HEAPU8[$1_1 + 92 | 0] | HEAPU8[$1_1 + 93 | 0] << 8 | (HEAPU8[$1_1 + 94 | 0] << 16 | HEAPU8[$1_1 + 95 | 0] << 24);
                $0_1 = $11_1 >>> 16 | 0;
                $6_1 = $2_1 + 80 | 0;
                $7_1 = HEAPU8[$1_1 + 88 | 0] | HEAPU8[$1_1 + 89 | 0] << 8 | (HEAPU8[$1_1 + 90 | 0] << 16 | HEAPU8[$1_1 + 91 | 0] << 24);
                $11_1 = ($11_1 & 65535) << 16 | $7_1 >>> 16;
                HEAP32[$6_1 >> 2] = $11_1;
                $24_1 = $0_1;
                HEAP32[$6_1 + 4 >> 2] = $0_1;
                $9_1 = $7_1 << 4 & 1048560;
                $4_1 = HEAPU8[$1_1 + 84 | 0] | HEAPU8[$1_1 + 85 | 0] << 8 | (HEAPU8[$1_1 + 86 | 0] << 16 | HEAPU8[$1_1 + 87 | 0] << 24);
                $0_1 = $4_1 >>> 28 | 0;
                $6_1 = $2_1 + 72 | 0;
                $7_1 = HEAPU8[$1_1 + 80 | 0] | HEAPU8[$1_1 + 81 | 0] << 8 | (HEAPU8[$1_1 + 82 | 0] << 16 | HEAPU8[$1_1 + 83 | 0] << 24);
                $12_1 = ($4_1 & 268435455) << 4 | $7_1 >>> 28;
                HEAP32[$6_1 >> 2] = $12_1;
                $16_1 = $0_1 | $9_1;
                HEAP32[$6_1 + 4 >> 2] = $16_1;
                $0_1 = $4_1 << 24 | $7_1 >>> 8;
                $8_1 = $7_1 << 24 & -16777216;
                $7_1 = HEAPU8[$1_1 + 72 | 0] | HEAPU8[$1_1 + 73 | 0] << 8 | (HEAPU8[$1_1 + 74 | 0] << 16 | HEAPU8[$1_1 + 75 | 0] << 24);
                $9_1 = $2_1 + 8 | 0;
                $6_1 = $9_1 + 56 | 0;
                $4_1 = HEAPU8[$1_1 + 76 | 0] | HEAPU8[$1_1 + 77 | 0] << 8 | (HEAPU8[$1_1 + 78 | 0] << 16 | HEAPU8[$1_1 + 79 | 0] << 24);
                $13_1 = $4_1 >>> 8 | $8_1;
                HEAP32[$6_1 >> 2] = $13_1;
                $17_1 = $0_1 & 1048575;
                HEAP32[$6_1 + 4 >> 2] = $17_1;
                $0_1 = $7_1;
                $4_1 = $4_1 << 12 | $0_1 >>> 20;
                $7_1 = HEAPU8[$1_1 + 64 | 0] | HEAPU8[$1_1 + 65 | 0] << 8 | (HEAPU8[$1_1 + 66 | 0] << 16 | HEAPU8[$1_1 + 67 | 0] << 24);
                $6_1 = $9_1 + 48 | 0;
                $8_1 = HEAPU8[$1_1 + 68 | 0] | HEAPU8[$1_1 + 69 | 0] << 8 | (HEAPU8[$1_1 + 70 | 0] << 16 | HEAPU8[$1_1 + 71 | 0] << 24);
                $14_1 = $0_1 << 12 & -4096 | $8_1 >>> 20;
                HEAP32[$6_1 >> 2] = $14_1;
                $18_1 = $4_1 & 1048575;
                HEAP32[$6_1 + 4 >> 2] = $18_1;
                HEAP32[$2_1 + 88 >> 2] = 0;
                HEAP32[$2_1 + 48 >> 2] = $7_1;
                $19_1 = $8_1 & 1048575;
                HEAP32[$2_1 + 52 >> 2] = $19_1;
                $0_1 = HEAPU8[$1_1 + 44 | 0] | HEAPU8[$1_1 + 45 | 0] << 8 | (HEAPU8[$1_1 + 46 | 0] << 16 | HEAPU8[$1_1 + 47 | 0] << 24);
                $6_1 = $0_1;
                $4_1 = HEAPU8[$1_1 + 40 | 0] | HEAPU8[$1_1 + 41 | 0] << 8 | (HEAPU8[$1_1 + 42 | 0] << 16 | HEAPU8[$1_1 + 43 | 0] << 24);
                $8_1 = ($0_1 << 12 | $4_1 >>> 20) & 1048575;
                $0_1 = HEAPU8[$1_1 + 32 | 0] | HEAPU8[$1_1 + 33 | 0] << 8 | (HEAPU8[$1_1 + 34 | 0] << 16 | HEAPU8[$1_1 + 35 | 0] << 24);
                $9_1 = $4_1 << 12 & -4096;
                $4_1 = HEAPU8[$1_1 + 36 | 0] | HEAPU8[$1_1 + 37 | 0] << 8 | (HEAPU8[$1_1 + 38 | 0] << 16 | HEAPU8[$1_1 + 39 | 0] << 24);
                $20_1 = $9_1 | $4_1 >>> 20;
                HEAP32[$2_1 + 16 >> 2] = $20_1;
                $25_1 = $8_1;
                HEAP32[$2_1 + 20 >> 2] = $8_1;
                $9_1 = $0_1;
                HEAP32[$2_1 + 8 >> 2] = $0_1;
                $21_1 = $4_1 & 1048575;
                HEAP32[$2_1 + 12 >> 2] = $21_1;
                $4_1 = HEAPU8[$1_1 + 60 | 0] | HEAPU8[$1_1 + 61 | 0] << 8 | (HEAPU8[$1_1 + 62 | 0] << 16 | HEAPU8[$1_1 + 63 | 0] << 24);
                $0_1 = $4_1 >>> 16 | 0;
                $8_1 = HEAPU8[$1_1 + 56 | 0] | HEAPU8[$1_1 + 57 | 0] << 8 | (HEAPU8[$1_1 + 58 | 0] << 16 | HEAPU8[$1_1 + 59 | 0] << 24);
                $22_1 = ($4_1 & 65535) << 16 | $8_1 >>> 16;
                HEAP32[$2_1 + 40 >> 2] = $22_1;
                $26_1 = $0_1;
                HEAP32[$2_1 + 44 >> 2] = $0_1;
                $4_1 = HEAPU8[$1_1 + 48 | 0] | HEAPU8[$1_1 + 49 | 0] << 8 | (HEAPU8[$1_1 + 50 | 0] << 16 | HEAPU8[$1_1 + 51 | 0] << 24);
                $0_1 = HEAPU8[$1_1 + 52 | 0] | HEAPU8[$1_1 + 53 | 0] << 8 | (HEAPU8[$1_1 + 54 | 0] << 16 | HEAPU8[$1_1 + 55 | 0] << 24);
                $1_1 = $0_1;
                $23_1 = ($0_1 << 24 | $4_1 >>> 8) & 1048575;
                $6_1 = $4_1 << 24 & -16777216 | $6_1 >>> 8;
                HEAP32[$2_1 + 24 >> 2] = $6_1;
                HEAP32[$2_1 + 28 >> 2] = $23_1;
                $8_1 = $8_1 << 4 & 1048560;
                $0_1 = $0_1 >>> 28 | 0;
                $4_1 = ($1_1 & 268435455) << 4 | $4_1 >>> 28;
                HEAP32[$2_1 + 32 >> 2] = $4_1;
                $0_1 = $0_1 | $8_1;
                HEAP32[$2_1 + 36 >> 2] = $0_1;
                if (!($9_1 | $20_1 | $22_1 | $6_1 | $4_1 | ($25_1 | $21_1 | $26_1 | $23_1 | $0_1))) {
                  FUNCTION_TABLE[HEAP32[$10_1 + 168 >> 2]](690116, HEAP32[$10_1 + 172 >> 2]);
                  $0_1 = 0;
                  break label$5;
                }
                if ($7_1 & 1) {
                  HEAP32[$2_1 + 80 >> 2] = -4 - $11_1;
                  HEAP32[$2_1 + 84 >> 2] = 262143 - (($11_1 >>> 0 > 4294967292) + $24_1 | 0);
                  HEAP32[$2_1 + 72 >> 2] = -4 - $12_1;
                  HEAP32[$2_1 + 76 >> 2] = 4194303 - (($12_1 >>> 0 > 4294967292) + $16_1 | 0);
                  HEAP32[$2_1 + 64 >> 2] = -4 - $13_1;
                  HEAP32[$2_1 + 68 >> 2] = 4194303 - (($13_1 >>> 0 > 4294967292) + $17_1 | 0);
                  HEAP32[$2_1 + 56 >> 2] = -4 - $14_1;
                  HEAP32[$2_1 + 60 >> 2] = 4194303 - (($14_1 >>> 0 > 4294967292) + $18_1 | 0);
                  HEAP32[$2_1 + 48 >> 2] = -3908 - $7_1;
                  HEAP32[$2_1 + 52 >> 2] = 4194299 - (($7_1 >>> 0 > 4294963388) + $19_1 | 0);
                  $27_1 = 1;
                }
                if ($15_1) {
                  HEAP32[$15_1 >> 2] = $27_1;
                }
                $35($5_1, $2_1 + 8 | 0);
                $0_1 = 1;
              }
              global$0 = $2_1 + 96 | 0;
              HEAP32[$3_1 + 300 >> 2] = $0_1;
              if (($0_1 | 0) == 1) {
                break label$3;
              }
              break label$1;
            }
            fimport$1(0);
            break label$2;
          }
          $2_1 = $58(HEAP32[172688], $3_1 + 200 | 0);
          HEAP32[$3_1 + 300 >> 2] = $2_1;
          $0_1 = 1;
          if (($2_1 | 0) == 1) {
            break label$2;
          }
          break label$1;
        }
        global$0 = $3_1 + 304 | 0;
        return $0_1 | 0;
      }
      HEAP32[$3_1 + 112 >> 2] = 0;
      $5($3_1 + 104 | 0);
      wasm2js_trap();
    }
    function $16($0_1) {
      $0_1 = $0_1 | 0;
      var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0;
      $3_1 = global$0 - 272 | 0;
      global$0 = $3_1;
      $1_1 = $3_1 + 8 | 0;
      $4_1 = $1_1 + 56 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $2_1 = $1_1 + 48 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $5_1 = $1_1 + 40 | 0;
      HEAP32[$5_1 >> 2] = 0;
      HEAP32[$5_1 + 4 >> 2] = 0;
      $6_1 = $1_1 + 32 | 0;
      HEAP32[$6_1 >> 2] = 0;
      HEAP32[$6_1 + 4 >> 2] = 0;
      $7_1 = $1_1 + 24 | 0;
      HEAP32[$7_1 >> 2] = 0;
      HEAP32[$7_1 + 4 >> 2] = 0;
      $8_1 = $1_1 + 16 | 0;
      HEAP32[$8_1 >> 2] = 0;
      HEAP32[$8_1 + 4 >> 2] = 0;
      $9_1 = $1_1 + 8 | 0;
      HEAP32[$9_1 >> 2] = 0;
      HEAP32[$9_1 + 4 >> 2] = 0;
      HEAP32[$3_1 + 8 >> 2] = 0;
      HEAP32[$3_1 + 12 >> 2] = 0;
      HEAP32[$3_1 + 76 >> 2] = 0;
      $1_1 = $3_1 + 208 | 0;
      $10_1 = $1_1 + 56 | 0;
      HEAP32[$10_1 >> 2] = 0;
      HEAP32[$10_1 + 4 >> 2] = 0;
      $11_1 = $1_1 + 48 | 0;
      HEAP32[$11_1 >> 2] = 0;
      HEAP32[$11_1 + 4 >> 2] = 0;
      $12_1 = $1_1 + 40 | 0;
      HEAP32[$12_1 >> 2] = 0;
      HEAP32[$12_1 + 4 >> 2] = 0;
      $13_1 = $1_1 + 32 | 0;
      HEAP32[$13_1 >> 2] = 0;
      HEAP32[$13_1 + 4 >> 2] = 0;
      $14_1 = $1_1 + 24 | 0;
      HEAP32[$14_1 >> 2] = 0;
      HEAP32[$14_1 + 4 >> 2] = 0;
      $15_1 = $1_1 + 16 | 0;
      HEAP32[$15_1 >> 2] = 0;
      HEAP32[$15_1 + 4 >> 2] = 0;
      $16_1 = $1_1 + 8 | 0;
      HEAP32[$16_1 >> 2] = 0;
      HEAP32[$16_1 + 4 >> 2] = 0;
      HEAP32[$3_1 + 208 >> 2] = 0;
      HEAP32[$3_1 + 212 >> 2] = 0;
      folding_inner0: {
        label$3: {
          if (($31(HEAP32[172688], $1_1, 690820, $0_1) | 0) == 1) {
            $1_1 = $3_1 + 208 | 0;
            $0_1 = $1_1 + 15 | 0;
            $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
            $4_1 = $3_1 + 144 | 0;
            $5_1 = $4_1 + 8 | 0;
            HEAP32[$5_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
            HEAP32[$5_1 + 4 >> 2] = $2_1;
            $0_1 = $1_1 + 23 | 0;
            $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
            $6_1 = $4_1 + 16 | 0;
            HEAP32[$6_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
            HEAP32[$6_1 + 4 >> 2] = $2_1;
            $0_1 = $1_1 + 31 | 0;
            $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
            $7_1 = $4_1 + 24 | 0;
            HEAP32[$7_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
            HEAP32[$7_1 + 4 >> 2] = $2_1;
            $0_1 = $1_1 + 39 | 0;
            $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
            $8_1 = $4_1 + 32 | 0;
            HEAP32[$8_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
            HEAP32[$8_1 + 4 >> 2] = $2_1;
            $0_1 = $1_1 + 47 | 0;
            $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
            $9_1 = $4_1 + 40 | 0;
            HEAP32[$9_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
            HEAP32[$9_1 + 4 >> 2] = $2_1;
            $0_1 = $1_1 + 55 | 0;
            $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
            $10_1 = $4_1 + 48 | 0;
            HEAP32[$10_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
            HEAP32[$10_1 + 4 >> 2] = $2_1;
            $2_1 = $4_1 + 56 | 0;
            HEAP8[$2_1 | 0] = HEAPU8[$1_1 + 63 | 0];
            HEAP8[$3_1 + 82 | 0] = HEAPU8[$3_1 + 210 | 0];
            HEAP16[$3_1 + 80 >> 1] = HEAPU16[$3_1 + 208 >> 1];
            $0_1 = HEAPU8[$3_1 + 219 | 0] | HEAPU8[$3_1 + 220 | 0] << 8 | (HEAPU8[$3_1 + 221 | 0] << 16 | HEAPU8[$3_1 + 222 | 0] << 24);
            HEAP32[$3_1 + 144 >> 2] = HEAPU8[$3_1 + 215 | 0] | HEAPU8[$3_1 + 216 | 0] << 8 | (HEAPU8[$3_1 + 217 | 0] << 16 | HEAPU8[$3_1 + 218 | 0] << 24);
            HEAP32[$3_1 + 148 >> 2] = $0_1;
            $4_1 = HEAPU8[$3_1 + 211 | 0] | HEAPU8[$3_1 + 212 | 0] << 8 | (HEAPU8[$3_1 + 213 | 0] << 16 | HEAPU8[$3_1 + 214 | 0] << 24);
            $0_1 = $3_1 + 80 | 0;
            HEAP8[$0_1 + 63 | 0] = HEAPU8[$2_1 | 0];
            $2_1 = HEAP32[$10_1 + 4 >> 2];
            $1_1 = $0_1 + 55 | 0;
            $10_1 = HEAP32[$10_1 >> 2];
            HEAP8[$1_1 | 0] = $10_1;
            HEAP8[$1_1 + 1 | 0] = $10_1 >>> 8;
            HEAP8[$1_1 + 2 | 0] = $10_1 >>> 16;
            HEAP8[$1_1 + 3 | 0] = $10_1 >>> 24;
            HEAP8[$1_1 + 4 | 0] = $2_1;
            HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
            HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
            HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
            $2_1 = HEAP32[$9_1 + 4 >> 2];
            $1_1 = $0_1 + 47 | 0;
            $9_1 = HEAP32[$9_1 >> 2];
            HEAP8[$1_1 | 0] = $9_1;
            HEAP8[$1_1 + 1 | 0] = $9_1 >>> 8;
            HEAP8[$1_1 + 2 | 0] = $9_1 >>> 16;
            HEAP8[$1_1 + 3 | 0] = $9_1 >>> 24;
            HEAP8[$1_1 + 4 | 0] = $2_1;
            HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
            HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
            HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
            $2_1 = HEAP32[$8_1 + 4 >> 2];
            $1_1 = $0_1 + 39 | 0;
            $8_1 = HEAP32[$8_1 >> 2];
            HEAP8[$1_1 | 0] = $8_1;
            HEAP8[$1_1 + 1 | 0] = $8_1 >>> 8;
            HEAP8[$1_1 + 2 | 0] = $8_1 >>> 16;
            HEAP8[$1_1 + 3 | 0] = $8_1 >>> 24;
            HEAP8[$1_1 + 4 | 0] = $2_1;
            HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
            HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
            HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
            $2_1 = HEAP32[$7_1 + 4 >> 2];
            $1_1 = $0_1 + 31 | 0;
            $7_1 = HEAP32[$7_1 >> 2];
            HEAP8[$1_1 | 0] = $7_1;
            HEAP8[$1_1 + 1 | 0] = $7_1 >>> 8;
            HEAP8[$1_1 + 2 | 0] = $7_1 >>> 16;
            HEAP8[$1_1 + 3 | 0] = $7_1 >>> 24;
            HEAP8[$1_1 + 4 | 0] = $2_1;
            HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
            HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
            HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
            $2_1 = HEAP32[$6_1 + 4 >> 2];
            $1_1 = $0_1 + 23 | 0;
            $6_1 = HEAP32[$6_1 >> 2];
            HEAP8[$1_1 | 0] = $6_1;
            HEAP8[$1_1 + 1 | 0] = $6_1 >>> 8;
            HEAP8[$1_1 + 2 | 0] = $6_1 >>> 16;
            HEAP8[$1_1 + 3 | 0] = $6_1 >>> 24;
            HEAP8[$1_1 + 4 | 0] = $2_1;
            HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
            HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
            HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
            $2_1 = HEAP32[$5_1 + 4 >> 2];
            $1_1 = $0_1 + 15 | 0;
            $5_1 = HEAP32[$5_1 >> 2];
            HEAP8[$1_1 | 0] = $5_1;
            HEAP8[$1_1 + 1 | 0] = $5_1 >>> 8;
            HEAP8[$1_1 + 2 | 0] = $5_1 >>> 16;
            HEAP8[$1_1 + 3 | 0] = $5_1 >>> 24;
            HEAP8[$1_1 + 4 | 0] = $2_1;
            HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
            HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
            HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
            HEAP8[$3_1 + 83 | 0] = $4_1;
            HEAP8[$3_1 + 84 | 0] = $4_1 >>> 8;
            HEAP8[$3_1 + 85 | 0] = $4_1 >>> 16;
            HEAP8[$3_1 + 86 | 0] = $4_1 >>> 24;
            $1_1 = HEAP32[$3_1 + 148 >> 2];
            $4_1 = HEAP32[$3_1 + 144 >> 2];
            HEAP8[$3_1 + 87 | 0] = $4_1;
            HEAP8[$3_1 + 88 | 0] = $4_1 >>> 8;
            HEAP8[$3_1 + 89 | 0] = $4_1 >>> 16;
            HEAP8[$3_1 + 90 | 0] = $4_1 >>> 24;
            HEAP8[$3_1 + 91 | 0] = $1_1;
            HEAP8[$3_1 + 92 | 0] = $1_1 >>> 8;
            HEAP8[$3_1 + 93 | 0] = $1_1 >>> 16;
            HEAP8[$3_1 + 94 | 0] = $1_1 >>> 24;
            $0_1 = $59($6(), $3_1 + 8 | 0, $3_1 + 76 | 0, $0_1);
            HEAP32[$3_1 + 144 >> 2] = $0_1;
            if (($0_1 | 0) != 1) {
              break folding_inner0;
            }
            $0_1 = $3_1 + 8 | 0;
            $4_1 = $0_1 + 8 | 0;
            $2_1 = HEAP32[$4_1 + 4 >> 2];
            $1_1 = $3_1 + 208 | 0;
            $5_1 = $1_1 + 8 | 0;
            HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
            HEAP32[$5_1 + 4 >> 2] = $2_1;
            $4_1 = $0_1 + 16 | 0;
            $2_1 = HEAP32[$4_1 + 4 >> 2];
            $5_1 = $1_1 + 16 | 0;
            HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
            HEAP32[$5_1 + 4 >> 2] = $2_1;
            $4_1 = $0_1 + 24 | 0;
            $2_1 = HEAP32[$4_1 + 4 >> 2];
            $5_1 = $1_1 + 24 | 0;
            HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
            HEAP32[$5_1 + 4 >> 2] = $2_1;
            $4_1 = $0_1 + 32 | 0;
            $2_1 = HEAP32[$4_1 + 4 >> 2];
            $5_1 = $1_1 + 32 | 0;
            HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
            HEAP32[$5_1 + 4 >> 2] = $2_1;
            $4_1 = $0_1 + 40 | 0;
            $2_1 = HEAP32[$4_1 + 4 >> 2];
            $5_1 = $1_1 + 40 | 0;
            HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
            HEAP32[$5_1 + 4 >> 2] = $2_1;
            $4_1 = $0_1 + 48 | 0;
            $2_1 = HEAP32[$4_1 + 4 >> 2];
            $5_1 = $1_1 + 48 | 0;
            HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
            HEAP32[$5_1 + 4 >> 2] = $2_1;
            $0_1 = $0_1 + 56 | 0;
            $4_1 = HEAP32[$0_1 + 4 >> 2];
            $1_1 = $1_1 + 56 | 0;
            HEAP32[$1_1 >> 2] = HEAP32[$0_1 >> 2];
            HEAP32[$1_1 + 4 >> 2] = $4_1;
            break label$3;
          }
          fimport$1(1);
          $0_1 = HEAP32[$4_1 + 4 >> 2];
          HEAP32[$10_1 >> 2] = HEAP32[$4_1 >> 2];
          HEAP32[$10_1 + 4 >> 2] = $0_1;
          $0_1 = HEAP32[$2_1 + 4 >> 2];
          HEAP32[$11_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$11_1 + 4 >> 2] = $0_1;
          $0_1 = HEAP32[$5_1 + 4 >> 2];
          HEAP32[$12_1 >> 2] = HEAP32[$5_1 >> 2];
          HEAP32[$12_1 + 4 >> 2] = $0_1;
          $0_1 = HEAP32[$6_1 + 4 >> 2];
          HEAP32[$13_1 >> 2] = HEAP32[$6_1 >> 2];
          HEAP32[$13_1 + 4 >> 2] = $0_1;
          $0_1 = HEAP32[$7_1 + 4 >> 2];
          HEAP32[$14_1 >> 2] = HEAP32[$7_1 >> 2];
          HEAP32[$14_1 + 4 >> 2] = $0_1;
          $0_1 = HEAP32[$8_1 + 4 >> 2];
          HEAP32[$15_1 >> 2] = HEAP32[$8_1 >> 2];
          HEAP32[$15_1 + 4 >> 2] = $0_1;
          $0_1 = HEAP32[$9_1 + 4 >> 2];
          HEAP32[$16_1 >> 2] = HEAP32[$9_1 >> 2];
          HEAP32[$16_1 + 4 >> 2] = $0_1;
        }
        $0_1 = HEAP32[$3_1 + 12 >> 2];
        HEAP32[$3_1 + 208 >> 2] = HEAP32[$3_1 + 8 >> 2];
        HEAP32[$3_1 + 212 >> 2] = $0_1;
        $1_1 = $3_1 + 208 | 0;
        $4_1 = $1_1 + 56 | 0;
        $2_1 = HEAP32[$4_1 + 4 >> 2];
        $0_1 = $3_1 + 80 | 0;
        $5_1 = $0_1 + 56 | 0;
        HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$5_1 + 4 >> 2] = $2_1;
        $4_1 = $1_1 + 48 | 0;
        $2_1 = HEAP32[$4_1 + 4 >> 2];
        $5_1 = $0_1 + 48 | 0;
        HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$5_1 + 4 >> 2] = $2_1;
        $4_1 = $1_1 + 40 | 0;
        $2_1 = HEAP32[$4_1 + 4 >> 2];
        $5_1 = $0_1 + 40 | 0;
        HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$5_1 + 4 >> 2] = $2_1;
        $4_1 = $1_1 + 32 | 0;
        $2_1 = HEAP32[$4_1 + 4 >> 2];
        $5_1 = $0_1 + 32 | 0;
        HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$5_1 + 4 >> 2] = $2_1;
        $4_1 = $1_1 + 24 | 0;
        $2_1 = HEAP32[$4_1 + 4 >> 2];
        $5_1 = $0_1 + 24 | 0;
        HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$5_1 + 4 >> 2] = $2_1;
        $4_1 = $1_1 + 16 | 0;
        $2_1 = HEAP32[$4_1 + 4 >> 2];
        $5_1 = $0_1 + 16 | 0;
        HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$5_1 + 4 >> 2] = $2_1;
        $1_1 = $1_1 + 8 | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2];
        $2_1 = $0_1 + 8 | 0;
        HEAP32[$2_1 >> 2] = HEAP32[$1_1 >> 2];
        HEAP32[$2_1 + 4 >> 2] = $4_1;
        $1_1 = HEAP32[$3_1 + 212 >> 2];
        HEAP32[$3_1 + 80 >> 2] = HEAP32[$3_1 + 208 >> 2];
        HEAP32[$3_1 + 84 >> 2] = $1_1;
        $0_1 = $58(HEAP32[172688], $0_1);
        HEAP32[$3_1 + 8 >> 2] = $0_1;
        if (($0_1 | 0) != 1) {
          break folding_inner0;
        }
        global$0 = $3_1 + 272 | 0;
        return 1;
      }
      HEAP32[$3_1 + 216 >> 2] = 0;
      $5($3_1 + 208 | 0);
      wasm2js_trap();
    }
    function $17($0_1, $1_1) {
      $0_1 = $0_1 | 0;
      $1_1 = $1_1 | 0;
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0;
      $5_1 = global$0 - 208 | 0;
      global$0 = $5_1;
      $2_1 = $5_1 + 136 | 0;
      $4_1 = $2_1 + 56 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $2_1 + 48 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $2_1 + 40 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $2_1 + 32 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $2_1 + 24 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $2_1 + 16 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $2_1 + 8 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      HEAP32[$5_1 + 136 >> 2] = 0;
      HEAP32[$5_1 + 140 >> 2] = 0;
      label$1: {
        if (($31(HEAP32[172688], $2_1, 690820, $0_1) | 0) == 1) {
          $10_1 = $5_1 + 136 | 0;
          $2_1 = $10_1 + 15 | 0;
          $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
          $4_1 = $5_1 + 72 | 0;
          $13_1 = $4_1 + 8 | 0;
          HEAP32[$13_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
          HEAP32[$13_1 + 4 >> 2] = $0_1;
          $2_1 = $10_1 + 23 | 0;
          $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
          $12_1 = $4_1 + 16 | 0;
          HEAP32[$12_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
          HEAP32[$12_1 + 4 >> 2] = $0_1;
          $2_1 = $10_1 + 31 | 0;
          $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
          $9_1 = $4_1 + 24 | 0;
          HEAP32[$9_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
          HEAP32[$9_1 + 4 >> 2] = $0_1;
          $2_1 = $10_1 + 39 | 0;
          $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
          $7_1 = $4_1 + 32 | 0;
          HEAP32[$7_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
          HEAP32[$7_1 + 4 >> 2] = $0_1;
          $2_1 = $10_1 + 47 | 0;
          $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
          $11_1 = $4_1 + 40 | 0;
          HEAP32[$11_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
          HEAP32[$11_1 + 4 >> 2] = $0_1;
          $8_1 = $10_1 + 55 | 0;
          $0_1 = HEAPU8[$8_1 + 4 | 0] | HEAPU8[$8_1 + 5 | 0] << 8 | (HEAPU8[$8_1 + 6 | 0] << 16 | HEAPU8[$8_1 + 7 | 0] << 24);
          $2_1 = $4_1 + 48 | 0;
          HEAP32[$2_1 >> 2] = HEAPU8[$8_1 | 0] | HEAPU8[$8_1 + 1 | 0] << 8 | (HEAPU8[$8_1 + 2 | 0] << 16 | HEAPU8[$8_1 + 3 | 0] << 24);
          HEAP32[$2_1 + 4 >> 2] = $0_1;
          $4_1 = $4_1 + 56 | 0;
          HEAP8[$4_1 | 0] = HEAPU8[$10_1 + 63 | 0];
          HEAP8[$5_1 + 10 | 0] = HEAPU8[$5_1 + 138 | 0];
          HEAP16[$5_1 + 8 >> 1] = HEAPU16[$5_1 + 136 >> 1];
          $0_1 = HEAPU8[$5_1 + 147 | 0] | HEAPU8[$5_1 + 148 | 0] << 8 | (HEAPU8[$5_1 + 149 | 0] << 16 | HEAPU8[$5_1 + 150 | 0] << 24);
          HEAP32[$5_1 + 72 >> 2] = HEAPU8[$5_1 + 143 | 0] | HEAPU8[$5_1 + 144 | 0] << 8 | (HEAPU8[$5_1 + 145 | 0] << 16 | HEAPU8[$5_1 + 146 | 0] << 24);
          HEAP32[$5_1 + 76 >> 2] = $0_1;
          $10_1 = HEAPU8[$5_1 + 139 | 0] | HEAPU8[$5_1 + 140 | 0] << 8 | (HEAPU8[$5_1 + 141 | 0] << 16 | HEAPU8[$5_1 + 142 | 0] << 24);
          $3_1 = $5_1 + 8 | 0;
          HEAP8[$3_1 + 63 | 0] = HEAPU8[$4_1 | 0];
          $4_1 = HEAP32[$2_1 + 4 >> 2];
          $8_1 = $3_1 + 55 | 0;
          $0_1 = HEAP32[$2_1 >> 2];
          HEAP8[$8_1 | 0] = $0_1;
          HEAP8[$8_1 + 1 | 0] = $0_1 >>> 8;
          HEAP8[$8_1 + 2 | 0] = $0_1 >>> 16;
          HEAP8[$8_1 + 3 | 0] = $0_1 >>> 24;
          HEAP8[$8_1 + 4 | 0] = $4_1;
          HEAP8[$8_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$8_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$8_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$11_1 + 4 >> 2];
          $2_1 = $3_1 + 47 | 0;
          $0_1 = HEAP32[$11_1 >> 2];
          HEAP8[$2_1 | 0] = $0_1;
          HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $4_1;
          HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$7_1 + 4 >> 2];
          $2_1 = $3_1 + 39 | 0;
          $0_1 = HEAP32[$7_1 >> 2];
          HEAP8[$2_1 | 0] = $0_1;
          HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $4_1;
          HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$9_1 + 4 >> 2];
          $2_1 = $3_1 + 31 | 0;
          $0_1 = HEAP32[$9_1 >> 2];
          HEAP8[$2_1 | 0] = $0_1;
          HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $4_1;
          HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$12_1 + 4 >> 2];
          $2_1 = $3_1 + 23 | 0;
          $0_1 = HEAP32[$12_1 >> 2];
          HEAP8[$2_1 | 0] = $0_1;
          HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $4_1;
          HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$13_1 + 4 >> 2];
          $2_1 = $3_1 + 15 | 0;
          $0_1 = HEAP32[$13_1 >> 2];
          HEAP8[$2_1 | 0] = $0_1;
          HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $4_1;
          HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
          HEAP8[$5_1 + 11 | 0] = $10_1;
          HEAP8[$5_1 + 12 | 0] = $10_1 >>> 8;
          HEAP8[$5_1 + 13 | 0] = $10_1 >>> 16;
          HEAP8[$5_1 + 14 | 0] = $10_1 >>> 24;
          $4_1 = HEAP32[$5_1 + 76 >> 2];
          $0_1 = HEAP32[$5_1 + 72 >> 2];
          HEAP8[$5_1 + 15 | 0] = $0_1;
          HEAP8[$5_1 + 16 | 0] = $0_1 >>> 8;
          HEAP8[$5_1 + 17 | 0] = $0_1 >>> 16;
          HEAP8[$5_1 + 18 | 0] = $0_1 >>> 24;
          HEAP8[$5_1 + 19 | 0] = $4_1;
          HEAP8[$5_1 + 20 | 0] = $4_1 >>> 8;
          HEAP8[$5_1 + 21 | 0] = $4_1 >>> 16;
          HEAP8[$5_1 + 22 | 0] = $4_1 >>> 24;
          $14_1 = $6();
          $6_1 = global$0 - 288 | 0;
          global$0 = $6_1;
          HEAP32[$6_1 + 4 >> 2] = 0;
          label$3: {
            if (!$3_1) {
              FUNCTION_TABLE[HEAP32[$14_1 + 168 >> 2]](689638, HEAP32[$14_1 + 172 >> 2]);
              break label$3;
            }
            $38($6_1 + 8 | 0, 690949, $6_1 + 4 | 0);
            if (HEAP32[$6_1 + 4 >> 2]) {
              HEAP8[$3_1 | 0] = 0;
              HEAP8[$3_1 + 1 | 0] = 0;
              HEAP8[$3_1 + 2 | 0] = 0;
              HEAP8[$3_1 + 3 | 0] = 0;
              HEAP8[$3_1 + 4 | 0] = 0;
              HEAP8[$3_1 + 5 | 0] = 0;
              HEAP8[$3_1 + 6 | 0] = 0;
              HEAP8[$3_1 + 7 | 0] = 0;
              $0_1 = $3_1 + 56 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $3_1 + 48 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $3_1 + 40 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $3_1 + 32 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $3_1 + 24 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $3_1 + 16 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $3_1 + 8 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              break label$3;
            }
            $0_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
            $8_1 = $0_1 >>> 16 | 0;
            $11_1 = $6_1 + 112 | 0;
            $4_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
            HEAP32[$11_1 >> 2] = ($0_1 & 65535) << 16 | $4_1 >>> 16;
            HEAP32[$11_1 + 4 >> 2] = $8_1;
            $11_1 = $4_1 << 4 & 1048560;
            $0_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
            $8_1 = $0_1 >>> 28 | 0;
            $7_1 = $6_1 + 104 | 0;
            $4_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
            HEAP32[$7_1 >> 2] = ($0_1 & 268435455) << 4 | $4_1 >>> 28;
            HEAP32[$7_1 + 4 >> 2] = $8_1 | $11_1;
            $8_1 = $0_1 << 24 | $4_1 >>> 8;
            $7_1 = $4_1 << 24 & -16777216;
            $4_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
            $9_1 = $6_1 + 40 | 0;
            $12_1 = $9_1 + 56 | 0;
            $0_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
            HEAP32[$12_1 >> 2] = $0_1 >>> 8 | $7_1;
            HEAP32[$12_1 + 4 >> 2] = $8_1 & 1048575;
            $12_1 = $0_1 << 12 | $4_1 >>> 20;
            $7_1 = $4_1 << 12 & -4096;
            $2_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
            $0_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
            $9_1 = $9_1 + 48 | 0;
            HEAP32[$9_1 >> 2] = $0_1 >>> 20 | $7_1;
            HEAP32[$9_1 + 4 >> 2] = $12_1 & 1048575;
            HEAP32[$6_1 + 120 >> 2] = 0;
            HEAP32[$6_1 + 80 >> 2] = $2_1;
            HEAP32[$6_1 + 84 >> 2] = $0_1 & 1048575;
            $2_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
            $10_1 = $2_1;
            $4_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
            $8_1 = $2_1 << 12 | $4_1 >>> 20;
            $7_1 = $4_1 << 12 & -4096;
            $13_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
            $4_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
            $2_1 = $4_1;
            $0_1 = $6_1;
            $15_1 = $2_1 >>> 20 | $7_1;
            HEAP32[$0_1 + 48 >> 2] = $15_1;
            $16_1 = $8_1 & 1048575;
            HEAP32[$0_1 + 52 >> 2] = $16_1;
            HEAP32[$0_1 + 40 >> 2] = $13_1;
            $17_1 = $2_1 & 1048575;
            HEAP32[$0_1 + 44 >> 2] = $17_1;
            $4_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
            $12_1 = $4_1;
            $2_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
            $11_1 = ($2_1 & 65535) << 16 | $4_1 >>> 16;
            HEAP32[$0_1 + 72 >> 2] = $11_1;
            $7_1 = $2_1 >>> 16 | 0;
            HEAP32[$0_1 + 76 >> 2] = $7_1;
            $4_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
            $2_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
            $8_1 = $2_1 << 24 | $4_1 >>> 8;
            $18_1 = $4_1 << 24 & -16777216 | $10_1 >>> 8;
            HEAP32[$0_1 + 56 >> 2] = $18_1;
            $10_1 = $8_1 & 1048575;
            HEAP32[$0_1 + 60 >> 2] = $10_1;
            $9_1 = $12_1 << 4 & 1048560;
            $4_1 = ($2_1 & 268435455) << 4 | $4_1 >>> 28;
            HEAP32[$0_1 + 64 >> 2] = $4_1;
            $0_1 = $2_1 >>> 28 | $9_1;
            HEAP32[$6_1 + 68 >> 2] = $0_1;
            if (!($13_1 | $15_1 | $11_1 | $18_1 | $4_1 | ($16_1 | $17_1 | $7_1 | $10_1 | $0_1))) {
              FUNCTION_TABLE[HEAP32[$14_1 + 168 >> 2]](690116, HEAP32[$14_1 + 172 >> 2]);
              $0_1 = $3_1 + 56 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $3_1 + 48 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $3_1 + 40 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $3_1 + 32 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $3_1 + 24 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $3_1 + 16 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $3_1 + 8 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              HEAP8[$3_1 | 0] = 0;
              HEAP8[$3_1 + 1 | 0] = 0;
              HEAP8[$3_1 + 2 | 0] = 0;
              HEAP8[$3_1 + 3 | 0] = 0;
              HEAP8[$3_1 + 4 | 0] = 0;
              HEAP8[$3_1 + 5 | 0] = 0;
              HEAP8[$3_1 + 6 | 0] = 0;
              HEAP8[$3_1 + 7 | 0] = 0;
              break label$3;
            }
            HEAP8[$3_1 | 0] = 0;
            HEAP8[$3_1 + 1 | 0] = 0;
            HEAP8[$3_1 + 2 | 0] = 0;
            HEAP8[$3_1 + 3 | 0] = 0;
            HEAP8[$3_1 + 4 | 0] = 0;
            HEAP8[$3_1 + 5 | 0] = 0;
            HEAP8[$3_1 + 6 | 0] = 0;
            HEAP8[$3_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 56 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 48 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 40 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 32 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 24 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 16 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 8 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            if (!(HEAP32[$6_1 + 32 >> 2] | (HEAP32[$6_1 + 24 >> 2] | (HEAP32[$6_1 + 16 >> 2] | HEAP32[$6_1 + 8 >> 2])) | (HEAP32[$6_1 + 36 >> 2] | (HEAP32[$6_1 + 28 >> 2] | (HEAP32[$6_1 + 20 >> 2] | HEAP32[$6_1 + 12 >> 2]))))) {
              break label$3;
            }
            $11_1 = $6_1 + 256 | 0;
            $0_1 = $11_1 + 24 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $11_1 + 16 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $11_1 + 8 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $7_1 = $6_1 + 40 | 0;
            $2_1 = $7_1 + 8 | 0;
            $4_1 = HEAP32[$2_1 + 4 >> 2];
            $9_1 = $6_1 + 128 | 0;
            $0_1 = $9_1 + 8 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $4_1;
            $2_1 = $7_1 + 16 | 0;
            $4_1 = HEAP32[$2_1 + 4 >> 2];
            $0_1 = $9_1 + 16 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $4_1;
            $2_1 = $7_1 + 24 | 0;
            $4_1 = HEAP32[$2_1 + 4 >> 2];
            $0_1 = $9_1 + 24 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $4_1;
            $2_1 = $7_1 + 32 | 0;
            $4_1 = HEAP32[$2_1 + 4 >> 2];
            $0_1 = $9_1 + 32 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $4_1;
            $2_1 = $7_1 + 48 | 0;
            $4_1 = HEAP32[$2_1 + 4 >> 2];
            $0_1 = $9_1 + 48 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $4_1;
            $2_1 = $7_1 + 56 | 0;
            $4_1 = HEAP32[$2_1 + 4 >> 2];
            $0_1 = $9_1 + 56 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $4_1;
            $2_1 = $7_1 - -64 | 0;
            $4_1 = HEAP32[$2_1 + 4 >> 2];
            $0_1 = $9_1 - -64 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $4_1;
            $2_1 = $7_1 + 72 | 0;
            $4_1 = HEAP32[$2_1 + 4 >> 2];
            $0_1 = $9_1 + 72 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $4_1;
            HEAP32[$6_1 + 256 >> 2] = 0;
            HEAP32[$6_1 + 260 >> 2] = 0;
            HEAP32[$6_1 + 248 >> 2] = 0;
            $0_1 = HEAP32[$6_1 + 44 >> 2];
            HEAP32[$6_1 + 128 >> 2] = HEAP32[$6_1 + 40 >> 2];
            HEAP32[$6_1 + 132 >> 2] = $0_1;
            $0_1 = HEAP32[$6_1 + 84 >> 2];
            HEAP32[$6_1 + 168 >> 2] = HEAP32[$6_1 + 80 >> 2];
            HEAP32[$6_1 + 172 >> 2] = $0_1;
            $0_1 = $6_1 + 240 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $6_1 + 232 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $6_1 + 224 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $6_1 + 216 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            HEAP32[$6_1 + 208 >> 2] = 1;
            HEAP32[$6_1 + 212 >> 2] = 0;
            $42($9_1, $9_1, $6_1 + 8 | 0, $11_1);
            $49($7_1, $9_1);
            $35($3_1, $7_1);
            $19_1 = 1;
          }
          global$0 = $6_1 + 288 | 0;
          if (!$19_1) {
            break label$1;
          }
          HEAP32[$5_1 + 204 >> 2] = $1_1;
          $0_1 = $36(HEAP32[172688], $5_1 + 204 | 0, $5_1 + 8 | 0, ($1_1 | 0) == 33 ? 258 : 2);
          HEAP32[$5_1 + 72 >> 2] = $0_1;
          $20_1 = 1;
          if (($0_1 | 0) == 1) {
            break label$1;
          }
          HEAP32[$5_1 + 144 >> 2] = 0;
          $5($5_1 + 136 | 0);
          wasm2js_trap();
        }
        fimport$1(1);
      }
      global$0 = $5_1 + 208 | 0;
      return $20_1 | 0;
    }
    function $18() {
      return ($52() | 0) == 1 | 0;
    }
    function $19() {
      var $0_1 = 0, $1_1 = 0;
      $0_1 = global$0 - 32 | 0;
      global$0 = $0_1;
      $1_1 = $51(HEAP32[172688], 690949);
      HEAP32[$0_1 + 4 >> 2] = $1_1;
      if (($1_1 | 0) == 1) {
        $1_1 = $52();
        global$0 = $0_1 + 32 | 0;
        return ($1_1 | 0) == 1 | 0;
      }
      HEAP32[$0_1 + 16 >> 2] = 0;
      $5($0_1 + 8 | 0);
      wasm2js_trap();
    }
    function $20() {
      var $0_1 = 0, $1_1 = 0;
      $0_1 = global$0 - 32 | 0;
      global$0 = $0_1;
      $1_1 = $51(HEAP32[172688], 690788);
      HEAP32[$0_1 + 4 >> 2] = $1_1;
      if (($1_1 | 0) == 1) {
        global$0 = $0_1 + 32 | 0;
        return;
      }
      HEAP32[$0_1 + 16 >> 2] = 0;
      $5($0_1 + 8 | 0);
      wasm2js_trap();
    }
    function $21($0_1) {
      $0_1 = $0_1 | 0;
      var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0;
      $3_1 = global$0 - 96 | 0;
      global$0 = $3_1;
      $1_1 = $3_1 + 56 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $3_1 + 48 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $3_1 + 40 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $3_1 + 32 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $3_1 + 24 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $3_1 + 16 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $3_1 + 8 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $2_1 = $6();
      $5_1 = HEAP32[172560];
      $0_1 = $0_1 ? 655681 : 0;
      $1_1 = global$0 + -64 | 0;
      global$0 = $1_1;
      label$1: {
        if (!HEAP32[$2_1 >> 2]) {
          FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](690045, HEAP32[$2_1 + 172 >> 2]);
          $0_1 = 0;
          break label$1;
        }
        if (!$3_1) {
          FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689760, HEAP32[$2_1 + 172 >> 2]);
          $0_1 = 0;
          break label$1;
        }
        $4_1 = $1_1 + 32 | 0;
        $0_1 = $47($2_1, $4_1, $1_1, 0, $5_1, $0_1);
        $6_1 = $4_1 + 24 | 0;
        $5_1 = HEAP32[$6_1 + 4 >> 2];
        $2_1 = $3_1 + 24 | 0;
        $6_1 = HEAP32[$6_1 >> 2];
        HEAP8[$2_1 | 0] = $6_1;
        HEAP8[$2_1 + 1 | 0] = $6_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $6_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $6_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $5_1;
        HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
        $6_1 = $4_1 + 16 | 0;
        $5_1 = HEAP32[$6_1 + 4 >> 2];
        $2_1 = $3_1 + 16 | 0;
        $6_1 = HEAP32[$6_1 >> 2];
        HEAP8[$2_1 | 0] = $6_1;
        HEAP8[$2_1 + 1 | 0] = $6_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $6_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $6_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $5_1;
        HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
        $4_1 = $4_1 + 8 | 0;
        $5_1 = HEAP32[$4_1 + 4 >> 2];
        $2_1 = $3_1 + 8 | 0;
        $4_1 = HEAP32[$4_1 >> 2];
        HEAP8[$2_1 | 0] = $4_1;
        HEAP8[$2_1 + 1 | 0] = $4_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $4_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $4_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $5_1;
        HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
        $2_1 = HEAP32[$1_1 + 36 >> 2];
        $5_1 = HEAP32[$1_1 + 32 >> 2];
        HEAP8[$3_1 | 0] = $5_1;
        HEAP8[$3_1 + 1 | 0] = $5_1 >>> 8;
        HEAP8[$3_1 + 2 | 0] = $5_1 >>> 16;
        HEAP8[$3_1 + 3 | 0] = $5_1 >>> 24;
        HEAP8[$3_1 + 4 | 0] = $2_1;
        HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
        HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
        HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
        $2_1 = HEAP32[$1_1 + 4 >> 2];
        $5_1 = HEAP32[$1_1 >> 2];
        HEAP8[$3_1 + 32 | 0] = $5_1;
        HEAP8[$3_1 + 33 | 0] = $5_1 >>> 8;
        HEAP8[$3_1 + 34 | 0] = $5_1 >>> 16;
        HEAP8[$3_1 + 35 | 0] = $5_1 >>> 24;
        HEAP8[$3_1 + 36 | 0] = $2_1;
        HEAP8[$3_1 + 37 | 0] = $2_1 >>> 8;
        HEAP8[$3_1 + 38 | 0] = $2_1 >>> 16;
        HEAP8[$3_1 + 39 | 0] = $2_1 >>> 24;
        $4_1 = $1_1 + 8 | 0;
        $5_1 = HEAP32[$4_1 + 4 >> 2];
        $2_1 = $3_1 + 40 | 0;
        $4_1 = HEAP32[$4_1 >> 2];
        HEAP8[$2_1 | 0] = $4_1;
        HEAP8[$2_1 + 1 | 0] = $4_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $4_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $4_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $5_1;
        HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
        $4_1 = $1_1 + 16 | 0;
        $5_1 = HEAP32[$4_1 + 4 >> 2];
        $2_1 = $3_1 + 48 | 0;
        $4_1 = HEAP32[$4_1 >> 2];
        HEAP8[$2_1 | 0] = $4_1;
        HEAP8[$2_1 + 1 | 0] = $4_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $4_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $4_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $5_1;
        HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
        $4_1 = $1_1 + 24 | 0;
        $5_1 = HEAP32[$4_1 + 4 >> 2];
        $2_1 = $3_1 + 56 | 0;
        $4_1 = HEAP32[$4_1 >> 2];
        HEAP8[$2_1 | 0] = $4_1;
        HEAP8[$2_1 + 1 | 0] = $4_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $4_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $4_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $5_1;
        HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
      }
      global$0 = $1_1 - -64 | 0;
      HEAP32[$3_1 + 68 >> 2] = $0_1;
      label$4: {
        label$5: {
          if (($0_1 | 0) == 1) {
            $1_1 = HEAP32[172688];
            $0_1 = global$0 + -64 | 0;
            global$0 = $0_1;
            label$7: {
              if (!$3_1) {
                FUNCTION_TABLE[HEAP32[$1_1 + 168 >> 2]](689748, HEAP32[$1_1 + 172 >> 2]);
                $1_1 = 0;
                break label$7;
              }
              $1_1 = $3_1 + 24 | 0;
              $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
              $2_1 = $0_1 + 32 | 0;
              $4_1 = $2_1 + 24 | 0;
              HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
              HEAP32[$4_1 + 4 >> 2] = $5_1;
              $1_1 = $3_1 + 16 | 0;
              $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
              $4_1 = $2_1 + 16 | 0;
              HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
              HEAP32[$4_1 + 4 >> 2] = $5_1;
              $1_1 = $3_1 + 8 | 0;
              $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
              $4_1 = $2_1 + 8 | 0;
              HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
              HEAP32[$4_1 + 4 >> 2] = $5_1;
              $1_1 = $3_1 + 40 | 0;
              $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
              $4_1 = $0_1 + 8 | 0;
              HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
              HEAP32[$4_1 + 4 >> 2] = $5_1;
              $1_1 = $3_1 + 48 | 0;
              $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
              $4_1 = $0_1 + 16 | 0;
              HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
              HEAP32[$4_1 + 4 >> 2] = $5_1;
              $1_1 = $3_1 + 56 | 0;
              $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
              $4_1 = $0_1 + 24 | 0;
              HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
              HEAP32[$4_1 + 4 >> 2] = $5_1;
              $1_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
              HEAP32[$0_1 + 32 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
              HEAP32[$0_1 + 36 >> 2] = $1_1;
              $1_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
              HEAP32[$0_1 >> 2] = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
              HEAP32[$0_1 + 4 >> 2] = $1_1;
              $39(690981, $2_1);
              $39(691013, $0_1);
              $1_1 = 1;
            }
            global$0 = $0_1 - -64 | 0;
            HEAP32[$3_1 + 68 >> 2] = $1_1;
            if (($1_1 | 0) == 1) {
              break label$5;
            }
            break label$4;
          }
          break label$4;
        }
        global$0 = $3_1 + 96 | 0;
        return;
      }
      HEAP32[$3_1 + 80 >> 2] = 0;
      $5($3_1 + 72 | 0);
      wasm2js_trap();
    }
    function $22($0_1) {
      $0_1 = $0_1 | 0;
      var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0;
      $8_1 = global$0 - 112 | 0;
      global$0 = $8_1;
      $5_1 = $8_1 + 16 | 0;
      $68($5_1, 65);
      $1_1 = $6();
      $3_1 = HEAP32[172560];
      $0_1 = $0_1 ? 655681 : 0;
      $2_1 = global$0 - 80 | 0;
      global$0 = $2_1;
      label$1: {
        if (!HEAP32[$1_1 >> 2]) {
          FUNCTION_TABLE[HEAP32[$1_1 + 168 >> 2]](690045, HEAP32[$1_1 + 172 >> 2]);
          $0_1 = 0;
          break label$1;
        }
        if (!$5_1) {
          FUNCTION_TABLE[HEAP32[$1_1 + 168 >> 2]](689760, HEAP32[$1_1 + 172 >> 2]);
          $0_1 = 0;
          break label$1;
        }
        $4_1 = $2_1 + 48 | 0;
        $7_1 = $2_1 + 16 | 0;
        $0_1 = $47($1_1, $4_1, $7_1, $2_1 + 12 | 0, $3_1, $0_1);
        $1_1 = HEAP32[$2_1 + 52 >> 2];
        $3_1 = HEAP32[$2_1 + 48 >> 2];
        HEAP8[$5_1 | 0] = $3_1;
        HEAP8[$5_1 + 1 | 0] = $3_1 >>> 8;
        HEAP8[$5_1 + 2 | 0] = $3_1 >>> 16;
        HEAP8[$5_1 + 3 | 0] = $3_1 >>> 24;
        HEAP8[$5_1 + 4 | 0] = $1_1;
        HEAP8[$5_1 + 5 | 0] = $1_1 >>> 8;
        HEAP8[$5_1 + 6 | 0] = $1_1 >>> 16;
        HEAP8[$5_1 + 7 | 0] = $1_1 >>> 24;
        $6_1 = $4_1 + 8 | 0;
        $3_1 = HEAP32[$6_1 + 4 >> 2];
        $1_1 = $5_1 + 8 | 0;
        $6_1 = HEAP32[$6_1 >> 2];
        HEAP8[$1_1 | 0] = $6_1;
        HEAP8[$1_1 + 1 | 0] = $6_1 >>> 8;
        HEAP8[$1_1 + 2 | 0] = $6_1 >>> 16;
        HEAP8[$1_1 + 3 | 0] = $6_1 >>> 24;
        HEAP8[$1_1 + 4 | 0] = $3_1;
        HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
        HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
        HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
        $6_1 = $4_1 + 16 | 0;
        $3_1 = HEAP32[$6_1 + 4 >> 2];
        $1_1 = $5_1 + 16 | 0;
        $6_1 = HEAP32[$6_1 >> 2];
        HEAP8[$1_1 | 0] = $6_1;
        HEAP8[$1_1 + 1 | 0] = $6_1 >>> 8;
        HEAP8[$1_1 + 2 | 0] = $6_1 >>> 16;
        HEAP8[$1_1 + 3 | 0] = $6_1 >>> 24;
        HEAP8[$1_1 + 4 | 0] = $3_1;
        HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
        HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
        HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
        $4_1 = $4_1 + 24 | 0;
        $3_1 = HEAP32[$4_1 + 4 >> 2];
        $1_1 = $5_1 + 24 | 0;
        $4_1 = HEAP32[$4_1 >> 2];
        HEAP8[$1_1 | 0] = $4_1;
        HEAP8[$1_1 + 1 | 0] = $4_1 >>> 8;
        HEAP8[$1_1 + 2 | 0] = $4_1 >>> 16;
        HEAP8[$1_1 + 3 | 0] = $4_1 >>> 24;
        HEAP8[$1_1 + 4 | 0] = $3_1;
        HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
        HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
        HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
        $1_1 = HEAP32[$2_1 + 20 >> 2];
        $3_1 = HEAP32[$2_1 + 16 >> 2];
        HEAP8[$5_1 + 32 | 0] = $3_1;
        HEAP8[$5_1 + 33 | 0] = $3_1 >>> 8;
        HEAP8[$5_1 + 34 | 0] = $3_1 >>> 16;
        HEAP8[$5_1 + 35 | 0] = $3_1 >>> 24;
        HEAP8[$5_1 + 36 | 0] = $1_1;
        HEAP8[$5_1 + 37 | 0] = $1_1 >>> 8;
        HEAP8[$5_1 + 38 | 0] = $1_1 >>> 16;
        HEAP8[$5_1 + 39 | 0] = $1_1 >>> 24;
        $4_1 = $7_1 + 8 | 0;
        $3_1 = HEAP32[$4_1 + 4 >> 2];
        $1_1 = $5_1 + 40 | 0;
        $4_1 = HEAP32[$4_1 >> 2];
        HEAP8[$1_1 | 0] = $4_1;
        HEAP8[$1_1 + 1 | 0] = $4_1 >>> 8;
        HEAP8[$1_1 + 2 | 0] = $4_1 >>> 16;
        HEAP8[$1_1 + 3 | 0] = $4_1 >>> 24;
        HEAP8[$1_1 + 4 | 0] = $3_1;
        HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
        HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
        HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
        $4_1 = $7_1 + 16 | 0;
        $3_1 = HEAP32[$4_1 + 4 >> 2];
        $1_1 = $5_1 + 48 | 0;
        $4_1 = HEAP32[$4_1 >> 2];
        HEAP8[$1_1 | 0] = $4_1;
        HEAP8[$1_1 + 1 | 0] = $4_1 >>> 8;
        HEAP8[$1_1 + 2 | 0] = $4_1 >>> 16;
        HEAP8[$1_1 + 3 | 0] = $4_1 >>> 24;
        HEAP8[$1_1 + 4 | 0] = $3_1;
        HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
        HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
        HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
        $4_1 = $7_1 + 24 | 0;
        $3_1 = HEAP32[$4_1 + 4 >> 2];
        $1_1 = $5_1 + 56 | 0;
        $4_1 = HEAP32[$4_1 >> 2];
        HEAP8[$1_1 | 0] = $4_1;
        HEAP8[$1_1 + 1 | 0] = $4_1 >>> 8;
        HEAP8[$1_1 + 2 | 0] = $4_1 >>> 16;
        HEAP8[$1_1 + 3 | 0] = $4_1 >>> 24;
        HEAP8[$1_1 + 4 | 0] = $3_1;
        HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
        HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
        HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
        HEAP8[$5_1 + 64 | 0] = HEAP32[$2_1 + 12 >> 2];
      }
      global$0 = $2_1 + 80 | 0;
      HEAP32[$8_1 + 84 >> 2] = $0_1;
      if (($0_1 | 0) == 1) {
        HEAP32[$8_1 + 12 >> 2] = 0;
        $2_1 = HEAP32[172688];
        $3_1 = $8_1 + 12 | 0;
        $5_1 = global$0 + -64 | 0;
        global$0 = $5_1;
        $0_1 = $8_1 + 16 | 0;
        label$5: {
          if (!$0_1) {
            FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689748, HEAP32[$2_1 + 172 >> 2]);
            break label$5;
          }
          if (!$3_1) {
            FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689795, HEAP32[$2_1 + 172 >> 2]);
            break label$5;
          }
          $2_1 = $0_1 + 24 | 0;
          $4_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
          $1_1 = $5_1 + 32 | 0;
          $7_1 = $1_1 + 24 | 0;
          HEAP32[$7_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
          HEAP32[$7_1 + 4 >> 2] = $4_1;
          $2_1 = $0_1 + 16 | 0;
          $4_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
          $7_1 = $1_1 + 16 | 0;
          HEAP32[$7_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
          HEAP32[$7_1 + 4 >> 2] = $4_1;
          $2_1 = $0_1 + 8 | 0;
          $4_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
          $7_1 = $1_1 + 8 | 0;
          HEAP32[$7_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
          HEAP32[$7_1 + 4 >> 2] = $4_1;
          $2_1 = $0_1 + 56 | 0;
          $4_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
          $7_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
          $2_1 = $0_1 + 48 | 0;
          $6_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
          $9_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
          $2_1 = $0_1 + 40 | 0;
          $10_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
          $2_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
          $11_1 = HEAPU8[$0_1 + 32 | 0] | HEAPU8[$0_1 + 33 | 0] << 8 | (HEAPU8[$0_1 + 34 | 0] << 16 | HEAPU8[$0_1 + 35 | 0] << 24);
          $12_1 = HEAPU8[$0_1 + 36 | 0] | HEAPU8[$0_1 + 37 | 0] << 8 | (HEAPU8[$0_1 + 38 | 0] << 16 | HEAPU8[$0_1 + 39 | 0] << 24);
          $13_1 = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          $14_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          HEAP32[$3_1 >> 2] = HEAPU8[$0_1 + 64 | 0];
          $0_1 = $5_1 + 8 | 0;
          HEAP32[$0_1 >> 2] = $10_1;
          HEAP32[$0_1 + 4 >> 2] = $2_1;
          $0_1 = $5_1 + 16 | 0;
          HEAP32[$0_1 >> 2] = $6_1;
          HEAP32[$0_1 + 4 >> 2] = $9_1;
          $0_1 = $5_1 + 24 | 0;
          HEAP32[$0_1 >> 2] = $4_1;
          HEAP32[$0_1 + 4 >> 2] = $7_1;
          HEAP32[$5_1 + 32 >> 2] = $13_1;
          HEAP32[$5_1 + 36 >> 2] = $14_1;
          HEAP32[$5_1 >> 2] = $11_1;
          HEAP32[$5_1 + 4 >> 2] = $12_1;
          $39(690981, $1_1);
          $39(691013, $5_1);
        }
        global$0 = $5_1 - -64 | 0;
        global$0 = $8_1 + 112 | 0;
        return HEAP32[$8_1 + 12 >> 2];
      }
      HEAP32[$8_1 + 96 >> 2] = 0;
      $5($8_1 + 88 | 0);
      wasm2js_trap();
    }
    function $23($0_1) {
      $0_1 = $0_1 | 0;
      var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0;
      $2_1 = global$0 - 128 | 0;
      global$0 = $2_1;
      $7_1 = $68($2_1, 96);
      $2_1 = $60($6(), $7_1);
      HEAP32[$7_1 + 100 >> 2] = $2_1;
      label$1: {
        label$2: {
          if (($2_1 | 0) == 1) {
            $15_1 = $6();
            $26_1 = $0_1 ? 655681 : 0;
            $1_1 = global$0 - 640 | 0;
            global$0 = $1_1;
            $0_1 = $1_1 + 88 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $1_1 + 80 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            HEAP32[$1_1 + 72 >> 2] = 0;
            HEAP32[$1_1 + 76 >> 2] = 0;
            HEAP32[$1_1 + 64 >> 2] = 0;
            HEAP32[$1_1 + 68 >> 2] = 0;
            label$4: {
              if (!HEAP32[$15_1 >> 2]) {
                FUNCTION_TABLE[HEAP32[$15_1 + 168 >> 2]](690045, HEAP32[$15_1 + 172 >> 2]);
                break label$4;
              }
              if (!$7_1) {
                FUNCTION_TABLE[HEAP32[$15_1 + 168 >> 2]](689700, HEAP32[$15_1 + 172 >> 2]);
                break label$4;
              }
              $17_1 = $1_1 + 472 | 0;
              $23_1 = global$0 - 16 | 0;
              global$0 = $23_1;
              $18_1 = HEAPU8[$7_1 + 40 | 0] | HEAPU8[$7_1 + 41 | 0] << 8 | (HEAPU8[$7_1 + 42 | 0] << 16 | HEAPU8[$7_1 + 43 | 0] << 24);
              $6_1 = HEAPU8[$7_1 + 44 | 0] | HEAPU8[$7_1 + 45 | 0] << 8 | (HEAPU8[$7_1 + 46 | 0] << 16 | HEAPU8[$7_1 + 47 | 0] << 24);
              $10_1 = HEAPU8[$7_1 + 48 | 0] | HEAPU8[$7_1 + 49 | 0] << 8 | (HEAPU8[$7_1 + 50 | 0] << 16 | HEAPU8[$7_1 + 51 | 0] << 24);
              $5_1 = HEAPU8[$7_1 + 52 | 0] | HEAPU8[$7_1 + 53 | 0] << 8 | (HEAPU8[$7_1 + 54 | 0] << 16 | HEAPU8[$7_1 + 55 | 0] << 24);
              $19_1 = HEAPU8[$7_1 + 72 | 0] | HEAPU8[$7_1 + 73 | 0] << 8 | (HEAPU8[$7_1 + 74 | 0] << 16 | HEAPU8[$7_1 + 75 | 0] << 24);
              $12_1 = HEAPU8[$7_1 + 76 | 0] | HEAPU8[$7_1 + 77 | 0] << 8 | (HEAPU8[$7_1 + 78 | 0] << 16 | HEAPU8[$7_1 + 79 | 0] << 24);
              $8_1 = HEAPU8[$7_1 + 80 | 0] | HEAPU8[$7_1 + 81 | 0] << 8 | (HEAPU8[$7_1 + 82 | 0] << 16 | HEAPU8[$7_1 + 83 | 0] << 24);
              $3_1 = HEAPU8[$7_1 + 84 | 0] | HEAPU8[$7_1 + 85 | 0] << 8 | (HEAPU8[$7_1 + 86 | 0] << 16 | HEAPU8[$7_1 + 87 | 0] << 24);
              $16_1 = HEAPU8[$7_1 + 32 | 0] | HEAPU8[$7_1 + 33 | 0] << 8 | (HEAPU8[$7_1 + 34 | 0] << 16 | HEAPU8[$7_1 + 35 | 0] << 24);
              $13_1 = HEAPU8[$7_1 + 36 | 0] | HEAPU8[$7_1 + 37 | 0] << 8 | (HEAPU8[$7_1 + 38 | 0] << 16 | HEAPU8[$7_1 + 39 | 0] << 24);
              $11_1 = HEAPU8[$7_1 + 56 | 0] | HEAPU8[$7_1 + 57 | 0] << 8 | (HEAPU8[$7_1 + 58 | 0] << 16 | HEAPU8[$7_1 + 59 | 0] << 24);
              $4_1 = HEAPU8[$7_1 + 60 | 0] | HEAPU8[$7_1 + 61 | 0] << 8 | (HEAPU8[$7_1 + 62 | 0] << 16 | HEAPU8[$7_1 + 63 | 0] << 24);
              $22_1 = HEAPU8[$7_1 + 64 | 0] | HEAPU8[$7_1 + 65 | 0] << 8 | (HEAPU8[$7_1 + 66 | 0] << 16 | HEAPU8[$7_1 + 67 | 0] << 24);
              $14_1 = HEAPU8[$7_1 + 68 | 0] | HEAPU8[$7_1 + 69 | 0] << 8 | (HEAPU8[$7_1 + 70 | 0] << 16 | HEAPU8[$7_1 + 71 | 0] << 24);
              $9_1 = HEAPU8[$7_1 + 88 | 0] | HEAPU8[$7_1 + 89 | 0] << 8 | (HEAPU8[$7_1 + 90 | 0] << 16 | HEAPU8[$7_1 + 91 | 0] << 24);
              $20_1 = HEAPU8[$7_1 + 92 | 0] | HEAPU8[$7_1 + 93 | 0] << 8 | (HEAPU8[$7_1 + 94 | 0] << 16 | HEAPU8[$7_1 + 95 | 0] << 24);
              $2_1 = $1_1 + 192 | 0;
              HEAP32[$2_1 + 80 >> 2] = 0;
              $21_1 = $2_1 + 72 | 0;
              HEAP32[$21_1 >> 2] = ($20_1 & 65535) << 16 | $9_1 >>> 16;
              HEAP32[$21_1 + 4 >> 2] = $20_1 >>> 16;
              HEAP32[$2_1 + 40 >> 2] = $22_1;
              HEAP32[$2_1 + 44 >> 2] = $14_1 & 1048575;
              $21_1 = ($4_1 & 65535) << 16 | $11_1 >>> 16;
              HEAP32[$2_1 + 32 >> 2] = $21_1;
              $22_1 = $4_1 >>> 16 | 0;
              HEAP32[$2_1 + 36 >> 2] = $22_1;
              HEAP32[$2_1 >> 2] = $16_1;
              $20_1 = $13_1 & 1048575;
              HEAP32[$2_1 + 4 >> 2] = $20_1;
              $24_1 = $2_1 - -64 | 0;
              HEAP32[$24_1 >> 2] = ($3_1 & 268435455) << 4 | $8_1 >>> 28;
              HEAP32[$24_1 + 4 >> 2] = $9_1 << 4 & 1048560 | $3_1 >>> 28;
              $0_1 = $3_1 << 24 | $8_1 >>> 8;
              $9_1 = $2_1 + 56 | 0;
              $3_1 = $12_1;
              HEAP32[$9_1 >> 2] = $8_1 << 24 & -16777216 | $3_1 >>> 8;
              HEAP32[$9_1 + 4 >> 2] = $0_1 & 1048575;
              $0_1 = $3_1 << 12;
              $3_1 = $19_1;
              $8_1 = ($0_1 | $3_1 >>> 20) & 1048575;
              $12_1 = $2_1 + 48 | 0;
              HEAP32[$12_1 >> 2] = $3_1 << 12 & -4096 | $14_1 >>> 20;
              HEAP32[$12_1 + 4 >> 2] = $8_1;
              $3_1 = $11_1 << 4 & 1048560;
              $4_1 = $5_1;
              $0_1 = $4_1 >>> 28 | 0;
              $5_1 = ($4_1 & 268435455) << 4 | $10_1 >>> 28;
              HEAP32[$2_1 + 24 >> 2] = $5_1;
              $3_1 = $0_1 | $3_1;
              HEAP32[$2_1 + 28 >> 2] = $3_1;
              $0_1 = $4_1 << 24 | $10_1 >>> 8;
              $4_1 = $6_1;
              $6_1 = $10_1 << 24 & -16777216 | $4_1 >>> 8;
              HEAP32[$2_1 + 16 >> 2] = $6_1;
              $10_1 = $0_1 & 1048575;
              HEAP32[$2_1 + 20 >> 2] = $10_1;
              $0_1 = $4_1 << 12;
              $4_1 = $18_1;
              $12_1 = ($0_1 | $4_1 >>> 20) & 1048575;
              $4_1 = $4_1 << 12 & -4096 | $13_1 >>> 20;
              HEAP32[$2_1 + 8 >> 2] = $4_1;
              $0_1 = $12_1;
              HEAP32[$2_1 + 12 >> 2] = $0_1;
              label$7: {
                label$8: {
                  if (!($4_1 | $16_1 | $21_1 | $6_1 | $5_1 | ($0_1 | $20_1 | $22_1 | $10_1 | $3_1))) {
                    FUNCTION_TABLE[HEAP32[$15_1 + 168 >> 2]](690116, HEAP32[$15_1 + 172 >> 2]);
                    $70($2_1, 690376, 88);
                    if ($17_1) {
                      break label$8;
                    }
                    break label$7;
                  }
                  $25_1 = 1;
                  if (!$17_1) {
                    break label$7;
                  }
                  $38($17_1, $7_1, $23_1 + 12 | 0);
                  if (!(HEAP32[$23_1 + 12 >> 2] | !(HEAP32[$17_1 + 24 >> 2] | (HEAP32[$17_1 + 16 >> 2] | (HEAP32[$17_1 + 8 >> 2] | HEAP32[$17_1 >> 2])) | (HEAP32[$17_1 + 28 >> 2] | (HEAP32[$17_1 + 20 >> 2] | (HEAP32[$17_1 + 12 >> 2] | HEAP32[$17_1 + 4 >> 2])))))) {
                    break label$7;
                  }
                  FUNCTION_TABLE[HEAP32[$15_1 + 168 >> 2]](689400, HEAP32[$15_1 + 172 >> 2]);
                  $70($2_1, 690376, 88);
                }
                $25_1 = 0;
                $0_1 = HEAP32[172569];
                $2_1 = $17_1 + 24 | 0;
                HEAP32[$2_1 >> 2] = HEAP32[172568];
                HEAP32[$2_1 + 4 >> 2] = $0_1;
                $0_1 = HEAP32[172567];
                $2_1 = $17_1 + 16 | 0;
                HEAP32[$2_1 >> 2] = HEAP32[172566];
                HEAP32[$2_1 + 4 >> 2] = $0_1;
                $0_1 = HEAP32[172565];
                $2_1 = $17_1 + 8 | 0;
                HEAP32[$2_1 >> 2] = HEAP32[172564];
                HEAP32[$2_1 + 4 >> 2] = $0_1;
                $0_1 = HEAP32[172563];
                HEAP32[$17_1 >> 2] = HEAP32[172562];
                HEAP32[$17_1 + 4 >> 2] = $0_1;
              }
              global$0 = $23_1 + 16 | 0;
              label$10: {
                if (!(HEAP8[$1_1 + 232 | 0] & 1)) {
                  $18_1 = HEAP32[$1_1 + 472 >> 2];
                  $12_1 = HEAP32[$1_1 + 476 >> 2];
                  $8_1 = HEAP32[$1_1 + 480 >> 2];
                  $2_1 = HEAP32[$1_1 + 484 >> 2];
                  $3_1 = HEAP32[$1_1 + 488 >> 2];
                  $5_1 = HEAP32[$1_1 + 492 >> 2];
                  $19_1 = HEAP32[$1_1 + 496 >> 2];
                  $10_1 = HEAP32[$1_1 + 500 >> 2];
                  break label$10;
                }
                $13_1 = HEAP32[$1_1 + 496 >> 2];
                $14_1 = HEAP32[$1_1 + 488 >> 2];
                $3_1 = HEAP32[$1_1 + 480 >> 2];
                $0_1 = HEAP32[$1_1 + 472 >> 2];
                $16_1 = HEAP32[$1_1 + 500 >> 2];
                $19_1 = HEAP32[$1_1 + 492 >> 2];
                $5_1 = HEAP32[$1_1 + 484 >> 2];
                $2_1 = HEAP32[$1_1 + 476 >> 2];
                $6_1 = $13_1 | ($14_1 | ($3_1 | $0_1)) | ($16_1 | ($19_1 | ($5_1 | $2_1))) ? -1 : 0;
                $0_1 = $0_1 ^ -1;
                $10_1 = $0_1 - 801750718 | 0;
                $18_1 = $6_1 & $10_1;
                HEAP32[$1_1 + 472 >> 2] = $18_1;
                $2_1 = $2_1 ^ -1;
                $4_1 = $2_1 - (($0_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
                $12_1 = $4_1 & $6_1;
                HEAP32[$1_1 + 476 >> 2] = $12_1;
                $0_1 = ($2_1 | 0) == ($4_1 | 0) & $0_1 >>> 0 > $10_1 >>> 0 | $2_1 >>> 0 > $4_1 >>> 0;
                $10_1 = $3_1 ^ -1;
                $3_1 = $0_1 + $10_1 | 0;
                $5_1 = $5_1 ^ -1;
                $0_1 = $5_1;
                $9_1 = $3_1 - 1354194885 | 0;
                $8_1 = $9_1 & $6_1;
                HEAP32[$1_1 + 480 >> 2] = $8_1;
                $0_1 = $3_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
                $11_1 = $0_1 - (($3_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
                $2_1 = $11_1 & $6_1;
                HEAP32[$1_1 + 484 >> 2] = $2_1;
                $4_1 = ($0_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
                $10_1 = ($0_1 | 0) == ($11_1 | 0) & $3_1 >>> 0 > $9_1 >>> 0 | $0_1 >>> 0 > $11_1 >>> 0;
                $3_1 = $4_1 + $10_1 | 0;
                $0_1 = $3_1 >>> 0 < $10_1 >>> 0;
                $11_1 = $14_1 ^ -1;
                $10_1 = $11_1 + $3_1 | 0;
                $14_1 = $19_1 ^ -1;
                $0_1 = $14_1 + $0_1 | 0;
                $9_1 = $10_1 - 2 | 0;
                $3_1 = $9_1 & $6_1;
                HEAP32[$1_1 + 488 >> 2] = $3_1;
                $0_1 = $10_1 >>> 0 < $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
                $19_1 = $0_1 - ($10_1 >>> 0 < 2) | 0;
                $5_1 = $19_1 & $6_1;
                HEAP32[$1_1 + 492 >> 2] = $5_1;
                $4_1 = ($0_1 | 0) == ($14_1 | 0) & $10_1 >>> 0 < $11_1 >>> 0 | $0_1 >>> 0 < $14_1 >>> 0;
                $10_1 = ($0_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 > $19_1 >>> 0;
                $4_1 = $4_1 + $10_1 | 0;
                $0_1 = $4_1 >>> 0 < $10_1 >>> 0;
                $10_1 = $4_1 - $13_1 | 0;
                $19_1 = $10_1 - 2 & $6_1;
                HEAP32[$1_1 + 496 >> 2] = $19_1;
                $10_1 = ($0_1 - (($4_1 >>> 0 < $13_1 >>> 0) + $16_1 | 0) | 0) - ($10_1 >>> 0 < 2) & $6_1;
                HEAP32[$1_1 + 500 >> 2] = $10_1;
              }
              HEAP8[$1_1 + 31 | 0] = $18_1;
              HEAP8[$1_1 + 30 | 0] = ($12_1 & 255) << 24 | $18_1 >>> 8;
              HEAP8[$1_1 + 29 | 0] = ($12_1 & 65535) << 16 | $18_1 >>> 16;
              HEAP8[$1_1 + 28 | 0] = ($12_1 & 16777215) << 8 | $18_1 >>> 24;
              HEAP8[$1_1 + 27 | 0] = $12_1;
              HEAP8[$1_1 + 26 | 0] = $12_1 >>> 8;
              HEAP8[$1_1 + 25 | 0] = $12_1 >>> 16;
              HEAP8[$1_1 + 24 | 0] = $12_1 >>> 24;
              HEAP8[$1_1 + 23 | 0] = $8_1;
              HEAP8[$1_1 + 22 | 0] = ($2_1 & 255) << 24 | $8_1 >>> 8;
              HEAP8[$1_1 + 21 | 0] = ($2_1 & 65535) << 16 | $8_1 >>> 16;
              HEAP8[$1_1 + 20 | 0] = ($2_1 & 16777215) << 8 | $8_1 >>> 24;
              HEAP8[$1_1 + 19 | 0] = $2_1;
              HEAP8[$1_1 + 18 | 0] = $2_1 >>> 8;
              HEAP8[$1_1 + 17 | 0] = $2_1 >>> 16;
              HEAP8[$1_1 + 16 | 0] = $2_1 >>> 24;
              HEAP8[$1_1 + 15 | 0] = $3_1;
              HEAP8[$1_1 + 14 | 0] = ($5_1 & 255) << 24 | $3_1 >>> 8;
              HEAP8[$1_1 + 13 | 0] = ($5_1 & 65535) << 16 | $3_1 >>> 16;
              HEAP8[$1_1 + 12 | 0] = ($5_1 & 16777215) << 8 | $3_1 >>> 24;
              HEAP8[$1_1 + 11 | 0] = $5_1;
              HEAP8[$1_1 + 10 | 0] = $5_1 >>> 8;
              HEAP8[$1_1 + 9 | 0] = $5_1 >>> 16;
              HEAP8[$1_1 + 8 | 0] = $5_1 >>> 24;
              HEAP8[$1_1 + 7 | 0] = $19_1;
              HEAP8[$1_1 + 6 | 0] = ($10_1 & 255) << 24 | $19_1 >>> 8;
              HEAP8[$1_1 + 5 | 0] = ($10_1 & 65535) << 16 | $19_1 >>> 16;
              HEAP8[$1_1 + 4 | 0] = ($10_1 & 16777215) << 8 | $19_1 >>> 24;
              HEAP8[$1_1 + 3 | 0] = $10_1;
              HEAP8[$1_1 + 2 | 0] = $10_1 >>> 8;
              HEAP8[$1_1 + 1 | 0] = $10_1 >>> 16;
              HEAP8[$1_1 | 0] = $10_1 >>> 24;
              $2_1 = HEAP32[$1_1 + 228 >> 2];
              $4_1 = HEAP32[$1_1 + 224 >> 2];
              HEAP8[$1_1 + 37 | 0] = $4_1;
              $0_1 = HEAP32[$1_1 + 212 >> 2];
              $3_1 = HEAP32[$1_1 + 208 >> 2];
              HEAP8[$1_1 + 50 | 0] = $3_1;
              HEAP8[$1_1 + 36 | 0] = ($2_1 & 255) << 24 | $4_1 >>> 8;
              HEAP8[$1_1 + 35 | 0] = ($2_1 & 65535) << 16 | $4_1 >>> 16;
              HEAP8[$1_1 + 34 | 0] = ($2_1 & 16777215) << 8 | $4_1 >>> 24;
              HEAP8[$1_1 + 33 | 0] = $2_1;
              HEAP8[$1_1 + 32 | 0] = $2_1 >>> 8;
              $2_1 = HEAP32[$1_1 + 220 >> 2];
              $4_1 = HEAP32[$1_1 + 216 >> 2];
              HEAP8[$1_1 + 43 | 0] = ($2_1 & 15) << 28 | $4_1 >>> 4;
              HEAP8[$1_1 + 42 | 0] = ($2_1 & 4095) << 20 | $4_1 >>> 12;
              HEAP8[$1_1 + 41 | 0] = ($2_1 & 1048575) << 12 | $4_1 >>> 20;
              HEAP8[$1_1 + 40 | 0] = ($2_1 & 268435455) << 4 | $4_1 >>> 28;
              HEAP8[$1_1 + 39 | 0] = $2_1 >>> 4;
              HEAP8[$1_1 + 38 | 0] = $2_1 >>> 12;
              HEAP8[$1_1 + 49 | 0] = ($0_1 & 255) << 24 | $3_1 >>> 8;
              HEAP8[$1_1 + 48 | 0] = ($0_1 & 65535) << 16 | $3_1 >>> 16;
              HEAP8[$1_1 + 47 | 0] = ($0_1 & 16777215) << 8 | $3_1 >>> 24;
              HEAP8[$1_1 + 46 | 0] = $0_1;
              HEAP8[$1_1 + 45 | 0] = $0_1 >>> 8;
              HEAP8[$1_1 + 44 | 0] = $0_1 >>> 16 & 15 | $4_1 << 4;
              $0_1 = HEAP32[$1_1 + 196 >> 2];
              $3_1 = HEAP32[$1_1 + 192 >> 2];
              HEAP8[$1_1 + 63 | 0] = $3_1;
              $2_1 = HEAP32[$1_1 + 204 >> 2];
              $4_1 = HEAP32[$1_1 + 200 >> 2];
              HEAP8[$1_1 + 56 | 0] = ($2_1 & 15) << 28 | $4_1 >>> 4;
              HEAP8[$1_1 + 55 | 0] = ($2_1 & 4095) << 20 | $4_1 >>> 12;
              HEAP8[$1_1 + 54 | 0] = ($2_1 & 1048575) << 12 | $4_1 >>> 20;
              HEAP8[$1_1 + 53 | 0] = ($2_1 & 268435455) << 4 | $4_1 >>> 28;
              HEAP8[$1_1 + 52 | 0] = $2_1 >>> 4;
              HEAP8[$1_1 + 51 | 0] = $2_1 >>> 12;
              HEAP8[$1_1 + 62 | 0] = ($0_1 & 255) << 24 | $3_1 >>> 8;
              HEAP8[$1_1 + 61 | 0] = ($0_1 & 65535) << 16 | $3_1 >>> 16;
              HEAP8[$1_1 + 60 | 0] = ($0_1 & 16777215) << 8 | $3_1 >>> 24;
              HEAP8[$1_1 + 59 | 0] = $0_1;
              HEAP8[$1_1 + 58 | 0] = $0_1 >>> 8;
              HEAP8[$1_1 + 57 | 0] = $0_1 >>> 16 & 15 | $4_1 << 4;
              $0_1 = $1_1 - -64 | 0;
              $2_1 = $61($0_1, 655649, 32, $1_1, $1_1 + 32 | 0, 690736, 13, $26_1);
              $4_1 = $1_1 + 408 | 0;
              $38($4_1, $0_1, 0);
              $0_1 = $25_1 & ($2_1 | 0) != 0;
              $2_1 = HEAP32[$1_1 + 432 >> 2];
              $5_1 = HEAP32[$1_1 + 424 >> 2];
              $3_1 = HEAP32[$1_1 + 416 >> 2];
              $6_1 = HEAP32[$1_1 + 408 >> 2];
              $10_1 = HEAP32[$1_1 + 436 >> 2];
              $13_1 = HEAP32[$1_1 + 428 >> 2];
              $12_1 = HEAP32[$1_1 + 420 >> 2];
              $8_1 = HEAP32[$1_1 + 412 >> 2];
              $24_1 = $0_1 & ($2_1 | ($5_1 | ($3_1 | $6_1)) | ($10_1 | ($13_1 | ($12_1 | $8_1)))) != 0;
              $23_1 = !$24_1;
              $0_1 = $23_1 - 1 | 0;
              $19_1 = $0_1 & $2_1;
              HEAP32[$1_1 + 432 >> 2] = $19_1;
              $2_1 = 0 - !$23_1 | 0;
              $10_1 = $2_1 & $10_1;
              HEAP32[$1_1 + 436 >> 2] = $10_1;
              $20_1 = $0_1 & $5_1;
              HEAP32[$1_1 + 424 >> 2] = $20_1;
              $22_1 = $2_1 & $13_1;
              HEAP32[$1_1 + 428 >> 2] = $22_1;
              $21_1 = $0_1 & $3_1;
              HEAP32[$1_1 + 416 >> 2] = $21_1;
              $17_1 = $2_1 & $12_1;
              HEAP32[$1_1 + 420 >> 2] = $17_1;
              $18_1 = $0_1 & $6_1 | $23_1;
              HEAP32[$1_1 + 408 >> 2] = $18_1;
              $12_1 = $2_1 & $8_1;
              HEAP32[$1_1 + 412 >> 2] = $12_1;
              $0_1 = $1_1 + 280 | 0;
              $48($15_1, $0_1, $4_1);
              $49($1_1 + 104 | 0, $0_1);
              $0_1 = $1_1 + 152 | 0;
              $4_1 = HEAP32[$0_1 >> 2];
              $6_1 = HEAP32[$0_1 + 4 >> 2];
              $5_1 = HEAP32[$1_1 + 148 >> 2];
              $0_1 = $1_1 + 176 | 0;
              $8_1 = HEAP32[$0_1 >> 2];
              $3_1 = HEAP32[$0_1 + 4 >> 2];
              $14_1 = $3_1;
              $0_1 = HEAP32[$1_1 + 144 >> 2];
              $2_1 = __wasm_i64_mul($3_1 >>> 16 | 0, 0, 977, 1);
              $3_1 = $0_1 + $2_1 | 0;
              $0_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
              $9_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $0_1 = $6_1;
              $2_1 = $9_1 >>> 20 | 0;
              $5_1 = $2_1;
              $2_1 = $2_1 + $4_1 | 0;
              $5_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $13_1 = $5_1 & 1048575;
              $0_1 = $1_1 + 168 | 0;
              $16_1 = HEAP32[$0_1 >> 2];
              $15_1 = HEAP32[$0_1 + 4 >> 2];
              $0_1 = $1_1 + 160 | 0;
              $6_1 = HEAP32[$0_1 >> 2];
              $0_1 = HEAP32[$0_1 + 4 >> 2];
              $4_1 = $5_1 >>> 20 | 0;
              $11_1 = $4_1;
              $4_1 = $4_1 + $6_1 | 0;
              $11_1 = $11_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $0_1 = $15_1;
              $6_1 = $11_1 >>> 20 | 0;
              $15_1 = $6_1;
              $6_1 = $6_1 + $16_1 | 0;
              $0_1 = $15_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $16_1 = $0_1 & 1048575;
              $11_1 = $11_1 & 1048575;
              $15_1 = ($2_1 & $4_1 & $6_1) == -1 & ($5_1 & $11_1 & $0_1) == 1048575;
              $5_1 = $0_1;
              $0_1 = $14_1 & 65535;
              $5_1 = $5_1 >>> 20 | 0;
              $14_1 = $5_1 + $8_1 | 0;
              $0_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $8_1 = $0_1;
              $5_1 = $9_1 & 1048575;
              if ($15_1 & (($14_1 | 0) == -1 & ($0_1 | 0) == 65535) & (($5_1 | 0) == 1048574 & $3_1 >>> 0 > 4294966318 | $5_1 >>> 0 > 1048574) | $0_1 >>> 16) {
                $0_1 = $5_1 + 1 | 0;
                $3_1 = $3_1 + 977 | 0;
                $0_1 = $3_1 >>> 0 < 977 ? $0_1 + 1 | 0 : $0_1;
                $5_1 = $0_1 & 1048575;
                $9_1 = $0_1;
                $0_1 = $13_1;
                $9_1 = $9_1 >>> 20 | 0;
                $2_1 = $2_1 + $9_1 | 0;
                $0_1 = $9_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
                $13_1 = $0_1 & 1048575;
                $9_1 = $0_1;
                $0_1 = $11_1;
                $9_1 = $9_1 >>> 20 | 0;
                $4_1 = $4_1 + $9_1 | 0;
                $0_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
                $11_1 = $0_1 & 1048575;
                $9_1 = $0_1;
                $0_1 = $16_1;
                $9_1 = $9_1 >>> 20 | 0;
                $6_1 = $6_1 + $9_1 | 0;
                $0_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
                $16_1 = $0_1 & 1048575;
                $9_1 = $0_1;
                $0_1 = $8_1;
                $8_1 = $14_1;
                $14_1 = ($9_1 >>> 20 | 0) + $14_1 | 0;
                $8_1 = ($8_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) & 65535;
              }
              HEAP32[$1_1 + 176 >> 2] = $14_1;
              HEAP32[$1_1 + 180 >> 2] = $8_1;
              HEAP32[$1_1 + 168 >> 2] = $6_1;
              HEAP32[$1_1 + 172 >> 2] = $16_1;
              HEAP32[$1_1 + 160 >> 2] = $4_1;
              HEAP32[$1_1 + 164 >> 2] = $11_1;
              HEAP32[$1_1 + 152 >> 2] = $2_1;
              HEAP32[$1_1 + 156 >> 2] = $13_1;
              HEAP32[$1_1 + 144 >> 2] = $3_1;
              HEAP32[$1_1 + 148 >> 2] = $5_1;
              if ($3_1 & 1) {
                $4_1 = $18_1 | $21_1 | $20_1 | $19_1 | ($12_1 | $17_1 | $22_1 | $10_1) ? -1 : 0;
                $0_1 = $18_1 ^ -1;
                $6_1 = $0_1 - 801750718 | 0;
                $18_1 = $4_1 & $6_1;
                HEAP32[$1_1 + 408 >> 2] = $18_1;
                $2_1 = $12_1 ^ -1;
                $3_1 = $2_1 - (($0_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
                $12_1 = $3_1 & $4_1;
                HEAP32[$1_1 + 412 >> 2] = $12_1;
                $0_1 = ($2_1 | 0) == ($3_1 | 0) & $0_1 >>> 0 > $6_1 >>> 0 | $2_1 >>> 0 > $3_1 >>> 0;
                $6_1 = $21_1 ^ -1;
                $3_1 = $0_1 + $6_1 | 0;
                $5_1 = $17_1 ^ -1;
                $0_1 = $5_1;
                $13_1 = $3_1 - 1354194885 | 0;
                $21_1 = $13_1 & $4_1;
                HEAP32[$1_1 + 416 >> 2] = $21_1;
                $0_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
                $8_1 = $0_1 - (($3_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
                $17_1 = $8_1 & $4_1;
                HEAP32[$1_1 + 420 >> 2] = $17_1;
                $2_1 = ($0_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
                $6_1 = ($0_1 | 0) == ($8_1 | 0) & $3_1 >>> 0 > $13_1 >>> 0 | $0_1 >>> 0 > $8_1 >>> 0;
                $3_1 = $2_1 + $6_1 | 0;
                $5_1 = $22_1 ^ -1;
                $0_1 = $5_1 + ($3_1 >>> 0 < $6_1 >>> 0) | 0;
                $6_1 = $20_1 ^ -1;
                $3_1 = $6_1 + $3_1 | 0;
                $13_1 = $3_1 - 2 | 0;
                $20_1 = $13_1 & $4_1;
                HEAP32[$1_1 + 424 >> 2] = $20_1;
                $0_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
                $8_1 = $0_1 - ($3_1 >>> 0 < 2) | 0;
                $22_1 = $8_1 & $4_1;
                HEAP32[$1_1 + 428 >> 2] = $22_1;
                $2_1 = ($0_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
                $3_1 = ($0_1 | 0) == ($8_1 | 0) & $3_1 >>> 0 > $13_1 >>> 0 | $0_1 >>> 0 > $8_1 >>> 0;
                $2_1 = $2_1 + $3_1 | 0;
                $0_1 = $2_1 >>> 0 < $3_1 >>> 0;
                $3_1 = $2_1 - $19_1 | 0;
                $6_1 = $3_1 - 2 | 0;
                $10_1 = ($0_1 - (($2_1 >>> 0 < $19_1 >>> 0) + $10_1 | 0) | 0) - ($3_1 >>> 0 < 2) & $4_1;
                $19_1 = $4_1 & $6_1;
                HEAP32[$1_1 + 432 >> 2] = $19_1;
                HEAP32[$1_1 + 436 >> 2] = $10_1;
              }
              $4_1 = HEAP32[$1_1 + 112 >> 2];
              $3_1 = HEAP32[$1_1 + 116 >> 2];
              $5_1 = HEAP32[$1_1 + 108 >> 2];
              $14_1 = HEAP32[$1_1 + 136 >> 2];
              $6_1 = HEAP32[$1_1 + 140 >> 2];
              $9_1 = $6_1;
              $0_1 = HEAP32[$1_1 + 104 >> 2];
              $2_1 = __wasm_i64_mul($6_1 >>> 16 | 0, 0, 977, 1);
              $6_1 = $0_1 + $2_1 | 0;
              $0_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
              $16_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $0_1 = $3_1;
              $2_1 = $16_1 >>> 20 | 0;
              $3_1 = $2_1 + $4_1 | 0;
              $8_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $5_1 = $8_1 & 1048575;
              $13_1 = HEAP32[$1_1 + 128 >> 2];
              $15_1 = HEAP32[$1_1 + 132 >> 2];
              $0_1 = HEAP32[$1_1 + 124 >> 2];
              $2_1 = $8_1 >>> 20 | 0;
              $4_1 = $2_1 + HEAP32[$1_1 + 120 >> 2] | 0;
              $11_1 = $2_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $0_1 = $15_1;
              $2_1 = $11_1 >>> 20 | 0;
              $15_1 = $2_1;
              $2_1 = $2_1 + $13_1 | 0;
              $0_1 = $15_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $13_1 = $0_1 & 1048575;
              $11_1 = $11_1 & 1048575;
              $15_1 = ($3_1 & $4_1 & $2_1) == -1 & ($8_1 & $11_1 & $0_1) == 1048575;
              $8_1 = $0_1;
              $0_1 = $9_1 & 65535;
              $8_1 = $8_1 >>> 20 | 0;
              $14_1 = $8_1 + $14_1 | 0;
              $0_1 = $8_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $8_1 = $0_1;
              $16_1 = $16_1 & 1048575;
              if ($15_1 & (($14_1 | 0) == -1 & ($0_1 | 0) == 65535) & (($16_1 | 0) == 1048574 & $6_1 >>> 0 > 4294966318 | $16_1 >>> 0 > 1048574) | $0_1 >>> 16) {
                $0_1 = $16_1 + 1 | 0;
                $6_1 = $6_1 + 977 | 0;
                $0_1 = $6_1 >>> 0 < 977 ? $0_1 + 1 | 0 : $0_1;
                $16_1 = $0_1 & 1048575;
                $9_1 = $0_1;
                $0_1 = $5_1;
                $9_1 = $9_1 >>> 20 | 0;
                $3_1 = $3_1 + $9_1 | 0;
                $0_1 = $9_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
                $5_1 = $0_1 & 1048575;
                $9_1 = $0_1;
                $0_1 = $11_1;
                $9_1 = $9_1 >>> 20 | 0;
                $4_1 = $4_1 + $9_1 | 0;
                $0_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
                $11_1 = $0_1 & 1048575;
                $9_1 = $0_1;
                $0_1 = $13_1;
                $9_1 = $9_1 >>> 20 | 0;
                $2_1 = $2_1 + $9_1 | 0;
                $0_1 = $9_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
                $13_1 = $0_1 & 1048575;
                $9_1 = $0_1;
                $0_1 = $8_1;
                $8_1 = $14_1;
                $14_1 = ($9_1 >>> 20 | 0) + $14_1 | 0;
                $8_1 = ($8_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) & 65535;
              }
              HEAP32[$1_1 + 136 >> 2] = $14_1;
              HEAP32[$1_1 + 140 >> 2] = $8_1;
              HEAP32[$1_1 + 128 >> 2] = $2_1;
              HEAP32[$1_1 + 132 >> 2] = $13_1;
              HEAP32[$1_1 + 120 >> 2] = $4_1;
              HEAP32[$1_1 + 124 >> 2] = $11_1;
              HEAP32[$1_1 + 112 >> 2] = $3_1;
              HEAP32[$1_1 + 116 >> 2] = $5_1;
              HEAP32[$1_1 + 104 >> 2] = $6_1;
              HEAP32[$1_1 + 108 >> 2] = $16_1;
              $37(690981, $1_1 + 104 | 0);
              HEAP32[$1_1 + 600 >> 2] = 64;
              HEAP32[$1_1 + 604 >> 2] = 0;
              HEAP32[$1_1 + 528 >> 2] = -1862921884;
              HEAP32[$1_1 + 532 >> 2] = 870954602;
              HEAP32[$1_1 + 520 >> 2] = -1748470448;
              HEAP32[$1_1 + 524 >> 2] = 3983205;
              HEAP32[$1_1 + 512 >> 2] = 292000018;
              HEAP32[$1_1 + 516 >> 2] = -782074353;
              HEAP32[$1_1 + 504 >> 2] = -1662207471;
              HEAP32[$1_1 + 508 >> 2] = 596792193;
              $0_1 = $1_1 + 504 | 0;
              $29($0_1, 690981, 32);
              $29($0_1, $1_1 + 32 | 0, 32);
              $29($0_1, 655649, 32);
              $2_1 = $0_1;
              $0_1 = $1_1 + 608 | 0;
              $30($2_1, $0_1);
              $9_1 = $1_1 + 440 | 0;
              $38($9_1, $0_1, 0);
              $15_1 = $1_1 + 472 | 0;
              $41($9_1, $9_1, $15_1);
              $2_1 = HEAP32[$1_1 + 440 >> 2];
              $8_1 = $2_1 + $18_1 | 0;
              $0_1 = $12_1 + HEAP32[$1_1 + 444 >> 2] | 0;
              $5_1 = $2_1 >>> 0 > $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $3_1 = ($12_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $18_1 >>> 0 | $5_1 >>> 0 < $12_1 >>> 0;
              $2_1 = HEAP32[$1_1 + 448 >> 2];
              $4_1 = $3_1 + $2_1 | 0;
              $0_1 = HEAP32[$1_1 + 452 >> 2];
              $2_1 = $2_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $0_1 = $2_1 + $17_1 | 0;
              $3_1 = !$2_1 & $3_1 >>> 0 > $4_1 >>> 0;
              $12_1 = $4_1 + $21_1 | 0;
              $6_1 = $12_1 >>> 0 < $21_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $4_1 = ($2_1 | 0) == ($6_1 | 0) & $4_1 >>> 0 > $12_1 >>> 0 | $2_1 >>> 0 > $6_1 >>> 0;
              $2_1 = $3_1 + $4_1 | 0;
              $0_1 = $2_1 >>> 0 < $4_1 >>> 0;
              $11_1 = $2_1;
              $2_1 = HEAP32[$1_1 + 456 >> 2];
              $4_1 = $11_1 + $2_1 | 0;
              $3_1 = $0_1;
              $0_1 = $0_1 + HEAP32[$1_1 + 460 >> 2] | 0;
              $2_1 = $2_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $0_1 = $2_1 + $22_1 | 0;
              $13_1 = $4_1;
              $14_1 = $4_1 + $20_1 | 0;
              $0_1 = $14_1 >>> 0 < $20_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $18_1 = $10_1;
              $11_1 = ($2_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 < $11_1 >>> 0 | $2_1 >>> 0 < $3_1 >>> 0;
              $4_1 = $0_1;
              $10_1 = $14_1;
              $3_1 = ($2_1 | 0) == ($0_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $0_1 >>> 0 < $2_1 >>> 0;
              $2_1 = $11_1 + $3_1 | 0;
              $0_1 = $2_1 >>> 0 < $3_1 >>> 0;
              $16_1 = $2_1;
              $3_1 = HEAP32[$1_1 + 464 >> 2];
              $2_1 = $2_1 + $3_1 | 0;
              $13_1 = $0_1;
              $0_1 = $0_1 + HEAP32[$1_1 + 468 >> 2] | 0;
              $3_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $0_1 = $3_1 + $18_1 | 0;
              $11_1 = $2_1;
              $2_1 = $2_1 + $19_1 | 0;
              $18_1 = $11_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $14_1 = $2_1;
              $16_1 = (($3_1 | 0) == ($18_1 | 0) & $11_1 >>> 0 > $2_1 >>> 0 | $3_1 >>> 0 > $18_1 >>> 0) + (($3_1 | 0) == ($13_1 | 0) & $11_1 >>> 0 < $16_1 >>> 0 | $3_1 >>> 0 < $13_1 >>> 0) | 0;
              $3_1 = ($4_1 | 0) == -1;
              $13_1 = $3_1 & $10_1 >>> 0 < 4294967294 | ($4_1 | 0) != -1 | ($2_1 & $18_1) != -1;
              $0_1 = ($6_1 | 0) == -1162945306;
              $11_1 = ($13_1 | ($0_1 & $12_1 >>> 0 < 2940772411 | $6_1 >>> 0 < 3132021990)) ^ -1;
              $13_1 = $16_1 + ($11_1 & (($5_1 | 0) == -1076732276 & $8_1 >>> 0 > 3493216576 | $5_1 >>> 0 > 3218235020) | ($11_1 & ($0_1 & $12_1 >>> 0 > 2940772411 | $6_1 >>> 0 > 3132021990) | ($10_1 | 0) == -1 & $3_1 & ($13_1 ^ -1))) | 0;
              $3_1 = __wasm_i64_mul($13_1, 0, 801750719, 1076732275);
              $11_1 = $3_1 + $8_1 | 0;
              $0_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
              HEAP32[$1_1 + 440 >> 2] = $11_1;
              $0_1 = $3_1 >>> 0 > $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              HEAP32[$1_1 + 444 >> 2] = $0_1;
              $8_1 = ($0_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 > $11_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
              $5_1 = __wasm_i64_mul($13_1, 0, 1354194884, 1162945305);
              $2_1 = $5_1 + $12_1 | 0;
              $0_1 = $6_1 + i64toi32_i32$HIGH_BITS | 0;
              $0_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $5_1 = $2_1;
              $2_1 = $0_1;
              $8_1 = $5_1 + $8_1 | 0;
              $0_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              HEAP32[$1_1 + 448 >> 2] = $8_1;
              HEAP32[$1_1 + 452 >> 2] = $0_1;
              $3_1 = ($2_1 | 0) == ($6_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $2_1 >>> 0 < $6_1 >>> 0;
              $6_1 = ($0_1 | 0) == ($2_1 | 0) & $5_1 >>> 0 > $8_1 >>> 0 | $0_1 >>> 0 < $2_1 >>> 0;
              $2_1 = $3_1 + $6_1 | 0;
              $5_1 = $2_1;
              $6_1 = $2_1 >>> 0 < $6_1 >>> 0;
              $0_1 = $4_1;
              $12_1 = $10_1 + $13_1 | 0;
              $2_1 = $12_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $0_1 = $2_1 + $6_1 | 0;
              $6_1 = $12_1;
              $5_1 = $5_1 + $6_1 | 0;
              $0_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              HEAP32[$1_1 + 456 >> 2] = $5_1;
              HEAP32[$1_1 + 460 >> 2] = $0_1;
              $3_1 = ($2_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 < $10_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
              $4_1 = ($0_1 | 0) == ($2_1 | 0) & $5_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 < $2_1 >>> 0;
              $2_1 = $3_1 + $4_1 | 0;
              $0_1 = $18_1 + ($2_1 >>> 0 < $4_1 >>> 0) | 0;
              $2_1 = $2_1 + $14_1 | 0;
              $0_1 = $2_1 >>> 0 < $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              HEAP32[$1_1 + 464 >> 2] = $2_1;
              HEAP32[$1_1 + 468 >> 2] = $0_1;
              $39(691013, $9_1);
              HEAP32[$1_1 + 504 >> 2] = $23_1;
              $0_1 = HEAP32[$1_1 + 504 >> 2] - 1 | 0;
              HEAP8[690981] = $0_1 & HEAPU8[690981];
              HEAP8[690982] = HEAPU8[690982] & $0_1;
              HEAP8[690983] = HEAPU8[690983] & $0_1;
              HEAP8[690984] = HEAPU8[690984] & $0_1;
              HEAP8[690985] = HEAPU8[690985] & $0_1;
              HEAP8[690986] = HEAPU8[690986] & $0_1;
              HEAP8[690987] = HEAPU8[690987] & $0_1;
              HEAP8[690988] = HEAPU8[690988] & $0_1;
              HEAP8[690989] = HEAPU8[690989] & $0_1;
              HEAP8[690990] = HEAPU8[690990] & $0_1;
              HEAP8[690991] = HEAPU8[690991] & $0_1;
              HEAP8[690992] = HEAPU8[690992] & $0_1;
              HEAP8[690993] = HEAPU8[690993] & $0_1;
              HEAP8[690994] = HEAPU8[690994] & $0_1;
              HEAP8[690995] = HEAPU8[690995] & $0_1;
              HEAP8[690996] = HEAPU8[690996] & $0_1;
              HEAP8[690997] = HEAPU8[690997] & $0_1;
              HEAP8[690998] = HEAPU8[690998] & $0_1;
              HEAP8[690999] = HEAPU8[690999] & $0_1;
              HEAP8[691e3] = HEAPU8[691e3] & $0_1;
              HEAP8[691001] = HEAPU8[691001] & $0_1;
              HEAP8[691002] = HEAPU8[691002] & $0_1;
              HEAP8[691003] = HEAPU8[691003] & $0_1;
              HEAP8[691004] = HEAPU8[691004] & $0_1;
              HEAP8[691005] = HEAPU8[691005] & $0_1;
              HEAP8[691006] = HEAPU8[691006] & $0_1;
              HEAP8[691007] = HEAPU8[691007] & $0_1;
              HEAP8[691008] = HEAPU8[691008] & $0_1;
              HEAP8[691009] = HEAPU8[691009] & $0_1;
              HEAP8[691010] = HEAPU8[691010] & $0_1;
              HEAP8[691011] = HEAPU8[691011] & $0_1;
              HEAP8[691012] = HEAPU8[691012] & $0_1;
              HEAP8[691013] = HEAPU8[691013] & $0_1;
              HEAP8[691014] = HEAPU8[691014] & $0_1;
              HEAP8[691015] = HEAPU8[691015] & $0_1;
              HEAP8[691016] = HEAPU8[691016] & $0_1;
              HEAP8[691017] = HEAPU8[691017] & $0_1;
              HEAP8[691018] = HEAPU8[691018] & $0_1;
              HEAP8[691019] = HEAPU8[691019] & $0_1;
              HEAP8[691020] = HEAPU8[691020] & $0_1;
              HEAP8[691021] = HEAPU8[691021] & $0_1;
              HEAP8[691022] = HEAPU8[691022] & $0_1;
              HEAP8[691023] = HEAPU8[691023] & $0_1;
              HEAP8[691024] = HEAPU8[691024] & $0_1;
              HEAP8[691025] = HEAPU8[691025] & $0_1;
              HEAP8[691026] = HEAPU8[691026] & $0_1;
              HEAP8[691027] = HEAPU8[691027] & $0_1;
              HEAP8[691028] = HEAPU8[691028] & $0_1;
              HEAP8[691029] = HEAPU8[691029] & $0_1;
              HEAP8[691030] = HEAPU8[691030] & $0_1;
              HEAP8[691031] = HEAPU8[691031] & $0_1;
              HEAP8[691032] = HEAPU8[691032] & $0_1;
              HEAP8[691033] = HEAPU8[691033] & $0_1;
              HEAP8[691034] = HEAPU8[691034] & $0_1;
              HEAP8[691035] = HEAPU8[691035] & $0_1;
              HEAP8[691036] = HEAPU8[691036] & $0_1;
              HEAP8[691037] = HEAPU8[691037] & $0_1;
              HEAP8[691038] = HEAPU8[691038] & $0_1;
              HEAP8[691039] = HEAPU8[691039] & $0_1;
              HEAP8[691040] = HEAPU8[691040] & $0_1;
              HEAP8[691041] = HEAPU8[691041] & $0_1;
              HEAP8[691042] = HEAPU8[691042] & $0_1;
              HEAP8[691043] = HEAPU8[691043] & $0_1;
              HEAP8[691044] = HEAPU8[691044] & $0_1;
              $0_1 = $1_1 + 408 | 0;
              $2_1 = $0_1 + 24 | 0;
              HEAP32[$2_1 >> 2] = 0;
              HEAP32[$2_1 + 4 >> 2] = 0;
              $2_1 = $0_1 + 16 | 0;
              HEAP32[$2_1 >> 2] = 0;
              HEAP32[$2_1 + 4 >> 2] = 0;
              $0_1 = $0_1 + 8 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              HEAP32[$1_1 + 408 >> 2] = 0;
              HEAP32[$1_1 + 412 >> 2] = 0;
              $0_1 = $15_1 + 24 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              $0_1 = $15_1 + 16 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              $0_1 = $15_1 + 8 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              HEAP32[$1_1 + 472 >> 2] = 0;
              HEAP32[$1_1 + 476 >> 2] = 0;
              $0_1 = $1_1 + 24 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              $0_1 = $1_1 + 16 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              HEAP32[$1_1 + 8 >> 2] = 0;
              HEAP32[$1_1 + 12 >> 2] = 0;
              HEAP32[$1_1 >> 2] = 0;
              HEAP32[$1_1 + 4 >> 2] = 0;
            }
            global$0 = $1_1 + 640 | 0;
            HEAP32[$7_1 + 100 >> 2] = $24_1;
            if ($24_1) {
              break label$2;
            }
            break label$1;
          }
          break label$1;
        }
        global$0 = $7_1 + 128 | 0;
        return;
      }
      HEAP32[$7_1 + 112 >> 2] = 0;
      $5($7_1 + 104 | 0);
      wasm2js_trap();
    }
    function $24($0_1, $1_1) {
      $0_1 = $0_1 | 0;
      $1_1 = $1_1 | 0;
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0;
      $5_1 = global$0 - 192 | 0;
      global$0 = $5_1;
      $4_1 = $5_1 + 128 | 0;
      $6_1 = $4_1 + 56 | 0;
      HEAP32[$6_1 >> 2] = 0;
      HEAP32[$6_1 + 4 >> 2] = 0;
      $7_1 = $4_1 + 48 | 0;
      HEAP32[$7_1 >> 2] = 0;
      HEAP32[$7_1 + 4 >> 2] = 0;
      $8_1 = $4_1 + 40 | 0;
      HEAP32[$8_1 >> 2] = 0;
      HEAP32[$8_1 + 4 >> 2] = 0;
      $12_1 = $4_1 + 32 | 0;
      HEAP32[$12_1 >> 2] = 0;
      HEAP32[$12_1 + 4 >> 2] = 0;
      $9_1 = $4_1 + 24 | 0;
      HEAP32[$9_1 >> 2] = 0;
      HEAP32[$9_1 + 4 >> 2] = 0;
      $11_1 = $4_1 + 16 | 0;
      HEAP32[$11_1 >> 2] = 0;
      HEAP32[$11_1 + 4 >> 2] = 0;
      $17_1 = $4_1 + 8 | 0;
      HEAP32[$17_1 >> 2] = 0;
      HEAP32[$17_1 + 4 >> 2] = 0;
      HEAP32[$5_1 + 128 >> 2] = 0;
      HEAP32[$5_1 + 132 >> 2] = 0;
      label$1: {
        if (($31(HEAP32[172688], $4_1, 690820, $0_1) | 0) == 1) {
          $4_1 = $5_1 + 128 | 0;
          $0_1 = $4_1 + 15 | 0;
          $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $3_1 = $5_1 - -64 | 0;
          $10_1 = $3_1 + 8 | 0;
          HEAP32[$10_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$10_1 + 4 >> 2] = $2_1;
          $0_1 = $4_1 + 23 | 0;
          $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $14_1 = $3_1 + 16 | 0;
          HEAP32[$14_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$14_1 + 4 >> 2] = $2_1;
          $0_1 = $4_1 + 31 | 0;
          $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $16_1 = $3_1 + 24 | 0;
          HEAP32[$16_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$16_1 + 4 >> 2] = $2_1;
          $0_1 = $4_1 + 39 | 0;
          $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $15_1 = $3_1 + 32 | 0;
          HEAP32[$15_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$15_1 + 4 >> 2] = $2_1;
          $0_1 = $4_1 + 47 | 0;
          $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $13_1 = $3_1 + 40 | 0;
          HEAP32[$13_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$13_1 + 4 >> 2] = $2_1;
          $0_1 = $4_1 + 55 | 0;
          $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $18_1 = $3_1 + 48 | 0;
          HEAP32[$18_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$18_1 + 4 >> 2] = $2_1;
          $3_1 = $3_1 + 56 | 0;
          HEAP8[$3_1 | 0] = HEAPU8[$4_1 + 63 | 0];
          HEAP8[$5_1 + 2 | 0] = HEAPU8[$5_1 + 130 | 0];
          HEAP16[$5_1 >> 1] = HEAPU16[$5_1 + 128 >> 1];
          $0_1 = HEAPU8[$5_1 + 139 | 0] | HEAPU8[$5_1 + 140 | 0] << 8 | (HEAPU8[$5_1 + 141 | 0] << 16 | HEAPU8[$5_1 + 142 | 0] << 24);
          HEAP32[$5_1 + 64 >> 2] = HEAPU8[$5_1 + 135 | 0] | HEAPU8[$5_1 + 136 | 0] << 8 | (HEAPU8[$5_1 + 137 | 0] << 16 | HEAPU8[$5_1 + 138 | 0] << 24);
          HEAP32[$5_1 + 68 >> 2] = $0_1;
          $0_1 = HEAPU8[$5_1 + 131 | 0] | HEAPU8[$5_1 + 132 | 0] << 8 | (HEAPU8[$5_1 + 133 | 0] << 16 | HEAPU8[$5_1 + 134 | 0] << 24);
          HEAP8[$5_1 + 63 | 0] = HEAPU8[$3_1 | 0];
          $2_1 = HEAP32[$18_1 + 4 >> 2];
          $3_1 = $5_1 + 55 | 0;
          $18_1 = HEAP32[$18_1 >> 2];
          HEAP8[$3_1 | 0] = $18_1;
          HEAP8[$3_1 + 1 | 0] = $18_1 >>> 8;
          HEAP8[$3_1 + 2 | 0] = $18_1 >>> 16;
          HEAP8[$3_1 + 3 | 0] = $18_1 >>> 24;
          HEAP8[$3_1 + 4 | 0] = $2_1;
          HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
          HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
          HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
          $2_1 = HEAP32[$13_1 + 4 >> 2];
          $3_1 = $5_1 + 47 | 0;
          $13_1 = HEAP32[$13_1 >> 2];
          HEAP8[$3_1 | 0] = $13_1;
          HEAP8[$3_1 + 1 | 0] = $13_1 >>> 8;
          HEAP8[$3_1 + 2 | 0] = $13_1 >>> 16;
          HEAP8[$3_1 + 3 | 0] = $13_1 >>> 24;
          HEAP8[$3_1 + 4 | 0] = $2_1;
          HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
          HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
          HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
          $2_1 = HEAP32[$15_1 + 4 >> 2];
          $3_1 = $5_1 + 39 | 0;
          $15_1 = HEAP32[$15_1 >> 2];
          HEAP8[$3_1 | 0] = $15_1;
          HEAP8[$3_1 + 1 | 0] = $15_1 >>> 8;
          HEAP8[$3_1 + 2 | 0] = $15_1 >>> 16;
          HEAP8[$3_1 + 3 | 0] = $15_1 >>> 24;
          HEAP8[$3_1 + 4 | 0] = $2_1;
          HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
          HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
          HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
          $2_1 = HEAP32[$16_1 + 4 >> 2];
          $3_1 = $5_1 + 31 | 0;
          $16_1 = HEAP32[$16_1 >> 2];
          HEAP8[$3_1 | 0] = $16_1;
          HEAP8[$3_1 + 1 | 0] = $16_1 >>> 8;
          HEAP8[$3_1 + 2 | 0] = $16_1 >>> 16;
          HEAP8[$3_1 + 3 | 0] = $16_1 >>> 24;
          HEAP8[$3_1 + 4 | 0] = $2_1;
          HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
          HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
          HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
          $2_1 = HEAP32[$14_1 + 4 >> 2];
          $3_1 = $5_1 + 23 | 0;
          $14_1 = HEAP32[$14_1 >> 2];
          HEAP8[$3_1 | 0] = $14_1;
          HEAP8[$3_1 + 1 | 0] = $14_1 >>> 8;
          HEAP8[$3_1 + 2 | 0] = $14_1 >>> 16;
          HEAP8[$3_1 + 3 | 0] = $14_1 >>> 24;
          HEAP8[$3_1 + 4 | 0] = $2_1;
          HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
          HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
          HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
          $2_1 = HEAP32[$10_1 + 4 >> 2];
          $3_1 = $5_1 + 15 | 0;
          $10_1 = HEAP32[$10_1 >> 2];
          HEAP8[$3_1 | 0] = $10_1;
          HEAP8[$3_1 + 1 | 0] = $10_1 >>> 8;
          HEAP8[$3_1 + 2 | 0] = $10_1 >>> 16;
          HEAP8[$3_1 + 3 | 0] = $10_1 >>> 24;
          HEAP8[$3_1 + 4 | 0] = $2_1;
          HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
          HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
          HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
          HEAP8[$5_1 + 3 | 0] = $0_1;
          HEAP8[$5_1 + 4 | 0] = $0_1 >>> 8;
          HEAP8[$5_1 + 5 | 0] = $0_1 >>> 16;
          HEAP8[$5_1 + 6 | 0] = $0_1 >>> 24;
          $0_1 = HEAP32[$5_1 + 68 >> 2];
          $3_1 = HEAP32[$5_1 + 64 >> 2];
          HEAP8[$5_1 + 7 | 0] = $3_1;
          HEAP8[$5_1 + 8 | 0] = $3_1 >>> 8;
          HEAP8[$5_1 + 9 | 0] = $3_1 >>> 16;
          HEAP8[$5_1 + 10 | 0] = $3_1 >>> 24;
          HEAP8[$5_1 + 11 | 0] = $0_1;
          HEAP8[$5_1 + 12 | 0] = $0_1 >>> 8;
          HEAP8[$5_1 + 13 | 0] = $0_1 >>> 16;
          HEAP8[$5_1 + 14 | 0] = $0_1 >>> 24;
          HEAP32[$6_1 >> 2] = 0;
          HEAP32[$6_1 + 4 >> 2] = 0;
          HEAP32[$7_1 >> 2] = 0;
          HEAP32[$7_1 + 4 >> 2] = 0;
          HEAP32[$8_1 >> 2] = 0;
          HEAP32[$8_1 + 4 >> 2] = 0;
          HEAP32[$12_1 >> 2] = 0;
          HEAP32[$12_1 + 4 >> 2] = 0;
          HEAP32[$9_1 >> 2] = 0;
          HEAP32[$9_1 + 4 >> 2] = 0;
          HEAP32[$11_1 >> 2] = 0;
          HEAP32[$11_1 + 4 >> 2] = 0;
          HEAP32[$17_1 >> 2] = 0;
          HEAP32[$17_1 + 4 >> 2] = 0;
          HEAP32[$5_1 + 128 >> 2] = 0;
          HEAP32[$5_1 + 132 >> 2] = 0;
          $3_1 = 0;
          $6_1 = HEAP32[172688];
          $2_1 = 0;
          $0_1 = global$0 - 80 | 0;
          global$0 = $0_1;
          HEAP32[$0_1 + 12 >> 2] = 0;
          label$3: {
            if (!$4_1) {
              FUNCTION_TABLE[HEAP32[$6_1 + 168 >> 2]](689748, HEAP32[$6_1 + 172 >> 2]);
              break label$3;
            }
            $2_1 = $0_1 + 12 | 0;
            $38($0_1 + 48 | 0, 690981, $2_1);
            $6_1 = HEAP32[$0_1 + 12 >> 2];
            $38($0_1 + 16 | 0, 691013, $2_1);
            if (!($6_1 | HEAP32[$0_1 + 12 >> 2])) {
              $2_1 = HEAP32[$0_1 + 52 >> 2];
              $6_1 = HEAP32[$0_1 + 48 >> 2];
              HEAP8[$4_1 | 0] = $6_1;
              HEAP8[$4_1 + 1 | 0] = $6_1 >>> 8;
              HEAP8[$4_1 + 2 | 0] = $6_1 >>> 16;
              HEAP8[$4_1 + 3 | 0] = $6_1 >>> 24;
              HEAP8[$4_1 + 4 | 0] = $2_1;
              HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
              HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
              HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
              $2_1 = HEAP32[$0_1 + 20 >> 2];
              $6_1 = HEAP32[$0_1 + 16 >> 2];
              HEAP8[$4_1 + 32 | 0] = $6_1;
              HEAP8[$4_1 + 33 | 0] = $6_1 >>> 8;
              HEAP8[$4_1 + 34 | 0] = $6_1 >>> 16;
              HEAP8[$4_1 + 35 | 0] = $6_1 >>> 24;
              HEAP8[$4_1 + 36 | 0] = $2_1;
              HEAP8[$4_1 + 37 | 0] = $2_1 >>> 8;
              HEAP8[$4_1 + 38 | 0] = $2_1 >>> 16;
              HEAP8[$4_1 + 39 | 0] = $2_1 >>> 24;
              $8_1 = $0_1 + 48 | 0;
              $7_1 = $8_1 + 24 | 0;
              $6_1 = HEAP32[$7_1 + 4 >> 2];
              $2_1 = $4_1 + 24 | 0;
              $7_1 = HEAP32[$7_1 >> 2];
              HEAP8[$2_1 | 0] = $7_1;
              HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
              HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
              HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
              HEAP8[$2_1 + 4 | 0] = $6_1;
              HEAP8[$2_1 + 5 | 0] = $6_1 >>> 8;
              HEAP8[$2_1 + 6 | 0] = $6_1 >>> 16;
              HEAP8[$2_1 + 7 | 0] = $6_1 >>> 24;
              $7_1 = $8_1 + 16 | 0;
              $6_1 = HEAP32[$7_1 + 4 >> 2];
              $2_1 = $4_1 + 16 | 0;
              $7_1 = HEAP32[$7_1 >> 2];
              HEAP8[$2_1 | 0] = $7_1;
              HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
              HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
              HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
              HEAP8[$2_1 + 4 | 0] = $6_1;
              HEAP8[$2_1 + 5 | 0] = $6_1 >>> 8;
              HEAP8[$2_1 + 6 | 0] = $6_1 >>> 16;
              HEAP8[$2_1 + 7 | 0] = $6_1 >>> 24;
              $7_1 = $8_1 + 8 | 0;
              $6_1 = HEAP32[$7_1 + 4 >> 2];
              $2_1 = $4_1 + 8 | 0;
              $7_1 = HEAP32[$7_1 >> 2];
              HEAP8[$2_1 | 0] = $7_1;
              HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
              HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
              HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
              HEAP8[$2_1 + 4 | 0] = $6_1;
              HEAP8[$2_1 + 5 | 0] = $6_1 >>> 8;
              HEAP8[$2_1 + 6 | 0] = $6_1 >>> 16;
              HEAP8[$2_1 + 7 | 0] = $6_1 >>> 24;
              $8_1 = $0_1 + 16 | 0;
              $7_1 = $8_1 + 8 | 0;
              $6_1 = HEAP32[$7_1 + 4 >> 2];
              $2_1 = $4_1 + 40 | 0;
              $7_1 = HEAP32[$7_1 >> 2];
              HEAP8[$2_1 | 0] = $7_1;
              HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
              HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
              HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
              HEAP8[$2_1 + 4 | 0] = $6_1;
              HEAP8[$2_1 + 5 | 0] = $6_1 >>> 8;
              HEAP8[$2_1 + 6 | 0] = $6_1 >>> 16;
              HEAP8[$2_1 + 7 | 0] = $6_1 >>> 24;
              $7_1 = $8_1 + 16 | 0;
              $6_1 = HEAP32[$7_1 + 4 >> 2];
              $2_1 = $4_1 + 48 | 0;
              $7_1 = HEAP32[$7_1 >> 2];
              HEAP8[$2_1 | 0] = $7_1;
              HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
              HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
              HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
              HEAP8[$2_1 + 4 | 0] = $6_1;
              HEAP8[$2_1 + 5 | 0] = $6_1 >>> 8;
              HEAP8[$2_1 + 6 | 0] = $6_1 >>> 16;
              HEAP8[$2_1 + 7 | 0] = $6_1 >>> 24;
              $6_1 = $8_1 + 24 | 0;
              $2_1 = HEAP32[$6_1 + 4 >> 2];
              $4_1 = $4_1 + 56 | 0;
              $6_1 = HEAP32[$6_1 >> 2];
              HEAP8[$4_1 | 0] = $6_1;
              HEAP8[$4_1 + 1 | 0] = $6_1 >>> 8;
              HEAP8[$4_1 + 2 | 0] = $6_1 >>> 16;
              HEAP8[$4_1 + 3 | 0] = $6_1 >>> 24;
              HEAP8[$4_1 + 4 | 0] = $2_1;
              HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
              HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
              HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
              $2_1 = 1;
              break label$3;
            }
            HEAP8[$4_1 | 0] = 0;
            HEAP8[$4_1 + 1 | 0] = 0;
            HEAP8[$4_1 + 2 | 0] = 0;
            HEAP8[$4_1 + 3 | 0] = 0;
            HEAP8[$4_1 + 4 | 0] = 0;
            HEAP8[$4_1 + 5 | 0] = 0;
            HEAP8[$4_1 + 6 | 0] = 0;
            HEAP8[$4_1 + 7 | 0] = 0;
            $2_1 = $4_1 + 56 | 0;
            HEAP8[$2_1 | 0] = 0;
            HEAP8[$2_1 + 1 | 0] = 0;
            HEAP8[$2_1 + 2 | 0] = 0;
            HEAP8[$2_1 + 3 | 0] = 0;
            HEAP8[$2_1 + 4 | 0] = 0;
            HEAP8[$2_1 + 5 | 0] = 0;
            HEAP8[$2_1 + 6 | 0] = 0;
            HEAP8[$2_1 + 7 | 0] = 0;
            $2_1 = $4_1 + 48 | 0;
            HEAP8[$2_1 | 0] = 0;
            HEAP8[$2_1 + 1 | 0] = 0;
            HEAP8[$2_1 + 2 | 0] = 0;
            HEAP8[$2_1 + 3 | 0] = 0;
            HEAP8[$2_1 + 4 | 0] = 0;
            HEAP8[$2_1 + 5 | 0] = 0;
            HEAP8[$2_1 + 6 | 0] = 0;
            HEAP8[$2_1 + 7 | 0] = 0;
            $2_1 = $4_1 + 40 | 0;
            HEAP8[$2_1 | 0] = 0;
            HEAP8[$2_1 + 1 | 0] = 0;
            HEAP8[$2_1 + 2 | 0] = 0;
            HEAP8[$2_1 + 3 | 0] = 0;
            HEAP8[$2_1 + 4 | 0] = 0;
            HEAP8[$2_1 + 5 | 0] = 0;
            HEAP8[$2_1 + 6 | 0] = 0;
            HEAP8[$2_1 + 7 | 0] = 0;
            $2_1 = $4_1 + 32 | 0;
            HEAP8[$2_1 | 0] = 0;
            HEAP8[$2_1 + 1 | 0] = 0;
            HEAP8[$2_1 + 2 | 0] = 0;
            HEAP8[$2_1 + 3 | 0] = 0;
            HEAP8[$2_1 + 4 | 0] = 0;
            HEAP8[$2_1 + 5 | 0] = 0;
            HEAP8[$2_1 + 6 | 0] = 0;
            HEAP8[$2_1 + 7 | 0] = 0;
            $2_1 = $4_1 + 24 | 0;
            HEAP8[$2_1 | 0] = 0;
            HEAP8[$2_1 + 1 | 0] = 0;
            HEAP8[$2_1 + 2 | 0] = 0;
            HEAP8[$2_1 + 3 | 0] = 0;
            HEAP8[$2_1 + 4 | 0] = 0;
            HEAP8[$2_1 + 5 | 0] = 0;
            HEAP8[$2_1 + 6 | 0] = 0;
            HEAP8[$2_1 + 7 | 0] = 0;
            $2_1 = $4_1 + 16 | 0;
            HEAP8[$2_1 | 0] = 0;
            HEAP8[$2_1 + 1 | 0] = 0;
            HEAP8[$2_1 + 2 | 0] = 0;
            HEAP8[$2_1 + 3 | 0] = 0;
            HEAP8[$2_1 + 4 | 0] = 0;
            HEAP8[$2_1 + 5 | 0] = 0;
            HEAP8[$2_1 + 6 | 0] = 0;
            HEAP8[$2_1 + 7 | 0] = 0;
            $4_1 = $4_1 + 8 | 0;
            HEAP8[$4_1 | 0] = 0;
            HEAP8[$4_1 + 1 | 0] = 0;
            HEAP8[$4_1 + 2 | 0] = 0;
            HEAP8[$4_1 + 3 | 0] = 0;
            HEAP8[$4_1 + 4 | 0] = 0;
            HEAP8[$4_1 + 5 | 0] = 0;
            HEAP8[$4_1 + 6 | 0] = 0;
            HEAP8[$4_1 + 7 | 0] = 0;
            $2_1 = 0;
          }
          global$0 = $0_1 + 80 | 0;
          if (!$2_1) {
            fimport$1(4);
            break label$1;
          }
          if (!$1_1) {
            label$8: {
              $0_1 = HEAP32[172688];
              $2_1 = $5_1 + 128 | 0;
              if (!$2_1) {
                FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689716, HEAP32[$0_1 + 172 >> 2]);
                break label$8;
              }
              $1_1 = HEAPU8[$2_1 + 60 | 0] | HEAPU8[$2_1 + 61 | 0] << 8 | (HEAPU8[$2_1 + 62 | 0] << 16 | HEAPU8[$2_1 + 63 | 0] << 24);
              $12_1 = $1_1;
              $1_1 = $1_1 >>> 31 | 0;
              $3_1 = $1_1 ^ -1;
              $9_1 = HEAPU8[$2_1 + 44 | 0] | HEAPU8[$2_1 + 45 | 0] << 8 | (HEAPU8[$2_1 + 46 | 0] << 16 | HEAPU8[$2_1 + 47 | 0] << 24);
              $4_1 = ($9_1 | 0) == 1566010995;
              $11_1 = HEAPU8[$2_1 + 40 | 0] | HEAPU8[$2_1 + 41 | 0] << 8 | (HEAPU8[$2_1 + 42 | 0] << 16 | HEAPU8[$2_1 + 43 | 0] << 24);
              $10_1 = HEAPU8[$2_1 + 48 | 0] | HEAPU8[$2_1 + 49 | 0] << 8 | (HEAPU8[$2_1 + 50 | 0] << 16 | HEAPU8[$2_1 + 51 | 0] << 24);
              $14_1 = HEAPU8[$2_1 + 52 | 0] | HEAPU8[$2_1 + 53 | 0] << 8 | (HEAPU8[$2_1 + 54 | 0] << 16 | HEAPU8[$2_1 + 55 | 0] << 24);
              $0_1 = HEAPU8[$2_1 + 56 | 0] | HEAPU8[$2_1 + 57 | 0] << 8 | (HEAPU8[$2_1 + 58 | 0] << 16 | HEAPU8[$2_1 + 59 | 0] << 24);
              $3_1 = ($3_1 & ($4_1 & $11_1 >>> 0 < 1470386205 | $9_1 >>> 0 < 1566010995) | ($3_1 & ($10_1 & $14_1) != -1 | (($12_1 | 0) == 2147483647 & ($0_1 | 0) != -1 | $12_1 >>> 0 < 2147483647))) ^ -1;
              $17_1 = HEAPU8[$2_1 + 36 | 0] | HEAPU8[$2_1 + 37 | 0] << 8 | (HEAPU8[$2_1 + 38 | 0] << 16 | HEAPU8[$2_1 + 39 | 0] << 24);
              $16_1 = HEAPU8[$2_1 + 32 | 0] | HEAPU8[$2_1 + 33 | 0] << 8 | (HEAPU8[$2_1 + 34 | 0] << 16 | HEAPU8[$2_1 + 35 | 0] << 24);
              $1_1 = $3_1 & (($17_1 | 0) == -538366138 & $16_1 >>> 0 > 1746608288 | $17_1 >>> 0 > 3756601158) | ($3_1 & ($4_1 & $11_1 >>> 0 > 1470386205 | $9_1 >>> 0 > 1566010995) | $1_1);
              if ($2_1) {
                if ($1_1) {
                  $1_1 = $16_1 ^ -1;
                  $4_1 = $1_1 - 801750718 | 0;
                  $13_1 = $4_1;
                  $3_1 = $17_1 ^ -1;
                  $7_1 = $3_1 - (($1_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
                  $4_1 = ($3_1 | 0) == ($7_1 | 0) & $1_1 >>> 0 > $4_1 >>> 0 | $3_1 >>> 0 > $7_1 >>> 0;
                  $15_1 = $11_1 ^ -1;
                  $1_1 = $4_1 + $15_1 | 0;
                  $3_1 = $9_1 ^ -1;
                  $6_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
                  $4_1 = $1_1 - 1354194885 | 0;
                  $18_1 = $4_1;
                  $19_1 = $10_1 ^ -1;
                  $3_1 = ($3_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 < $15_1 >>> 0 | $3_1 >>> 0 > $6_1 >>> 0;
                  $15_1 = $6_1 - (($1_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
                  $4_1 = ($15_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 > $4_1 >>> 0 | $6_1 >>> 0 > $15_1 >>> 0;
                  $1_1 = $3_1 + $4_1 | 0;
                  $8_1 = $14_1 ^ -1;
                  $3_1 = $8_1 + ($1_1 >>> 0 < $4_1 >>> 0) | 0;
                  $4_1 = $1_1 + $19_1 | 0;
                  $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
                  $6_1 = $4_1 - 2 | 0;
                  $20_1 = $6_1;
                  $1_1 = $11_1 | $16_1 | $10_1 | $0_1 | ($9_1 | $17_1 | $14_1 | $12_1) ? -1 : 0;
                  $14_1 = ($3_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 < $19_1 >>> 0 | $3_1 >>> 0 < $8_1 >>> 0;
                  $8_1 = $3_1 - ($4_1 >>> 0 < 2) | 0;
                  $3_1 = ($8_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 > $6_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
                  $4_1 = $14_1 + $3_1 | 0;
                  $6_1 = $3_1 >>> 0 > $4_1 >>> 0;
                  $3_1 = $0_1;
                  $9_1 = $4_1 - $3_1 | 0;
                  $0_1 = $9_1 - 2 & $1_1;
                  $12_1 = $1_1 & ($6_1 - (($3_1 >>> 0 > $4_1 >>> 0) + $12_1 | 0) | 0) - ($9_1 >>> 0 < 2);
                  $3_1 = $1_1;
                  $10_1 = $3_1 & $20_1;
                  $14_1 = $3_1 & $8_1;
                  $16_1 = $3_1 & $13_1;
                  $17_1 = $3_1 & $7_1;
                  $11_1 = $3_1 & $18_1;
                  $9_1 = $3_1 & $15_1;
                }
                $6_1 = $2_1 + 8 | 0;
                $15_1 = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8 | (HEAPU8[$6_1 + 2 | 0] << 16 | HEAPU8[$6_1 + 3 | 0] << 24);
                $3_1 = HEAPU8[$6_1 + 4 | 0] | HEAPU8[$6_1 + 5 | 0] << 8 | (HEAPU8[$6_1 + 6 | 0] << 16 | HEAPU8[$6_1 + 7 | 0] << 24);
                $7_1 = $2_1 + 16 | 0;
                $13_1 = HEAPU8[$7_1 | 0] | HEAPU8[$7_1 + 1 | 0] << 8 | (HEAPU8[$7_1 + 2 | 0] << 16 | HEAPU8[$7_1 + 3 | 0] << 24);
                $1_1 = HEAPU8[$7_1 + 4 | 0] | HEAPU8[$7_1 + 5 | 0] << 8 | (HEAPU8[$7_1 + 6 | 0] << 16 | HEAPU8[$7_1 + 7 | 0] << 24);
                $18_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
                $4_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
                $8_1 = $2_1 + 24 | 0;
                $19_1 = HEAPU8[$8_1 + 4 | 0] | HEAPU8[$8_1 + 5 | 0] << 8 | (HEAPU8[$8_1 + 6 | 0] << 16 | HEAPU8[$8_1 + 7 | 0] << 24);
                $20_1 = HEAPU8[$8_1 | 0] | HEAPU8[$8_1 + 1 | 0] << 8 | (HEAPU8[$8_1 + 2 | 0] << 16 | HEAPU8[$8_1 + 3 | 0] << 24);
                HEAP8[$8_1 | 0] = $20_1;
                HEAP8[$8_1 + 1 | 0] = $20_1 >>> 8;
                HEAP8[$8_1 + 2 | 0] = $20_1 >>> 16;
                HEAP8[$8_1 + 3 | 0] = $20_1 >>> 24;
                HEAP8[$8_1 + 4 | 0] = $19_1;
                HEAP8[$8_1 + 5 | 0] = $19_1 >>> 8;
                HEAP8[$8_1 + 6 | 0] = $19_1 >>> 16;
                HEAP8[$8_1 + 7 | 0] = $19_1 >>> 24;
                HEAP8[$7_1 | 0] = $13_1;
                HEAP8[$7_1 + 1 | 0] = $13_1 >>> 8;
                HEAP8[$7_1 + 2 | 0] = $13_1 >>> 16;
                HEAP8[$7_1 + 3 | 0] = $13_1 >>> 24;
                HEAP8[$7_1 + 4 | 0] = $1_1;
                HEAP8[$7_1 + 5 | 0] = $1_1 >>> 8;
                HEAP8[$7_1 + 6 | 0] = $1_1 >>> 16;
                HEAP8[$7_1 + 7 | 0] = $1_1 >>> 24;
                HEAP8[$6_1 | 0] = $15_1;
                HEAP8[$6_1 + 1 | 0] = $15_1 >>> 8;
                HEAP8[$6_1 + 2 | 0] = $15_1 >>> 16;
                HEAP8[$6_1 + 3 | 0] = $15_1 >>> 24;
                HEAP8[$6_1 + 4 | 0] = $3_1;
                HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
                HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
                HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
                HEAP8[$2_1 | 0] = $18_1;
                HEAP8[$2_1 + 1 | 0] = $18_1 >>> 8;
                HEAP8[$2_1 + 2 | 0] = $18_1 >>> 16;
                HEAP8[$2_1 + 3 | 0] = $18_1 >>> 24;
                HEAP8[$2_1 + 4 | 0] = $4_1;
                HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
                HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
                HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
                HEAP8[$2_1 + 56 | 0] = $0_1;
                HEAP8[$2_1 + 57 | 0] = $0_1 >>> 8;
                HEAP8[$2_1 + 58 | 0] = $0_1 >>> 16;
                HEAP8[$2_1 + 59 | 0] = $0_1 >>> 24;
                HEAP8[$2_1 + 60 | 0] = $12_1;
                HEAP8[$2_1 + 61 | 0] = $12_1 >>> 8;
                HEAP8[$2_1 + 62 | 0] = $12_1 >>> 16;
                HEAP8[$2_1 + 63 | 0] = $12_1 >>> 24;
                HEAP8[$2_1 + 48 | 0] = $10_1;
                HEAP8[$2_1 + 49 | 0] = $10_1 >>> 8;
                HEAP8[$2_1 + 50 | 0] = $10_1 >>> 16;
                HEAP8[$2_1 + 51 | 0] = $10_1 >>> 24;
                HEAP8[$2_1 + 52 | 0] = $14_1;
                HEAP8[$2_1 + 53 | 0] = $14_1 >>> 8;
                HEAP8[$2_1 + 54 | 0] = $14_1 >>> 16;
                HEAP8[$2_1 + 55 | 0] = $14_1 >>> 24;
                HEAP8[$2_1 + 40 | 0] = $11_1;
                HEAP8[$2_1 + 41 | 0] = $11_1 >>> 8;
                HEAP8[$2_1 + 42 | 0] = $11_1 >>> 16;
                HEAP8[$2_1 + 43 | 0] = $11_1 >>> 24;
                HEAP8[$2_1 + 44 | 0] = $9_1;
                HEAP8[$2_1 + 45 | 0] = $9_1 >>> 8;
                HEAP8[$2_1 + 46 | 0] = $9_1 >>> 16;
                HEAP8[$2_1 + 47 | 0] = $9_1 >>> 24;
                HEAP8[$2_1 + 32 | 0] = $16_1;
                HEAP8[$2_1 + 33 | 0] = $16_1 >>> 8;
                HEAP8[$2_1 + 34 | 0] = $16_1 >>> 16;
                HEAP8[$2_1 + 35 | 0] = $16_1 >>> 24;
                HEAP8[$2_1 + 36 | 0] = $17_1;
                HEAP8[$2_1 + 37 | 0] = $17_1 >>> 8;
                HEAP8[$2_1 + 38 | 0] = $17_1 >>> 16;
                HEAP8[$2_1 + 39 | 0] = $17_1 >>> 24;
              }
            }
          }
          $13_1 = $6();
          $0_1 = 0;
          $1_1 = global$0 - 464 | 0;
          global$0 = $1_1;
          $3_1 = $5_1 + 128 | 0;
          label$12: {
            if (!$3_1) {
              FUNCTION_TABLE[HEAP32[$13_1 + 168 >> 2]](689748, HEAP32[$13_1 + 172 >> 2]);
              break label$12;
            }
            if (!$5_1) {
              FUNCTION_TABLE[HEAP32[$13_1 + 168 >> 2]](689638, HEAP32[$13_1 + 172 >> 2]);
              break label$12;
            }
            $38($1_1 + 8 | 0, 655649, 0);
            $4_1 = $3_1 + 24 | 0;
            $6_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
            $2_1 = $1_1 + 40 | 0;
            $7_1 = $2_1 + 24 | 0;
            HEAP32[$7_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
            HEAP32[$7_1 + 4 >> 2] = $6_1;
            $4_1 = $3_1 + 16 | 0;
            $6_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
            $7_1 = $2_1 + 16 | 0;
            HEAP32[$7_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
            HEAP32[$7_1 + 4 >> 2] = $6_1;
            $4_1 = $3_1 + 8 | 0;
            $6_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
            $2_1 = $2_1 + 8 | 0;
            HEAP32[$2_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
            HEAP32[$2_1 + 4 >> 2] = $6_1;
            $4_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
            HEAP32[$1_1 + 40 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
            HEAP32[$1_1 + 44 >> 2] = $4_1;
            $6_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
            $21_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
            $4_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
            $8_1 = $4_1 >>> 31 | 0;
            $10_1 = $8_1 ^ -1;
            $2_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
            $11_1 = ($2_1 | 0) == 1566010995;
            $7_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
            $17_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
            $9_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
            $12_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
            $3_1 = ($10_1 & ($11_1 & $7_1 >>> 0 < 1470386205 | $2_1 >>> 0 < 1566010995) | ($10_1 & ($17_1 & $9_1) != -1 | (($4_1 | 0) == 2147483647 & ($12_1 | 0) != -1 | $4_1 >>> 0 < 2147483647))) ^ -1;
            if ((($6_1 | 0) == -538366138 & $21_1 >>> 0 > 1746608288 | $6_1 >>> 0 > 3756601158) & $3_1 | ($3_1 & ($11_1 & $7_1 >>> 0 > 1470386205 | $2_1 >>> 0 > 1566010995) | $8_1)) {
              break label$12;
            }
            $3_1 = HEAPU8[$5_1 + 12 | 0] | HEAPU8[$5_1 + 13 | 0] << 8 | (HEAPU8[$5_1 + 14 | 0] << 16 | HEAPU8[$5_1 + 15 | 0] << 24);
            $11_1 = $3_1;
            $8_1 = HEAPU8[$5_1 + 8 | 0] | HEAPU8[$5_1 + 9 | 0] << 8 | (HEAPU8[$5_1 + 10 | 0] << 16 | HEAPU8[$5_1 + 11 | 0] << 24);
            $10_1 = ($3_1 << 12 | $8_1 >>> 20) & 1048575;
            $14_1 = HEAPU8[$5_1 + 4 | 0] | HEAPU8[$5_1 + 5 | 0] << 8 | (HEAPU8[$5_1 + 6 | 0] << 16 | HEAPU8[$5_1 + 7 | 0] << 24);
            $18_1 = $14_1;
            $22_1 = $8_1 << 12 & -4096 | $14_1 >>> 20;
            $23_1 = $10_1;
            $8_1 = HEAPU8[$5_1 + 16 | 0] | HEAPU8[$5_1 + 17 | 0] << 8 | (HEAPU8[$5_1 + 18 | 0] << 16 | HEAPU8[$5_1 + 19 | 0] << 24);
            $19_1 = $8_1;
            $3_1 = HEAPU8[$5_1 + 20 | 0] | HEAPU8[$5_1 + 21 | 0] << 8 | (HEAPU8[$5_1 + 22 | 0] << 16 | HEAPU8[$5_1 + 23 | 0] << 24);
            $15_1 = $3_1;
            $10_1 = ($3_1 << 24 | $8_1 >>> 8) & 1048575;
            $24_1 = $8_1 << 24 & -16777216 | $11_1 >>> 8;
            $25_1 = $10_1;
            $11_1 = HEAPU8[$5_1 + 28 | 0] | HEAPU8[$5_1 + 29 | 0] << 8 | (HEAPU8[$5_1 + 30 | 0] << 16 | HEAPU8[$5_1 + 31 | 0] << 24);
            $3_1 = $11_1 >>> 16 | 0;
            $8_1 = HEAPU8[$5_1 + 24 | 0] | HEAPU8[$5_1 + 25 | 0] << 8 | (HEAPU8[$5_1 + 26 | 0] << 16 | HEAPU8[$5_1 + 27 | 0] << 24);
            $10_1 = ($11_1 & 65535) << 16 | $8_1 >>> 16;
            $14_1 = $3_1;
            $11_1 = $8_1 << 4 & 1048560;
            $8_1 = $15_1;
            $3_1 = $8_1 >>> 28 | 0;
            $26_1 = ($8_1 & 268435455) << 4 | $19_1 >>> 28;
            $27_1 = HEAPU8[$5_1 | 0] | HEAPU8[$5_1 + 1 | 0] << 8 | (HEAPU8[$5_1 + 2 | 0] << 16 | HEAPU8[$5_1 + 3 | 0] << 24);
            $28_1 = $3_1 | $11_1;
            $29_1 = $18_1 & 1048575;
            if (!($26_1 | ($24_1 | ($10_1 | ($22_1 | $27_1))) | ($28_1 | ($25_1 | ($14_1 | ($23_1 | $29_1)))))) {
              FUNCTION_TABLE[HEAP32[$13_1 + 168 >> 2]](690116, HEAP32[$13_1 + 172 >> 2]);
              break label$12;
            }
            $11_1 = HEAP32[$1_1 + 64 >> 2];
            $16_1 = HEAP32[$1_1 + 56 >> 2];
            $30_1 = HEAP32[$1_1 + 48 >> 2];
            $31_1 = HEAP32[$1_1 + 40 >> 2];
            $8_1 = HEAP32[$1_1 + 68 >> 2];
            $18_1 = HEAP32[$1_1 + 60 >> 2];
            $15_1 = HEAP32[$1_1 + 52 >> 2];
            $13_1 = HEAP32[$1_1 + 44 >> 2];
            if (!($11_1 | ($16_1 | ($30_1 | $31_1)) | ($8_1 | ($18_1 | ($15_1 | $13_1))))) {
              break label$12;
            }
            if (!($7_1 | $21_1 | $17_1 | $12_1 | ($2_1 | $6_1 | $9_1 | $4_1))) {
              break label$12;
            }
            $19_1 = HEAPU8[$5_1 + 48 | 0] | HEAPU8[$5_1 + 49 | 0] << 8 | (HEAPU8[$5_1 + 50 | 0] << 16 | HEAPU8[$5_1 + 51 | 0] << 24);
            $20_1 = HEAPU8[$5_1 + 52 | 0] | HEAPU8[$5_1 + 53 | 0] << 8 | (HEAPU8[$5_1 + 54 | 0] << 16 | HEAPU8[$5_1 + 55 | 0] << 24);
            $32_1 = HEAPU8[$5_1 + 56 | 0] | HEAPU8[$5_1 + 57 | 0] << 8 | (HEAPU8[$5_1 + 58 | 0] << 16 | HEAPU8[$5_1 + 59 | 0] << 24);
            $34_1 = HEAPU8[$5_1 + 60 | 0] | HEAPU8[$5_1 + 61 | 0] << 8 | (HEAPU8[$5_1 + 62 | 0] << 16 | HEAPU8[$5_1 + 63 | 0] << 24);
            $35_1 = HEAPU8[$5_1 + 40 | 0] | HEAPU8[$5_1 + 41 | 0] << 8 | (HEAPU8[$5_1 + 42 | 0] << 16 | HEAPU8[$5_1 + 43 | 0] << 24);
            $36_1 = HEAPU8[$5_1 + 44 | 0] | HEAPU8[$5_1 + 45 | 0] << 8 | (HEAPU8[$5_1 + 46 | 0] << 16 | HEAPU8[$5_1 + 47 | 0] << 24);
            $37_1 = HEAPU8[$5_1 + 32 | 0] | HEAPU8[$5_1 + 33 | 0] << 8 | (HEAPU8[$5_1 + 34 | 0] << 16 | HEAPU8[$5_1 + 35 | 0] << 24);
            $33_1 = HEAPU8[$5_1 + 36 | 0] | HEAPU8[$5_1 + 37 | 0] << 8 | (HEAPU8[$5_1 + 38 | 0] << 16 | HEAPU8[$5_1 + 39 | 0] << 24);
            HEAP32[$1_1 + 232 >> 2] = $4_1 >>> 24;
            HEAP32[$1_1 + 236 >> 2] = 0;
            HEAP32[$1_1 + 200 >> 2] = $21_1;
            HEAP32[$1_1 + 204 >> 2] = $6_1 & 1073741823;
            $3_1 = $4_1 << 6 | $12_1 >>> 26;
            $4_1 = $9_1;
            HEAP32[$1_1 + 224 >> 2] = $12_1 << 6 | $4_1 >>> 26;
            HEAP32[$1_1 + 228 >> 2] = $3_1 & 1073741823;
            $3_1 = $4_1 << 4 | $17_1 >>> 28;
            HEAP32[$1_1 + 216 >> 2] = $17_1 << 4 | $2_1 >>> 28;
            HEAP32[$1_1 + 220 >> 2] = $3_1 & 1073741823;
            $2_1 = $2_1 << 2 | $7_1 >>> 30;
            HEAP32[$1_1 + 208 >> 2] = $7_1 << 2 | $6_1 >>> 30;
            HEAP32[$1_1 + 212 >> 2] = $2_1 & 1073741823;
            $12_1 = $1_1 + 200 | 0;
            $40($12_1, 690320);
            $2_1 = HEAP32[$1_1 + 232 >> 2] << 24;
            $7_1 = HEAP32[$1_1 + 228 >> 2];
            $3_1 = $7_1 >>> 6 | 0;
            $6_1 = HEAP32[$1_1 + 224 >> 2];
            HEAP32[$1_1 + 456 >> 2] = ($7_1 & 63) << 26 | $6_1 >>> 6;
            HEAP32[$1_1 + 460 >> 2] = $2_1 | $3_1;
            $2_1 = $6_1 << 26;
            $7_1 = HEAP32[$1_1 + 220 >> 2];
            $3_1 = $7_1 >>> 4 | 0;
            $6_1 = HEAP32[$1_1 + 216 >> 2];
            HEAP32[$1_1 + 448 >> 2] = ($7_1 & 15) << 28 | $6_1 >>> 4;
            HEAP32[$1_1 + 452 >> 2] = $2_1 | $3_1;
            $2_1 = $6_1 << 28;
            $7_1 = HEAP32[$1_1 + 212 >> 2];
            $3_1 = $7_1 >>> 2 | 0;
            $6_1 = HEAP32[$1_1 + 208 >> 2];
            HEAP32[$1_1 + 440 >> 2] = ($7_1 & 3) << 30 | $6_1 >>> 2;
            HEAP32[$1_1 + 444 >> 2] = $2_1 | $3_1;
            $2_1 = HEAP32[$1_1 + 204 >> 2];
            $3_1 = $6_1 << 30;
            HEAP32[$1_1 + 432 >> 2] = HEAP32[$1_1 + 200 >> 2];
            HEAP32[$1_1 + 436 >> 2] = $2_1 | $3_1;
            $6_1 = $1_1 + 400 | 0;
            $3_1 = $1_1 + 432 | 0;
            $41($6_1, $3_1, $1_1 + 8 | 0);
            $7_1 = $1_1 + 368 | 0;
            $41($7_1, $3_1, $1_1 + 40 | 0);
            $3_1 = $1_1 + 288 | 0;
            HEAP32[$3_1 >> 2] = 0;
            HEAP32[$3_1 + 4 >> 2] = 0;
            $4_1 = $34_1;
            $3_1 = $4_1 >>> 16 | 0;
            $2_1 = $1_1 + 272 | 0;
            HEAP32[$2_1 >> 2] = ($4_1 & 65535) << 16 | $32_1 >>> 16;
            HEAP32[$2_1 + 4 >> 2] = $3_1;
            $9_1 = $32_1 << 4 & 1048560;
            $4_1 = $20_1;
            $3_1 = $4_1 >>> 28 | 0;
            $2_1 = $1_1 + 264 | 0;
            HEAP32[$2_1 >> 2] = ($4_1 & 268435455) << 4 | $19_1 >>> 28;
            HEAP32[$2_1 + 4 >> 2] = $3_1 | $9_1;
            $3_1 = $4_1 << 24 | $19_1 >>> 8;
            $2_1 = $1_1 + 256 | 0;
            $4_1 = $36_1;
            HEAP32[$2_1 >> 2] = $19_1 << 24 & -16777216 | $4_1 >>> 8;
            HEAP32[$2_1 + 4 >> 2] = $3_1 & 1048575;
            $3_1 = $4_1 << 12;
            $4_1 = $35_1;
            $9_1 = ($3_1 | $4_1 >>> 20) & 1048575;
            $2_1 = $1_1 + 248 | 0;
            HEAP32[$2_1 >> 2] = $4_1 << 12 & -4096 | $33_1 >>> 20;
            HEAP32[$2_1 + 4 >> 2] = $9_1;
            $3_1 = $1_1 + 296 | 0;
            HEAP32[$3_1 >> 2] = 0;
            HEAP32[$3_1 + 4 >> 2] = 0;
            $3_1 = $1_1 + 304 | 0;
            HEAP32[$3_1 >> 2] = 0;
            HEAP32[$3_1 + 4 >> 2] = 0;
            $3_1 = $1_1 + 312 | 0;
            HEAP32[$3_1 >> 2] = 0;
            HEAP32[$3_1 + 4 >> 2] = 0;
            HEAP32[$1_1 + 280 >> 2] = 1;
            HEAP32[$1_1 + 284 >> 2] = 0;
            HEAP32[$1_1 + 240 >> 2] = $37_1;
            HEAP32[$1_1 + 244 >> 2] = $33_1 & 1048575;
            HEAP32[$1_1 + 232 >> 2] = $10_1;
            HEAP32[$1_1 + 236 >> 2] = $14_1;
            HEAP32[$1_1 + 224 >> 2] = $26_1;
            HEAP32[$1_1 + 228 >> 2] = $28_1;
            HEAP32[$1_1 + 216 >> 2] = $24_1;
            HEAP32[$1_1 + 220 >> 2] = $25_1;
            HEAP32[$1_1 + 208 >> 2] = $22_1;
            HEAP32[$1_1 + 212 >> 2] = $23_1;
            HEAP32[$1_1 + 200 >> 2] = $27_1;
            HEAP32[$1_1 + 204 >> 2] = $29_1;
            HEAP32[$1_1 + 320 >> 2] = 0;
            $42($1_1 + 72 | 0, $12_1, $7_1, $6_1);
            if (HEAP32[$1_1 + 192 >> 2]) {
              break label$12;
            }
            $0_1 = $8_1;
            $3_1 = $0_1 >>> 16 | 0;
            HEAP32[$1_1 + 360 >> 2] = ($0_1 & 65535) << 16 | $11_1 >>> 16;
            HEAP32[$1_1 + 364 >> 2] = $3_1;
            $4_1 = $31_1;
            HEAP32[$1_1 + 328 >> 2] = $4_1;
            $8_1 = $13_1 & 1048575;
            HEAP32[$1_1 + 332 >> 2] = $8_1;
            $2_1 = $0_1;
            $0_1 = $18_1;
            $3_1 = $11_1 << 4 & 1048560 | $0_1 >>> 28;
            $17_1 = $3_1;
            $10_1 = ($0_1 & 268435455) << 4 | $16_1 >>> 28;
            HEAP32[$1_1 + 352 >> 2] = $10_1;
            HEAP32[$1_1 + 356 >> 2] = $3_1;
            $3_1 = $0_1 << 24 | $16_1 >>> 8;
            $0_1 = $15_1;
            $12_1 = $16_1 << 24 & -16777216 | $0_1 >>> 8;
            HEAP32[$1_1 + 344 >> 2] = $12_1;
            $6_1 = $3_1 & 1048575;
            HEAP32[$1_1 + 348 >> 2] = $6_1;
            $3_1 = $0_1 << 12;
            $0_1 = $30_1;
            $7_1 = ($3_1 | $0_1 >>> 20) & 1048575;
            $9_1 = $0_1 << 12 & -4096 | $13_1 >>> 20;
            HEAP32[$1_1 + 336 >> 2] = $9_1;
            HEAP32[$1_1 + 340 >> 2] = $7_1;
            $0_1 = 1;
            if ($43($1_1 + 328 | 0, $1_1 + 72 | 0)) {
              break label$12;
            }
            if ($2_1 | !$2_1 & $11_1 >>> 0 > 65535) {
              $0_1 = 0;
              break label$12;
            }
            if ($10_1 | $17_1) {
              $0_1 = 0;
              break label$12;
            }
            if ($6_1 | !$6_1 & $12_1 >>> 0 > 21319971) {
              $0_1 = 0;
              break label$12;
            }
            label$19: {
              if ($6_1 | ($12_1 | 0) != 21319971) {
                break label$19;
              }
              if (($7_1 | 0) == 103691 & $9_1 >>> 0 > 1979466754 | $7_1 >>> 0 > 103691) {
                $0_1 = 0;
                break label$12;
              }
              if (($9_1 | 0) != 1979466754 | ($7_1 | 0) != 103691) {
                break label$19;
              }
              $0_1 = 0;
              if (($8_1 | 0) == 893298 & $4_1 >>> 0 > 801749741 | $8_1 >>> 0 > 893298) {
                break label$12;
              }
            }
            HEAP32[$1_1 + 360 >> 2] = -1;
            HEAP32[$1_1 + 364 >> 2] = 65535;
            HEAP32[$1_1 + 352 >> 2] = -1;
            HEAP32[$1_1 + 356 >> 2] = 1048575;
            $3_1 = $6_1 + 1048575 | 0;
            $0_1 = $12_1 - 21319972 | 0;
            $3_1 = $0_1 >>> 0 < 4273647324 ? $3_1 + 1 | 0 : $3_1;
            HEAP32[$1_1 + 344 >> 2] = $0_1;
            HEAP32[$1_1 + 348 >> 2] = $3_1;
            $3_1 = $7_1 + 944884 | 0;
            $2_1 = $9_1 - 1979466755 | 0;
            $3_1 = $2_1 >>> 0 < 2315500541 ? $3_1 + 1 | 0 : $3_1;
            HEAP32[$1_1 + 336 >> 2] = $2_1;
            HEAP32[$1_1 + 340 >> 2] = $3_1;
            $6_1 = $8_1 + 155276 | 0;
            $0_1 = $4_1 - 801750719 | 0;
            $6_1 = $0_1 >>> 0 < 3493216577 ? $6_1 + 1 | 0 : $6_1;
            HEAP32[$1_1 + 328 >> 2] = $0_1;
            HEAP32[$1_1 + 332 >> 2] = $6_1;
            $0_1 = ($43($1_1 + 328 | 0, $1_1 + 72 | 0) | 0) != 0;
          }
          global$0 = $1_1 + 464 | 0;
          $3_1 = $0_1;
          break label$1;
        }
        fimport$1(1);
      }
      global$0 = $5_1 + 192 | 0;
      return $3_1 | 0;
    }
    function $25($0_1, $1_1) {
      $0_1 = $0_1 | 0;
      $1_1 = $1_1 | 0;
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0;
      $10_1 = global$0 - 176 | 0;
      global$0 = $10_1;
      $7_1 = $10_1 + 8 | 0;
      $68($7_1, 65);
      $2_1 = HEAP32[172688];
      $5_1 = global$0 - 80 | 0;
      global$0 = $5_1;
      HEAP32[$5_1 + 12 >> 2] = 0;
      label$1: {
        if (!$7_1) {
          FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689748, HEAP32[$2_1 + 172 >> 2]);
          break label$1;
        }
        if ($1_1 >>> 0 >= 4) {
          FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689986, HEAP32[$2_1 + 172 >> 2]);
          break label$1;
        }
        $2_1 = $5_1 + 12 | 0;
        $38($5_1 + 48 | 0, 690981, $2_1);
        $3_1 = HEAP32[$5_1 + 12 >> 2];
        $38($5_1 + 16 | 0, 691013, $2_1);
        if (!($3_1 | HEAP32[$5_1 + 12 >> 2])) {
          $2_1 = HEAP32[$5_1 + 52 >> 2];
          $3_1 = HEAP32[$5_1 + 48 >> 2];
          HEAP8[$7_1 | 0] = $3_1;
          HEAP8[$7_1 + 1 | 0] = $3_1 >>> 8;
          HEAP8[$7_1 + 2 | 0] = $3_1 >>> 16;
          HEAP8[$7_1 + 3 | 0] = $3_1 >>> 24;
          HEAP8[$7_1 + 4 | 0] = $2_1;
          HEAP8[$7_1 + 5 | 0] = $2_1 >>> 8;
          HEAP8[$7_1 + 6 | 0] = $2_1 >>> 16;
          HEAP8[$7_1 + 7 | 0] = $2_1 >>> 24;
          $2_1 = HEAP32[$5_1 + 20 >> 2];
          $3_1 = HEAP32[$5_1 + 16 >> 2];
          HEAP8[$7_1 + 32 | 0] = $3_1;
          HEAP8[$7_1 + 33 | 0] = $3_1 >>> 8;
          HEAP8[$7_1 + 34 | 0] = $3_1 >>> 16;
          HEAP8[$7_1 + 35 | 0] = $3_1 >>> 24;
          HEAP8[$7_1 + 36 | 0] = $2_1;
          HEAP8[$7_1 + 37 | 0] = $2_1 >>> 8;
          HEAP8[$7_1 + 38 | 0] = $2_1 >>> 16;
          HEAP8[$7_1 + 39 | 0] = $2_1 >>> 24;
          HEAP8[$7_1 + 64 | 0] = $1_1;
          $3_1 = $5_1 + 48 | 0;
          $1_1 = $3_1 + 24 | 0;
          $2_1 = HEAP32[$1_1 + 4 >> 2];
          $4_1 = $7_1 + 24 | 0;
          $1_1 = HEAP32[$1_1 >> 2];
          HEAP8[$4_1 | 0] = $1_1;
          HEAP8[$4_1 + 1 | 0] = $1_1 >>> 8;
          HEAP8[$4_1 + 2 | 0] = $1_1 >>> 16;
          HEAP8[$4_1 + 3 | 0] = $1_1 >>> 24;
          HEAP8[$4_1 + 4 | 0] = $2_1;
          HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
          HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
          HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
          $1_1 = $3_1 + 16 | 0;
          $2_1 = HEAP32[$1_1 + 4 >> 2];
          $4_1 = $7_1 + 16 | 0;
          $1_1 = HEAP32[$1_1 >> 2];
          HEAP8[$4_1 | 0] = $1_1;
          HEAP8[$4_1 + 1 | 0] = $1_1 >>> 8;
          HEAP8[$4_1 + 2 | 0] = $1_1 >>> 16;
          HEAP8[$4_1 + 3 | 0] = $1_1 >>> 24;
          HEAP8[$4_1 + 4 | 0] = $2_1;
          HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
          HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
          HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
          $1_1 = $3_1 + 8 | 0;
          $3_1 = HEAP32[$1_1 + 4 >> 2];
          $2_1 = $7_1 + 8 | 0;
          $1_1 = HEAP32[$1_1 >> 2];
          HEAP8[$2_1 | 0] = $1_1;
          HEAP8[$2_1 + 1 | 0] = $1_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $1_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $1_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $3_1;
          HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
          $3_1 = $5_1 + 16 | 0;
          $1_1 = $3_1 + 8 | 0;
          $2_1 = HEAP32[$1_1 + 4 >> 2];
          $4_1 = $7_1 + 40 | 0;
          $1_1 = HEAP32[$1_1 >> 2];
          HEAP8[$4_1 | 0] = $1_1;
          HEAP8[$4_1 + 1 | 0] = $1_1 >>> 8;
          HEAP8[$4_1 + 2 | 0] = $1_1 >>> 16;
          HEAP8[$4_1 + 3 | 0] = $1_1 >>> 24;
          HEAP8[$4_1 + 4 | 0] = $2_1;
          HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
          HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
          HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
          $1_1 = $3_1 + 16 | 0;
          $2_1 = HEAP32[$1_1 + 4 >> 2];
          $4_1 = $7_1 + 48 | 0;
          $1_1 = HEAP32[$1_1 >> 2];
          HEAP8[$4_1 | 0] = $1_1;
          HEAP8[$4_1 + 1 | 0] = $1_1 >>> 8;
          HEAP8[$4_1 + 2 | 0] = $1_1 >>> 16;
          HEAP8[$4_1 + 3 | 0] = $1_1 >>> 24;
          HEAP8[$4_1 + 4 | 0] = $2_1;
          HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
          HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
          HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
          $1_1 = $3_1 + 24 | 0;
          $3_1 = HEAP32[$1_1 + 4 >> 2];
          $2_1 = $7_1 + 56 | 0;
          $1_1 = HEAP32[$1_1 >> 2];
          HEAP8[$2_1 | 0] = $1_1;
          HEAP8[$2_1 + 1 | 0] = $1_1 >>> 8;
          HEAP8[$2_1 + 2 | 0] = $1_1 >>> 16;
          HEAP8[$2_1 + 3 | 0] = $1_1 >>> 24;
          HEAP8[$2_1 + 4 | 0] = $3_1;
          HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
          HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
          HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
          $3_1 = 1;
          break label$1;
        }
        $3_1 = 0;
        $68($7_1, 65);
      }
      global$0 = $5_1 + 80 | 0;
      label$5: {
        label$6: {
          if (!$3_1) {
            fimport$1(4);
            break label$6;
          }
          $1_1 = $10_1 + 136 | 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          $1_1 = $10_1 + 128 | 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          $1_1 = $10_1 + 120 | 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          $1_1 = $10_1 + 112 | 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          $1_1 = $10_1 + 104 | 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          $1_1 = $10_1 + 96 | 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          $1_1 = $10_1 + 88 | 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          HEAP32[$10_1 + 80 >> 2] = 0;
          HEAP32[$10_1 + 84 >> 2] = 0;
          $2_1 = $6();
          $12_1 = $10_1 + 80 | 0;
          $3_1 = global$0 - 640 | 0;
          global$0 = $3_1;
          $1_1 = $10_1 + 8 | 0;
          label$8: {
            label$9: {
              if (!$1_1) {
                FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689760, HEAP32[$2_1 + 172 >> 2]);
                break label$9;
              }
              if (!$12_1) {
                FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689638, HEAP32[$2_1 + 172 >> 2]);
                break label$9;
              }
              $5_1 = $1_1 + 40 | 0;
              $4_1 = HEAPU8[$5_1 + 4 | 0] | HEAPU8[$5_1 + 5 | 0] << 8 | (HEAPU8[$5_1 + 6 | 0] << 16 | HEAPU8[$5_1 + 7 | 0] << 24);
              $2_1 = $3_1 + 48 | 0;
              HEAP32[$2_1 >> 2] = HEAPU8[$5_1 | 0] | HEAPU8[$5_1 + 1 | 0] << 8 | (HEAPU8[$5_1 + 2 | 0] << 16 | HEAPU8[$5_1 + 3 | 0] << 24);
              HEAP32[$2_1 + 4 >> 2] = $4_1;
              $5_1 = $1_1 + 48 | 0;
              $4_1 = HEAPU8[$5_1 + 4 | 0] | HEAPU8[$5_1 + 5 | 0] << 8 | (HEAPU8[$5_1 + 6 | 0] << 16 | HEAPU8[$5_1 + 7 | 0] << 24);
              $2_1 = $3_1 + 56 | 0;
              HEAP32[$2_1 >> 2] = HEAPU8[$5_1 | 0] | HEAPU8[$5_1 + 1 | 0] << 8 | (HEAPU8[$5_1 + 2 | 0] << 16 | HEAPU8[$5_1 + 3 | 0] << 24);
              HEAP32[$2_1 + 4 >> 2] = $4_1;
              $5_1 = $1_1 + 56 | 0;
              $4_1 = HEAPU8[$5_1 + 4 | 0] | HEAPU8[$5_1 + 5 | 0] << 8 | (HEAPU8[$5_1 + 6 | 0] << 16 | HEAPU8[$5_1 + 7 | 0] << 24);
              $2_1 = $3_1 - -64 | 0;
              HEAP32[$2_1 >> 2] = HEAPU8[$5_1 | 0] | HEAPU8[$5_1 + 1 | 0] << 8 | (HEAPU8[$5_1 + 2 | 0] << 16 | HEAPU8[$5_1 + 3 | 0] << 24);
              HEAP32[$2_1 + 4 >> 2] = $4_1;
              $2_1 = HEAPU8[$1_1 + 36 | 0] | HEAPU8[$1_1 + 37 | 0] << 8 | (HEAPU8[$1_1 + 38 | 0] << 16 | HEAPU8[$1_1 + 39 | 0] << 24);
              HEAP32[$3_1 + 40 >> 2] = HEAPU8[$1_1 + 32 | 0] | HEAPU8[$1_1 + 33 | 0] << 8 | (HEAPU8[$1_1 + 34 | 0] << 16 | HEAPU8[$1_1 + 35 | 0] << 24);
              HEAP32[$3_1 + 44 >> 2] = $2_1;
              $17_1 = HEAPU8[$1_1 + 64 | 0];
              $11_1 = HEAPU8[$1_1 + 24 | 0] | HEAPU8[$1_1 + 25 | 0] << 8 | (HEAPU8[$1_1 + 26 | 0] << 16 | HEAPU8[$1_1 + 27 | 0] << 24);
              $2_1 = HEAPU8[$1_1 + 28 | 0] | HEAPU8[$1_1 + 29 | 0] << 8 | (HEAPU8[$1_1 + 30 | 0] << 16 | HEAPU8[$1_1 + 31 | 0] << 24);
              $14_1 = HEAPU8[$1_1 + 16 | 0] | HEAPU8[$1_1 + 17 | 0] << 8 | (HEAPU8[$1_1 + 18 | 0] << 16 | HEAPU8[$1_1 + 19 | 0] << 24);
              $7_1 = HEAPU8[$1_1 + 20 | 0] | HEAPU8[$1_1 + 21 | 0] << 8 | (HEAPU8[$1_1 + 22 | 0] << 16 | HEAPU8[$1_1 + 23 | 0] << 24);
              $18_1 = HEAPU8[$1_1 + 8 | 0] | HEAPU8[$1_1 + 9 | 0] << 8 | (HEAPU8[$1_1 + 10 | 0] << 16 | HEAPU8[$1_1 + 11 | 0] << 24);
              $5_1 = HEAPU8[$1_1 + 12 | 0] | HEAPU8[$1_1 + 13 | 0] << 8 | (HEAPU8[$1_1 + 14 | 0] << 16 | HEAPU8[$1_1 + 15 | 0] << 24);
              $19_1 = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
              $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
              $38($3_1 + 8 | 0, 655649, 0);
              label$12: {
                if (!($11_1 | ($14_1 | ($18_1 | $19_1)) | ($2_1 | ($7_1 | ($4_1 | $5_1))))) {
                  break label$12;
                }
                if (!(HEAP32[$3_1 + 64 >> 2] | (HEAP32[$3_1 + 56 >> 2] | (HEAP32[$3_1 + 48 >> 2] | HEAP32[$3_1 + 40 >> 2])) | (HEAP32[$3_1 + 68 >> 2] | (HEAP32[$3_1 + 60 >> 2] | (HEAP32[$3_1 + 52 >> 2] | HEAP32[$3_1 + 44 >> 2]))))) {
                  break label$12;
                }
                $1_1 = $3_1;
                HEAP32[$1_1 + 632 >> 2] = ($2_1 & 65535) << 16 | $11_1 >>> 16;
                HEAP32[$1_1 + 636 >> 2] = $2_1 >>> 16;
                HEAP32[$1_1 + 600 >> 2] = $19_1;
                $23_1 = $4_1 & 1048575;
                HEAP32[$1_1 + 604 >> 2] = $23_1;
                $15_1 = $11_1 << 4;
                $9_1 = $15_1 & 1044480;
                $6_1 = $9_1 | ($15_1 & 4080 | $7_1 >>> 28);
                $24_1 = $6_1;
                $21_1 = ($7_1 & 268435455) << 4 | $14_1 >>> 28;
                HEAP32[$1_1 + 624 >> 2] = $21_1;
                HEAP32[$1_1 + 628 >> 2] = $6_1;
                $15_1 = $7_1 << 24 | $14_1 >>> 8;
                $20_1 = $15_1 & 983040;
                $16_1 = $15_1 & 65280;
                $13_1 = $14_1 << 24 & -16777216 | $5_1 >>> 8;
                HEAP32[$1_1 + 616 >> 2] = $13_1;
                $22_1 = $20_1 | ($16_1 | $15_1 & 255);
                HEAP32[$1_1 + 620 >> 2] = $22_1;
                $6_1 = $5_1 << 12 | $18_1 >>> 20;
                $20_1 = $6_1 & 1044480;
                $16_1 = $6_1 & 4080;
                $1_1 = $18_1 << 12;
                $15_1 = $1_1 & -268435456;
                $9_1 = $6_1 & 15;
                $8_1 = $1_1 & 267386880;
                $8_1 = $15_1 | ($8_1 | ($1_1 & 1044480 | $4_1 >>> 20));
                HEAP32[$3_1 + 608 >> 2] = $8_1;
                $9_1 = $20_1 | ($9_1 | $16_1);
                HEAP32[$3_1 + 612 >> 2] = $9_1;
                if ($17_1 & 2) {
                  if ($2_1 | !$2_1 & $11_1 >>> 0 > 65535) {
                    break label$12;
                  }
                  if ($24_1 | $21_1) {
                    break label$12;
                  }
                  if ($22_1 | !$22_1 & $13_1 >>> 0 > 21319971) {
                    break label$12;
                  }
                  label$14: {
                    if ($22_1 | ($13_1 | 0) != 21319971) {
                      break label$14;
                    }
                    if (($9_1 | 0) == 103691 & $8_1 >>> 0 > 1979466754 | $9_1 >>> 0 > 103691) {
                      break label$12;
                    }
                    if (($8_1 | 0) != 1979466754 | ($9_1 | 0) != 103691) {
                      break label$14;
                    }
                    if (($23_1 | 0) == 893298 & $19_1 >>> 0 > 801749741 | $23_1 >>> 0 > 893298) {
                      break label$12;
                    }
                  }
                  HEAP32[$3_1 + 632 >> 2] = -1;
                  HEAP32[$3_1 + 636 >> 2] = 65535;
                  HEAP32[$3_1 + 624 >> 2] = -1;
                  HEAP32[$3_1 + 628 >> 2] = 1048575;
                  $6_1 = $22_1 + 1048575 | 0;
                  $1_1 = $13_1 - 21319972 | 0;
                  $6_1 = $1_1 >>> 0 < 4273647324 ? $6_1 + 1 | 0 : $6_1;
                  HEAP32[$3_1 + 616 >> 2] = $1_1;
                  HEAP32[$3_1 + 620 >> 2] = $6_1;
                  $1_1 = $9_1 + 944884 | 0;
                  $8_1 = $8_1 - 1979466755 | 0;
                  $1_1 = $8_1 >>> 0 < 2315500541 ? $1_1 + 1 | 0 : $1_1;
                  HEAP32[$3_1 + 608 >> 2] = $8_1;
                  HEAP32[$3_1 + 612 >> 2] = $1_1;
                  $6_1 = $23_1 + 155276 | 0;
                  $1_1 = $19_1 - 801750719 | 0;
                  $6_1 = $1_1 >>> 0 < 3493216577 ? $6_1 + 1 | 0 : $6_1;
                  HEAP32[$3_1 + 600 >> 2] = $1_1;
                  HEAP32[$3_1 + 604 >> 2] = $6_1;
                }
                if (!$33($3_1 + 512 | 0, $3_1 + 600 | 0, $17_1 & 1)) {
                  break label$12;
                }
                $9_1 = $3_1 + 512 | 0;
                $8_1 = $9_1 + 8 | 0;
                $6_1 = HEAP32[$8_1 + 4 >> 2];
                $13_1 = $3_1 + 384 | 0;
                $1_1 = $13_1 + 8 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $6_1;
                $8_1 = $9_1 + 16 | 0;
                $6_1 = HEAP32[$8_1 + 4 >> 2];
                $1_1 = $13_1 + 16 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $6_1;
                $8_1 = $9_1 + 24 | 0;
                $6_1 = HEAP32[$8_1 + 4 >> 2];
                $1_1 = $13_1 + 24 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $6_1;
                $8_1 = $9_1 + 32 | 0;
                $6_1 = HEAP32[$8_1 + 4 >> 2];
                $1_1 = $13_1 + 32 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $6_1;
                $8_1 = $9_1 + 48 | 0;
                $6_1 = HEAP32[$8_1 + 4 >> 2];
                $1_1 = $13_1 + 48 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $6_1;
                $8_1 = $9_1 + 56 | 0;
                $6_1 = HEAP32[$8_1 + 4 >> 2];
                $1_1 = $13_1 + 56 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $6_1;
                $8_1 = $9_1 - -64 | 0;
                $6_1 = HEAP32[$8_1 + 4 >> 2];
                $1_1 = $13_1 - -64 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $6_1;
                $8_1 = $9_1 + 72 | 0;
                $6_1 = HEAP32[$8_1 + 4 >> 2];
                $1_1 = $13_1 + 72 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $6_1;
                HEAP32[$3_1 + 504 >> 2] = HEAP32[$3_1 + 592 >> 2];
                $1_1 = HEAP32[$3_1 + 516 >> 2];
                HEAP32[$3_1 + 384 >> 2] = HEAP32[$3_1 + 512 >> 2];
                HEAP32[$3_1 + 388 >> 2] = $1_1;
                $1_1 = HEAP32[$3_1 + 556 >> 2];
                HEAP32[$3_1 + 424 >> 2] = HEAP32[$3_1 + 552 >> 2];
                HEAP32[$3_1 + 428 >> 2] = $1_1;
                $1_1 = $3_1 + 472 | 0;
                HEAP32[$1_1 >> 2] = 0;
                HEAP32[$1_1 + 4 >> 2] = 0;
                $1_1 = $3_1 + 480 | 0;
                HEAP32[$1_1 >> 2] = 0;
                HEAP32[$1_1 + 4 >> 2] = 0;
                $1_1 = $3_1 + 488 | 0;
                HEAP32[$1_1 >> 2] = 0;
                HEAP32[$1_1 + 4 >> 2] = 0;
                $1_1 = $3_1 + 496 | 0;
                HEAP32[$1_1 >> 2] = 0;
                HEAP32[$1_1 + 4 >> 2] = 0;
                HEAP32[$3_1 + 464 >> 2] = 1;
                HEAP32[$3_1 + 468 >> 2] = 0;
                HEAP32[$3_1 + 104 >> 2] = $2_1 >>> 24;
                HEAP32[$3_1 + 108 >> 2] = 0;
                $2_1 = $2_1 << 6 | $11_1 >>> 26;
                $1_1 = $7_1;
                HEAP32[$3_1 + 96 >> 2] = $11_1 << 6 | $1_1 >>> 26;
                HEAP32[$3_1 + 100 >> 2] = $2_1 & 1073741823;
                $7_1 = $1_1 << 4 | $14_1 >>> 28;
                $2_1 = $3_1;
                $1_1 = $5_1;
                HEAP32[$2_1 + 88 >> 2] = $14_1 << 4 | $1_1 >>> 28;
                HEAP32[$2_1 + 92 >> 2] = $7_1 & 1073741823;
                HEAP32[$2_1 + 80 >> 2] = $18_1 << 2 | $4_1 >>> 30;
                HEAP32[$2_1 + 84 >> 2] = ($1_1 << 2 | $18_1 >>> 30) & 1073741823;
                HEAP32[$2_1 + 72 >> 2] = $19_1;
                HEAP32[$2_1 + 76 >> 2] = $4_1 & 1073741823;
                $15_1 = $2_1 + 72 | 0;
                $40($15_1, 690320);
                $7_1 = HEAP32[$2_1 + 104 >> 2] << 24;
                $4_1 = HEAP32[$2_1 + 100 >> 2];
                $1_1 = $4_1 >>> 6 | 0;
                $5_1 = HEAP32[$2_1 + 96 >> 2];
                HEAP32[$2_1 + 376 >> 2] = ($4_1 & 63) << 26 | $5_1 >>> 6;
                HEAP32[$2_1 + 380 >> 2] = $1_1 | $7_1;
                $5_1 = $5_1 << 26;
                $1_1 = HEAP32[$2_1 + 92 >> 2];
                $6_1 = $1_1 >>> 4 | 0;
                $4_1 = HEAP32[$2_1 + 88 >> 2];
                HEAP32[$2_1 + 368 >> 2] = ($1_1 & 15) << 28 | $4_1 >>> 4;
                HEAP32[$2_1 + 372 >> 2] = $6_1 | $5_1;
                $7_1 = $4_1 << 28;
                $4_1 = HEAP32[$2_1 + 84 >> 2];
                $1_1 = $4_1 >>> 2 | 0;
                $5_1 = HEAP32[$2_1 + 80 >> 2];
                HEAP32[$2_1 + 360 >> 2] = ($4_1 & 3) << 30 | $5_1 >>> 2;
                HEAP32[$2_1 + 364 >> 2] = $1_1 | $7_1;
                $7_1 = HEAP32[$2_1 + 76 >> 2];
                $6_1 = $5_1 << 30;
                HEAP32[$2_1 + 352 >> 2] = HEAP32[$2_1 + 72 >> 2];
                HEAP32[$2_1 + 356 >> 2] = $6_1 | $7_1;
                $9_1 = $2_1 + 320 | 0;
                $8_1 = $2_1 + 352 | 0;
                $41($9_1, $8_1, $2_1 + 8 | 0);
                $21_1 = HEAP32[$2_1 + 344 >> 2];
                $19_1 = HEAP32[$2_1 + 336 >> 2];
                $11_1 = HEAP32[$2_1 + 328 >> 2];
                $4_1 = HEAP32[$2_1 + 320 >> 2];
                $18_1 = HEAP32[$2_1 + 348 >> 2];
                $14_1 = HEAP32[$2_1 + 340 >> 2];
                $6_1 = HEAP32[$2_1 + 332 >> 2];
                $7_1 = HEAP32[$2_1 + 324 >> 2];
                $1_1 = $21_1 | ($19_1 | ($11_1 | $4_1)) | ($18_1 | ($14_1 | ($6_1 | $7_1))) ? -1 : 0;
                $16_1 = $4_1 ^ -1;
                $5_1 = $16_1 - 801750718 | 0;
                HEAP32[$2_1 + 320 >> 2] = $1_1 & $5_1;
                $4_1 = $1_1;
                $7_1 = $7_1 ^ -1;
                $1_1 = $7_1 - (($16_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
                HEAP32[$2_1 + 324 >> 2] = $4_1 & $1_1;
                $1_1 = ($1_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 < $7_1 >>> 0;
                $11_1 = $11_1 ^ -1;
                $17_1 = $1_1 + $11_1 | 0;
                $20_1 = $6_1 ^ -1;
                $6_1 = $20_1;
                $6_1 = $1_1 >>> 0 > $17_1 >>> 0 ? $6_1 + 1 | 0 : $6_1;
                $1_1 = $17_1 - 1354194885 | 0;
                HEAP32[$2_1 + 328 >> 2] = $1_1 & $4_1;
                $16_1 = $6_1 - (($17_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
                HEAP32[$2_1 + 332 >> 2] = $16_1 & $4_1;
                $7_1 = $19_1 ^ -1;
                $1_1 = ($6_1 | 0) == ($16_1 | 0) & $1_1 >>> 0 < $17_1 >>> 0 | $6_1 >>> 0 > $16_1 >>> 0;
                $11_1 = $1_1 + (($6_1 | 0) == ($20_1 | 0) & $11_1 >>> 0 > $17_1 >>> 0 | $6_1 >>> 0 < $20_1 >>> 0) | 0;
                $14_1 = $14_1 ^ -1;
                $1_1 = $14_1 + ($1_1 >>> 0 > $11_1 >>> 0) | 0;
                $6_1 = $7_1 + $11_1 | 0;
                $1_1 = $6_1 >>> 0 < $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
                $5_1 = $6_1 - 2 | 0;
                HEAP32[$2_1 + 336 >> 2] = $5_1 & $4_1;
                $11_1 = $1_1 - ($6_1 >>> 0 < 2) | 0;
                HEAP32[$2_1 + 340 >> 2] = $11_1 & $4_1;
                $24_1 = ($1_1 | 0) == ($14_1 | 0) & $6_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
                $1_1 = ($1_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 > $5_1 >>> 0 | $1_1 >>> 0 > $11_1 >>> 0;
                $2_1 = $24_1 + $1_1 | 0;
                $6_1 = $1_1 >>> 0 > $2_1 >>> 0;
                $1_1 = $2_1 - $21_1 | 0;
                HEAP32[$3_1 + 344 >> 2] = $1_1 - 2 & $4_1;
                HEAP32[$3_1 + 348 >> 2] = ($6_1 - (($2_1 >>> 0 < $21_1 >>> 0) + $18_1 | 0) | 0) - ($1_1 >>> 0 < 2) & $4_1;
                $2_1 = $3_1 + 288 | 0;
                $41($2_1, $8_1, $3_1 + 40 | 0);
                $1_1 = $3_1 + 160 | 0;
                $42($1_1, $13_1, $2_1, $9_1);
                $56($15_1, $1_1);
                if (HEAP32[$3_1 + 280 >> 2]) {
                  break label$12;
                }
                $35($12_1, $3_1 + 72 | 0);
                $1_1 = 1;
                break label$8;
              }
              HEAP8[$12_1 | 0] = 0;
              HEAP8[$12_1 + 1 | 0] = 0;
              HEAP8[$12_1 + 2 | 0] = 0;
              HEAP8[$12_1 + 3 | 0] = 0;
              HEAP8[$12_1 + 4 | 0] = 0;
              HEAP8[$12_1 + 5 | 0] = 0;
              HEAP8[$12_1 + 6 | 0] = 0;
              HEAP8[$12_1 + 7 | 0] = 0;
              $1_1 = $12_1 + 56 | 0;
              HEAP8[$1_1 | 0] = 0;
              HEAP8[$1_1 + 1 | 0] = 0;
              HEAP8[$1_1 + 2 | 0] = 0;
              HEAP8[$1_1 + 3 | 0] = 0;
              HEAP8[$1_1 + 4 | 0] = 0;
              HEAP8[$1_1 + 5 | 0] = 0;
              HEAP8[$1_1 + 6 | 0] = 0;
              HEAP8[$1_1 + 7 | 0] = 0;
              $1_1 = $12_1 + 48 | 0;
              HEAP8[$1_1 | 0] = 0;
              HEAP8[$1_1 + 1 | 0] = 0;
              HEAP8[$1_1 + 2 | 0] = 0;
              HEAP8[$1_1 + 3 | 0] = 0;
              HEAP8[$1_1 + 4 | 0] = 0;
              HEAP8[$1_1 + 5 | 0] = 0;
              HEAP8[$1_1 + 6 | 0] = 0;
              HEAP8[$1_1 + 7 | 0] = 0;
              $1_1 = $12_1 + 40 | 0;
              HEAP8[$1_1 | 0] = 0;
              HEAP8[$1_1 + 1 | 0] = 0;
              HEAP8[$1_1 + 2 | 0] = 0;
              HEAP8[$1_1 + 3 | 0] = 0;
              HEAP8[$1_1 + 4 | 0] = 0;
              HEAP8[$1_1 + 5 | 0] = 0;
              HEAP8[$1_1 + 6 | 0] = 0;
              HEAP8[$1_1 + 7 | 0] = 0;
              $1_1 = $12_1 + 32 | 0;
              HEAP8[$1_1 | 0] = 0;
              HEAP8[$1_1 + 1 | 0] = 0;
              HEAP8[$1_1 + 2 | 0] = 0;
              HEAP8[$1_1 + 3 | 0] = 0;
              HEAP8[$1_1 + 4 | 0] = 0;
              HEAP8[$1_1 + 5 | 0] = 0;
              HEAP8[$1_1 + 6 | 0] = 0;
              HEAP8[$1_1 + 7 | 0] = 0;
              $1_1 = $12_1 + 24 | 0;
              HEAP8[$1_1 | 0] = 0;
              HEAP8[$1_1 + 1 | 0] = 0;
              HEAP8[$1_1 + 2 | 0] = 0;
              HEAP8[$1_1 + 3 | 0] = 0;
              HEAP8[$1_1 + 4 | 0] = 0;
              HEAP8[$1_1 + 5 | 0] = 0;
              HEAP8[$1_1 + 6 | 0] = 0;
              HEAP8[$1_1 + 7 | 0] = 0;
              $1_1 = $12_1 + 16 | 0;
              HEAP8[$1_1 | 0] = 0;
              HEAP8[$1_1 + 1 | 0] = 0;
              HEAP8[$1_1 + 2 | 0] = 0;
              HEAP8[$1_1 + 3 | 0] = 0;
              HEAP8[$1_1 + 4 | 0] = 0;
              HEAP8[$1_1 + 5 | 0] = 0;
              HEAP8[$1_1 + 6 | 0] = 0;
              HEAP8[$1_1 + 7 | 0] = 0;
              $1_1 = $12_1 + 8 | 0;
              HEAP8[$1_1 | 0] = 0;
              HEAP8[$1_1 + 1 | 0] = 0;
              HEAP8[$1_1 + 2 | 0] = 0;
              HEAP8[$1_1 + 3 | 0] = 0;
              HEAP8[$1_1 + 4 | 0] = 0;
              HEAP8[$1_1 + 5 | 0] = 0;
              HEAP8[$1_1 + 6 | 0] = 0;
              HEAP8[$1_1 + 7 | 0] = 0;
            }
            $1_1 = 0;
          }
          global$0 = $3_1 + 640 | 0;
          if (!$1_1) {
            break label$6;
          }
          HEAP32[$10_1 + 144 >> 2] = $0_1;
          $0_1 = $36(HEAP32[172688], $10_1 + 144 | 0, $10_1 + 80 | 0, ($0_1 | 0) == 33 ? 258 : 2);
          HEAP32[$10_1 + 148 >> 2] = $0_1;
          if (($0_1 | 0) != 1) {
            break label$5;
          }
          $25_1 = 1;
        }
        global$0 = $10_1 + 176 | 0;
        return $25_1 | 0;
      }
      HEAP32[$10_1 + 160 >> 2] = 0;
      $5($10_1 + 152 | 0);
      wasm2js_trap();
    }
    function $26() {
      var $0_1 = 0, $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0;
      $3_1 = global$0 - 192 | 0;
      global$0 = $3_1;
      $0_1 = $3_1 + 128 | 0;
      $2_1 = $0_1 + 56 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $0_1 + 48 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $0_1 + 40 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $0_1 + 32 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $0_1 + 24 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $0_1 + 16 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $0_1 + 8 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      HEAP32[$3_1 + 128 >> 2] = 0;
      HEAP32[$3_1 + 132 >> 2] = 0;
      label$1: {
        if (($57(HEAP32[172688], $0_1, 690885) | 0) == 1) {
          $2_1 = $3_1 + 128 | 0;
          $0_1 = $2_1 + 15 | 0;
          $6_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $4_1 = $3_1 - -64 | 0;
          $5_1 = $4_1 + 8 | 0;
          HEAP32[$5_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$5_1 + 4 >> 2] = $6_1;
          $0_1 = $2_1 + 23 | 0;
          $1_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $6_1 = $4_1 + 16 | 0;
          HEAP32[$6_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$6_1 + 4 >> 2] = $1_1;
          $0_1 = $2_1 + 31 | 0;
          $9_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $1_1 = $4_1 + 24 | 0;
          HEAP32[$1_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$1_1 + 4 >> 2] = $9_1;
          $0_1 = $2_1 + 39 | 0;
          $7_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $9_1 = $4_1 + 32 | 0;
          HEAP32[$9_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$9_1 + 4 >> 2] = $7_1;
          $0_1 = $2_1 + 47 | 0;
          $11_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $7_1 = $4_1 + 40 | 0;
          HEAP32[$7_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$7_1 + 4 >> 2] = $11_1;
          $0_1 = $2_1 + 55 | 0;
          $10_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $11_1 = $4_1 + 48 | 0;
          HEAP32[$11_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$11_1 + 4 >> 2] = $10_1;
          $0_1 = $4_1 + 56 | 0;
          HEAP8[$0_1 | 0] = HEAPU8[$2_1 + 63 | 0];
          HEAP8[$3_1 + 2 | 0] = HEAPU8[$3_1 + 130 | 0];
          HEAP16[$3_1 >> 1] = HEAPU16[$3_1 + 128 >> 1];
          $2_1 = HEAPU8[$3_1 + 139 | 0] | HEAPU8[$3_1 + 140 | 0] << 8 | (HEAPU8[$3_1 + 141 | 0] << 16 | HEAPU8[$3_1 + 142 | 0] << 24);
          HEAP32[$3_1 + 64 >> 2] = HEAPU8[$3_1 + 135 | 0] | HEAPU8[$3_1 + 136 | 0] << 8 | (HEAPU8[$3_1 + 137 | 0] << 16 | HEAPU8[$3_1 + 138 | 0] << 24);
          HEAP32[$3_1 + 68 >> 2] = $2_1;
          $2_1 = HEAPU8[$3_1 + 131 | 0] | HEAPU8[$3_1 + 132 | 0] << 8 | (HEAPU8[$3_1 + 133 | 0] << 16 | HEAPU8[$3_1 + 134 | 0] << 24);
          HEAP8[$3_1 + 63 | 0] = HEAPU8[$0_1 | 0];
          $4_1 = HEAP32[$11_1 + 4 >> 2];
          $0_1 = $3_1 + 55 | 0;
          $11_1 = HEAP32[$11_1 >> 2];
          HEAP8[$0_1 | 0] = $11_1;
          HEAP8[$0_1 + 1 | 0] = $11_1 >>> 8;
          HEAP8[$0_1 + 2 | 0] = $11_1 >>> 16;
          HEAP8[$0_1 + 3 | 0] = $11_1 >>> 24;
          HEAP8[$0_1 + 4 | 0] = $4_1;
          HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$7_1 + 4 >> 2];
          $0_1 = $3_1 + 47 | 0;
          $7_1 = HEAP32[$7_1 >> 2];
          HEAP8[$0_1 | 0] = $7_1;
          HEAP8[$0_1 + 1 | 0] = $7_1 >>> 8;
          HEAP8[$0_1 + 2 | 0] = $7_1 >>> 16;
          HEAP8[$0_1 + 3 | 0] = $7_1 >>> 24;
          HEAP8[$0_1 + 4 | 0] = $4_1;
          HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$9_1 + 4 >> 2];
          $0_1 = $3_1 + 39 | 0;
          $9_1 = HEAP32[$9_1 >> 2];
          HEAP8[$0_1 | 0] = $9_1;
          HEAP8[$0_1 + 1 | 0] = $9_1 >>> 8;
          HEAP8[$0_1 + 2 | 0] = $9_1 >>> 16;
          HEAP8[$0_1 + 3 | 0] = $9_1 >>> 24;
          HEAP8[$0_1 + 4 | 0] = $4_1;
          HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$1_1 + 4 >> 2];
          $0_1 = $3_1 + 31 | 0;
          $1_1 = HEAP32[$1_1 >> 2];
          HEAP8[$0_1 | 0] = $1_1;
          HEAP8[$0_1 + 1 | 0] = $1_1 >>> 8;
          HEAP8[$0_1 + 2 | 0] = $1_1 >>> 16;
          HEAP8[$0_1 + 3 | 0] = $1_1 >>> 24;
          HEAP8[$0_1 + 4 | 0] = $4_1;
          HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$6_1 + 4 >> 2];
          $0_1 = $3_1 + 23 | 0;
          $6_1 = HEAP32[$6_1 >> 2];
          HEAP8[$0_1 | 0] = $6_1;
          HEAP8[$0_1 + 1 | 0] = $6_1 >>> 8;
          HEAP8[$0_1 + 2 | 0] = $6_1 >>> 16;
          HEAP8[$0_1 + 3 | 0] = $6_1 >>> 24;
          HEAP8[$0_1 + 4 | 0] = $4_1;
          HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
          $4_1 = HEAP32[$5_1 + 4 >> 2];
          $0_1 = $3_1 + 15 | 0;
          $5_1 = HEAP32[$5_1 >> 2];
          HEAP8[$0_1 | 0] = $5_1;
          HEAP8[$0_1 + 1 | 0] = $5_1 >>> 8;
          HEAP8[$0_1 + 2 | 0] = $5_1 >>> 16;
          HEAP8[$0_1 + 3 | 0] = $5_1 >>> 24;
          HEAP8[$0_1 + 4 | 0] = $4_1;
          HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
          HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
          HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
          HEAP8[$3_1 + 3 | 0] = $2_1;
          HEAP8[$3_1 + 4 | 0] = $2_1 >>> 8;
          HEAP8[$3_1 + 5 | 0] = $2_1 >>> 16;
          HEAP8[$3_1 + 6 | 0] = $2_1 >>> 24;
          $0_1 = HEAP32[$3_1 + 68 >> 2];
          $2_1 = HEAP32[$3_1 + 64 >> 2];
          HEAP8[$3_1 + 7 | 0] = $2_1;
          HEAP8[$3_1 + 8 | 0] = $2_1 >>> 8;
          HEAP8[$3_1 + 9 | 0] = $2_1 >>> 16;
          HEAP8[$3_1 + 10 | 0] = $2_1 >>> 24;
          HEAP8[$3_1 + 11 | 0] = $0_1;
          HEAP8[$3_1 + 12 | 0] = $0_1 >>> 8;
          HEAP8[$3_1 + 13 | 0] = $0_1 >>> 16;
          HEAP8[$3_1 + 14 | 0] = $0_1 >>> 24;
          $16_1 = $6();
          $1_1 = global$0 - 496 | 0;
          global$0 = $1_1;
          label$3: {
            if (!$3_1) {
              FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](689638, HEAP32[$16_1 + 172 >> 2]);
              break label$3;
            }
            if (!$32($1_1 + 136 | 0, 690981)) {
              break label$3;
            }
            $38($1_1 + 464 | 0, 691013, $1_1 + 12 | 0);
            if (HEAP32[$1_1 + 12 >> 2]) {
              break label$3;
            }
            $2_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
            $6_1 = $2_1;
            $10_1 = $2_1 >>> 20 | 0;
            $5_1 = $10_1;
            $0_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
            $12_1 = $0_1;
            $22_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
            $2_1 = $22_1;
            $0_1 = $0_1 << 12 | $2_1 >>> 20;
            $17_1 = $2_1 << 12;
            $23_1 = $5_1 | $17_1 & -4096;
            $11_1 = $0_1;
            $24_1 = $0_1 & 1048575;
            $25_1 = $12_1 >>> 8 | 0;
            $9_1 = $25_1;
            $0_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
            $7_1 = $0_1;
            $20_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
            $2_1 = $20_1;
            $0_1 = $0_1 << 24 | $2_1 >>> 8;
            $26_1 = $9_1 | $2_1 << 24 & -16777216;
            $2_1 = $0_1;
            $27_1 = $0_1 & 1048575;
            $5_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
            $9_1 = $5_1;
            $14_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
            $18_1 = ($5_1 & 65535) << 16 | $14_1 >>> 16;
            $15_1 = $5_1 >>> 16 | 0;
            $5_1 = $7_1 >>> 28 | 0;
            $8_1 = ($7_1 & 268435455) << 4 | $20_1 >>> 28;
            $19_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
            $4_1 = $14_1;
            $0_1 = $4_1 << 4;
            $28_1 = $5_1 | $0_1 & 1048560;
            $13_1 = $6_1 & 1048575;
            if (!($8_1 | ($26_1 | ($18_1 | ($19_1 | $23_1))) | ($28_1 | ($27_1 | ($15_1 | ($13_1 | $24_1)))))) {
              FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](690116, HEAP32[$16_1 + 172 >> 2]);
              break label$3;
            }
            $14_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
            $16_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
            $21_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
            $30_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
            $31_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
            $32_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
            $33_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
            $29_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
            HEAP8[$1_1 + 34 | 0] = $25_1;
            HEAP8[$1_1 + 21 | 0] = $18_1;
            HEAP8[$1_1 + 38 | 0] = ($11_1 & 1048575) << 12 | $17_1 >>> 20;
            HEAP8[$1_1 + 37 | 0] = ($11_1 & 268435455) << 4 | $17_1 >>> 28;
            HEAP8[$1_1 + 36 | 0] = $11_1 >>> 4;
            HEAP8[$1_1 + 35 | 0] = $11_1 >>> 12;
            HEAP8[$1_1 + 30 | 0] = $2_1;
            HEAP8[$1_1 + 29 | 0] = $2_1 >>> 8;
            HEAP8[$1_1 + 22 | 0] = $0_1 >>> 12;
            HEAP8[$1_1 + 47 | 0] = $19_1;
            HEAP8[$1_1 + 46 | 0] = ($6_1 & 255) << 24 | $19_1 >>> 8;
            HEAP8[$1_1 + 45 | 0] = ($6_1 & 65535) << 16 | $19_1 >>> 16;
            HEAP8[$1_1 + 44 | 0] = ($6_1 & 16777215) << 8 | $19_1 >>> 24;
            HEAP8[$1_1 + 43 | 0] = $6_1;
            HEAP8[$1_1 + 42 | 0] = $6_1 >>> 8;
            HEAP8[$1_1 + 41 | 0] = $10_1 << 4 | $13_1 >>> 16;
            HEAP8[$1_1 + 40 | 0] = $6_1 >>> 24;
            HEAP8[$1_1 + 39 | 0] = $22_1;
            HEAP8[$1_1 + 33 | 0] = $12_1 >>> 16;
            HEAP8[$1_1 + 32 | 0] = $12_1 >>> 24;
            HEAP8[$1_1 + 31 | 0] = $20_1;
            $0_1 = $7_1;
            HEAP8[$1_1 + 27 | 0] = $0_1;
            HEAP8[$1_1 + 26 | 0] = $0_1 >>> 8;
            HEAP8[$1_1 + 25 | 0] = $0_1 >>> 16;
            HEAP8[$1_1 + 24 | 0] = $0_1 >>> 24;
            HEAP8[$1_1 + 23 | 0] = $4_1;
            $0_1 = $9_1;
            HEAP8[$1_1 + 20 | 0] = ($0_1 & 16777215) << 8 | $4_1 >>> 24;
            HEAP8[$1_1 + 19 | 0] = $0_1;
            HEAP8[$1_1 + 18 | 0] = $0_1 >>> 8;
            HEAP8[$1_1 + 17 | 0] = $0_1 >>> 16;
            HEAP8[$1_1 + 16 | 0] = $0_1 >>> 24;
            HEAP8[$1_1 + 28 | 0] = $2_1 >>> 16 & 15 | $8_1 << 4;
            HEAP32[$1_1 + 400 >> 2] = 64;
            HEAP32[$1_1 + 404 >> 2] = 0;
            HEAP32[$1_1 + 328 >> 2] = -1862921884;
            HEAP32[$1_1 + 332 >> 2] = 870954602;
            HEAP32[$1_1 + 320 >> 2] = -1748470448;
            HEAP32[$1_1 + 324 >> 2] = 3983205;
            HEAP32[$1_1 + 312 >> 2] = 292000018;
            HEAP32[$1_1 + 316 >> 2] = -782074353;
            HEAP32[$1_1 + 304 >> 2] = -1662207471;
            HEAP32[$1_1 + 308 >> 2] = 596792193;
            $6_1 = $1_1 + 304 | 0;
            $29($6_1, 690981, 32);
            $29($6_1, $1_1 + 16 | 0, 32);
            $29($6_1, 655649, 32);
            $7_1 = $1_1 + 48 | 0;
            $30($6_1, $7_1);
            $17_1 = $1_1 + 432 | 0;
            $38($17_1, $7_1, 0);
            $2_1 = $16_1;
            $0_1 = $2_1 >>> 16 | 0;
            $9_1 = $1_1 + 176 | 0;
            $4_1 = $9_1 + 72 | 0;
            HEAP32[$4_1 >> 2] = ($2_1 & 65535) << 16 | $14_1 >>> 16;
            HEAP32[$4_1 + 4 >> 2] = $0_1;
            $5_1 = $14_1 << 4 & 1048560;
            $2_1 = $30_1;
            $0_1 = $2_1 >>> 28 | 0;
            $4_1 = $9_1 - -64 | 0;
            HEAP32[$4_1 >> 2] = ($2_1 & 268435455) << 4 | $21_1 >>> 28;
            HEAP32[$4_1 + 4 >> 2] = $0_1 | $5_1;
            $0_1 = $2_1 << 24 | $21_1 >>> 8;
            $4_1 = $9_1 + 56 | 0;
            $2_1 = $32_1;
            HEAP32[$4_1 >> 2] = $21_1 << 24 & -16777216 | $2_1 >>> 8;
            HEAP32[$4_1 + 4 >> 2] = $0_1 & 1048575;
            $0_1 = $2_1 << 12;
            $2_1 = $31_1;
            $5_1 = ($0_1 | $2_1 >>> 20) & 1048575;
            $4_1 = $9_1 + 48 | 0;
            HEAP32[$4_1 >> 2] = $2_1 << 12 & -4096 | $29_1 >>> 20;
            HEAP32[$4_1 + 4 >> 2] = $5_1;
            HEAP32[$1_1 + 296 >> 2] = 0;
            HEAP32[$1_1 + 256 >> 2] = 1;
            HEAP32[$1_1 + 260 >> 2] = 0;
            HEAP32[$1_1 + 216 >> 2] = $33_1;
            HEAP32[$1_1 + 220 >> 2] = $29_1 & 1048575;
            HEAP32[$1_1 + 208 >> 2] = $18_1;
            HEAP32[$1_1 + 212 >> 2] = $15_1;
            HEAP32[$1_1 + 200 >> 2] = $8_1;
            HEAP32[$1_1 + 204 >> 2] = $28_1;
            HEAP32[$1_1 + 192 >> 2] = $26_1;
            HEAP32[$1_1 + 196 >> 2] = $27_1;
            HEAP32[$1_1 + 184 >> 2] = $23_1;
            HEAP32[$1_1 + 188 >> 2] = $24_1;
            HEAP32[$1_1 + 176 >> 2] = $19_1;
            HEAP32[$1_1 + 180 >> 2] = $13_1;
            $11_1 = HEAP32[$1_1 + 456 >> 2];
            $13_1 = HEAP32[$1_1 + 448 >> 2];
            $12_1 = HEAP32[$1_1 + 440 >> 2];
            $0_1 = HEAP32[$1_1 + 432 >> 2];
            $18_1 = HEAP32[$1_1 + 460 >> 2];
            $14_1 = HEAP32[$1_1 + 452 >> 2];
            $8_1 = HEAP32[$1_1 + 444 >> 2];
            $2_1 = HEAP32[$1_1 + 436 >> 2];
            $4_1 = $11_1 | ($13_1 | ($12_1 | $0_1)) | ($18_1 | ($14_1 | ($8_1 | $2_1))) ? -1 : 0;
            $0_1 = $0_1 ^ -1;
            $15_1 = $0_1 - 801750718 | 0;
            HEAP32[$1_1 + 432 >> 2] = $4_1 & $15_1;
            $5_1 = $2_1 ^ -1;
            $10_1 = $5_1 - (($0_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
            HEAP32[$1_1 + 436 >> 2] = $10_1 & $4_1;
            $0_1 = ($5_1 | 0) == ($10_1 | 0) & $0_1 >>> 0 > $15_1 >>> 0 | $5_1 >>> 0 > $10_1 >>> 0;
            $10_1 = $12_1 ^ -1;
            $5_1 = $0_1 + $10_1 | 0;
            $12_1 = $8_1 ^ -1;
            $0_1 = $12_1;
            $15_1 = $5_1 - 1354194885 | 0;
            HEAP32[$1_1 + 440 >> 2] = $15_1 & $4_1;
            $0_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $8_1 = $0_1 - (($5_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
            HEAP32[$1_1 + 444 >> 2] = $8_1 & $4_1;
            $16_1 = $13_1 ^ -1;
            $2_1 = ($0_1 | 0) == ($12_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
            $10_1 = ($0_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $15_1 >>> 0 | $0_1 >>> 0 > $8_1 >>> 0;
            $5_1 = $2_1 + $10_1 | 0;
            $13_1 = $14_1 ^ -1;
            $0_1 = $13_1 + ($5_1 >>> 0 < $10_1 >>> 0) | 0;
            $2_1 = $5_1;
            $5_1 = $5_1 + $16_1 | 0;
            $0_1 = $2_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $12_1 = $5_1 - 2 | 0;
            HEAP32[$1_1 + 448 >> 2] = $12_1 & $4_1;
            $10_1 = $0_1 - ($5_1 >>> 0 < 2) | 0;
            HEAP32[$1_1 + 452 >> 2] = $10_1 & $4_1;
            $2_1 = ($0_1 | 0) == ($13_1 | 0) & $5_1 >>> 0 < $16_1 >>> 0 | $0_1 >>> 0 < $13_1 >>> 0;
            $5_1 = ($0_1 | 0) == ($10_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $0_1 >>> 0 > $10_1 >>> 0;
            $2_1 = $2_1 + $5_1 | 0;
            $0_1 = $2_1 >>> 0 < $5_1 >>> 0;
            $5_1 = $2_1 - $11_1 | 0;
            HEAP32[$1_1 + 456 >> 2] = $5_1 - 2 & $4_1;
            HEAP32[$1_1 + 460 >> 2] = ($0_1 - (($2_1 >>> 0 < $11_1 >>> 0) + $18_1 | 0) | 0) - ($5_1 >>> 0 < 2) & $4_1;
            $0_1 = $1_1 + 288 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $1_1 + 280 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $1_1 + 272 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $1_1 + 264 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $42($6_1, $9_1, $17_1, $1_1 + 464 | 0);
            $56($7_1, $6_1);
            if (HEAP32[$1_1 + 128 >> 2]) {
              break label$3;
            }
            $5_1 = HEAP32[$1_1 + 92 >> 2];
            $4_1 = $1_1 + 48 | 0;
            $0_1 = $4_1 + 72 | 0;
            $8_1 = HEAP32[$0_1 >> 2];
            $6_1 = HEAP32[$0_1 + 4 >> 2];
            $13_1 = $6_1;
            $0_1 = HEAP32[$1_1 + 88 >> 2];
            $2_1 = __wasm_i64_mul($6_1 >>> 16 | 0, 0, 977, 1);
            $9_1 = $0_1 + $2_1 | 0;
            $0_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
            $7_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $0_1 = $4_1 + 48 | 0;
            $5_1 = HEAP32[$0_1 >> 2];
            $0_1 = HEAP32[$0_1 + 4 >> 2];
            $2_1 = $7_1 >>> 20 | 0;
            $6_1 = $2_1;
            $2_1 = $2_1 + $5_1 | 0;
            $6_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $11_1 = $6_1 & 1048575;
            $0_1 = $4_1 - -64 | 0;
            $10_1 = HEAP32[$0_1 >> 2];
            $14_1 = HEAP32[$0_1 + 4 >> 2];
            $0_1 = $4_1 + 56 | 0;
            $5_1 = HEAP32[$0_1 >> 2];
            $0_1 = HEAP32[$0_1 + 4 >> 2];
            $4_1 = $6_1 >>> 20 | 0;
            $5_1 = $4_1 + $5_1 | 0;
            $12_1 = $4_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $0_1 = $14_1;
            $4_1 = $12_1 >>> 20 | 0;
            $14_1 = $4_1;
            $4_1 = $4_1 + $10_1 | 0;
            $0_1 = $14_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $10_1 = $0_1 & 1048575;
            $12_1 = $12_1 & 1048575;
            $14_1 = ($2_1 & $5_1 & $4_1) == -1 & ($6_1 & $12_1 & $0_1) == 1048575;
            $6_1 = $0_1;
            $0_1 = $13_1 & 65535;
            $6_1 = $6_1 >>> 20 | 0;
            $8_1 = $6_1 + $8_1 | 0;
            $6_1 = $6_1 >>> 0 > $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $0_1 = $7_1 & 1048575;
            $13_1 = $0_1;
            $7_1 = $8_1;
            if ($14_1 & (($7_1 | 0) == -1 & ($6_1 | 0) == 65535) & (($0_1 | 0) == 1048574 & $9_1 >>> 0 > 4294966318 | $0_1 >>> 0 > 1048574) | $6_1 >>> 16) {
              $0_1 = $13_1 + 1 | 0;
              $9_1 = $9_1 + 977 | 0;
              $0_1 = $9_1 >>> 0 < 977 ? $0_1 + 1 | 0 : $0_1;
              $13_1 = $0_1 & 1048575;
              $8_1 = $0_1;
              $0_1 = $11_1;
              $8_1 = $8_1 >>> 20 | 0;
              $2_1 = $2_1 + $8_1 | 0;
              $0_1 = $8_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $11_1 = $0_1 & 1048575;
              $8_1 = $0_1;
              $0_1 = $12_1;
              $8_1 = $8_1 >>> 20 | 0;
              $5_1 = $5_1 + $8_1 | 0;
              $0_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $12_1 = $0_1 & 1048575;
              $8_1 = $0_1;
              $0_1 = $10_1;
              $8_1 = $8_1 >>> 20 | 0;
              $4_1 = $4_1 + $8_1 | 0;
              $0_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $10_1 = $0_1 & 1048575;
              $8_1 = $0_1;
              $0_1 = $6_1;
              $6_1 = $7_1;
              $7_1 = ($8_1 >>> 20 | 0) + $7_1 | 0;
              $6_1 = ($6_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) & 65535;
            }
            HEAP32[$1_1 + 120 >> 2] = $7_1;
            HEAP32[$1_1 + 124 >> 2] = $6_1;
            HEAP32[$1_1 + 112 >> 2] = $4_1;
            HEAP32[$1_1 + 116 >> 2] = $10_1;
            HEAP32[$1_1 + 104 >> 2] = $5_1;
            HEAP32[$1_1 + 108 >> 2] = $12_1;
            HEAP32[$1_1 + 96 >> 2] = $2_1;
            HEAP32[$1_1 + 100 >> 2] = $11_1;
            HEAP32[$1_1 + 88 >> 2] = $9_1;
            HEAP32[$1_1 + 92 >> 2] = $13_1;
            if ($9_1 & 1) {
              break label$3;
            }
            $0_1 = HEAP32[$1_1 + 48 >> 2];
            $2_1 = HEAP32[$1_1 + 136 >> 2];
            $4_1 = $0_1 - $2_1 | 0;
            $6_1 = HEAP32[$1_1 + 52 >> 2] - (HEAP32[$1_1 + 140 >> 2] + ($0_1 >>> 0 < $2_1 >>> 0) | 0) | 0;
            $0_1 = HEAP32[$1_1 + 80 >> 2];
            $5_1 = HEAP32[$1_1 + 168 >> 2];
            $2_1 = ($0_1 - $5_1 | 0) - 4 | 0;
            $0_1 = (HEAP32[$1_1 + 84 >> 2] - (HEAP32[$1_1 + 172 >> 2] + ($0_1 >>> 0 < $5_1 >>> 0) | 0) | 0) + 262143 | 0;
            $5_1 = $2_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
            $9_1 = __wasm_i64_mul($5_1 >>> 16 | 0, 0, 977, 1);
            $4_1 = $9_1 + $4_1 | 0;
            $0_1 = $6_1 + i64toi32_i32$HIGH_BITS | 0;
            $0_1 = ($4_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194299 | 0;
            $4_1 = $4_1 - 3908 | 0;
            $0_1 = $4_1 >>> 0 < 4294963388 ? $0_1 + 1 | 0 : $0_1;
            $6_1 = $0_1 & 1048575;
            $13_1 = $6_1;
            $12_1 = $4_1 ^ 976;
            $14_1 = $6_1 ^ 1;
            if ((($12_1 | 0) != -1 | ($14_1 | 0) != 1048575) & ($4_1 | $6_1) != 0) {
              break label$3;
            }
            $10_1 = $2_1;
            $18_1 = $5_1 & 65535;
            $2_1 = HEAP32[$1_1 + 72 >> 2];
            $5_1 = HEAP32[$1_1 + 160 >> 2];
            $11_1 = $2_1 - $5_1 | 0;
            $8_1 = HEAP32[$1_1 + 76 >> 2] - (HEAP32[$1_1 + 164 >> 2] + ($2_1 >>> 0 < $5_1 >>> 0) | 0) | 0;
            $2_1 = HEAP32[$1_1 + 64 >> 2];
            $5_1 = HEAP32[$1_1 + 152 >> 2];
            $9_1 = $2_1 - $5_1 | 0;
            $7_1 = HEAP32[$1_1 + 68 >> 2] - (HEAP32[$1_1 + 156 >> 2] + ($2_1 >>> 0 < $5_1 >>> 0) | 0) | 0;
            $2_1 = $0_1 >>> 20 | 0;
            $17_1 = HEAP32[$1_1 + 144 >> 2];
            $15_1 = $2_1 - $17_1 | 0;
            $5_1 = $15_1 + HEAP32[$1_1 + 56 >> 2] | 0;
            $0_1 = HEAP32[$1_1 + 60 >> 2] - (HEAP32[$1_1 + 148 >> 2] + ($2_1 >>> 0 < $17_1 >>> 0) | 0) | 0;
            $0_1 = ($5_1 >>> 0 < $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194303 | 0;
            $2_1 = $5_1 - 4 | 0;
            $5_1 = $2_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
            $0_1 = $7_1;
            $6_1 = $5_1 >>> 20 | 0;
            $7_1 = $6_1;
            $6_1 = $6_1 + $9_1 | 0;
            $0_1 = ($7_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194303 | 0;
            $6_1 = $6_1 - 4 | 0;
            $9_1 = $6_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
            $0_1 = $8_1;
            $7_1 = $9_1 >>> 20 | 0;
            $8_1 = $7_1;
            $7_1 = $7_1 + $11_1 | 0;
            $0_1 = ($8_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194303 | 0;
            $7_1 = $7_1 - 4 | 0;
            $11_1 = $7_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
            $0_1 = $18_1;
            $8_1 = $11_1 >>> 20 | 0;
            $10_1 = $8_1 + $10_1 | 0;
            $0_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            if (($2_1 & $12_1 & $6_1 & $7_1 & $10_1) == -1) {
              $8_1 = ($5_1 & $14_1 & $9_1 & $11_1 & ($0_1 ^ 983040)) == 1048575;
            } else {
              $8_1 = 0;
            }
            if ($8_1) {
              $2_1 = 0;
              $0_1 = 0;
            } else {
              $2_1 = $7_1 | ($6_1 | ($2_1 | $4_1)) | $10_1;
              $0_1 = $11_1 & 1048575 | ($9_1 & 1048575 | ($5_1 & 1048575 | $13_1)) | $0_1;
            }
            $34_1 = !($0_1 | $2_1);
          }
          global$0 = $1_1 + 496 | 0;
          break label$1;
        }
        fimport$1(1);
      }
      global$0 = $3_1 + 192 | 0;
      return $34_1 | 0;
    }
    function $27($0_1, $1_1, $2_1, $3_1, $4_1) {
      var $5_1 = 0;
      label$1: {
        label$2: {
          if (($2_1 | 0) != 1114112) {
            $5_1 = 1;
            if (FUNCTION_TABLE[HEAP32[$1_1 + 16 >> 2]]($0_1, $2_1) | 0) {
              break label$2;
            }
          }
          if ($3_1) {
            break label$1;
          }
          $5_1 = 0;
        }
        return $5_1;
      }
      return FUNCTION_TABLE[HEAP32[$1_1 + 12 >> 2]]($0_1, $3_1, $4_1) | 0;
    }
    function $28($0_1, $1_1) {
      $0_1 = $0_1 | 0;
      $1_1 = $1_1 | 0;
      var $2_1 = 0;
      if (HEAPU8[$0_1 | 0]) {
        $1_1 = $0_1 + 1 | 0;
        $0_1 = 0;
        while (1) {
          $2_1 = $0_1 + $1_1 | 0;
          $0_1 = $0_1 + 1 | 0;
          if (HEAPU8[$2_1 | 0]) {
            continue;
          }
          break;
        }
        ;
      }
      wasm2js_trap();
    }
    function $29($0_1, $1_1, $2_1) {
      var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0, $51_1 = 0, $52_1 = 0, $53_1 = 0, $54_1 = 0, $55_1 = 0, $56_1 = 0, $57_1 = 0, $58_1 = 0, $59_1 = 0, $60_1 = 0, $61_1 = 0, $62_1 = 0, $63_1 = 0, $64_1 = 0, $65_1 = 0, $66_1 = 0, $67_1 = 0, $68_1 = 0, $69_1 = 0, $70_1 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;
      $3_1 = HEAP32[$0_1 + 100 >> 2];
      $4_1 = HEAP32[$0_1 + 96 >> 2];
      $7_1 = $4_1 + $2_1 | 0;
      $3_1 = $7_1 >>> 0 < $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$0_1 + 96 >> 2] = $7_1;
      HEAP32[$0_1 + 100 >> 2] = $3_1;
      $3_1 = $4_1 & 63;
      $61_1 = 64 - $3_1 | 0;
      if ($61_1 >>> 0 <= $2_1 >>> 0) {
        $74 = $0_1 + 32 | 0;
        while (1) {
          $70($3_1 + $74 | 0, $1_1, $61_1);
          $4_1 = HEAPU8[$0_1 + 67 | 0];
          $3_1 = HEAPU8[$0_1 + 65 | 0] << 16 | HEAPU8[$0_1 + 64 | 0] << 24;
          $38_1 = $4_1 | ($3_1 | HEAPU8[$0_1 + 66 | 0] << 8);
          $9_1 = HEAPU8[$0_1 + 39 | 0];
          $7_1 = HEAPU8[$0_1 + 37 | 0] << 16 | HEAPU8[$0_1 + 36 | 0] << 24;
          $11_1 = $9_1 | ($7_1 | HEAPU8[$0_1 + 38 | 0] << 8);
          $22_1 = HEAPU8[$0_1 + 59 | 0];
          $23_1 = HEAPU8[$0_1 + 57 | 0] << 16 | HEAPU8[$0_1 + 56 | 0] << 24;
          $20_1 = $22_1 | ($23_1 | HEAPU8[$0_1 + 58 | 0] << 8);
          $6_1 = HEAPU8[$0_1 + 51 | 0];
          $17_1 = HEAPU8[$0_1 + 49 | 0] << 16 | HEAPU8[$0_1 + 48 | 0] << 24;
          $14_1 = $6_1 | ($17_1 | HEAPU8[$0_1 + 50 | 0] << 8);
          $12_1 = HEAPU8[$0_1 + 43 | 0];
          $10_1 = HEAPU8[$0_1 + 41 | 0] << 16 | HEAPU8[$0_1 + 40 | 0] << 24;
          $13_1 = $12_1 | ($10_1 | HEAPU8[$0_1 + 42 | 0] << 8);
          $59_1 = ($4_1 << 25 | $38_1 >>> 7) ^ ($38_1 << 14 | $3_1 >>> 18) ^ $38_1 >>> 3;
          $15_1 = HEAPU8[$0_1 + 63 | 0];
          $4_1 = HEAPU8[$0_1 + 61 | 0] << 16 | HEAPU8[$0_1 + 60 | 0] << 24;
          $21_1 = $15_1 | ($4_1 | HEAPU8[$0_1 + 62 | 0] << 8);
          $19_1 = HEAPU8[$0_1 + 71 | 0];
          $16_1 = HEAPU8[$0_1 + 69 | 0] << 16 | HEAPU8[$0_1 + 68 | 0] << 24;
          $43_1 = $19_1 | ($16_1 | HEAPU8[$0_1 + 70 | 0] << 8);
          $3_1 = HEAPU8[$0_1 + 32 | 0] | HEAPU8[$0_1 + 33 | 0] << 8 | (HEAPU8[$0_1 + 34 | 0] << 16 | HEAPU8[$0_1 + 35 | 0] << 24);
          $52_1 = $3_1 << 8 & 16711680 | $3_1 << 24 | ($3_1 >>> 8 & 65280 | $3_1 >>> 24);
          $8_1 = $43_1 + ($52_1 + (($9_1 << 25 | $11_1 >>> 7) ^ ($11_1 << 14 | $7_1 >>> 18) ^ $11_1 >>> 3) | 0) | 0;
          $7_1 = HEAPU8[$0_1 + 89 | 0] << 16 | HEAPU8[$0_1 + 88 | 0] << 24;
          $3_1 = $7_1 | HEAPU8[$0_1 + 90 | 0] << 8;
          $24_1 = HEAPU8[$0_1 + 91 | 0];
          $26_1 = $3_1 | $24_1;
          $5_1 = $8_1 + (($26_1 << 15 | $7_1 >>> 17) ^ (($26_1 << 13 | $7_1 >>> 19) ^ $3_1 >>> 10)) | 0;
          $53_1 = ($22_1 << 25 | $20_1 >>> 7) ^ ($20_1 << 14 | $23_1 >>> 18) ^ $20_1 >>> 3;
          $22_1 = HEAPU8[$0_1 + 55 | 0];
          $23_1 = HEAPU8[$0_1 + 53 | 0] << 16 | HEAPU8[$0_1 + 52 | 0] << 24;
          $18_1 = $22_1 | ($23_1 | HEAPU8[$0_1 + 54 | 0] << 8);
          $33_1 = HEAPU8[$0_1 + 83 | 0];
          $28_1 = HEAPU8[$0_1 + 81 | 0] << 16 | HEAPU8[$0_1 + 80 | 0] << 24;
          $44_1 = $33_1 | ($28_1 | HEAPU8[$0_1 + 82 | 0] << 8);
          $8_1 = ($6_1 << 25 | $14_1 >>> 7) ^ ($14_1 << 14 | $17_1 >>> 18) ^ $14_1 >>> 3;
          $25_1 = HEAPU8[$0_1 + 47 | 0];
          $17_1 = HEAPU8[$0_1 + 45 | 0] << 16 | HEAPU8[$0_1 + 44 | 0] << 24;
          $54_1 = $25_1 | ($17_1 | HEAPU8[$0_1 + 46 | 0] << 8);
          $34_1 = HEAPU8[$0_1 + 75 | 0];
          $35_1 = HEAPU8[$0_1 + 73 | 0] << 16 | HEAPU8[$0_1 + 72 | 0] << 24;
          $45_1 = $34_1 | ($35_1 | HEAPU8[$0_1 + 74 | 0] << 8);
          $36_1 = HEAPU8[$0_1 + 95 | 0];
          $9_1 = HEAPU8[$0_1 + 93 | 0] << 16 | HEAPU8[$0_1 + 92 | 0] << 24;
          $3_1 = $9_1 | HEAPU8[$0_1 + 94 | 0] << 8;
          $27_1 = $36_1 | $3_1;
          $6_1 = ($45_1 + ((($12_1 << 25 | $13_1 >>> 7) ^ ($13_1 << 14 | $10_1 >>> 18) ^ $13_1 >>> 3) + $11_1 | 0) | 0) + (($27_1 << 15 | $9_1 >>> 17) ^ (($27_1 << 13 | $9_1 >>> 19) ^ $3_1 >>> 10)) | 0;
          $10_1 = ($44_1 + ($8_1 + $54_1 | 0) | 0) + (__wasm_rotl_i32($6_1, 15) ^ __wasm_rotl_i32($6_1, 13) ^ $6_1 >>> 10) | 0;
          $12_1 = (($53_1 + $18_1 | 0) + $26_1 | 0) + (__wasm_rotl_i32($10_1, 15) ^ __wasm_rotl_i32($10_1, 13) ^ $10_1 >>> 10) | 0;
          $3_1 = (($59_1 + $21_1 | 0) + $5_1 | 0) + (__wasm_rotl_i32($12_1, 15) ^ __wasm_rotl_i32($12_1, 13) ^ $12_1 >>> 10) | 0;
          $69_1 = ((($19_1 << 25 | $43_1 >>> 7) ^ ($43_1 << 14 | $16_1 >>> 18) ^ $43_1 >>> 3) + $38_1 | 0) + $6_1 | 0;
          $59_1 = ((($15_1 << 25 | $21_1 >>> 7) ^ ($21_1 << 14 | $4_1 >>> 18) ^ $21_1 >>> 3) + $20_1 | 0) + $27_1 | 0;
          $53_1 = (($22_1 << 25 | $18_1 >>> 7) ^ ($18_1 << 14 | $23_1 >>> 18) ^ $18_1 >>> 3) + $14_1 | 0;
          $22_1 = HEAPU8[$0_1 + 87 | 0];
          $23_1 = HEAPU8[$0_1 + 85 | 0] << 16 | HEAPU8[$0_1 + 84 | 0] << 24;
          $60_1 = $22_1 | ($23_1 | HEAPU8[$0_1 + 86 | 0] << 8);
          $8_1 = (($25_1 << 25 | $54_1 >>> 7) ^ ($54_1 << 14 | $17_1 >>> 18) ^ $54_1 >>> 3) + $13_1 | 0;
          $37_1 = HEAPU8[$0_1 + 79 | 0];
          $17_1 = HEAPU8[$0_1 + 77 | 0] << 16 | HEAPU8[$0_1 + 76 | 0] << 24;
          $46_1 = $37_1 | ($17_1 | HEAPU8[$0_1 + 78 | 0] << 8);
          $15_1 = ($8_1 + $46_1 | 0) + (__wasm_rotl_i32($5_1, 15) ^ __wasm_rotl_i32($5_1, 13) ^ $5_1 >>> 10) | 0;
          $16_1 = ($53_1 + $60_1 | 0) + (__wasm_rotl_i32($15_1, 15) ^ __wasm_rotl_i32($15_1, 13) ^ $15_1 >>> 10) | 0;
          $19_1 = $59_1 + (__wasm_rotl_i32($16_1, 15) ^ __wasm_rotl_i32($16_1, 13) ^ $16_1 >>> 10) | 0;
          $4_1 = $69_1 + (__wasm_rotl_i32($19_1, 15) ^ __wasm_rotl_i32($19_1, 13) ^ $19_1 >>> 10) | 0;
          $29_1 = $4_1 + ((__wasm_rotl_i32($5_1, 25) ^ __wasm_rotl_i32($5_1, 14) ^ $5_1 >>> 3) + $27_1 | 0) | 0;
          $8_1 = ((($24_1 << 25 | $26_1 >>> 7) ^ ($26_1 << 14 | $7_1 >>> 18) ^ $26_1 >>> 3) + $60_1 | 0) + $19_1 | 0;
          $24_1 = (((($34_1 << 25 | $45_1 >>> 7) ^ ($45_1 << 14 | $35_1 >>> 18) ^ $45_1 >>> 3) + $43_1 | 0) + $15_1 | 0) + (__wasm_rotl_i32($3_1, 15) ^ __wasm_rotl_i32($3_1, 13) ^ $3_1 >>> 10) | 0;
          $25_1 = (((($33_1 << 25 | $44_1 >>> 7) ^ ($44_1 << 14 | $28_1 >>> 18) ^ $44_1 >>> 3) + $46_1 | 0) + $16_1 | 0) + (__wasm_rotl_i32($24_1, 15) ^ __wasm_rotl_i32($24_1, 13) ^ $24_1 >>> 10) | 0;
          $28_1 = $8_1 + (__wasm_rotl_i32($25_1, 15) ^ __wasm_rotl_i32($25_1, 13) ^ $25_1 >>> 10) | 0;
          $7_1 = $29_1 + (__wasm_rotl_i32($28_1, 15) ^ __wasm_rotl_i32($28_1, 13) ^ $28_1 >>> 10) | 0;
          $39_1 = $7_1 + ((__wasm_rotl_i32($3_1, 25) ^ __wasm_rotl_i32($3_1, 14) ^ $3_1 >>> 3) + $19_1 | 0) | 0;
          $29_1 = ((__wasm_rotl_i32($12_1, 25) ^ __wasm_rotl_i32($12_1, 14) ^ $12_1 >>> 3) + $16_1 | 0) + $28_1 | 0;
          $30_1 = ((__wasm_rotl_i32($10_1, 25) ^ __wasm_rotl_i32($10_1, 14) ^ $10_1 >>> 3) + $15_1 | 0) + $25_1 | 0;
          $31_1 = ((__wasm_rotl_i32($6_1, 25) ^ __wasm_rotl_i32($6_1, 14) ^ $6_1 >>> 3) + $5_1 | 0) + $24_1 | 0;
          $33_1 = (((($37_1 << 25 | $46_1 >>> 7) ^ ($46_1 << 14 | $17_1 >>> 18) ^ $46_1 >>> 3) + $45_1 | 0) + $10_1 | 0) + (__wasm_rotl_i32($4_1, 15) ^ __wasm_rotl_i32($4_1, 13) ^ $4_1 >>> 10) | 0;
          $35_1 = (((($22_1 << 25 | $60_1 >>> 7) ^ ($60_1 << 14 | $23_1 >>> 18) ^ $60_1 >>> 3) + $44_1 | 0) + $12_1 | 0) + (__wasm_rotl_i32($33_1, 15) ^ __wasm_rotl_i32($33_1, 13) ^ $33_1 >>> 10) | 0;
          $34_1 = (((($36_1 << 25 | $27_1 >>> 7) ^ ($27_1 << 14 | $9_1 >>> 18) ^ $27_1 >>> 3) + $26_1 | 0) + $3_1 | 0) + (__wasm_rotl_i32($35_1, 15) ^ __wasm_rotl_i32($35_1, 13) ^ $35_1 >>> 10) | 0;
          $36_1 = $31_1 + (__wasm_rotl_i32($34_1, 15) ^ __wasm_rotl_i32($34_1, 13) ^ $34_1 >>> 10) | 0;
          $37_1 = $30_1 + (__wasm_rotl_i32($36_1, 15) ^ __wasm_rotl_i32($36_1, 13) ^ $36_1 >>> 10) | 0;
          $29_1 = $29_1 + (__wasm_rotl_i32($37_1, 15) ^ __wasm_rotl_i32($37_1, 13) ^ $37_1 >>> 10) | 0;
          $9_1 = $39_1 + (__wasm_rotl_i32($29_1, 15) ^ __wasm_rotl_i32($29_1, 13) ^ $29_1 >>> 10) | 0;
          $23_1 = $9_1 + ((__wasm_rotl_i32($34_1, 25) ^ __wasm_rotl_i32($34_1, 14) ^ $34_1 >>> 3) + $28_1 | 0) | 0;
          $22_1 = ((__wasm_rotl_i32($35_1, 25) ^ __wasm_rotl_i32($35_1, 14) ^ $35_1 >>> 3) + $25_1 | 0) + $29_1 | 0;
          $17_1 = ((__wasm_rotl_i32($33_1, 25) ^ __wasm_rotl_i32($33_1, 14) ^ $33_1 >>> 3) + $24_1 | 0) + $37_1 | 0;
          $40_1 = ((__wasm_rotl_i32($4_1, 25) ^ __wasm_rotl_i32($4_1, 14) ^ $4_1 >>> 3) + $3_1 | 0) + $36_1 | 0;
          $31_1 = ((__wasm_rotl_i32($19_1, 25) ^ __wasm_rotl_i32($19_1, 14) ^ $19_1 >>> 3) + $12_1 | 0) + $34_1 | 0;
          $30_1 = ((__wasm_rotl_i32($16_1, 25) ^ __wasm_rotl_i32($16_1, 14) ^ $16_1 >>> 3) + $10_1 | 0) + $35_1 | 0;
          $39_1 = (((__wasm_rotl_i32($15_1, 25) ^ __wasm_rotl_i32($15_1, 14) ^ $15_1 >>> 3) + $6_1 | 0) + $33_1 | 0) + (__wasm_rotl_i32($7_1, 15) ^ __wasm_rotl_i32($7_1, 13) ^ $7_1 >>> 10) | 0;
          $30_1 = $30_1 + (__wasm_rotl_i32($39_1, 15) ^ __wasm_rotl_i32($39_1, 13) ^ $39_1 >>> 10) | 0;
          $31_1 = $31_1 + (__wasm_rotl_i32($30_1, 15) ^ __wasm_rotl_i32($30_1, 13) ^ $30_1 >>> 10) | 0;
          $40_1 = $40_1 + (__wasm_rotl_i32($31_1, 15) ^ __wasm_rotl_i32($31_1, 13) ^ $31_1 >>> 10) | 0;
          $47_1 = $17_1 + (__wasm_rotl_i32($40_1, 15) ^ __wasm_rotl_i32($40_1, 13) ^ $40_1 >>> 10) | 0;
          $48_1 = $22_1 + (__wasm_rotl_i32($47_1, 15) ^ __wasm_rotl_i32($47_1, 13) ^ $47_1 >>> 10) | 0;
          $23_1 = $23_1 + (__wasm_rotl_i32($48_1, 15) ^ __wasm_rotl_i32($48_1, 13) ^ $48_1 >>> 10) | 0;
          $22_1 = ((__wasm_rotl_i32($7_1, 25) ^ __wasm_rotl_i32($7_1, 14) ^ $7_1 >>> 3) + $34_1 | 0) + $40_1 | 0;
          $17_1 = ((__wasm_rotl_i32($28_1, 25) ^ __wasm_rotl_i32($28_1, 14) ^ $28_1 >>> 3) + $35_1 | 0) + $31_1 | 0;
          $41_1 = ((__wasm_rotl_i32($25_1, 25) ^ __wasm_rotl_i32($25_1, 14) ^ $25_1 >>> 3) + $33_1 | 0) + $30_1 | 0;
          $49_1 = (((__wasm_rotl_i32($24_1, 25) ^ __wasm_rotl_i32($24_1, 14) ^ $24_1 >>> 3) + $4_1 | 0) + $39_1 | 0) + (__wasm_rotl_i32($9_1, 15) ^ __wasm_rotl_i32($9_1, 13) ^ $9_1 >>> 10) | 0;
          $41_1 = $41_1 + (__wasm_rotl_i32($49_1, 15) ^ __wasm_rotl_i32($49_1, 13) ^ $49_1 >>> 10) | 0;
          $50_1 = $17_1 + (__wasm_rotl_i32($41_1, 15) ^ __wasm_rotl_i32($41_1, 13) ^ $41_1 >>> 10) | 0;
          $22_1 = $22_1 + (__wasm_rotl_i32($50_1, 15) ^ __wasm_rotl_i32($50_1, 13) ^ $50_1 >>> 10) | 0;
          $17_1 = $22_1 + ((__wasm_rotl_i32($9_1, 25) ^ __wasm_rotl_i32($9_1, 14) ^ $9_1 >>> 3) + $31_1 | 0) | 0;
          $32_1 = ((__wasm_rotl_i32($29_1, 25) ^ __wasm_rotl_i32($29_1, 14) ^ $29_1 >>> 3) + $30_1 | 0) + $50_1 | 0;
          $42_1 = ((__wasm_rotl_i32($37_1, 25) ^ __wasm_rotl_i32($37_1, 14) ^ $37_1 >>> 3) + $39_1 | 0) + $41_1 | 0;
          $51_1 = (((__wasm_rotl_i32($36_1, 25) ^ __wasm_rotl_i32($36_1, 14) ^ $36_1 >>> 3) + $7_1 | 0) + $49_1 | 0) + (__wasm_rotl_i32($23_1, 15) ^ __wasm_rotl_i32($23_1, 13) ^ $23_1 >>> 10) | 0;
          $62_1 = $42_1 + (__wasm_rotl_i32($51_1, 15) ^ __wasm_rotl_i32($51_1, 13) ^ $51_1 >>> 10) | 0;
          $63_1 = $32_1 + (__wasm_rotl_i32($62_1, 15) ^ __wasm_rotl_i32($62_1, 13) ^ $62_1 >>> 10) | 0;
          $64_1 = $17_1 + (__wasm_rotl_i32($63_1, 15) ^ __wasm_rotl_i32($63_1, 13) ^ $63_1 >>> 10) | 0;
          $17_1 = $64_1 + ((__wasm_rotl_i32($23_1, 25) ^ __wasm_rotl_i32($23_1, 14) ^ $23_1 >>> 3) + $50_1 | 0) | 0;
          $32_1 = ((__wasm_rotl_i32($48_1, 25) ^ __wasm_rotl_i32($48_1, 14) ^ $48_1 >>> 3) + $41_1 | 0) + $63_1 | 0;
          $55_1 = ((__wasm_rotl_i32($47_1, 25) ^ __wasm_rotl_i32($47_1, 14) ^ $47_1 >>> 3) + $49_1 | 0) + $62_1 | 0;
          $56_1 = ((__wasm_rotl_i32($40_1, 25) ^ __wasm_rotl_i32($40_1, 14) ^ $40_1 >>> 3) + $9_1 | 0) + $51_1 | 0;
          $57_1 = ((__wasm_rotl_i32($31_1, 25) ^ __wasm_rotl_i32($31_1, 14) ^ $31_1 >>> 3) + $29_1 | 0) + $23_1 | 0;
          $58_1 = ((__wasm_rotl_i32($30_1, 25) ^ __wasm_rotl_i32($30_1, 14) ^ $30_1 >>> 3) + $37_1 | 0) + $48_1 | 0;
          $42_1 = (((__wasm_rotl_i32($39_1, 25) ^ __wasm_rotl_i32($39_1, 14) ^ $39_1 >>> 3) + $36_1 | 0) + $47_1 | 0) + (__wasm_rotl_i32($22_1, 15) ^ __wasm_rotl_i32($22_1, 13) ^ $22_1 >>> 10) | 0;
          $58_1 = $58_1 + (__wasm_rotl_i32($42_1, 15) ^ __wasm_rotl_i32($42_1, 13) ^ $42_1 >>> 10) | 0;
          $57_1 = $57_1 + (__wasm_rotl_i32($58_1, 15) ^ __wasm_rotl_i32($58_1, 13) ^ $58_1 >>> 10) | 0;
          $56_1 = $56_1 + (__wasm_rotl_i32($57_1, 15) ^ __wasm_rotl_i32($57_1, 13) ^ $57_1 >>> 10) | 0;
          $55_1 = $55_1 + (__wasm_rotl_i32($56_1, 15) ^ __wasm_rotl_i32($56_1, 13) ^ $56_1 >>> 10) | 0;
          $70_1 = $32_1 + (__wasm_rotl_i32($55_1, 15) ^ __wasm_rotl_i32($55_1, 13) ^ $55_1 >>> 10) | 0;
          $71 = $17_1 + (__wasm_rotl_i32($70_1, 15) ^ __wasm_rotl_i32($70_1, 13) ^ $70_1 >>> 10) | 0;
          $69_1 = HEAP32[$0_1 + 12 >> 2];
          $59_1 = HEAP32[$0_1 + 28 >> 2];
          $32_1 = HEAP32[$0_1 + 16 >> 2];
          $17_1 = $59_1 + (__wasm_rotl_i32($32_1, 26) ^ __wasm_rotl_i32($32_1, 21) ^ __wasm_rotl_i32($32_1, 7)) | 0;
          $65_1 = HEAP32[$0_1 + 20 >> 2];
          $72 = HEAP32[$0_1 + 24 >> 2];
          $66_1 = ($52_1 + ($17_1 + (($65_1 ^ $72) & $32_1 ^ $72) | 0) | 0) + 1116352408 | 0;
          $17_1 = $66_1 + $69_1 | 0;
          $52_1 = HEAP32[$0_1 + 4 >> 2];
          $8_1 = $13_1 + $65_1 | 0;
          $73 = HEAP32[$0_1 + 8 >> 2];
          $67_1 = ((($72 + ($17_1 & ($32_1 ^ $65_1) ^ $65_1) | 0) + $11_1 | 0) + (__wasm_rotl_i32($17_1, 26) ^ __wasm_rotl_i32($17_1, 21) ^ __wasm_rotl_i32($17_1, 7)) | 0) + 1899447441 | 0;
          $13_1 = $73 + $67_1 | 0;
          $68_1 = (($8_1 + ($13_1 & ($17_1 ^ $32_1) ^ $32_1) | 0) + (__wasm_rotl_i32($13_1, 26) ^ __wasm_rotl_i32($13_1, 21) ^ __wasm_rotl_i32($13_1, 7)) | 0) - 1245643825 | 0;
          $11_1 = $52_1 + $68_1 | 0;
          $8_1 = $14_1 + $17_1 | 0;
          $53_1 = ((($32_1 + $54_1 | 0) + ($11_1 & ($13_1 ^ $17_1) ^ $17_1) | 0) + (__wasm_rotl_i32($11_1, 26) ^ __wasm_rotl_i32($11_1, 21) ^ __wasm_rotl_i32($11_1, 7)) | 0) - 373957723 | 0;
          $17_1 = HEAP32[$0_1 >> 2];
          $14_1 = $53_1 + $17_1 | 0;
          $54_1 = (($8_1 + ($14_1 & ($11_1 ^ $13_1) ^ $13_1) | 0) + (__wasm_rotl_i32($14_1, 26) ^ __wasm_rotl_i32($14_1, 21) ^ __wasm_rotl_i32($14_1, 7)) | 0) + 961987163 | 0;
          $8_1 = $13_1 + $18_1 | 0;
          $13_1 = (($73 & ($17_1 | $52_1) | $17_1 & $52_1) + (__wasm_rotl_i32($17_1, 30) ^ __wasm_rotl_i32($17_1, 19) ^ __wasm_rotl_i32($17_1, 10)) | 0) + $66_1 | 0;
          $18_1 = $13_1 + $54_1 | 0;
          $66_1 = (($8_1 + ($18_1 & ($11_1 ^ $14_1) ^ $11_1) | 0) + (__wasm_rotl_i32($18_1, 26) ^ __wasm_rotl_i32($18_1, 21) ^ __wasm_rotl_i32($18_1, 7)) | 0) + 1508970993 | 0;
          $8_1 = $11_1 + $20_1 | 0;
          $11_1 = ((($13_1 | $17_1) & $52_1 | $13_1 & $17_1) + (__wasm_rotl_i32($13_1, 30) ^ __wasm_rotl_i32($13_1, 19) ^ __wasm_rotl_i32($13_1, 10)) | 0) + $67_1 | 0;
          $20_1 = $11_1 + $66_1 | 0;
          $67_1 = (($8_1 + ($20_1 & ($14_1 ^ $18_1) ^ $14_1) | 0) + (__wasm_rotl_i32($20_1, 26) ^ __wasm_rotl_i32($20_1, 21) ^ __wasm_rotl_i32($20_1, 7)) | 0) - 1841331548 | 0;
          $8_1 = $14_1 + $21_1 | 0;
          $14_1 = ((($11_1 | $13_1) & $17_1 | $11_1 & $13_1) + (__wasm_rotl_i32($11_1, 30) ^ __wasm_rotl_i32($11_1, 19) ^ __wasm_rotl_i32($11_1, 10)) | 0) + $68_1 | 0;
          $21_1 = $14_1 + $67_1 | 0;
          $68_1 = (($8_1 + ($21_1 & ($18_1 ^ $20_1) ^ $18_1) | 0) + (__wasm_rotl_i32($21_1, 26) ^ __wasm_rotl_i32($21_1, 21) ^ __wasm_rotl_i32($21_1, 7)) | 0) - 1424204075 | 0;
          $8_1 = $18_1 + $38_1 | 0;
          $13_1 = ((($11_1 | $14_1) & $13_1 | $11_1 & $14_1) + (__wasm_rotl_i32($14_1, 30) ^ __wasm_rotl_i32($14_1, 19) ^ __wasm_rotl_i32($14_1, 10)) | 0) + $53_1 | 0;
          $18_1 = $13_1 + $68_1 | 0;
          $38_1 = (($8_1 + ($18_1 & ($20_1 ^ $21_1) ^ $20_1) | 0) + (__wasm_rotl_i32($18_1, 26) ^ __wasm_rotl_i32($18_1, 21) ^ __wasm_rotl_i32($18_1, 7)) | 0) - 670586216 | 0;
          $8_1 = $20_1 + $43_1 | 0;
          $11_1 = ((($13_1 | $14_1) & $11_1 | $13_1 & $14_1) + (__wasm_rotl_i32($13_1, 30) ^ __wasm_rotl_i32($13_1, 19) ^ __wasm_rotl_i32($13_1, 10)) | 0) + $54_1 | 0;
          $20_1 = $11_1 + $38_1 | 0;
          $43_1 = (($8_1 + ($20_1 & ($18_1 ^ $21_1) ^ $21_1) | 0) + (__wasm_rotl_i32($20_1, 26) ^ __wasm_rotl_i32($20_1, 21) ^ __wasm_rotl_i32($20_1, 7)) | 0) + 310598401 | 0;
          $8_1 = $21_1 + $45_1 | 0;
          $14_1 = ((($11_1 | $13_1) & $14_1 | $11_1 & $13_1) + (__wasm_rotl_i32($11_1, 30) ^ __wasm_rotl_i32($11_1, 19) ^ __wasm_rotl_i32($11_1, 10)) | 0) + $66_1 | 0;
          $21_1 = $14_1 + $43_1 | 0;
          $45_1 = (($8_1 + ($21_1 & ($18_1 ^ $20_1) ^ $18_1) | 0) + (__wasm_rotl_i32($21_1, 26) ^ __wasm_rotl_i32($21_1, 21) ^ __wasm_rotl_i32($21_1, 7)) | 0) + 607225278 | 0;
          $8_1 = $18_1 + $46_1 | 0;
          $13_1 = ((($11_1 | $14_1) & $13_1 | $11_1 & $14_1) + (__wasm_rotl_i32($14_1, 30) ^ __wasm_rotl_i32($14_1, 19) ^ __wasm_rotl_i32($14_1, 10)) | 0) + $67_1 | 0;
          $18_1 = $13_1 + $45_1 | 0;
          $46_1 = (($8_1 + ($18_1 & ($20_1 ^ $21_1) ^ $20_1) | 0) + (__wasm_rotl_i32($18_1, 26) ^ __wasm_rotl_i32($18_1, 21) ^ __wasm_rotl_i32($18_1, 7)) | 0) + 1426881987 | 0;
          $8_1 = $20_1 + $44_1 | 0;
          $11_1 = ((($13_1 | $14_1) & $11_1 | $13_1 & $14_1) + (__wasm_rotl_i32($13_1, 30) ^ __wasm_rotl_i32($13_1, 19) ^ __wasm_rotl_i32($13_1, 10)) | 0) + $68_1 | 0;
          $20_1 = $11_1 + $46_1 | 0;
          $44_1 = (($8_1 + ($20_1 & ($18_1 ^ $21_1) ^ $21_1) | 0) + (__wasm_rotl_i32($20_1, 26) ^ __wasm_rotl_i32($20_1, 21) ^ __wasm_rotl_i32($20_1, 7)) | 0) + 1925078388 | 0;
          $8_1 = $21_1 + $60_1 | 0;
          $14_1 = ((($11_1 | $13_1) & $14_1 | $11_1 & $13_1) + (__wasm_rotl_i32($11_1, 30) ^ __wasm_rotl_i32($11_1, 19) ^ __wasm_rotl_i32($11_1, 10)) | 0) + $38_1 | 0;
          $21_1 = $14_1 + $44_1 | 0;
          $38_1 = (($8_1 + ($21_1 & ($18_1 ^ $20_1) ^ $18_1) | 0) + (__wasm_rotl_i32($21_1, 26) ^ __wasm_rotl_i32($21_1, 21) ^ __wasm_rotl_i32($21_1, 7)) | 0) - 2132889090 | 0;
          $8_1 = $18_1 + $26_1 | 0;
          $13_1 = ((($11_1 | $14_1) & $13_1 | $11_1 & $14_1) + (__wasm_rotl_i32($14_1, 30) ^ __wasm_rotl_i32($14_1, 19) ^ __wasm_rotl_i32($14_1, 10)) | 0) + $43_1 | 0;
          $26_1 = $13_1 + $38_1 | 0;
          $18_1 = (($8_1 + ($26_1 & ($20_1 ^ $21_1) ^ $20_1) | 0) + (__wasm_rotl_i32($26_1, 26) ^ __wasm_rotl_i32($26_1, 21) ^ __wasm_rotl_i32($26_1, 7)) | 0) - 1680079193 | 0;
          $8_1 = $20_1 + $27_1 | 0;
          $11_1 = ((($13_1 | $14_1) & $11_1 | $13_1 & $14_1) + (__wasm_rotl_i32($13_1, 30) ^ __wasm_rotl_i32($13_1, 19) ^ __wasm_rotl_i32($13_1, 10)) | 0) + $45_1 | 0;
          $27_1 = $11_1 + $18_1 | 0;
          $20_1 = (($8_1 + ($27_1 & ($21_1 ^ $26_1) ^ $21_1) | 0) + (__wasm_rotl_i32($27_1, 26) ^ __wasm_rotl_i32($27_1, 21) ^ __wasm_rotl_i32($27_1, 7)) | 0) - 1046744716 | 0;
          $8_1 = $5_1 + $21_1 | 0;
          $5_1 = ((($11_1 | $13_1) & $14_1 | $11_1 & $13_1) + (__wasm_rotl_i32($11_1, 30) ^ __wasm_rotl_i32($11_1, 19) ^ __wasm_rotl_i32($11_1, 10)) | 0) + $46_1 | 0;
          $14_1 = $5_1 + $20_1 | 0;
          $21_1 = (($8_1 + ($14_1 & ($26_1 ^ $27_1) ^ $26_1) | 0) + (__wasm_rotl_i32($14_1, 26) ^ __wasm_rotl_i32($14_1, 21) ^ __wasm_rotl_i32($14_1, 7)) | 0) - 459576895 | 0;
          $8_1 = $6_1 + $26_1 | 0;
          $6_1 = ((($5_1 | $11_1) & $13_1 | $5_1 & $11_1) + (__wasm_rotl_i32($5_1, 30) ^ __wasm_rotl_i32($5_1, 19) ^ __wasm_rotl_i32($5_1, 10)) | 0) + $44_1 | 0;
          $13_1 = $6_1 + $21_1 | 0;
          $26_1 = (($8_1 + ($13_1 & ($14_1 ^ $27_1) ^ $27_1) | 0) + (__wasm_rotl_i32($13_1, 26) ^ __wasm_rotl_i32($13_1, 21) ^ __wasm_rotl_i32($13_1, 7)) | 0) - 272742522 | 0;
          $8_1 = $15_1 + $27_1 | 0;
          $15_1 = ((($5_1 | $6_1) & $11_1 | $5_1 & $6_1) + (__wasm_rotl_i32($6_1, 30) ^ __wasm_rotl_i32($6_1, 19) ^ __wasm_rotl_i32($6_1, 10)) | 0) + $38_1 | 0;
          $11_1 = $15_1 + $26_1 | 0;
          $27_1 = (($8_1 + ($11_1 & ($13_1 ^ $14_1) ^ $14_1) | 0) + (__wasm_rotl_i32($11_1, 26) ^ __wasm_rotl_i32($11_1, 21) ^ __wasm_rotl_i32($11_1, 7)) | 0) + 264347078 | 0;
          $8_1 = $10_1 + $14_1 | 0;
          $5_1 = ((($6_1 | $15_1) & $5_1 | $6_1 & $15_1) + (__wasm_rotl_i32($15_1, 30) ^ __wasm_rotl_i32($15_1, 19) ^ __wasm_rotl_i32($15_1, 10)) | 0) + $18_1 | 0;
          $14_1 = $5_1 + $27_1 | 0;
          $18_1 = (($8_1 + ($14_1 & ($11_1 ^ $13_1) ^ $13_1) | 0) + (__wasm_rotl_i32($14_1, 26) ^ __wasm_rotl_i32($14_1, 21) ^ __wasm_rotl_i32($14_1, 7)) | 0) + 604807628 | 0;
          $8_1 = $13_1 + $16_1 | 0;
          $6_1 = ((($5_1 | $15_1) & $6_1 | $5_1 & $15_1) + (__wasm_rotl_i32($5_1, 30) ^ __wasm_rotl_i32($5_1, 19) ^ __wasm_rotl_i32($5_1, 10)) | 0) + $20_1 | 0;
          $16_1 = $6_1 + $18_1 | 0;
          $13_1 = (($8_1 + ($16_1 & ($11_1 ^ $14_1) ^ $11_1) | 0) + (__wasm_rotl_i32($16_1, 26) ^ __wasm_rotl_i32($16_1, 21) ^ __wasm_rotl_i32($16_1, 7)) | 0) + 770255983 | 0;
          $8_1 = $11_1 + $12_1 | 0;
          $10_1 = ((($5_1 | $6_1) & $15_1 | $5_1 & $6_1) + (__wasm_rotl_i32($6_1, 30) ^ __wasm_rotl_i32($6_1, 19) ^ __wasm_rotl_i32($6_1, 10)) | 0) + $21_1 | 0;
          $12_1 = $10_1 + $13_1 | 0;
          $11_1 = (($8_1 + ($12_1 & ($14_1 ^ $16_1) ^ $14_1) | 0) + (__wasm_rotl_i32($12_1, 26) ^ __wasm_rotl_i32($12_1, 21) ^ __wasm_rotl_i32($12_1, 7)) | 0) + 1249150122 | 0;
          $5_1 = ((($6_1 | $10_1) & $5_1 | $6_1 & $10_1) + (__wasm_rotl_i32($10_1, 30) ^ __wasm_rotl_i32($10_1, 19) ^ __wasm_rotl_i32($10_1, 10)) | 0) + $26_1 | 0;
          $15_1 = $5_1 + $11_1 | 0;
          $19_1 = ((($14_1 + $19_1 | 0) + ($15_1 & ($12_1 ^ $16_1) ^ $16_1) | 0) + (__wasm_rotl_i32($15_1, 26) ^ __wasm_rotl_i32($15_1, 21) ^ __wasm_rotl_i32($15_1, 7)) | 0) + 1555081692 | 0;
          $8_1 = $3_1 + $16_1 | 0;
          $3_1 = ((($5_1 | $10_1) & $6_1 | $5_1 & $10_1) + (__wasm_rotl_i32($5_1, 30) ^ __wasm_rotl_i32($5_1, 19) ^ __wasm_rotl_i32($5_1, 10)) | 0) + $27_1 | 0;
          $6_1 = $3_1 + $19_1 | 0;
          $16_1 = (($8_1 + ($6_1 & ($12_1 ^ $15_1) ^ $12_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 1996064986 | 0;
          $8_1 = $4_1 + $12_1 | 0;
          $4_1 = ((($3_1 | $5_1) & $10_1 | $3_1 & $5_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $18_1 | 0;
          $10_1 = $4_1 + $16_1 | 0;
          $14_1 = (($8_1 + ($10_1 & ($6_1 ^ $15_1) ^ $15_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) - 1740746414 | 0;
          $5_1 = ((($3_1 | $4_1) & $5_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $13_1 | 0;
          $12_1 = $5_1 + $14_1 | 0;
          $15_1 = ((($15_1 + $24_1 | 0) + ($12_1 & ($6_1 ^ $10_1) ^ $6_1) | 0) + (__wasm_rotl_i32($12_1, 26) ^ __wasm_rotl_i32($12_1, 21) ^ __wasm_rotl_i32($12_1, 7)) | 0) - 1473132947 | 0;
          $8_1 = $6_1 + $33_1 | 0;
          $3_1 = ((($4_1 | $5_1) & $3_1 | $4_1 & $5_1) + (__wasm_rotl_i32($5_1, 30) ^ __wasm_rotl_i32($5_1, 19) ^ __wasm_rotl_i32($5_1, 10)) | 0) + $11_1 | 0;
          $6_1 = $3_1 + $15_1 | 0;
          $24_1 = (($8_1 + ($6_1 & ($10_1 ^ $12_1) ^ $10_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 1341970488 | 0;
          $8_1 = $10_1 + $25_1 | 0;
          $4_1 = ((($3_1 | $5_1) & $4_1 | $3_1 & $5_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $19_1 | 0;
          $10_1 = $4_1 + $24_1 | 0;
          $19_1 = (($8_1 + ($10_1 & ($6_1 ^ $12_1) ^ $12_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) - 1084653625 | 0;
          $8_1 = $12_1 + $35_1 | 0;
          $5_1 = ((($3_1 | $4_1) & $5_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $16_1 | 0;
          $12_1 = $5_1 + $19_1 | 0;
          $16_1 = (($8_1 + ($12_1 & ($6_1 ^ $10_1) ^ $6_1) | 0) + (__wasm_rotl_i32($12_1, 26) ^ __wasm_rotl_i32($12_1, 21) ^ __wasm_rotl_i32($12_1, 7)) | 0) - 958395405 | 0;
          $8_1 = $6_1 + $28_1 | 0;
          $3_1 = ((($4_1 | $5_1) & $3_1 | $4_1 & $5_1) + (__wasm_rotl_i32($5_1, 30) ^ __wasm_rotl_i32($5_1, 19) ^ __wasm_rotl_i32($5_1, 10)) | 0) + $14_1 | 0;
          $6_1 = $3_1 + $16_1 | 0;
          $25_1 = (($8_1 + ($6_1 & ($10_1 ^ $12_1) ^ $10_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 710438585 | 0;
          $8_1 = $10_1 + $34_1 | 0;
          $4_1 = ((($3_1 | $5_1) & $4_1 | $3_1 & $5_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $15_1 | 0;
          $10_1 = $4_1 + $25_1 | 0;
          $15_1 = (($8_1 + ($10_1 & ($6_1 ^ $12_1) ^ $12_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) + 113926993 | 0;
          $8_1 = $7_1 + $12_1 | 0;
          $7_1 = ((($3_1 | $4_1) & $5_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $24_1 | 0;
          $5_1 = $7_1 + $15_1 | 0;
          $12_1 = (($8_1 + ($5_1 & ($6_1 ^ $10_1) ^ $6_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 338241895 | 0;
          $8_1 = $6_1 + $36_1 | 0;
          $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $19_1 | 0;
          $6_1 = $3_1 + $12_1 | 0;
          $19_1 = (($8_1 + ($6_1 & ($5_1 ^ $10_1) ^ $10_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 666307205 | 0;
          $8_1 = $10_1 + $39_1 | 0;
          $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $16_1 | 0;
          $10_1 = $4_1 + $19_1 | 0;
          $16_1 = (($8_1 + ($10_1 & ($5_1 ^ $6_1) ^ $5_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) + 773529912 | 0;
          $8_1 = $5_1 + $37_1 | 0;
          $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $25_1 | 0;
          $5_1 = $7_1 + $16_1 | 0;
          $24_1 = (($8_1 + ($5_1 & ($6_1 ^ $10_1) ^ $6_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 1294757372 | 0;
          $8_1 = $6_1 + $30_1 | 0;
          $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $15_1 | 0;
          $6_1 = $3_1 + $24_1 | 0;
          $15_1 = (($8_1 + ($6_1 & ($5_1 ^ $10_1) ^ $10_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 1396182291 | 0;
          $8_1 = $10_1 + $29_1 | 0;
          $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $12_1 | 0;
          $10_1 = $4_1 + $15_1 | 0;
          $12_1 = (($8_1 + ($10_1 & ($5_1 ^ $6_1) ^ $5_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) + 1695183700 | 0;
          $8_1 = $5_1 + $31_1 | 0;
          $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $19_1 | 0;
          $5_1 = $7_1 + $12_1 | 0;
          $19_1 = (($8_1 + ($5_1 & ($6_1 ^ $10_1) ^ $6_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 1986661051 | 0;
          $8_1 = $6_1 + $9_1 | 0;
          $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $16_1 | 0;
          $9_1 = $3_1 + $19_1 | 0;
          $16_1 = (($8_1 + ($9_1 & ($5_1 ^ $10_1) ^ $10_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) - 2117940946 | 0;
          $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $24_1 | 0;
          $6_1 = $4_1 + $16_1 | 0;
          $10_1 = ((($10_1 + $40_1 | 0) + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 1838011259 | 0;
          $8_1 = $5_1 + $49_1 | 0;
          $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $15_1 | 0;
          $5_1 = $7_1 + $10_1 | 0;
          $15_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) - 1564481375 | 0;
          $8_1 = $9_1 + $47_1 | 0;
          $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $12_1 | 0;
          $9_1 = $3_1 + $15_1 | 0;
          $12_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) - 1474664885 | 0;
          $8_1 = $6_1 + $41_1 | 0;
          $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $19_1 | 0;
          $6_1 = $4_1 + $12_1 | 0;
          $19_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 1035236496 | 0;
          $8_1 = $5_1 + $48_1 | 0;
          $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $16_1 | 0;
          $5_1 = $7_1 + $19_1 | 0;
          $16_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) - 949202525 | 0;
          $8_1 = $9_1 + $50_1 | 0;
          $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $10_1 | 0;
          $9_1 = $3_1 + $16_1 | 0;
          $10_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) - 778901479 | 0;
          $8_1 = $6_1 + $23_1 | 0;
          $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $15_1 | 0;
          $6_1 = $4_1 + $10_1 | 0;
          $15_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 694614492 | 0;
          $8_1 = $5_1 + $22_1 | 0;
          $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $12_1 | 0;
          $5_1 = $7_1 + $15_1 | 0;
          $12_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) - 200395387 | 0;
          $8_1 = $9_1 + $51_1 | 0;
          $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $19_1 | 0;
          $9_1 = $3_1 + $12_1 | 0;
          $19_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) + 275423344 | 0;
          $8_1 = $6_1 + $42_1 | 0;
          $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $16_1 | 0;
          $6_1 = $4_1 + $19_1 | 0;
          $16_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 430227734 | 0;
          $8_1 = $5_1 + $62_1 | 0;
          $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $10_1 | 0;
          $5_1 = $7_1 + $16_1 | 0;
          $10_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 506948616 | 0;
          $8_1 = $9_1 + $58_1 | 0;
          $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $15_1 | 0;
          $9_1 = $3_1 + $10_1 | 0;
          $24_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) + 659060556 | 0;
          $8_1 = $6_1 + $63_1 | 0;
          $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $12_1 | 0;
          $6_1 = $4_1 + $24_1 | 0;
          $12_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 883997877 | 0;
          $8_1 = $5_1 + $57_1 | 0;
          $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $19_1 | 0;
          $5_1 = $7_1 + $12_1 | 0;
          $19_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 958139571 | 0;
          $8_1 = $9_1 + $64_1 | 0;
          $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $16_1 | 0;
          $9_1 = $3_1 + $19_1 | 0;
          $25_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) + 1322822218 | 0;
          $8_1 = $6_1 + $56_1 | 0;
          $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $10_1 | 0;
          $6_1 = $4_1 + $25_1 | 0;
          $28_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 1537002063 | 0;
          $15_1 = (((__wasm_rotl_i32($49_1, 25) ^ __wasm_rotl_i32($49_1, 14) ^ $49_1 >>> 3) + $40_1 | 0) + $42_1 | 0) + (__wasm_rotl_i32($64_1, 15) ^ __wasm_rotl_i32($64_1, 13) ^ $64_1 >>> 10) | 0;
          $8_1 = $15_1 + $5_1 | 0;
          $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $24_1 | 0;
          $5_1 = $7_1 + $28_1 | 0;
          $24_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 1747873779 | 0;
          $8_1 = $9_1 + $55_1 | 0;
          $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $12_1 | 0;
          $9_1 = $3_1 + $24_1 | 0;
          $12_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) + 1955562222 | 0;
          $16_1 = ((__wasm_rotl_i32($50_1, 25) ^ __wasm_rotl_i32($50_1, 14) ^ $50_1 >>> 3) + $48_1 | 0) + $57_1 | 0;
          $10_1 = (((__wasm_rotl_i32($41_1, 25) ^ __wasm_rotl_i32($41_1, 14) ^ $41_1 >>> 3) + $47_1 | 0) + $58_1 | 0) + (__wasm_rotl_i32($15_1, 15) ^ __wasm_rotl_i32($15_1, 13) ^ $15_1 >>> 10) | 0;
          $16_1 = $16_1 + (__wasm_rotl_i32($10_1, 15) ^ __wasm_rotl_i32($10_1, 13) ^ $10_1 >>> 10) | 0;
          $8_1 = $6_1 + $10_1 | 0;
          $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $19_1 | 0;
          $6_1 = $4_1 + $12_1 | 0;
          $19_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 2024104815 | 0;
          $8_1 = $5_1 + $70_1 | 0;
          $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $25_1 | 0;
          $5_1 = $7_1 + $19_1 | 0;
          $25_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) - 2067236844 | 0;
          $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $28_1 | 0;
          $10_1 = $3_1 + $25_1 | 0;
          $28_1 = ((($9_1 + $16_1 | 0) + ($10_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) - 1933114872 | 0;
          $8_1 = $6_1 + $71 | 0;
          $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $24_1 | 0;
          $6_1 = $4_1 + $28_1 | 0;
          $24_1 = (($8_1 + ($6_1 & ($5_1 ^ $10_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 1866530822 | 0;
          $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $12_1 | 0;
          $12_1 = $24_1 + $7_1 | 0;
          HEAP32[$0_1 + 28 >> 2] = $12_1 + $59_1;
          $9_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $19_1 | 0;
          $3_1 = (($4_1 & ($9_1 | $7_1) | $7_1 & $9_1) + (__wasm_rotl_i32($9_1, 30) ^ __wasm_rotl_i32($9_1, 19) ^ __wasm_rotl_i32($9_1, 10)) | 0) + $25_1 | 0;
          $4_1 = ((($3_1 | $9_1) & $7_1 | $3_1 & $9_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $28_1 | 0;
          $7_1 = ((($4_1 | $3_1) & $9_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $24_1 | 0;
          HEAP32[$0_1 + 12 >> 2] = $7_1 + $69_1;
          $53_1 = $9_1;
          $8_1 = $5_1;
          $5_1 = (((__wasm_rotl_i32($22_1, 25) ^ __wasm_rotl_i32($22_1, 14) ^ $22_1 >>> 3) + $23_1 | 0) + $56_1 | 0) + (__wasm_rotl_i32($16_1, 15) ^ __wasm_rotl_i32($16_1, 13) ^ $16_1 >>> 10) | 0;
          $9_1 = ((($8_1 + $5_1 | 0) + ($12_1 & ($6_1 ^ $10_1) ^ $10_1) | 0) + (__wasm_rotl_i32($12_1, 26) ^ __wasm_rotl_i32($12_1, 21) ^ __wasm_rotl_i32($12_1, 7)) | 0) - 1538233109 | 0;
          $23_1 = $53_1 + $9_1 | 0;
          HEAP32[$0_1 + 24 >> 2] = $23_1 + $72;
          $9_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $9_1 | 0;
          HEAP32[$0_1 + 8 >> 2] = $9_1 + $73;
          $8_1 = $3_1;
          $3_1 = (((((($22_1 + (__wasm_rotl_i32($51_1, 25) ^ __wasm_rotl_i32($51_1, 14) ^ $51_1 >>> 3) | 0) + $15_1 | 0) + (__wasm_rotl_i32($71, 15) ^ __wasm_rotl_i32($71, 13) ^ $71 >>> 10) | 0) + $10_1 | 0) + ($23_1 & ($6_1 ^ $12_1) ^ $6_1) | 0) + (__wasm_rotl_i32($23_1, 26) ^ __wasm_rotl_i32($23_1, 21) ^ __wasm_rotl_i32($23_1, 7)) | 0) - 1090935817 | 0;
          $22_1 = $8_1 + $3_1 | 0;
          HEAP32[$0_1 + 20 >> 2] = $22_1 + $65_1;
          $3_1 = ((($7_1 | $9_1) & $4_1 | $7_1 & $9_1) + (__wasm_rotl_i32($9_1, 30) ^ __wasm_rotl_i32($9_1, 19) ^ __wasm_rotl_i32($9_1, 10)) | 0) + $3_1 | 0;
          HEAP32[$0_1 + 4 >> 2] = $3_1 + $52_1;
          $8_1 = $4_1 + $32_1 | 0;
          $4_1 = (((((($51_1 + (__wasm_rotl_i32($42_1, 25) ^ __wasm_rotl_i32($42_1, 14) ^ $42_1 >>> 3) | 0) + $55_1 | 0) + (__wasm_rotl_i32($5_1, 15) ^ __wasm_rotl_i32($5_1, 13) ^ $5_1 >>> 10) | 0) + $6_1 | 0) + ($22_1 & ($12_1 ^ $23_1) ^ $12_1) | 0) + (__wasm_rotl_i32($22_1, 26) ^ __wasm_rotl_i32($22_1, 21) ^ __wasm_rotl_i32($22_1, 7)) | 0) - 965641998 | 0;
          HEAP32[$0_1 + 16 >> 2] = $8_1 + $4_1;
          wasm2js_i32$0 = $0_1, wasm2js_i32$1 = (($17_1 + (($3_1 | $9_1) & $7_1 | $3_1 & $9_1) | 0) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $4_1 | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
          $1_1 = $1_1 + $61_1 | 0;
          $2_1 = $2_1 - $61_1 | 0;
          $61_1 = 64;
          $3_1 = 0;
          if ($2_1 >>> 0 > 63) {
            continue;
          }
          break;
        }
        ;
      }
      if ($2_1) {
        $70(($0_1 + $3_1 | 0) + 32 | 0, $1_1, $2_1);
      }
    }
    function $30($0_1, $1_1) {
      var $2_1 = 0, $3_1 = 0, $4_1 = 0;
      $3_1 = global$0 - 16 | 0;
      global$0 = $3_1;
      $2_1 = HEAP32[$0_1 + 100 >> 2];
      $4_1 = HEAP32[$0_1 + 96 >> 2];
      HEAP8[$3_1 + 11 | 0] = ($2_1 & 536870911) << 3 | $4_1 >>> 29;
      HEAP8[$3_1 + 10 | 0] = $2_1 >>> 5;
      HEAP8[$3_1 + 9 | 0] = $2_1 >>> 13;
      HEAP8[$3_1 + 8 | 0] = $2_1 >>> 21;
      HEAP8[$3_1 + 15 | 0] = $4_1 << 3;
      HEAP8[$3_1 + 14 | 0] = $4_1 >>> 5;
      HEAP8[$3_1 + 13 | 0] = $4_1 >>> 13;
      HEAP8[$3_1 + 12 | 0] = $4_1 >>> 21;
      $29($0_1, 690512, (55 - $4_1 & 63) + 1 | 0);
      $29($0_1, $3_1 + 8 | 0, 8);
      $2_1 = HEAP32[$0_1 >> 2];
      $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
      HEAP8[$1_1 | 0] = $2_1;
      HEAP8[$1_1 + 1 | 0] = $2_1 >>> 8;
      HEAP8[$1_1 + 2 | 0] = $2_1 >>> 16;
      HEAP8[$1_1 + 3 | 0] = $2_1 >>> 24;
      HEAP32[$0_1 >> 2] = 0;
      $2_1 = HEAP32[$0_1 + 4 >> 2];
      $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
      HEAP8[$1_1 + 4 | 0] = $2_1;
      HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
      HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
      HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $2_1 = HEAP32[$0_1 + 8 >> 2];
      $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
      HEAP8[$1_1 + 8 | 0] = $2_1;
      HEAP8[$1_1 + 9 | 0] = $2_1 >>> 8;
      HEAP8[$1_1 + 10 | 0] = $2_1 >>> 16;
      HEAP8[$1_1 + 11 | 0] = $2_1 >>> 24;
      HEAP32[$0_1 + 8 >> 2] = 0;
      $2_1 = HEAP32[$0_1 + 12 >> 2];
      $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
      HEAP8[$1_1 + 12 | 0] = $2_1;
      HEAP8[$1_1 + 13 | 0] = $2_1 >>> 8;
      HEAP8[$1_1 + 14 | 0] = $2_1 >>> 16;
      HEAP8[$1_1 + 15 | 0] = $2_1 >>> 24;
      HEAP32[$0_1 + 12 >> 2] = 0;
      $2_1 = HEAP32[$0_1 + 16 >> 2];
      $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
      HEAP8[$1_1 + 16 | 0] = $2_1;
      HEAP8[$1_1 + 17 | 0] = $2_1 >>> 8;
      HEAP8[$1_1 + 18 | 0] = $2_1 >>> 16;
      HEAP8[$1_1 + 19 | 0] = $2_1 >>> 24;
      HEAP32[$0_1 + 16 >> 2] = 0;
      $2_1 = HEAP32[$0_1 + 20 >> 2];
      $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
      HEAP8[$1_1 + 20 | 0] = $2_1;
      HEAP8[$1_1 + 21 | 0] = $2_1 >>> 8;
      HEAP8[$1_1 + 22 | 0] = $2_1 >>> 16;
      HEAP8[$1_1 + 23 | 0] = $2_1 >>> 24;
      HEAP32[$0_1 + 20 >> 2] = 0;
      $2_1 = HEAP32[$0_1 + 24 >> 2];
      $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
      HEAP8[$1_1 + 24 | 0] = $2_1;
      HEAP8[$1_1 + 25 | 0] = $2_1 >>> 8;
      HEAP8[$1_1 + 26 | 0] = $2_1 >>> 16;
      HEAP8[$1_1 + 27 | 0] = $2_1 >>> 24;
      HEAP32[$0_1 + 24 >> 2] = 0;
      $2_1 = HEAP32[$0_1 + 28 >> 2];
      $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
      HEAP8[$1_1 + 28 | 0] = $2_1;
      HEAP8[$1_1 + 29 | 0] = $2_1 >>> 8;
      HEAP8[$1_1 + 30 | 0] = $2_1 >>> 16;
      HEAP8[$1_1 + 31 | 0] = $2_1 >>> 24;
      HEAP32[$0_1 + 28 >> 2] = 0;
      global$0 = $3_1 + 16 | 0;
    }
    function $31($0_1, $1_1, $2_1, $3_1) {
      var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0;
      $6_1 = global$0 - 880 | 0;
      global$0 = $6_1;
      label$1: {
        if (!$1_1) {
          FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689638, HEAP32[$0_1 + 172 >> 2]);
          $0_1 = 0;
          break label$1;
        }
        HEAP8[$1_1 | 0] = 0;
        HEAP8[$1_1 + 1 | 0] = 0;
        HEAP8[$1_1 + 2 | 0] = 0;
        HEAP8[$1_1 + 3 | 0] = 0;
        HEAP8[$1_1 + 4 | 0] = 0;
        HEAP8[$1_1 + 5 | 0] = 0;
        HEAP8[$1_1 + 6 | 0] = 0;
        HEAP8[$1_1 + 7 | 0] = 0;
        $4_1 = $1_1 + 56 | 0;
        HEAP8[$4_1 | 0] = 0;
        HEAP8[$4_1 + 1 | 0] = 0;
        HEAP8[$4_1 + 2 | 0] = 0;
        HEAP8[$4_1 + 3 | 0] = 0;
        HEAP8[$4_1 + 4 | 0] = 0;
        HEAP8[$4_1 + 5 | 0] = 0;
        HEAP8[$4_1 + 6 | 0] = 0;
        HEAP8[$4_1 + 7 | 0] = 0;
        $4_1 = $1_1 + 48 | 0;
        HEAP8[$4_1 | 0] = 0;
        HEAP8[$4_1 + 1 | 0] = 0;
        HEAP8[$4_1 + 2 | 0] = 0;
        HEAP8[$4_1 + 3 | 0] = 0;
        HEAP8[$4_1 + 4 | 0] = 0;
        HEAP8[$4_1 + 5 | 0] = 0;
        HEAP8[$4_1 + 6 | 0] = 0;
        HEAP8[$4_1 + 7 | 0] = 0;
        $4_1 = $1_1 + 40 | 0;
        HEAP8[$4_1 | 0] = 0;
        HEAP8[$4_1 + 1 | 0] = 0;
        HEAP8[$4_1 + 2 | 0] = 0;
        HEAP8[$4_1 + 3 | 0] = 0;
        HEAP8[$4_1 + 4 | 0] = 0;
        HEAP8[$4_1 + 5 | 0] = 0;
        HEAP8[$4_1 + 6 | 0] = 0;
        HEAP8[$4_1 + 7 | 0] = 0;
        $4_1 = $1_1 + 32 | 0;
        HEAP8[$4_1 | 0] = 0;
        HEAP8[$4_1 + 1 | 0] = 0;
        HEAP8[$4_1 + 2 | 0] = 0;
        HEAP8[$4_1 + 3 | 0] = 0;
        HEAP8[$4_1 + 4 | 0] = 0;
        HEAP8[$4_1 + 5 | 0] = 0;
        HEAP8[$4_1 + 6 | 0] = 0;
        HEAP8[$4_1 + 7 | 0] = 0;
        $4_1 = $1_1 + 24 | 0;
        HEAP8[$4_1 | 0] = 0;
        HEAP8[$4_1 + 1 | 0] = 0;
        HEAP8[$4_1 + 2 | 0] = 0;
        HEAP8[$4_1 + 3 | 0] = 0;
        HEAP8[$4_1 + 4 | 0] = 0;
        HEAP8[$4_1 + 5 | 0] = 0;
        HEAP8[$4_1 + 6 | 0] = 0;
        HEAP8[$4_1 + 7 | 0] = 0;
        $4_1 = $1_1 + 16 | 0;
        HEAP8[$4_1 | 0] = 0;
        HEAP8[$4_1 + 1 | 0] = 0;
        HEAP8[$4_1 + 2 | 0] = 0;
        HEAP8[$4_1 + 3 | 0] = 0;
        HEAP8[$4_1 + 4 | 0] = 0;
        HEAP8[$4_1 + 5 | 0] = 0;
        HEAP8[$4_1 + 6 | 0] = 0;
        HEAP8[$4_1 + 7 | 0] = 0;
        $4_1 = $1_1 + 8 | 0;
        HEAP8[$4_1 | 0] = 0;
        HEAP8[$4_1 + 1 | 0] = 0;
        HEAP8[$4_1 + 2 | 0] = 0;
        HEAP8[$4_1 + 3 | 0] = 0;
        HEAP8[$4_1 + 4 | 0] = 0;
        HEAP8[$4_1 + 5 | 0] = 0;
        HEAP8[$4_1 + 6 | 0] = 0;
        HEAP8[$4_1 + 7 | 0] = 0;
        if (!$2_1) {
          FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689668, HEAP32[$0_1 + 172 >> 2]);
          $0_1 = 0;
          break label$1;
        }
        $0_1 = 0;
        label$4: {
          if (($3_1 | 0) != 65) {
            if (($3_1 | 0) != 33) {
              break label$1;
            }
            if ((HEAPU8[$2_1 | 0] & 254) != 2) {
              break label$1;
            }
            if (!$32($6_1 + 840 | 0, $2_1 + 1 | 0)) {
              $3_1 = 0;
              break label$4;
            }
            $3_1 = ($33($6_1 + 672 | 0, $6_1 + 840 | 0, HEAPU8[$2_1 | 0] == 3) | 0) != 0;
            break label$4;
          }
          $3_1 = HEAPU8[$2_1 | 0];
          if ($3_1 >>> 0 > 7) {
            break label$1;
          }
          if (!(1 << $3_1 & 208)) {
            break label$1;
          }
          $3_1 = 0;
          if (!$32($6_1 + 800 | 0, $2_1 + 1 | 0)) {
            break label$4;
          }
          if (!$32($6_1 + 760 | 0, $2_1 + 33 | 0)) {
            break label$4;
          }
          $7_1 = $6_1 + 800 | 0;
          $5_1 = $7_1 + 8 | 0;
          $4_1 = HEAP32[$5_1 + 4 >> 2];
          $8_1 = $6_1 + 672 | 0;
          $3_1 = $8_1 + 8 | 0;
          HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
          HEAP32[$3_1 + 4 >> 2] = $4_1;
          $5_1 = $7_1 + 16 | 0;
          $4_1 = HEAP32[$5_1 + 4 >> 2];
          $3_1 = $8_1 + 16 | 0;
          HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
          HEAP32[$3_1 + 4 >> 2] = $4_1;
          $5_1 = $7_1 + 24 | 0;
          $4_1 = HEAP32[$5_1 + 4 >> 2];
          $3_1 = $8_1 + 24 | 0;
          HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
          HEAP32[$3_1 + 4 >> 2] = $4_1;
          $5_1 = $7_1 + 32 | 0;
          $4_1 = HEAP32[$5_1 + 4 >> 2];
          $3_1 = $8_1 + 32 | 0;
          HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
          HEAP32[$3_1 + 4 >> 2] = $4_1;
          $5_1 = $6_1 + 760 | 0;
          $4_1 = $5_1 + 8 | 0;
          $3_1 = HEAP32[$4_1 + 4 >> 2];
          $19_1 = $6_1 + 720 | 0;
          HEAP32[$19_1 >> 2] = HEAP32[$4_1 >> 2];
          HEAP32[$19_1 + 4 >> 2] = $3_1;
          $4_1 = $5_1 + 16 | 0;
          $3_1 = HEAP32[$4_1 + 4 >> 2];
          $14_1 = $6_1 + 728 | 0;
          HEAP32[$14_1 >> 2] = HEAP32[$4_1 >> 2];
          HEAP32[$14_1 + 4 >> 2] = $3_1;
          $4_1 = $5_1 + 24 | 0;
          $3_1 = HEAP32[$4_1 + 4 >> 2];
          $7_1 = $6_1 + 736 | 0;
          HEAP32[$7_1 >> 2] = HEAP32[$4_1 >> 2];
          HEAP32[$7_1 + 4 >> 2] = $3_1;
          $4_1 = $5_1 + 32 | 0;
          $3_1 = HEAP32[$4_1 + 4 >> 2];
          $23_1 = $6_1 + 744 | 0;
          HEAP32[$23_1 >> 2] = HEAP32[$4_1 >> 2];
          HEAP32[$23_1 + 4 >> 2] = $3_1;
          HEAP32[$6_1 + 752 >> 2] = 0;
          $3_1 = HEAP32[$6_1 + 804 >> 2];
          HEAP32[$6_1 + 672 >> 2] = HEAP32[$6_1 + 800 >> 2];
          HEAP32[$6_1 + 676 >> 2] = $3_1;
          $3_1 = HEAP32[$6_1 + 764 >> 2];
          HEAP32[$6_1 + 712 >> 2] = HEAP32[$6_1 + 760 >> 2];
          HEAP32[$6_1 + 716 >> 2] = $3_1;
          $2_1 = HEAPU8[$2_1 | 0];
          if (($2_1 & 254) == 6) {
            $3_1 = 0;
            if ((HEAP8[$6_1 + 760 | 0] & 1) == (($2_1 | 0) != 7 | 0)) {
              break label$4;
            }
          }
          $2_1 = HEAP32[$6_1 + 716 >> 2];
          $28_1 = $2_1;
          $9_1 = HEAP32[$6_1 + 712 >> 2];
          $3_1 = $9_1;
          $2_1 = $2_1 << 1 | $3_1 >>> 31;
          $15_1 = $6_1 + 96 | 0;
          $10_1 = HEAP32[$7_1 >> 2];
          $11_1 = HEAP32[$7_1 + 4 >> 2];
          $24_1 = $3_1 << 1;
          $30_1 = $2_1;
          $69($15_1, $10_1, $11_1, 0, 0, $24_1, $2_1, 0, 0);
          $2_1 = HEAP32[$19_1 + 4 >> 2];
          $25_1 = $2_1;
          $26_1 = HEAP32[$19_1 >> 2];
          $4_1 = $26_1;
          $2_1 = $2_1 << 1 | $4_1 >>> 31;
          $12_1 = $6_1 + 160 | 0;
          $13_1 = HEAP32[$14_1 >> 2];
          $14_1 = HEAP32[$14_1 + 4 >> 2];
          $4_1 = $4_1 << 1;
          $5_1 = $2_1;
          $69($12_1, $13_1, $14_1, 0, 0, $4_1, $2_1, 0, 0);
          $19_1 = $6_1 + 288 | 0;
          $3_1 = HEAP32[$23_1 >> 2];
          $2_1 = HEAP32[$23_1 + 4 >> 2];
          $69($19_1, $3_1, $2_1, 0, 0, $3_1, $2_1, 0, 0);
          $7_1 = $6_1 + 272 | 0;
          $69($7_1, HEAP32[$6_1 + 288 >> 2], HEAP32[$6_1 + 292 >> 2], 0, 0, 15632, 16, 0, 0);
          $2_1 = $2_1 << 1 | $3_1 >>> 31;
          $33_1 = $6_1 + 128 | 0;
          $17_1 = $3_1 << 1;
          $23_1 = $2_1;
          $69($33_1, $17_1, $2_1, 0, 0, $9_1, $28_1, 0, 0);
          $34_1 = $6_1 + 144 | 0;
          $69($34_1, $10_1, $11_1, 0, 0, $4_1, $5_1, 0, 0);
          $35_1 = $6_1 + 224 | 0;
          $69($35_1, $13_1, $14_1, 0, 0, $13_1, $14_1, 0, 0);
          $16_1 = $6_1 + 256 | 0;
          $2_1 = $19_1 + 8 | 0;
          $69($16_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
          $43_1 = $6_1 + 112 | 0;
          $69($43_1, $9_1, $28_1, 0, 0, $9_1, $28_1, 0, 0);
          $31_1 = $6_1 + 192 | 0;
          $69($31_1, $17_1, $23_1, 0, 0, $26_1, $25_1, 0, 0);
          $38_1 = $6_1 + 240 | 0;
          $69($38_1, $10_1, $11_1, 0, 0, $13_1 << 1, $14_1 << 1 | $13_1 >>> 31, 0, 0);
          $28_1 = HEAP32[$6_1 + 100 >> 2];
          $2_1 = $28_1 + HEAP32[$6_1 + 164 >> 2] | 0;
          $8_1 = HEAP32[$6_1 + 96 >> 2];
          $3_1 = HEAP32[$6_1 + 160 >> 2];
          $5_1 = $8_1 + $3_1 | 0;
          $4_1 = HEAP32[$6_1 + 272 >> 2];
          $39_1 = $5_1 + $4_1 | 0;
          $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $3_1 + HEAP32[$6_1 + 276 >> 2] | 0;
          $4_1 = $4_1 >>> 0 > $39_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $9_1 = ($3_1 | 0) == ($4_1 | 0) & $5_1 >>> 0 > $39_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
          $2_1 = $7_1 + 8 | 0;
          $19_1 = HEAP32[$2_1 >> 2];
          $7_1 = HEAP32[$2_1 + 4 >> 2];
          $8_1 = ($3_1 | 0) == ($28_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $3_1 >>> 0 < $28_1 >>> 0;
          $5_1 = $12_1 + 8 | 0;
          $3_1 = HEAP32[$5_1 >> 2];
          $2_1 = $15_1 + 8 | 0;
          $12_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
          $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
          $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $3_1 = $8_1 + $12_1 | 0;
          $2_1 = ($3_1 >>> 0 < $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $7_1 | 0;
          $5_1 = $3_1;
          $3_1 = $3_1 + $19_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $3_1;
          $3_1 = $3_1 + $9_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $40_1 = $4_1;
          $19_1 = $3_1 << 12 | $4_1 >>> 20;
          $5_1 = $2_1;
          $8_1 = $2_1 << 12 | $3_1 >>> 20;
          $21_1 = HEAP32[$6_1 + 144 >> 2];
          $3_1 = HEAP32[$6_1 + 224 >> 2];
          $12_1 = $21_1 + $3_1 | 0;
          $32_1 = HEAP32[$6_1 + 148 >> 2];
          $2_1 = $32_1 + HEAP32[$6_1 + 228 >> 2] | 0;
          $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $3_1 = HEAP32[$6_1 + 128 >> 2];
          $9_1 = $3_1 + $12_1 | 0;
          $15_1 = $2_1;
          $2_1 = $2_1 + HEAP32[$6_1 + 132 >> 2] | 0;
          $2_1 = $3_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $3_1 = HEAP32[$6_1 + 256 >> 2];
          $7_1 = $3_1 + $9_1 | 0;
          $4_1 = $2_1;
          $2_1 = $2_1 + HEAP32[$6_1 + 260 >> 2] | 0;
          $3_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $3_1 + $8_1 | 0;
          $44_1 = $6_1 + 32 | 0;
          $29_1 = $44_1;
          $19_1 = $7_1 + $19_1 | 0;
          $8_1 = $19_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $27_1 = ($3_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 > $19_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
          $22_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
          $2_1 = $16_1 + 8 | 0;
          $18_1 = HEAP32[$2_1 >> 2];
          $20_1 = HEAP32[$2_1 + 4 >> 2];
          $28_1 = ($4_1 | 0) == ($15_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $4_1 >>> 0 < $15_1 >>> 0;
          $2_1 = $33_1 + 8 | 0;
          $16_1 = HEAP32[$2_1 >> 2];
          $9_1 = HEAP32[$2_1 + 4 >> 2];
          $7_1 = ($15_1 | 0) == ($32_1 | 0) & $12_1 >>> 0 < $21_1 >>> 0 | $15_1 >>> 0 < $32_1 >>> 0;
          $4_1 = $35_1 + 8 | 0;
          $3_1 = HEAP32[$4_1 >> 2];
          $2_1 = $34_1 + 8 | 0;
          $12_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
          $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
          $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $3_1 = $7_1 + $12_1 | 0;
          $2_1 = ($3_1 >>> 0 < $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $9_1 | 0;
          $4_1 = $3_1;
          $3_1 = $3_1 + $16_1 | 0;
          $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $3_1;
          $3_1 = $3_1 + $28_1 | 0;
          $2_1 = ($4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $20_1 | 0;
          $4_1 = $3_1;
          $3_1 = $3_1 + $18_1 | 0;
          $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $3_1 + $22_1 | 0;
          $2_1 = $4_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $5_1 >>> 20 | 0;
          $3_1 = $4_1 + $5_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $3_1;
          $3_1 = $3_1 + $27_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $8_1;
          $7_1 = $3_1 << 12 | $4_1 >>> 20;
          $5_1 = $2_1;
          $8_1 = $2_1 << 12 | $3_1 >>> 20;
          $18_1 = HEAP32[$6_1 + 192 >> 2];
          $3_1 = HEAP32[$6_1 + 240 >> 2];
          $9_1 = $18_1 + $3_1 | 0;
          $22_1 = HEAP32[$6_1 + 196 >> 2];
          $2_1 = $22_1 + HEAP32[$6_1 + 244 >> 2] | 0;
          $3_1 = $3_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $3_1 + $8_1 | 0;
          $7_1 = $7_1 + $9_1 | 0;
          $2_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $15_1 = $7_1 << 4 & -16;
          $8_1 = $2_1;
          $12_1 = ($2_1 << 4 | $7_1 >>> 28) & 16777215;
          $28_1 = $4_1;
          $69($29_1, $15_1 | $4_1 >>> 16 & 15, $12_1, 0, 0, 977, 1, 0, 0);
          $45_1 = $6_1 + 16 | 0;
          $69($45_1, $26_1, $25_1, 0, 0, $24_1, $30_1, 0, 0);
          $20_1 = $6_1 + 208 | 0;
          $69($20_1, $17_1, $23_1, 0, 0, $13_1, $14_1, 0, 0);
          $16_1 = $6_1 + 320 | 0;
          $69($16_1, $10_1, $11_1, 0, 0, $10_1, $11_1, 0, 0);
          $46_1 = $6_1 + 80 | 0;
          $15_1 = $46_1;
          $12_1 = ($3_1 | 0) == ($2_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 > $2_1 >>> 0;
          $7_1 = ($3_1 | 0) == ($22_1 | 0) & $9_1 >>> 0 < $18_1 >>> 0 | $3_1 >>> 0 < $22_1 >>> 0;
          $4_1 = $38_1 + 8 | 0;
          $3_1 = HEAP32[$4_1 >> 2];
          $2_1 = $31_1 + 8 | 0;
          $9_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
          $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
          $2_1 = $3_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $7_1 + $9_1 | 0;
          $2_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $5_1 >>> 20 | 0;
          $3_1 = $4_1 + $5_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $3_1;
          $3_1 = $3_1 + $12_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $8_1 = $3_1 << 12 | $8_1 >>> 20;
          $4_1 = $2_1;
          $9_1 = $2_1 << 12 | $3_1 >>> 20;
          $18_1 = HEAP32[$6_1 + 212 >> 2];
          $2_1 = $18_1 + HEAP32[$6_1 + 324 >> 2] | 0;
          $12_1 = HEAP32[$6_1 + 208 >> 2];
          $3_1 = HEAP32[$6_1 + 320 >> 2];
          $5_1 = $12_1 + $3_1 | 0;
          $7_1 = $5_1;
          $8_1 = $5_1 + $8_1 | 0;
          $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $3_1 + $9_1 | 0;
          $5_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $69($15_1, $8_1, $5_1 & 1048575, 0, 0, 15632, 16, 0, 0);
          $69($6_1, $13_1, $14_1, 0, 0, $24_1, $30_1, 0, 0);
          $47_1 = $6_1 + 176 | 0;
          $69($47_1, $26_1, $25_1, 0, 0, $26_1, $25_1, 0, 0);
          $9_1 = $6_1 + 304 | 0;
          $69($9_1, $17_1, $23_1, 0, 0, $10_1, $11_1, 0, 0);
          $48_1 = $6_1 - -64 | 0;
          $11_1 = $48_1;
          $14_1 = ($3_1 | 0) == ($5_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $3_1 >>> 0 > $5_1 >>> 0;
          $7_1 = ($3_1 | 0) == ($18_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 < $18_1 >>> 0;
          $8_1 = $16_1 + 8 | 0;
          $3_1 = HEAP32[$8_1 >> 2];
          $2_1 = $20_1 + 8 | 0;
          $10_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
          $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
          $2_1 = $3_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $8_1 = $7_1 + $10_1 | 0;
          $2_1 = $8_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $4_1 >>> 20 | 0;
          $3_1 = $4_1 + $8_1 | 0;
          $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $3_1;
          $3_1 = $3_1 + $14_1 | 0;
          $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $8_1 = $3_1 << 12 | $5_1 >>> 20;
          $5_1 = HEAP32[$6_1 + 304 >> 2];
          $14_1 = $8_1 + $5_1 | 0;
          $4_1 = $2_1;
          $3_1 = $2_1 << 12 | $3_1 >>> 20;
          $2_1 = $3_1 + HEAP32[$6_1 + 308 >> 2] | 0;
          $2_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $69($11_1, $14_1, $2_1, 0, 0, 15632, 16, 0, 0);
          $49_1 = $6_1 + 48 | 0;
          $7_1 = $49_1;
          $8_1 = ($2_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $14_1 >>> 0 | $2_1 >>> 0 < $3_1 >>> 0;
          $2_1 = $9_1 + 8 | 0;
          $5_1 = HEAP32[$2_1 >> 2];
          $2_1 = HEAP32[$2_1 + 4 >> 2];
          $4_1 = $4_1 >>> 20 | 0;
          $3_1 = $4_1 + $5_1 | 0;
          $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $3_1;
          $3_1 = $3_1 + $8_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $69($7_1, $3_1, $2_1, 0, 0, 64028672, 65536, 0, 0);
          $2_1 = HEAP32[$6_1 + 676 >> 2];
          $13_1 = $2_1;
          $11_1 = HEAP32[$6_1 + 672 >> 2];
          $3_1 = $11_1;
          $2_1 = $2_1 << 1 | $3_1 >>> 31;
          $9_1 = $6_1 + 432 | 0;
          $16_1 = HEAP32[$6_1 + 696 >> 2];
          $15_1 = HEAP32[$6_1 + 700 >> 2];
          $27_1 = $3_1 << 1;
          $29_1 = $2_1;
          $69($9_1, $16_1, $15_1, 0, 0, $27_1, $2_1, 0, 0);
          $2_1 = HEAP32[$6_1 + 684 >> 2];
          $42_1 = $2_1;
          $41_1 = HEAP32[$6_1 + 680 >> 2];
          $4_1 = $41_1;
          $2_1 = $2_1 << 1 | $4_1 >>> 31;
          $10_1 = $6_1 + 496 | 0;
          $18_1 = HEAP32[$6_1 + 688 >> 2];
          $17_1 = HEAP32[$6_1 + 692 >> 2];
          $4_1 = $4_1 << 1;
          $5_1 = $2_1;
          $69($10_1, $18_1, $17_1, 0, 0, $4_1, $2_1, 0, 0);
          $14_1 = $6_1 + 624 | 0;
          $3_1 = HEAP32[$6_1 + 704 >> 2];
          $2_1 = HEAP32[$6_1 + 708 >> 2];
          $69($14_1, $3_1, $2_1, 0, 0, $3_1, $2_1, 0, 0);
          $7_1 = $6_1 + 608 | 0;
          $69($7_1, HEAP32[$6_1 + 624 >> 2], HEAP32[$6_1 + 628 >> 2], 0, 0, 15632, 16, 0, 0);
          $2_1 = $2_1 << 1 | $3_1 >>> 31;
          $26_1 = $6_1 + 464 | 0;
          $38_1 = $3_1 << 1;
          $22_1 = $2_1;
          $69($26_1, $38_1, $2_1, 0, 0, $11_1, $13_1, 0, 0);
          $32_1 = $6_1 + 480 | 0;
          $69($32_1, $16_1, $15_1, 0, 0, $4_1, $5_1, 0, 0);
          $33_1 = $6_1 + 560 | 0;
          $69($33_1, $18_1, $17_1, 0, 0, $18_1, $17_1, 0, 0);
          $12_1 = $6_1 + 592 | 0;
          $2_1 = $14_1 + 8 | 0;
          $69($12_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
          $50_1 = $6_1 + 448 | 0;
          $69($50_1, $11_1, $13_1, 0, 0, $11_1, $13_1, 0, 0);
          $36_1 = $6_1 + 528 | 0;
          $69($36_1, $38_1, $22_1, 0, 0, $41_1, $42_1, 0, 0);
          $37_1 = $6_1 + 576 | 0;
          $69($37_1, $16_1, $15_1, 0, 0, $18_1 << 1, $17_1 << 1 | $18_1 >>> 31, 0, 0);
          $13_1 = HEAP32[$6_1 + 436 >> 2];
          $2_1 = $13_1 + HEAP32[$6_1 + 500 >> 2] | 0;
          $8_1 = HEAP32[$6_1 + 432 >> 2];
          $3_1 = HEAP32[$6_1 + 496 >> 2];
          $4_1 = $8_1 + $3_1 | 0;
          $5_1 = HEAP32[$6_1 + 608 >> 2];
          $30_1 = $4_1 + $5_1 | 0;
          $3_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $3_1 + HEAP32[$6_1 + 612 >> 2] | 0;
          $5_1 = $5_1 >>> 0 > $30_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $11_1 = ($3_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $30_1 >>> 0 | $3_1 >>> 0 > $5_1 >>> 0;
          $2_1 = $7_1 + 8 | 0;
          $14_1 = HEAP32[$2_1 >> 2];
          $7_1 = HEAP32[$2_1 + 4 >> 2];
          $8_1 = ($3_1 | 0) == ($13_1 | 0) & $4_1 >>> 0 < $8_1 >>> 0 | $3_1 >>> 0 < $13_1 >>> 0;
          $4_1 = $10_1 + 8 | 0;
          $3_1 = HEAP32[$4_1 >> 2];
          $2_1 = $9_1 + 8 | 0;
          $10_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
          $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
          $2_1 = $3_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $3_1 = $8_1 + $10_1 | 0;
          $2_1 = ($3_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $7_1 | 0;
          $4_1 = $3_1;
          $3_1 = $3_1 + $14_1 | 0;
          $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $3_1;
          $3_1 = $3_1 + $11_1 | 0;
          $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $24_1 = $5_1;
          $14_1 = $3_1 << 12 | $5_1 >>> 20;
          $4_1 = $2_1;
          $8_1 = $2_1 << 12 | $3_1 >>> 20;
          $34_1 = HEAP32[$6_1 + 480 >> 2];
          $3_1 = HEAP32[$6_1 + 560 >> 2];
          $11_1 = $34_1 + $3_1 | 0;
          $25_1 = HEAP32[$6_1 + 484 >> 2];
          $2_1 = $25_1 + HEAP32[$6_1 + 564 >> 2] | 0;
          $2_1 = $3_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $3_1 = HEAP32[$6_1 + 464 >> 2];
          $7_1 = $3_1 + $11_1 | 0;
          $9_1 = $2_1;
          $2_1 = $2_1 + HEAP32[$6_1 + 468 >> 2] | 0;
          $2_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $3_1 = HEAP32[$6_1 + 592 >> 2];
          $5_1 = $3_1 + $7_1 | 0;
          $10_1 = $2_1;
          $2_1 = $2_1 + HEAP32[$6_1 + 596 >> 2] | 0;
          $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $3_1 + $8_1 | 0;
          $35_1 = $6_1 + 368 | 0;
          $14_1 = $5_1 + $14_1 | 0;
          $8_1 = $14_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $31_1 = ($3_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $14_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
          $21_1 = ($3_1 | 0) == ($10_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $3_1 >>> 0 < $10_1 >>> 0;
          $2_1 = $12_1 + 8 | 0;
          $20_1 = HEAP32[$2_1 >> 2];
          $23_1 = HEAP32[$2_1 + 4 >> 2];
          $13_1 = ($9_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $9_1 >>> 0 > $10_1 >>> 0;
          $2_1 = $26_1 + 8 | 0;
          $12_1 = HEAP32[$2_1 >> 2];
          $10_1 = HEAP32[$2_1 + 4 >> 2];
          $7_1 = ($9_1 | 0) == ($25_1 | 0) & $11_1 >>> 0 < $34_1 >>> 0 | $9_1 >>> 0 < $25_1 >>> 0;
          $5_1 = $33_1 + 8 | 0;
          $3_1 = HEAP32[$5_1 >> 2];
          $2_1 = $32_1 + 8 | 0;
          $11_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
          $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
          $2_1 = $3_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $3_1 = $7_1 + $11_1 | 0;
          $2_1 = ($3_1 >>> 0 < $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $10_1 | 0;
          $5_1 = $3_1;
          $3_1 = $3_1 + $12_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $3_1;
          $3_1 = $3_1 + $13_1 | 0;
          $2_1 = ($5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $23_1 | 0;
          $5_1 = $3_1;
          $3_1 = $3_1 + $20_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $3_1 + $21_1 | 0;
          $2_1 = $5_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $4_1 >>> 20 | 0;
          $3_1 = $4_1 + $5_1 | 0;
          $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $3_1;
          $3_1 = $3_1 + $31_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $8_1;
          $7_1 = $3_1 << 12 | $4_1 >>> 20;
          $5_1 = $2_1;
          $11_1 = $2_1 << 12 | $3_1 >>> 20;
          $21_1 = HEAP32[$6_1 + 532 >> 2];
          $2_1 = $21_1 + HEAP32[$6_1 + 580 >> 2] | 0;
          $13_1 = HEAP32[$6_1 + 528 >> 2];
          $3_1 = HEAP32[$6_1 + 576 >> 2];
          $8_1 = $13_1 + $3_1 | 0;
          $9_1 = $8_1;
          $7_1 = $8_1 + $7_1 | 0;
          $3_1 = $3_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $3_1 + $11_1 | 0;
          $10_1 = $7_1 << 4 & -16;
          $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $11_1 = ($8_1 << 4 | $7_1 >>> 28) & 16777215;
          $23_1 = $4_1;
          $69($35_1, $10_1 | $4_1 >>> 16 & 15, $11_1, 0, 0, 977, 1, 0, 0);
          $11_1 = HEAP32[$6_1 + 372 >> 2];
          $2_1 = $11_1 + HEAP32[$6_1 + 452 >> 2] | 0;
          $31_1 = HEAP32[$6_1 + 368 >> 2];
          $4_1 = HEAP32[$6_1 + 448 >> 2];
          $10_1 = $31_1 + $4_1 | 0;
          HEAP32[$6_1 + 840 >> 2] = $10_1;
          $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          HEAP32[$6_1 + 844 >> 2] = $4_1 & 1048575;
          $25_1 = $6_1 + 352 | 0;
          $69($25_1, $41_1, $42_1, 0, 0, $27_1, $29_1, 0, 0);
          $26_1 = $6_1 + 544 | 0;
          $69($26_1, $38_1, $22_1, 0, 0, $18_1, $17_1, 0, 0);
          $32_1 = $6_1 + 656 | 0;
          $69($32_1, $16_1, $15_1, 0, 0, $16_1, $15_1, 0, 0);
          $33_1 = $6_1 + 416 | 0;
          $20_1 = $33_1;
          $12_1 = ($3_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
          $9_1 = ($3_1 | 0) == ($21_1 | 0) & $9_1 >>> 0 < $13_1 >>> 0 | $3_1 >>> 0 < $21_1 >>> 0;
          $7_1 = $37_1 + 8 | 0;
          $3_1 = HEAP32[$7_1 >> 2];
          $2_1 = $36_1 + 8 | 0;
          $13_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
          $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
          $2_1 = $3_1 >>> 0 > $13_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $7_1 = $9_1 + $13_1 | 0;
          $2_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $5_1 >>> 20 | 0;
          $3_1 = $5_1 + $7_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $3_1;
          $3_1 = $3_1 + $12_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $9_1 = $3_1 << 12 | $8_1 >>> 20;
          $7_1 = $2_1;
          $8_1 = $2_1 << 12 | $3_1 >>> 20;
          $36_1 = HEAP32[$6_1 + 548 >> 2];
          $2_1 = $36_1 + HEAP32[$6_1 + 660 >> 2] | 0;
          $34_1 = HEAP32[$6_1 + 544 >> 2];
          $5_1 = HEAP32[$6_1 + 656 >> 2];
          $3_1 = $34_1 + $5_1 | 0;
          $21_1 = $3_1;
          $13_1 = $3_1 + $9_1 | 0;
          $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $5_1 + $8_1 | 0;
          $9_1 = $13_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $69($20_1, $13_1, $9_1 & 1048575, 0, 0, 15632, 16, 0, 0);
          $10_1 = ($4_1 | 0) == ($11_1 | 0) & $10_1 >>> 0 < $31_1 >>> 0 | $4_1 >>> 0 < $11_1 >>> 0;
          $8_1 = $50_1 + 8 | 0;
          $3_1 = HEAP32[$8_1 >> 2];
          $2_1 = $35_1 + 8 | 0;
          $12_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
          $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
          $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $3_1 = $10_1 + $12_1 | 0;
          $2_1 = $3_1 >>> 0 < $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $12_1 = $3_1 << 12 | $4_1 >>> 20;
          $8_1 = $2_1;
          $10_1 = $2_1 << 12 | $3_1 >>> 20;
          $35_1 = HEAP32[$6_1 + 416 >> 2];
          $3_1 = HEAP32[$6_1 + 352 >> 2];
          $20_1 = $35_1 + $3_1 | 0;
          $37_1 = HEAP32[$6_1 + 420 >> 2];
          $2_1 = $37_1 + HEAP32[$6_1 + 356 >> 2] | 0;
          $4_1 = $3_1 >>> 0 > $20_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $4_1 + $10_1 | 0;
          $12_1 = $12_1 + $20_1 | 0;
          $2_1 = $12_1 >>> 0 < $20_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          HEAP32[$6_1 + 848 >> 2] = $12_1;
          $10_1 = $2_1;
          HEAP32[$6_1 + 852 >> 2] = $2_1 & 1048575;
          $31_1 = $6_1 + 336 | 0;
          $69($31_1, $18_1, $17_1, 0, 0, $27_1, $29_1, 0, 0);
          $29_1 = $6_1 + 512 | 0;
          $69($29_1, $41_1, $42_1, 0, 0, $41_1, $42_1, 0, 0);
          $27_1 = $6_1 + 640 | 0;
          $69($27_1, $38_1, $22_1, 0, 0, $16_1, $15_1, 0, 0);
          $18_1 = $6_1 + 400 | 0;
          $16_1 = $18_1;
          $17_1 = ($5_1 | 0) == ($9_1 | 0) & $13_1 >>> 0 < $21_1 >>> 0 | $5_1 >>> 0 > $9_1 >>> 0;
          $13_1 = ($5_1 | 0) == ($36_1 | 0) & $21_1 >>> 0 < $34_1 >>> 0 | $5_1 >>> 0 < $36_1 >>> 0;
          $5_1 = $32_1 + 8 | 0;
          $3_1 = HEAP32[$5_1 >> 2];
          $2_1 = $26_1 + 8 | 0;
          $15_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
          $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
          $2_1 = $3_1 >>> 0 > $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $13_1 + $15_1 | 0;
          $2_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $7_1 = $7_1 >>> 20 | 0;
          $3_1 = $5_1 + $7_1 | 0;
          $2_1 = $7_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $3_1;
          $3_1 = $3_1 + $17_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $15_1 = $3_1 << 12 | $9_1 >>> 20;
          $7_1 = HEAP32[$6_1 + 640 >> 2];
          $9_1 = $15_1 + $7_1 | 0;
          $5_1 = $2_1;
          $21_1 = $2_1 << 12 | $3_1 >>> 20;
          $2_1 = $21_1 + HEAP32[$6_1 + 644 >> 2] | 0;
          $13_1 = $7_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $69($16_1, $9_1, $13_1, 0, 0, 15632, 16, 0, 0);
          $12_1 = ($4_1 | 0) == ($10_1 | 0) & $12_1 >>> 0 < $20_1 >>> 0 | $4_1 >>> 0 > $10_1 >>> 0;
          $11_1 = ($4_1 | 0) == ($37_1 | 0) & $20_1 >>> 0 < $35_1 >>> 0 | $4_1 >>> 0 < $37_1 >>> 0;
          $4_1 = $25_1 + 8 | 0;
          $3_1 = HEAP32[$4_1 >> 2];
          $2_1 = $33_1 + 8 | 0;
          $17_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
          $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
          $2_1 = $3_1 >>> 0 > $17_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $11_1 + $17_1 | 0;
          $2_1 = $4_1 >>> 0 < $17_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $8_1 = $8_1 >>> 20 | 0;
          $3_1 = $4_1 + $8_1 | 0;
          $2_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $3_1;
          $3_1 = $3_1 + $12_1 | 0;
          $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $11_1 = $3_1 << 12 | $10_1 >>> 20;
          $4_1 = $2_1;
          $8_1 = $2_1 << 12 | $3_1 >>> 20;
          $20_1 = HEAP32[$6_1 + 336 >> 2];
          $3_1 = HEAP32[$6_1 + 512 >> 2];
          $12_1 = $20_1 + $3_1 | 0;
          $22_1 = HEAP32[$6_1 + 340 >> 2];
          $2_1 = $22_1 + HEAP32[$6_1 + 516 >> 2] | 0;
          $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $3_1 = HEAP32[$6_1 + 400 >> 2];
          $10_1 = $3_1 + $12_1 | 0;
          $17_1 = $2_1;
          $2_1 = $2_1 + HEAP32[$6_1 + 404 >> 2] | 0;
          $3_1 = $3_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $3_1 + $8_1 | 0;
          $11_1 = $11_1 + $10_1 | 0;
          $2_1 = $11_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          HEAP32[$6_1 + 856 >> 2] = $11_1;
          $8_1 = $2_1;
          HEAP32[$6_1 + 860 >> 2] = $2_1 & 1048575;
          $16_1 = $6_1 + 384 | 0;
          $15_1 = ($13_1 | 0) == ($21_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $13_1 >>> 0 < $21_1 >>> 0;
          $2_1 = $27_1 + 8 | 0;
          $13_1 = HEAP32[$2_1 >> 2];
          $2_1 = HEAP32[$2_1 + 4 >> 2];
          $5_1 = $5_1 >>> 20 | 0;
          $7_1 = $5_1;
          $5_1 = $5_1 + $13_1 | 0;
          $2_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $7_1 = $5_1;
          $5_1 = $5_1 + $15_1 | 0;
          $2_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $69($16_1, $5_1, $2_1, 0, 0, 64028672, 65536, 0, 0);
          $15_1 = ($3_1 | 0) == ($8_1 | 0) & $11_1 >>> 0 < $10_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
          $13_1 = ($3_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 < $17_1 >>> 0;
          $2_1 = $18_1 + 8 | 0;
          $9_1 = HEAP32[$2_1 >> 2];
          $10_1 = HEAP32[$2_1 + 4 >> 2];
          $11_1 = ($17_1 | 0) == ($22_1 | 0) & $12_1 >>> 0 < $20_1 >>> 0 | $17_1 >>> 0 < $22_1 >>> 0;
          $7_1 = $29_1 + 8 | 0;
          $3_1 = HEAP32[$7_1 >> 2];
          $2_1 = $31_1 + 8 | 0;
          $12_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
          $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
          $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $3_1 = $11_1 + $12_1 | 0;
          $2_1 = ($3_1 >>> 0 < $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $10_1 | 0;
          $5_1 = $3_1;
          $3_1 = $3_1 + $9_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $7_1 = $3_1 + $13_1 | 0;
          $2_1 = $7_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $4_1 >>> 20 | 0;
          $3_1 = $4_1 + $7_1 | 0;
          $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $3_1;
          $3_1 = $3_1 + $15_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $7_1 = $3_1 << 12 | $8_1 >>> 20;
          $4_1 = $2_1;
          $10_1 = $2_1 << 12 | $3_1 >>> 20;
          $12_1 = HEAP32[$6_1 + 384 >> 2];
          $8_1 = $30_1 & -2;
          $3_1 = $12_1 + $8_1 | 0;
          $13_1 = HEAP32[$6_1 + 388 >> 2];
          $2_1 = $13_1 + ($24_1 & 1048575) | 0;
          $11_1 = $3_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $11_1 + $10_1 | 0;
          $5_1 = $7_1;
          $7_1 = $3_1;
          $8_1 = $5_1 + $3_1 | 0;
          HEAP32[$6_1 + 864 >> 2] = $8_1;
          $3_1 = $3_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          HEAP32[$6_1 + 868 >> 2] = $3_1 & 1048575;
          $9_1 = $23_1 & 65535;
          $10_1 = ($3_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $3_1 >>> 0 < $11_1 >>> 0;
          $5_1 = ($11_1 | 0) == ($13_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $11_1 >>> 0 < $13_1 >>> 0;
          $2_1 = $16_1 + 8 | 0;
          $8_1 = $5_1 + HEAP32[$2_1 >> 2] | 0;
          $2_1 = HEAP32[$2_1 + 4 >> 2];
          $2_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $4_1 >>> 20 | 0;
          $5_1 = $4_1;
          $4_1 = $4_1 + $8_1 | 0;
          $2_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $4_1;
          $4_1 = $4_1 + $10_1 | 0;
          $2_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $3_1 = $4_1 << 12 | $3_1 >>> 20;
          $5_1 = $3_1 + $14_1 | 0;
          $2_1 = $9_1 + ($2_1 << 12 | $4_1 >>> 20) | 0;
          HEAP32[$6_1 + 872 >> 2] = $5_1;
          HEAP32[$6_1 + 876 >> 2] = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $43_1 + 8 | 0;
          $7_1 = HEAP32[$2_1 >> 2];
          $8_1 = HEAP32[$2_1 + 4 >> 2];
          $2_1 = $44_1 + 8 | 0;
          $32_1 = HEAP32[$2_1 >> 2];
          $4_1 = HEAP32[$2_1 + 4 >> 2];
          $5_1 = HEAP32[$6_1 + 112 >> 2];
          $3_1 = HEAP32[$6_1 + 116 >> 2];
          $13_1 = HEAP32[$6_1 + 32 >> 2];
          $36_1 = HEAP32[$6_1 + 36 >> 2];
          $2_1 = $45_1 + 8 | 0;
          $20_1 = HEAP32[$2_1 >> 2];
          $16_1 = HEAP32[$2_1 + 4 >> 2];
          $2_1 = $46_1 + 8 | 0;
          $33_1 = HEAP32[$2_1 >> 2];
          $24_1 = HEAP32[$2_1 + 4 >> 2];
          $18_1 = HEAP32[$6_1 + 16 >> 2];
          $12_1 = HEAP32[$6_1 + 20 >> 2];
          $34_1 = HEAP32[$6_1 + 80 >> 2];
          $37_1 = HEAP32[$6_1 + 84 >> 2];
          $2_1 = $47_1 + 8 | 0;
          $15_1 = HEAP32[$2_1 >> 2];
          $17_1 = HEAP32[$2_1 + 4 >> 2];
          $2_1 = $6_1 + 8 | 0;
          $35_1 = HEAP32[$2_1 >> 2];
          $30_1 = HEAP32[$2_1 + 4 >> 2];
          $21_1 = HEAP32[$6_1 + 176 >> 2];
          $9_1 = HEAP32[$6_1 + 180 >> 2];
          $29_1 = HEAP32[$6_1 >> 2];
          $25_1 = HEAP32[$6_1 + 4 >> 2];
          $2_1 = $48_1 + 8 | 0;
          $11_1 = HEAP32[$2_1 >> 2];
          $14_1 = HEAP32[$2_1 + 4 >> 2];
          $27_1 = HEAP32[$6_1 + 64 >> 2];
          $10_1 = HEAP32[$6_1 + 68 >> 2];
          $31_1 = HEAP32[$6_1 + 48 >> 2];
          $26_1 = HEAP32[$6_1 + 52 >> 2];
          $2_1 = $49_1 + 8 | 0;
          $38_1 = HEAP32[$2_1 >> 2];
          $23_1 = HEAP32[$2_1 + 4 >> 2];
          $2_1 = $6_1 + 840 | 0;
          $34($2_1, $2_1, $6_1 + 672 | 0);
          $2_1 = $3_1 + $36_1 | 0;
          $3_1 = $5_1 + $13_1 | 0;
          $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $22_1 = $3_1;
          $3_1 = ($36_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $13_1 >>> 0 | $5_1 >>> 0 < $36_1 >>> 0;
          $2_1 = $4_1 + $8_1 | 0;
          $4_1 = $7_1 + $32_1 | 0;
          $2_1 = $4_1 >>> 0 < $32_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $3_1 = $3_1 + $4_1 | 0;
          $2_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $13_1 = $5_1;
          $7_1 = $3_1 << 12 | $5_1 >>> 20;
          $4_1 = $2_1;
          $8_1 = $2_1 << 12 | $3_1 >>> 20;
          $2_1 = $12_1 + $37_1 | 0;
          $5_1 = $18_1 + $34_1 | 0;
          $3_1 = $5_1 >>> 0 < $18_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $3_1 + $8_1 | 0;
          $18_1 = $5_1 + $7_1 | 0;
          $8_1 = $18_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $7_1 = ($3_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $18_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
          $3_1 = ($3_1 | 0) == ($37_1 | 0) & $5_1 >>> 0 < $34_1 >>> 0 | $3_1 >>> 0 < $37_1 >>> 0;
          $2_1 = $16_1 + $24_1 | 0;
          $5_1 = $20_1 + $33_1 | 0;
          $2_1 = $5_1 >>> 0 < $33_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $20_1 = $5_1;
          $5_1 = $3_1 + $5_1 | 0;
          $2_1 = $20_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $4_1 >>> 20 | 0;
          $3_1 = $4_1 + $5_1 | 0;
          $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $3_1;
          $3_1 = $3_1 + $7_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $12_1 = $8_1;
          $24_1 = $3_1 << 12 | $8_1 >>> 20;
          $5_1 = $2_1;
          $7_1 = $2_1 << 12 | $3_1 >>> 20;
          $2_1 = $9_1 + $25_1 | 0;
          $3_1 = $21_1 + $29_1 | 0;
          $4_1 = $3_1 >>> 0 < $21_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $10_1 + $4_1 | 0;
          $10_1 = $3_1;
          $8_1 = $3_1 + $27_1 | 0;
          $3_1 = $8_1 >>> 0 < $27_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $3_1 + $7_1 | 0;
          $9_1 = $8_1;
          $7_1 = $8_1 + $24_1 | 0;
          $8_1 = $8_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $20_1 = $7_1;
          $24_1 = ($3_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
          $2_1 = $4_1;
          $9_1 = ($2_1 | 0) == ($3_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $2_1 >>> 0 > $3_1 >>> 0;
          $4_1 = $11_1;
          $3_1 = $14_1;
          $7_1 = ($2_1 | 0) == ($25_1 | 0) & $10_1 >>> 0 < $29_1 >>> 0 | $2_1 >>> 0 < $25_1 >>> 0;
          $2_1 = $17_1 + $30_1 | 0;
          $14_1 = $15_1 + $35_1 | 0;
          $2_1 = $14_1 >>> 0 < $35_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $7_1 = $7_1 + $14_1 | 0;
          $2_1 = ($7_1 >>> 0 < $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $3_1 | 0;
          $3_1 = $4_1 + $7_1 | 0;
          $2_1 = $3_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $3_1 + $9_1 | 0;
          $2_1 = $4_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $5_1 >>> 20 | 0;
          $3_1 = $4_1 + $5_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $3_1;
          $3_1 = $3_1 + $24_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $9_1 = $8_1;
          $8_1 = $3_1 << 12 | $8_1 >>> 20;
          $4_1 = $2_1;
          $5_1 = $2_1 << 12 | $3_1 >>> 20;
          $3_1 = $39_1 & -2;
          $16_1 = $3_1 + $31_1 | 0;
          $2_1 = $26_1 + ($40_1 & 1048575) | 0;
          $3_1 = $3_1 >>> 0 > $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $3_1 + $5_1 | 0;
          $5_1 = $8_1 + $16_1 | 0;
          $2_1 = $5_1 >>> 0 < $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $40_1 = $5_1;
          $8_1 = $2_1;
          $21_1 = HEAP32[$6_1 + 864 >> 2];
          $29_1 = HEAP32[$6_1 + 868 >> 2];
          $27_1 = HEAP32[$6_1 + 856 >> 2];
          $30_1 = HEAP32[$6_1 + 860 >> 2];
          $24_1 = HEAP32[$6_1 + 848 >> 2];
          $10_1 = HEAP32[$6_1 + 852 >> 2];
          $7_1 = HEAP32[$6_1 + 844 >> 2];
          $14_1 = HEAP32[$6_1 + 872 >> 2];
          $5_1 = HEAP32[$6_1 + 876 >> 2];
          $39_1 = $5_1;
          $2_1 = HEAP32[$6_1 + 840 >> 2];
          $5_1 = __wasm_i64_mul($5_1 >>> 16 | 0, 0, 977, 1);
          $11_1 = $2_1 + $5_1 | 0;
          $2_1 = $7_1 + i64toi32_i32$HIGH_BITS | 0;
          $2_1 = $5_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $5_1 = $11_1 + 7 | 0;
          $2_1 = $5_1 >>> 0 < 7 ? $2_1 + 1 | 0 : $2_1;
          $15_1 = $5_1;
          $7_1 = $2_1;
          $2_1 = $10_1;
          $5_1 = $7_1 >>> 20 | 0;
          $10_1 = $5_1;
          $5_1 = $5_1 + $24_1 | 0;
          $2_1 = $10_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $17_1 = $5_1;
          $10_1 = $2_1;
          $2_1 = $30_1;
          $5_1 = $10_1 >>> 20 | 0;
          $11_1 = $5_1;
          $5_1 = $5_1 + $27_1 | 0;
          $2_1 = $11_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $30_1 = $5_1;
          $11_1 = $2_1;
          $2_1 = $29_1;
          $5_1 = $11_1 >>> 20 | 0;
          $29_1 = $5_1;
          $5_1 = $5_1 + $21_1 | 0;
          $2_1 = $29_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $24_1 = $5_1;
          $5_1 = $2_1;
          $27_1 = $15_1 - $22_1 | 0;
          $22_1 = ($7_1 & 1048575) - (($13_1 & 1048575) + ($15_1 >>> 0 < $22_1 >>> 0) | 0) | 0;
          $39_1 = $39_1 & 65535;
          $15_1 = $28_1 & 65535;
          $13_1 = ($3_1 | 0) == ($8_1 | 0) & $16_1 >>> 0 > $40_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
          $3_1 = ($3_1 | 0) == ($26_1 | 0) & $16_1 >>> 0 < $31_1 >>> 0 | $3_1 >>> 0 < $26_1 >>> 0;
          $7_1 = $3_1 + $38_1 | 0;
          $2_1 = $23_1;
          $2_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $4_1 >>> 20 | 0;
          $3_1 = $4_1 + $7_1 | 0;
          $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $3_1;
          $3_1 = $3_1 + $13_1 | 0;
          $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $3_1 << 12 | $8_1 >>> 20;
          $7_1 = $4_1 + $19_1 | 0;
          $2_1 = $15_1 + ($2_1 << 12 | $3_1 >>> 20) | 0;
          $2_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = $14_1 - $7_1 | 0;
          $2_1 = $39_1 - (($7_1 >>> 0 > $14_1 >>> 0) + $2_1 | 0) | 0;
          $7_1 = $5_1 >>> 20 | 0;
          $3_1 = $4_1 + $7_1 | 0;
          $2_1 = ($7_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + 262143 | 0;
          $3_1 = $3_1 - 4 | 0;
          $14_1 = $3_1 >>> 0 < 4294967292 ? $2_1 + 1 | 0 : $2_1;
          $4_1 = __wasm_i64_mul($14_1 >>> 16 | 0, 0, 977, 1);
          $7_1 = $4_1 + $27_1 | 0;
          $2_1 = $22_1 + i64toi32_i32$HIGH_BITS | 0;
          $2_1 = ($4_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + 4194299 | 0;
          $4_1 = $7_1 - 3908 | 0;
          $2_1 = $4_1 >>> 0 < 4294963388 ? $2_1 + 1 | 0 : $2_1;
          $28_1 = $4_1 ^ 976;
          $7_1 = $2_1 & 1048575;
          $16_1 = $7_1 ^ 1;
          if ((($28_1 | 0) != -1 | ($16_1 | 0) != 1048575) & ($4_1 | $7_1) != 0) {
            $3_1 = 0;
          } else {
            $15_1 = $24_1 - $40_1 | 0;
            $23_1 = ($5_1 & 1048575) - (($8_1 & 1048575) + ($24_1 >>> 0 < $40_1 >>> 0) | 0) | 0;
            $13_1 = $30_1 - $20_1 | 0;
            $19_1 = ($11_1 & 1048575) - (($9_1 & 1048575) + ($20_1 >>> 0 > $30_1 >>> 0) | 0) | 0;
            $4_1 = $2_1;
            $2_1 = ($10_1 & 1048575) - (($12_1 & 1048575) + ($17_1 >>> 0 < $18_1 >>> 0) | 0) | 0;
            $4_1 = $4_1 >>> 20 | 0;
            $5_1 = $4_1;
            $4_1 = $4_1 + ($17_1 - $18_1 | 0) | 0;
            $2_1 = ($5_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + 4194303 | 0;
            $7_1 = $4_1 - 4 | 0;
            $8_1 = $7_1 >>> 0 < 4294967292 ? $2_1 + 1 | 0 : $2_1;
            $2_1 = $19_1;
            $4_1 = $8_1 >>> 20 | 0;
            $5_1 = $4_1;
            $4_1 = $4_1 + $13_1 | 0;
            $2_1 = ($5_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + 4194303 | 0;
            $5_1 = $4_1 - 4 | 0;
            $4_1 = $5_1 >>> 0 < 4294967292 ? $2_1 + 1 | 0 : $2_1;
            $2_1 = $23_1;
            $19_1 = $4_1 >>> 20 | 0;
            $9_1 = $19_1;
            $19_1 = $15_1 + $19_1 | 0;
            $2_1 = ($9_1 >>> 0 > $19_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + 4194303 | 0;
            $19_1 = $19_1 - 4 | 0;
            $2_1 = $19_1 >>> 0 < 4294967292 ? $2_1 + 1 | 0 : $2_1;
            $7_1 = $19_1 & ($7_1 & $28_1 & $5_1);
            $8_1 = $2_1 & ($8_1 & $16_1 & $4_1);
            $4_1 = $3_1;
            $3_1 = $2_1;
            $2_1 = $14_1 & 65535;
            $3_1 = $3_1 >>> 20 | 0;
            $5_1 = $3_1;
            $3_1 = $3_1 + $4_1 | 0;
            $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $3_1 = ($3_1 & $7_1) == -1 & ($8_1 & ($2_1 ^ 983040)) == 1048575;
          }
        }
        if (!$3_1) {
          break label$1;
        }
        $35($1_1, $6_1 + 672 | 0);
        $0_1 = 1;
      }
      global$0 = $6_1 + 880 | 0;
      return $0_1;
    }
    function $32($0_1, $1_1) {
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0;
      $4_1 = $0_1;
      $2_1 = HEAPU8[$1_1 + 30 | 0];
      $0_1 = $2_1 >>> 24 | 0;
      $3_1 = HEAPU8[$1_1 + 31 | 0] | $2_1 << 8;
      $2_1 = $0_1;
      $5_1 = HEAPU8[$1_1 + 29 | 0];
      $0_1 = $5_1 >>> 16 | 0;
      $5_1 = $5_1 << 16 | $3_1;
      $3_1 = $0_1 | $2_1;
      $2_1 = HEAPU8[$1_1 + 28 | 0];
      $0_1 = $2_1 >>> 8 | 0;
      $2_1 = $2_1 << 24 | $5_1;
      $0_1 = HEAPU8[$1_1 + 27 | 0] | ($0_1 | $3_1) | HEAPU8[$1_1 + 26 | 0] << 8 | (HEAPU8[$1_1 + 25 | 0] & 15) << 16;
      $5_1 = $0_1;
      $13_1 = $2_1;
      HEAP32[$4_1 >> 2] = $2_1;
      HEAP32[$4_1 + 4 >> 2] = $0_1;
      $2_1 = HEAPU8[$1_1 + 24 | 0];
      $0_1 = $2_1 >>> 28 | 0;
      $6_1 = $2_1 << 4 | HEAPU8[$1_1 + 25 | 0] >>> 4;
      $2_1 = $0_1;
      $3_1 = HEAPU8[$1_1 + 23 | 0];
      $0_1 = $3_1 >>> 20 | 0;
      $3_1 = $3_1 << 12 | $6_1;
      $6_1 = $0_1 | $2_1;
      $2_1 = HEAPU8[$1_1 + 22 | 0];
      $0_1 = $2_1 >>> 12 | 0;
      $3_1 = $2_1 << 20 | $3_1;
      $6_1 = $0_1 | $6_1;
      $2_1 = HEAPU8[$1_1 + 21 | 0];
      $0_1 = $2_1 >>> 4 | 0;
      $2_1 = $2_1 << 28 | $3_1;
      $3_1 = $0_1 | $6_1 | HEAPU8[$1_1 + 20 | 0] << 4;
      $0_1 = HEAPU8[$1_1 + 19 | 0] << 12;
      $6_1 = $2_1;
      HEAP32[$4_1 + 8 >> 2] = $2_1;
      $10_1 = $0_1 | $3_1;
      HEAP32[$4_1 + 12 >> 2] = $10_1;
      $2_1 = HEAPU8[$1_1 + 17 | 0];
      $0_1 = $2_1 >>> 24 | 0;
      $8_1 = HEAPU8[$1_1 + 18 | 0] | $2_1 << 8;
      $2_1 = $0_1;
      $3_1 = HEAPU8[$1_1 + 16 | 0];
      $0_1 = $3_1 >>> 16 | 0;
      $3_1 = $3_1 << 16 | $8_1;
      $8_1 = $0_1 | $2_1;
      $2_1 = HEAPU8[$1_1 + 15 | 0];
      $0_1 = $2_1 >>> 8 | 0;
      $2_1 = $2_1 << 24 | $3_1;
      $3_1 = HEAPU8[$1_1 + 14 | 0] | ($0_1 | $8_1) | HEAPU8[$1_1 + 13 | 0] << 8;
      $0_1 = (HEAPU8[$1_1 + 12 | 0] & 15) << 16;
      $8_1 = $2_1;
      HEAP32[$4_1 + 16 >> 2] = $2_1;
      $11_1 = $0_1 | $3_1;
      HEAP32[$4_1 + 20 >> 2] = $11_1;
      $2_1 = HEAPU8[$1_1 + 11 | 0];
      $0_1 = $2_1 >>> 28 | 0;
      $7_1 = $2_1 << 4 | HEAPU8[$1_1 + 12 | 0] >>> 4;
      $2_1 = $0_1;
      $3_1 = HEAPU8[$1_1 + 10 | 0];
      $0_1 = $3_1 >>> 20 | 0;
      $3_1 = $3_1 << 12 | $7_1;
      $7_1 = $0_1 | $2_1;
      $2_1 = HEAPU8[$1_1 + 9 | 0];
      $0_1 = $2_1 >>> 12 | 0;
      $3_1 = $2_1 << 20 | $3_1;
      $7_1 = $0_1 | $7_1;
      $2_1 = HEAPU8[$1_1 + 8 | 0];
      $0_1 = $2_1 >>> 4 | 0;
      $2_1 = $2_1 << 28 | $3_1;
      $3_1 = $0_1 | $7_1 | HEAPU8[$1_1 + 7 | 0] << 4;
      $0_1 = HEAPU8[$1_1 + 6 | 0] << 12;
      $7_1 = $2_1;
      HEAP32[$4_1 + 24 >> 2] = $2_1;
      $12_1 = $0_1 | $3_1;
      HEAP32[$4_1 + 28 >> 2] = $12_1;
      $2_1 = HEAPU8[$1_1 + 4 | 0];
      $0_1 = $2_1 >>> 24 | 0;
      $9_1 = HEAPU8[$1_1 + 5 | 0] | $2_1 << 8;
      $2_1 = $0_1;
      $3_1 = HEAPU8[$1_1 + 3 | 0];
      $0_1 = $3_1 >>> 16 | 0;
      $3_1 = $3_1 << 16 | $9_1;
      $9_1 = $0_1 | $2_1;
      $2_1 = HEAPU8[$1_1 + 2 | 0];
      $0_1 = $2_1 >>> 8 | 0;
      $2_1 = $2_1 << 24 | $3_1;
      $3_1 = HEAPU8[$1_1 + 1 | 0] | ($0_1 | $9_1);
      $0_1 = HEAPU8[$1_1 | 0] << 8;
      HEAP32[$4_1 + 32 >> 2] = $2_1;
      $0_1 = $0_1 | $3_1;
      HEAP32[$4_1 + 36 >> 2] = $0_1;
      return ($6_1 & $8_1 & $7_1) != -1 | ($10_1 & $11_1 & $12_1) != 1048575 | (($2_1 | 0) != -1 | ($0_1 | 0) != 65535) | (($5_1 | 0) == 1048574 & $13_1 >>> 0 < 4294966319 | $5_1 >>> 0 < 1048574);
    }
    function $33($0_1, $1_1, $2_1) {
      var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0;
      $6_1 = global$0 - 7616 | 0;
      global$0 = $6_1;
      $5_1 = $1_1 + 32 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $3_1 = $0_1 + 32 | 0;
      HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$3_1 + 4 >> 2] = $4_1;
      $5_1 = $1_1 + 24 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $3_1 = $0_1 + 24 | 0;
      HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$3_1 + 4 >> 2] = $4_1;
      $5_1 = $1_1 + 16 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $3_1 = $0_1 + 16 | 0;
      HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$3_1 + 4 >> 2] = $4_1;
      $5_1 = $1_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $3_1 = $0_1 + 8 | 0;
      HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$3_1 + 4 >> 2] = $4_1;
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$0_1 + 4 >> 2] = $3_1;
      $3_1 = $6_1 + 7096 | 0;
      $54($3_1, $1_1);
      $41_1 = $6_1 + 7056 | 0;
      $34($41_1, $1_1, $3_1);
      HEAP32[$0_1 + 80 >> 2] = 0;
      $3_1 = HEAP32[$6_1 + 7060 >> 2];
      $4_1 = HEAP32[$6_1 + 7056 >> 2] + 7 | 0;
      $1_1 = $4_1 >>> 0 < 7 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1;
      HEAP32[$6_1 + 7056 >> 2] = $3_1;
      HEAP32[$6_1 + 7060 >> 2] = $1_1;
      $13_1 = $6_1 + 6848 | 0;
      $21_1 = HEAP32[$6_1 + 7080 >> 2];
      $17_1 = HEAP32[$6_1 + 7084 >> 2];
      $28_1 = $3_1 << 1;
      $7_1 = $3_1;
      $22_1 = $1_1 << 1 | $3_1 >>> 31;
      $69($13_1, $21_1, $17_1, 0, 0, $28_1, $22_1, 0, 0);
      $3_1 = HEAP32[$6_1 + 7068 >> 2];
      $40_1 = $3_1;
      $33_1 = HEAP32[$6_1 + 7064 >> 2];
      $5_1 = $33_1;
      $3_1 = $3_1 << 1 | $5_1 >>> 31;
      $12_1 = $6_1 + 6880 | 0;
      $24_1 = HEAP32[$6_1 + 7072 >> 2];
      $18_1 = HEAP32[$6_1 + 7076 >> 2];
      $5_1 = $5_1 << 1;
      $8_1 = $3_1;
      $69($12_1, $24_1, $18_1, 0, 0, $5_1, $3_1, 0, 0);
      $9_1 = $6_1 + 7008 | 0;
      $4_1 = HEAP32[$6_1 + 7088 >> 2];
      $3_1 = HEAP32[$6_1 + 7092 >> 2];
      $69($9_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
      $10_1 = $6_1 + 6992 | 0;
      $69($10_1, HEAP32[$6_1 + 7008 >> 2], HEAP32[$6_1 + 7012 >> 2], 0, 0, 15632, 16, 0, 0);
      $3_1 = $3_1 << 1 | $4_1 >>> 31;
      $31_1 = $6_1 + 6800 | 0;
      $23_1 = $4_1 << 1;
      $20_1 = $3_1;
      $69($31_1, $23_1, $3_1, 0, 0, $7_1, $1_1, 0, 0);
      $37_1 = $6_1 + 6864 | 0;
      $69($37_1, $21_1, $17_1, 0, 0, $5_1, $8_1, 0, 0);
      $30_1 = $6_1 + 6944 | 0;
      $69($30_1, $24_1, $18_1, 0, 0, $24_1, $18_1, 0, 0);
      $14_1 = $6_1 + 6976 | 0;
      $3_1 = $9_1 + 8 | 0;
      $69($14_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $39_1 = $6_1 + 6720 | 0;
      $69($39_1, $7_1, $1_1, 0, 0, $7_1, $1_1, 0, 0);
      $38_1 = $6_1 + 6912 | 0;
      $69($38_1, $23_1, $20_1, 0, 0, $33_1, $40_1, 0, 0);
      $35_1 = $6_1 + 6960 | 0;
      $69($35_1, $21_1, $17_1, 0, 0, $24_1 << 1, $18_1 << 1 | $24_1 >>> 31, 0, 0);
      $16_1 = HEAP32[$6_1 + 6852 >> 2];
      $3_1 = $16_1 + HEAP32[$6_1 + 6884 >> 2] | 0;
      $8_1 = HEAP32[$6_1 + 6848 >> 2];
      $4_1 = HEAP32[$6_1 + 6880 >> 2];
      $1_1 = $8_1 + $4_1 | 0;
      $5_1 = HEAP32[$6_1 + 6992 >> 2];
      $15_1 = $1_1 + $5_1 | 0;
      $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + HEAP32[$6_1 + 6996 >> 2] | 0;
      $5_1 = $5_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $15_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
      $3_1 = $10_1 + 8 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $7_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = ($4_1 | 0) == ($16_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
      $3_1 = $12_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $13_1 + 8 | 0;
      $10_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $10_1 | 0;
      $3_1 = ($1_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $11_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $16_1 = $5_1;
      $11_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $32_1 = HEAP32[$6_1 + 6864 >> 2];
      $1_1 = HEAP32[$6_1 + 6944 >> 2];
      $9_1 = $32_1 + $1_1 | 0;
      $34_1 = HEAP32[$6_1 + 6868 >> 2];
      $3_1 = $34_1 + HEAP32[$6_1 + 6948 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 6800 >> 2];
      $7_1 = $1_1 + $9_1 | 0;
      $12_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 6804 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 6976 >> 2];
      $5_1 = $1_1 + $7_1 | 0;
      $10_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 6980 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $36_1 = $6_1 + 6736 | 0;
      $29_1 = $36_1;
      $11_1 = $5_1 + $11_1 | 0;
      $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $27_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
      $25_1 = ($1_1 | 0) == ($10_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $10_1 >>> 0;
      $1_1 = $14_1 + 8 | 0;
      $19_1 = HEAP32[$1_1 >> 2];
      $26_1 = HEAP32[$1_1 + 4 >> 2];
      $13_1 = ($10_1 | 0) == ($12_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $10_1 >>> 0 < $12_1 >>> 0;
      $1_1 = $31_1 + 8 | 0;
      $14_1 = HEAP32[$1_1 >> 2];
      $10_1 = HEAP32[$1_1 + 4 >> 2];
      $7_1 = ($12_1 | 0) == ($34_1 | 0) & $9_1 >>> 0 < $32_1 >>> 0 | $12_1 >>> 0 < $34_1 >>> 0;
      $3_1 = $30_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $37_1 + 8 | 0;
      $9_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $7_1 + $9_1 | 0;
      $3_1 = ($1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $14_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $13_1 | 0;
      $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $19_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1 + $25_1 | 0;
      $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $27_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $8_1;
      $7_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $14_1 = HEAP32[$6_1 + 6912 >> 2];
      $1_1 = HEAP32[$6_1 + 6960 >> 2];
      $10_1 = $14_1 + $1_1 | 0;
      $19_1 = HEAP32[$6_1 + 6916 >> 2];
      $3_1 = $19_1 + HEAP32[$6_1 + 6964 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $7_1 = $7_1 + $10_1 | 0;
      $3_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $7_1 << 4 & -16;
      $8_1 = $3_1;
      $9_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
      $13_1 = $4_1;
      $69($29_1, $12_1 | $4_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
      $27_1 = HEAP32[$6_1 + 6740 >> 2];
      $3_1 = $27_1 + HEAP32[$6_1 + 6724 >> 2] | 0;
      $25_1 = HEAP32[$6_1 + 6736 >> 2];
      $4_1 = HEAP32[$6_1 + 6720 >> 2];
      $9_1 = $25_1 + $4_1 | 0;
      HEAP32[$6_1 + 7576 >> 2] = $9_1;
      $4_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 7580 >> 2] = $4_1 & 1048575;
      $31_1 = $6_1 + 6832 | 0;
      $69($31_1, $33_1, $40_1, 0, 0, $28_1, $22_1, 0, 0);
      $37_1 = $6_1 + 6928 | 0;
      $69($37_1, $23_1, $20_1, 0, 0, $24_1, $18_1, 0, 0);
      $30_1 = $6_1 + 7040 | 0;
      $69($30_1, $21_1, $17_1, 0, 0, $21_1, $17_1, 0, 0);
      $32_1 = $6_1 + 6784 | 0;
      $26_1 = $32_1;
      $12_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
      $10_1 = ($1_1 | 0) == ($19_1 | 0) & $10_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $19_1 >>> 0;
      $3_1 = $35_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $1_1 = $38_1 + 8 | 0;
      $14_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $10_1 + $14_1 | 0;
      $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $5_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $12_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $1_1 << 12 | $8_1 >>> 20;
      $7_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $35_1 = HEAP32[$6_1 + 6932 >> 2];
      $3_1 = $35_1 + HEAP32[$6_1 + 7044 >> 2] | 0;
      $29_1 = HEAP32[$6_1 + 6928 >> 2];
      $5_1 = HEAP32[$6_1 + 7040 >> 2];
      $1_1 = $29_1 + $5_1 | 0;
      $19_1 = $1_1;
      $14_1 = $1_1 + $10_1 | 0;
      $5_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $5_1 + $8_1 | 0;
      $10_1 = $14_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($26_1, $14_1, $10_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $9_1 = ($4_1 | 0) == ($27_1 | 0) & $9_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $27_1 >>> 0;
      $3_1 = $39_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $1_1 = $36_1 + 8 | 0;
      $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $9_1 + $12_1 | 0;
      $3_1 = $1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $1_1 << 12 | $4_1 >>> 20;
      $8_1 = $3_1;
      $9_1 = $3_1 << 12 | $1_1 >>> 20;
      $27_1 = HEAP32[$6_1 + 6784 >> 2];
      $1_1 = HEAP32[$6_1 + 6832 >> 2];
      $26_1 = $27_1 + $1_1 | 0;
      $36_1 = HEAP32[$6_1 + 6788 >> 2];
      $3_1 = $36_1 + HEAP32[$6_1 + 6836 >> 2] | 0;
      $4_1 = $1_1 >>> 0 > $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $9_1 | 0;
      $12_1 = $12_1 + $26_1 | 0;
      $3_1 = $12_1 >>> 0 < $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 7584 >> 2] = $12_1;
      $9_1 = $3_1;
      HEAP32[$6_1 + 7588 >> 2] = $3_1 & 1048575;
      $25_1 = $6_1 + 6816 | 0;
      $69($25_1, $24_1, $18_1, 0, 0, $28_1, $22_1, 0, 0);
      $22_1 = $6_1 + 6896 | 0;
      $69($22_1, $33_1, $40_1, 0, 0, $33_1, $40_1, 0, 0);
      $28_1 = $6_1 + 7024 | 0;
      $69($28_1, $23_1, $20_1, 0, 0, $21_1, $17_1, 0, 0);
      $24_1 = $6_1 + 6768 | 0;
      $21_1 = $24_1;
      $18_1 = ($5_1 | 0) == ($10_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $5_1 >>> 0 > $10_1 >>> 0;
      $14_1 = ($5_1 | 0) == ($35_1 | 0) & $19_1 >>> 0 < $29_1 >>> 0 | $5_1 >>> 0 < $35_1 >>> 0;
      $3_1 = $30_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $37_1 + 8 | 0;
      $17_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $14_1 + $17_1 | 0;
      $3_1 = $5_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $7_1 >>> 20 | 0;
      $1_1 = $5_1 + $7_1 | 0;
      $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $18_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $17_1 = $1_1 << 12 | $10_1 >>> 20;
      $7_1 = HEAP32[$6_1 + 7024 >> 2];
      $10_1 = $17_1 + $7_1 | 0;
      $5_1 = $3_1;
      $19_1 = $3_1 << 12 | $1_1 >>> 20;
      $3_1 = $19_1 + HEAP32[$6_1 + 7028 >> 2] | 0;
      $14_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($21_1, $10_1, $14_1, 0, 0, 15632, 16, 0, 0);
      $12_1 = ($4_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $26_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
      $7_1 = ($4_1 | 0) == ($36_1 | 0) & $26_1 >>> 0 < $27_1 >>> 0 | $4_1 >>> 0 < $36_1 >>> 0;
      $3_1 = $31_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $32_1 + 8 | 0;
      $18_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $18_1 | 0;
      $3_1 = $4_1 >>> 0 < $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $8_1 >>> 20 | 0;
      $1_1 = $4_1 + $8_1 | 0;
      $3_1 = $8_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $12_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $9_1 >>> 20;
      $4_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $26_1 = HEAP32[$6_1 + 6816 >> 2];
      $1_1 = HEAP32[$6_1 + 6896 >> 2];
      $12_1 = $26_1 + $1_1 | 0;
      $20_1 = HEAP32[$6_1 + 6820 >> 2];
      $3_1 = $20_1 + HEAP32[$6_1 + 6900 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 6768 >> 2];
      $9_1 = $1_1 + $12_1 | 0;
      $18_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 6772 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $7_1 = $7_1 + $9_1 | 0;
      $3_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 7592 >> 2] = $7_1;
      $8_1 = $3_1;
      HEAP32[$6_1 + 7596 >> 2] = $3_1 & 1048575;
      $21_1 = $6_1 + 6752 | 0;
      $17_1 = ($14_1 | 0) == ($19_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $14_1 >>> 0 < $19_1 >>> 0;
      $3_1 = $28_1 + 8 | 0;
      $14_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $5_1 = $5_1 >>> 20 | 0;
      $10_1 = $5_1;
      $5_1 = $5_1 + $14_1 | 0;
      $3_1 = $10_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $5_1;
      $5_1 = $5_1 + $17_1 | 0;
      $3_1 = $10_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($21_1, $5_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $17_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
      $14_1 = ($1_1 | 0) == ($18_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $18_1 >>> 0;
      $1_1 = $24_1 + 8 | 0;
      $10_1 = HEAP32[$1_1 >> 2];
      $9_1 = HEAP32[$1_1 + 4 >> 2];
      $7_1 = ($18_1 | 0) == ($20_1 | 0) & $12_1 >>> 0 < $26_1 >>> 0 | $18_1 >>> 0 < $20_1 >>> 0;
      $3_1 = $22_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $25_1 + 8 | 0;
      $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $7_1 + $12_1 | 0;
      $3_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $9_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1 + $14_1 | 0;
      $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $17_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $1_1 << 12 | $8_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $12_1 = HEAP32[$6_1 + 6752 >> 2];
      $1_1 = $15_1 & -2;
      $8_1 = $12_1 + $1_1 | 0;
      $14_1 = HEAP32[$6_1 + 6756 >> 2];
      $3_1 = $14_1 + ($16_1 & 1048575) | 0;
      $7_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $7_1 + $5_1 | 0;
      $5_1 = $8_1 + $9_1 | 0;
      $3_1 = $5_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 7600 >> 2] = $5_1;
      $1_1 = $3_1;
      HEAP32[$6_1 + 7604 >> 2] = $3_1 & 1048575;
      $10_1 = $13_1 & 65535;
      $9_1 = ($3_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $3_1 >>> 0 < $7_1 >>> 0;
      $5_1 = ($7_1 | 0) == ($14_1 | 0) & $8_1 >>> 0 < $12_1 >>> 0 | $7_1 >>> 0 < $14_1 >>> 0;
      $3_1 = $21_1 + 8 | 0;
      $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $9_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $4_1 << 12 | $1_1 >>> 20;
      $5_1 = $1_1 + $11_1 | 0;
      $3_1 = $10_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
      HEAP32[$6_1 + 7608 >> 2] = $5_1;
      HEAP32[$6_1 + 7612 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $40_1 = $6_1 + 7576 | 0;
      $34($40_1, $40_1, $41_1);
      $1_1 = HEAP32[$6_1 + 7580 >> 2];
      $16_1 = $1_1;
      $13_1 = HEAP32[$6_1 + 7576 >> 2];
      $7_1 = $13_1;
      $3_1 = $1_1 << 1 | $7_1 >>> 31;
      $12_1 = $6_1 + 6448 | 0;
      $24_1 = HEAP32[$6_1 + 7600 >> 2];
      $26_1 = HEAP32[$6_1 + 7604 >> 2];
      $19_1 = $7_1 << 1;
      $23_1 = $3_1;
      $69($12_1, $24_1, $26_1, 0, 0, $19_1, $3_1, 0, 0);
      $1_1 = HEAP32[$6_1 + 7588 >> 2];
      $44_1 = $1_1;
      $43_1 = HEAP32[$6_1 + 7584 >> 2];
      $4_1 = $43_1;
      $3_1 = $1_1 << 1 | $4_1 >>> 31;
      $10_1 = $6_1 + 6656 | 0;
      $28_1 = HEAP32[$6_1 + 7592 >> 2];
      $21_1 = HEAP32[$6_1 + 7596 >> 2];
      $4_1 = $4_1 << 1;
      $5_1 = $3_1;
      $69($10_1, $28_1, $21_1, 0, 0, $4_1, $3_1, 0, 0);
      $9_1 = $6_1 + 6608 | 0;
      $8_1 = HEAP32[$6_1 + 7608 >> 2];
      $1_1 = HEAP32[$6_1 + 7612 >> 2];
      $69($9_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
      $11_1 = $6_1 + 6592 | 0;
      $69($11_1, HEAP32[$6_1 + 6608 >> 2], HEAP32[$6_1 + 6612 >> 2], 0, 0, 15632, 16, 0, 0);
      $3_1 = $1_1 << 1 | $8_1 >>> 31;
      $36_1 = $6_1 + 6560 | 0;
      $27_1 = $8_1 << 1;
      $22_1 = $3_1;
      $69($36_1, $27_1, $3_1, 0, 0, $7_1, $16_1, 0, 0);
      $31_1 = $6_1 + 6464 | 0;
      $69($31_1, $24_1, $26_1, 0, 0, $4_1, $5_1, 0, 0);
      $37_1 = $6_1 + 6640 | 0;
      $69($37_1, $28_1, $21_1, 0, 0, $28_1, $21_1, 0, 0);
      $14_1 = $6_1 + 6576 | 0;
      $1_1 = $9_1 + 8 | 0;
      $69($14_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $39_1 = $6_1 + 6704 | 0;
      $69($39_1, $7_1, $16_1, 0, 0, $7_1, $16_1, 0, 0);
      $38_1 = $6_1 + 6544 | 0;
      $69($38_1, $27_1, $3_1, 0, 0, $43_1, $44_1, 0, 0);
      $30_1 = $6_1 + 6480 | 0;
      $69($30_1, $24_1, $26_1, 0, 0, $28_1 << 1, $21_1 << 1 | $28_1 >>> 31, 0, 0);
      $13_1 = HEAP32[$6_1 + 6452 >> 2];
      $3_1 = $13_1 + HEAP32[$6_1 + 6660 >> 2] | 0;
      $8_1 = HEAP32[$6_1 + 6448 >> 2];
      $4_1 = HEAP32[$6_1 + 6656 >> 2];
      $1_1 = $8_1 + $4_1 | 0;
      $5_1 = HEAP32[$6_1 + 6592 >> 2];
      $17_1 = $1_1 + $5_1 | 0;
      $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + HEAP32[$6_1 + 6596 >> 2] | 0;
      $5_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $17_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
      $3_1 = $11_1 + 8 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $7_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = ($4_1 | 0) == ($13_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $13_1 >>> 0;
      $3_1 = $10_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $12_1 + 8 | 0;
      $10_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $10_1 | 0;
      $3_1 = ($1_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $11_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $18_1 = $5_1;
      $11_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $32_1 = HEAP32[$6_1 + 6464 >> 2];
      $1_1 = HEAP32[$6_1 + 6640 >> 2];
      $9_1 = $32_1 + $1_1 | 0;
      $35_1 = HEAP32[$6_1 + 6468 >> 2];
      $3_1 = $35_1 + HEAP32[$6_1 + 6644 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 6560 >> 2];
      $7_1 = $1_1 + $9_1 | 0;
      $12_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 6564 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 6576 >> 2];
      $5_1 = $1_1 + $7_1 | 0;
      $10_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 6580 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $29_1 = $6_1 + 6384 | 0;
      $11_1 = $5_1 + $11_1 | 0;
      $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $25_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
      $20_1 = ($1_1 | 0) == ($10_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $10_1 >>> 0;
      $1_1 = $14_1 + 8 | 0;
      $15_1 = HEAP32[$1_1 >> 2];
      $16_1 = HEAP32[$1_1 + 4 >> 2];
      $13_1 = ($10_1 | 0) == ($12_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $10_1 >>> 0 < $12_1 >>> 0;
      $1_1 = $36_1 + 8 | 0;
      $14_1 = HEAP32[$1_1 >> 2];
      $10_1 = HEAP32[$1_1 + 4 >> 2];
      $7_1 = ($12_1 | 0) == ($35_1 | 0) & $9_1 >>> 0 < $32_1 >>> 0 | $12_1 >>> 0 < $35_1 >>> 0;
      $3_1 = $37_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $31_1 + 8 | 0;
      $9_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $7_1 + $9_1 | 0;
      $3_1 = ($1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $14_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $13_1 | 0;
      $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $15_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1 + $20_1 | 0;
      $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $25_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $8_1;
      $7_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $14_1 = HEAP32[$6_1 + 6544 >> 2];
      $1_1 = HEAP32[$6_1 + 6480 >> 2];
      $9_1 = $14_1 + $1_1 | 0;
      $13_1 = HEAP32[$6_1 + 6548 >> 2];
      $3_1 = $13_1 + HEAP32[$6_1 + 6484 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $7_1 = $7_1 + $9_1 | 0;
      $3_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $7_1 << 4 & -16;
      $8_1 = $3_1;
      $10_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
      $15_1 = $4_1;
      $69($29_1, $12_1 | $4_1 >>> 16 & 15, $10_1, 0, 0, 977, 1, 0, 0);
      $35_1 = $6_1 + 6688 | 0;
      $69($35_1, $43_1, $44_1, 0, 0, $19_1, $23_1, 0, 0);
      $36_1 = $6_1 + 6528 | 0;
      $69($36_1, $27_1, $22_1, 0, 0, $28_1, $21_1, 0, 0);
      $31_1 = $6_1 + 6496 | 0;
      $69($31_1, $24_1, $26_1, 0, 0, $24_1, $26_1, 0, 0);
      $37_1 = $6_1 + 6432 | 0;
      $12_1 = $37_1;
      $10_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $7_1 = ($1_1 | 0) == ($13_1 | 0) & $9_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $13_1 >>> 0;
      $3_1 = $30_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $38_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $10_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $8_1 >>> 20;
      $7_1 = $3_1;
      $4_1 = $3_1 << 12 | $1_1 >>> 20;
      $30_1 = HEAP32[$6_1 + 6528 >> 2];
      $1_1 = HEAP32[$6_1 + 6496 >> 2];
      $20_1 = $30_1 + $1_1 | 0;
      $33_1 = HEAP32[$6_1 + 6532 >> 2];
      $3_1 = $33_1 + HEAP32[$6_1 + 6500 >> 2] | 0;
      $5_1 = $1_1 >>> 0 > $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $5_1 + $4_1 | 0;
      $16_1 = $8_1 + $20_1 | 0;
      $3_1 = $16_1 >>> 0 < $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $3_1;
      $69($12_1, $16_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $8_1 = HEAP32[$6_1 + 6384 >> 2];
      $1_1 = HEAP32[$6_1 + 6704 >> 2];
      $13_1 = $8_1 + $1_1 | 0;
      $9_1 = HEAP32[$6_1 + 6388 >> 2];
      $3_1 = $9_1 + HEAP32[$6_1 + 6708 >> 2] | 0;
      $42_1 = $6_1 + 7536 | 0;
      $34_1 = $42_1 + 8 | 0;
      $4_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = ($9_1 | 0) == ($4_1 | 0) & $8_1 >>> 0 > $13_1 >>> 0 | $4_1 >>> 0 < $9_1 >>> 0;
      $3_1 = $39_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $1_1 = $29_1 + 8 | 0;
      $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $9_1 + $12_1 | 0;
      $3_1 = $1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $4_1;
      $12_1 = $1_1 << 12 | $4_1 >>> 20;
      $8_1 = $3_1;
      $9_1 = $3_1 << 12 | $1_1 >>> 20;
      $38_1 = HEAP32[$6_1 + 6436 >> 2];
      $3_1 = $38_1 + HEAP32[$6_1 + 6692 >> 2] | 0;
      $32_1 = HEAP32[$6_1 + 6432 >> 2];
      $4_1 = HEAP32[$6_1 + 6688 >> 2];
      $1_1 = $32_1 + $4_1 | 0;
      $25_1 = $1_1;
      $12_1 = $1_1 + $12_1 | 0;
      $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $9_1 | 0;
      HEAP32[$34_1 >> 2] = $12_1;
      $9_1 = $12_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$34_1 + 4 >> 2] = $9_1 & 1048575;
      $29_1 = $6_1 + 6624 | 0;
      $69($29_1, $28_1, $21_1, 0, 0, $19_1, $23_1, 0, 0);
      $23_1 = $6_1 + 6672 | 0;
      $69($23_1, $43_1, $44_1, 0, 0, $43_1, $44_1, 0, 0);
      $19_1 = $6_1 + 6512 | 0;
      $69($19_1, $27_1, $22_1, 0, 0, $24_1, $26_1, 0, 0);
      $22_1 = $6_1 + 6416 | 0;
      $21_1 = ($5_1 | 0) == ($10_1 | 0) & $16_1 >>> 0 < $20_1 >>> 0 | $5_1 >>> 0 > $10_1 >>> 0;
      $16_1 = ($5_1 | 0) == ($33_1 | 0) & $20_1 >>> 0 < $30_1 >>> 0 | $5_1 >>> 0 < $33_1 >>> 0;
      $3_1 = $31_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $36_1 + 8 | 0;
      $24_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $16_1 + $24_1 | 0;
      $3_1 = $5_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $7_1 >>> 20 | 0;
      $1_1 = $5_1 + $7_1 | 0;
      $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $21_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $28_1 = $1_1 << 12 | $10_1 >>> 20;
      $7_1 = HEAP32[$6_1 + 6512 >> 2];
      $10_1 = $28_1 + $7_1 | 0;
      $5_1 = $3_1;
      $30_1 = $3_1 << 12 | $1_1 >>> 20;
      $3_1 = $30_1 + HEAP32[$6_1 + 6516 >> 2] | 0;
      $16_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($22_1, $10_1, $16_1, 0, 0, 15632, 16, 0, 0);
      $27_1 = $42_1 + 16 | 0;
      $24_1 = $27_1;
      $12_1 = ($4_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
      $7_1 = ($4_1 | 0) == ($38_1 | 0) & $25_1 >>> 0 < $32_1 >>> 0 | $4_1 >>> 0 < $38_1 >>> 0;
      $3_1 = $35_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $37_1 + 8 | 0;
      $21_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $21_1 | 0;
      $3_1 = $4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $8_1 >>> 20 | 0;
      $1_1 = $4_1 + $8_1 | 0;
      $3_1 = $8_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $12_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $9_1 >>> 20;
      $4_1 = $3_1;
      $26_1 = $3_1 << 12 | $1_1 >>> 20;
      $20_1 = HEAP32[$6_1 + 6624 >> 2];
      $1_1 = HEAP32[$6_1 + 6672 >> 2];
      $9_1 = $20_1 + $1_1 | 0;
      $25_1 = HEAP32[$6_1 + 6628 >> 2];
      $3_1 = $25_1 + HEAP32[$6_1 + 6676 >> 2] | 0;
      $21_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $21_1 + HEAP32[$6_1 + 6420 >> 2] | 0;
      $1_1 = HEAP32[$6_1 + 6416 >> 2];
      $8_1 = $1_1 + $9_1 | 0;
      $12_1 = $8_1;
      $7_1 = $8_1 + $7_1 | 0;
      $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $26_1 | 0;
      HEAP32[$24_1 >> 2] = $7_1;
      $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$24_1 + 4 >> 2] = $8_1 & 1048575;
      $24_1 = $6_1 + 6400 | 0;
      $26_1 = ($16_1 | 0) == ($30_1 | 0) & $10_1 >>> 0 < $28_1 >>> 0 | $16_1 >>> 0 < $30_1 >>> 0;
      $3_1 = $19_1 + 8 | 0;
      $16_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $5_1 = $5_1 >>> 20 | 0;
      $10_1 = $5_1;
      $5_1 = $5_1 + $16_1 | 0;
      $3_1 = $10_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $16_1 = $5_1;
      $5_1 = $5_1 + $26_1 | 0;
      $3_1 = $16_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($24_1, $5_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $28_1 = $42_1 + 24 | 0;
      $26_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
      $16_1 = ($1_1 | 0) == ($21_1 | 0) & $9_1 >>> 0 > $12_1 >>> 0 | $1_1 >>> 0 < $21_1 >>> 0;
      $1_1 = $22_1 + 8 | 0;
      $12_1 = HEAP32[$1_1 >> 2];
      $10_1 = HEAP32[$1_1 + 4 >> 2];
      $7_1 = ($21_1 | 0) == ($25_1 | 0) & $9_1 >>> 0 < $20_1 >>> 0 | $21_1 >>> 0 < $25_1 >>> 0;
      $3_1 = $23_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $29_1 + 8 | 0;
      $9_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $7_1 + $9_1 | 0;
      $3_1 = ($1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $12_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1 + $16_1 | 0;
      $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $26_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $8_1 >>> 20;
      $4_1 = $3_1;
      $9_1 = $3_1 << 12 | $1_1 >>> 20;
      $12_1 = HEAP32[$6_1 + 6400 >> 2];
      $5_1 = $17_1 & -2;
      $1_1 = $12_1 + $5_1 | 0;
      $17_1 = HEAP32[$6_1 + 6404 >> 2];
      $3_1 = $17_1 + ($18_1 & 1048575) | 0;
      $7_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $7_1 + $9_1 | 0;
      $5_1 = $8_1;
      $8_1 = $1_1;
      $5_1 = $5_1 + $1_1 | 0;
      HEAP32[$28_1 >> 2] = $5_1;
      $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$28_1 + 4 >> 2] = $1_1 & 1048575;
      $18_1 = $42_1 + 32 | 0;
      $16_1 = $18_1;
      $10_1 = $15_1 & 65535;
      $9_1 = ($1_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $1_1 >>> 0 < $7_1 >>> 0;
      $5_1 = ($7_1 | 0) == ($17_1 | 0) & $8_1 >>> 0 < $12_1 >>> 0 | $7_1 >>> 0 < $17_1 >>> 0;
      $3_1 = $24_1 + 8 | 0;
      $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $9_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $4_1 << 12 | $1_1 >>> 20;
      $5_1 = $1_1 + $11_1 | 0;
      $3_1 = $10_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
      HEAP32[$16_1 >> 2] = $5_1;
      HEAP32[$16_1 + 4 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 7536 >> 2] = $13_1;
      HEAP32[$6_1 + 7540 >> 2] = $14_1 & 1048575;
      $34($42_1, $42_1, $41_1);
      $1_1 = HEAP32[$6_1 + 7540 >> 2];
      $22_1 = $1_1;
      $20_1 = HEAP32[$6_1 + 7536 >> 2];
      $7_1 = $20_1;
      $3_1 = $1_1 << 1 | $7_1 >>> 31;
      $15_1 = $6_1 + 6224 | 0;
      $12_1 = HEAP32[$28_1 >> 2];
      $10_1 = HEAP32[$28_1 + 4 >> 2];
      $21_1 = $7_1 << 1;
      $26_1 = $3_1;
      $69($15_1, $12_1, $10_1, 0, 0, $21_1, $3_1, 0, 0);
      $1_1 = HEAP32[$34_1 + 4 >> 2];
      $41_1 = $1_1;
      $33_1 = HEAP32[$34_1 >> 2];
      $4_1 = $33_1;
      $3_1 = $1_1 << 1 | $4_1 >>> 31;
      $16_1 = $6_1 + 6320 | 0;
      $13_1 = HEAP32[$27_1 >> 2];
      $9_1 = HEAP32[$27_1 + 4 >> 2];
      $4_1 = $4_1 << 1;
      $5_1 = $3_1;
      $69($16_1, $13_1, $9_1, 0, 0, $4_1, $3_1, 0, 0);
      $14_1 = $6_1 + 6208 | 0;
      $8_1 = HEAP32[$18_1 >> 2];
      $1_1 = HEAP32[$18_1 + 4 >> 2];
      $69($14_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
      $11_1 = $6_1 + 6192 | 0;
      $69($11_1, HEAP32[$6_1 + 6208 >> 2], HEAP32[$6_1 + 6212 >> 2], 0, 0, 15632, 16, 0, 0);
      $3_1 = $1_1 << 1 | $8_1 >>> 31;
      $39_1 = $6_1 + 6160 | 0;
      $24_1 = $8_1 << 1;
      $17_1 = $3_1;
      $69($39_1, $24_1, $3_1, 0, 0, $7_1, $22_1, 0, 0);
      $38_1 = $6_1 + 6240 | 0;
      $69($38_1, $12_1, $10_1, 0, 0, $4_1, $5_1, 0, 0);
      $35_1 = $6_1 + 6304 | 0;
      $69($35_1, $13_1, $9_1, 0, 0, $13_1, $9_1, 0, 0);
      $28_1 = $6_1 + 6176 | 0;
      $1_1 = $14_1 + 8 | 0;
      $69($28_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $36_1 = $6_1 + 6368 | 0;
      $69($36_1, $7_1, $22_1, 0, 0, $7_1, $22_1, 0, 0);
      $31_1 = $6_1 + 6144 | 0;
      $69($31_1, $24_1, $3_1, 0, 0, $33_1, $41_1, 0, 0);
      $37_1 = $6_1 + 6256 | 0;
      $69($37_1, $12_1, $10_1, 0, 0, $13_1 << 1, $9_1 << 1 | $13_1 >>> 31, 0, 0);
      $20_1 = HEAP32[$6_1 + 6228 >> 2];
      $3_1 = $20_1 + HEAP32[$6_1 + 6324 >> 2] | 0;
      $8_1 = HEAP32[$6_1 + 6224 >> 2];
      $4_1 = HEAP32[$6_1 + 6320 >> 2];
      $1_1 = $8_1 + $4_1 | 0;
      $5_1 = HEAP32[$6_1 + 6192 >> 2];
      $18_1 = $1_1 + $5_1 | 0;
      $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + HEAP32[$6_1 + 6196 >> 2] | 0;
      $5_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
      $3_1 = $11_1 + 8 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $7_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = ($4_1 | 0) == ($20_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0;
      $3_1 = $16_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $15_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $16_1 | 0;
      $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $11_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $14_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $5_1;
      $11_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $30_1 = HEAP32[$6_1 + 6240 >> 2];
      $1_1 = HEAP32[$6_1 + 6304 >> 2];
      $14_1 = $30_1 + $1_1 | 0;
      $34_1 = HEAP32[$6_1 + 6244 >> 2];
      $3_1 = $34_1 + HEAP32[$6_1 + 6308 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 6160 >> 2];
      $7_1 = $1_1 + $14_1 | 0;
      $20_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 6164 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 6176 >> 2];
      $5_1 = $1_1 + $7_1 | 0;
      $16_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 6180 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $32_1 = $6_1 + 6128 | 0;
      $29_1 = $32_1;
      $11_1 = $5_1 + $11_1 | 0;
      $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $27_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
      $25_1 = ($1_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
      $1_1 = $28_1 + 8 | 0;
      $23_1 = HEAP32[$1_1 >> 2];
      $19_1 = HEAP32[$1_1 + 4 >> 2];
      $22_1 = ($16_1 | 0) == ($20_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $16_1 >>> 0 < $20_1 >>> 0;
      $1_1 = $39_1 + 8 | 0;
      $28_1 = HEAP32[$1_1 >> 2];
      $16_1 = HEAP32[$1_1 + 4 >> 2];
      $7_1 = ($20_1 | 0) == ($34_1 | 0) & $14_1 >>> 0 < $30_1 >>> 0 | $20_1 >>> 0 < $34_1 >>> 0;
      $3_1 = $35_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $38_1 + 8 | 0;
      $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $7_1 + $14_1 | 0;
      $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $28_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $22_1 | 0;
      $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $23_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1 + $25_1 | 0;
      $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $27_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $8_1;
      $7_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $16_1 = $3_1 << 12 | $1_1 >>> 20;
      $23_1 = HEAP32[$6_1 + 6148 >> 2];
      $3_1 = $23_1 + HEAP32[$6_1 + 6260 >> 2] | 0;
      $19_1 = HEAP32[$6_1 + 6144 >> 2];
      $1_1 = HEAP32[$6_1 + 6256 >> 2];
      $8_1 = $19_1 + $1_1 | 0;
      $14_1 = $8_1;
      $7_1 = $8_1 + $7_1 | 0;
      $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $16_1 | 0;
      $28_1 = $7_1 << 4 & -16;
      $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = ($8_1 << 4 | $7_1 >>> 28) & 16777215;
      $16_1 = $4_1;
      $69($29_1, $28_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
      $29_1 = $6_1 + 6352 | 0;
      $69($29_1, $33_1, $41_1, 0, 0, $21_1, $26_1, 0, 0);
      $25_1 = $6_1 + 6096 | 0;
      $69($25_1, $24_1, $17_1, 0, 0, $13_1, $9_1, 0, 0);
      $22_1 = $6_1 + 6272 | 0;
      $69($22_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
      $28_1 = $6_1 + 6080 | 0;
      $20_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
      $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
      $3_1 = $37_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $31_1 + 8 | 0;
      $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $14_1 | 0;
      $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $8_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $20_1 = HEAP32[$6_1 + 6096 >> 2];
      $1_1 = HEAP32[$6_1 + 6272 >> 2];
      $7_1 = $20_1 + $1_1 | 0;
      $27_1 = HEAP32[$6_1 + 6100 >> 2];
      $3_1 = $27_1 + HEAP32[$6_1 + 6276 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $8_1 = $7_1 + $8_1 | 0;
      $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $3_1;
      $69($28_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $23_1 = $6_1 + 6288 | 0;
      $69($23_1, $13_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
      $19_1 = $6_1 + 6336 | 0;
      $69($19_1, $33_1, $41_1, 0, 0, $33_1, $41_1, 0, 0);
      $14_1 = $6_1 + 6032 | 0;
      $69($14_1, $24_1, $17_1, 0, 0, $12_1, $10_1, 0, 0);
      $21_1 = $6_1 + 6016 | 0;
      $10_1 = $21_1;
      $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $7_1 = ($1_1 | 0) == ($27_1 | 0) & $7_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
      $3_1 = $22_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $1_1 = $25_1 + 8 | 0;
      $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $7_1 + $12_1 | 0;
      $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $5_1 >>> 20;
      $5_1 = HEAP32[$6_1 + 6032 >> 2];
      $9_1 = $8_1 + $5_1 | 0;
      $4_1 = $3_1;
      $1_1 = $3_1 << 12 | $1_1 >>> 20;
      $3_1 = $1_1 + HEAP32[$6_1 + 6036 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $27_1 = $6_1 + 5952 | 0;
      $7_1 = $27_1;
      $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $1_1 = $14_1 + 8 | 0;
      $5_1 = HEAP32[$1_1 >> 2];
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $4_1 = HEAP32[$6_1 + 6128 >> 2];
      $1_1 = HEAP32[$6_1 + 6368 >> 2];
      $7_1 = $4_1 + $1_1 | 0;
      $8_1 = HEAP32[$6_1 + 6132 >> 2];
      $3_1 = $8_1 + HEAP32[$6_1 + 6372 >> 2] | 0;
      $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
      $3_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $32_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $9_1 | 0;
      $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $5_1;
      $8_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $10_1 = HEAP32[$6_1 + 6080 >> 2];
      $1_1 = HEAP32[$6_1 + 6352 >> 2];
      $9_1 = $10_1 + $1_1 | 0;
      $14_1 = HEAP32[$6_1 + 6084 >> 2];
      $3_1 = $14_1 + HEAP32[$6_1 + 6356 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $8_1 = $8_1 + $9_1 | 0;
      $5_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
      $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
      $3_1 = $29_1 + 8 | 0;
      $9_1 = HEAP32[$3_1 >> 2];
      $1_1 = $28_1 + 8 | 0;
      $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $10_1 + $14_1 | 0;
      $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $12_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $5_1;
      $9_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $22_1 = HEAP32[$6_1 + 6288 >> 2];
      $1_1 = HEAP32[$6_1 + 6336 >> 2];
      $12_1 = $22_1 + $1_1 | 0;
      $29_1 = HEAP32[$6_1 + 6292 >> 2];
      $3_1 = $29_1 + HEAP32[$6_1 + 6340 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 6016 >> 2];
      $10_1 = $1_1 + $12_1 | 0;
      $17_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 6020 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $25_1 = $6_1 + 5936 | 0;
      $28_1 = $25_1;
      $5_1 = $9_1 + $10_1 | 0;
      $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
      $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
      $1_1 = $21_1 + 8 | 0;
      $26_1 = HEAP32[$1_1 >> 2];
      $21_1 = HEAP32[$1_1 + 4 >> 2];
      $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
      $3_1 = $19_1 + 8 | 0;
      $10_1 = HEAP32[$3_1 >> 2];
      $1_1 = $23_1 + 8 | 0;
      $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $12_1 + $17_1 | 0;
      $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
      $12_1 = $1_1;
      $1_1 = $1_1 + $26_1 | 0;
      $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $1_1 + $24_1 | 0;
      $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $10_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $9_1;
      $12_1 = $1_1 << 12 | $9_1 >>> 20;
      $4_1 = $3_1;
      $17_1 = $3_1 << 12 | $1_1 >>> 20;
      $29_1 = HEAP32[$6_1 + 5956 >> 2];
      $3_1 = $29_1 + ($15_1 & 1048575) | 0;
      $22_1 = HEAP32[$6_1 + 5952 >> 2];
      $1_1 = $18_1 & -2;
      $9_1 = $22_1 + $1_1 | 0;
      $15_1 = $9_1;
      $12_1 = $9_1 + $12_1 | 0;
      $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $17_1 | 0;
      $9_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $17_1 = $9_1 & 1048575;
      $3_1 = $13_1 & 1048575;
      $32_1 = $3_1;
      $13_1 = $7_1;
      $3_1 = $3_1 << 1 | $7_1 >>> 31;
      $26_1 = $7_1 << 1;
      $24_1 = $3_1;
      $69($28_1, $12_1, $17_1, 0, 0, $26_1, $3_1, 0, 0);
      $3_1 = $14_1 & 1048575;
      $33_1 = $3_1;
      $23_1 = $6_1 + 5968 | 0;
      $18_1 = $10_1 & 1048575;
      $7_1 = $8_1 << 1;
      $28_1 = $8_1;
      $10_1 = $3_1 << 1 | $8_1 >>> 31;
      $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
      $19_1 = $6_1 + 5872 | 0;
      $20_1 = $19_1;
      $21_1 = $16_1 & 65535;
      $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
      $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
      $1_1 = $27_1 + 8 | 0;
      $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $9_1 >>> 20;
      $4_1 = $8_1 + $11_1 | 0;
      $3_1 = $21_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
      $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($20_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
      $11_1 = $6_1 + 5856 | 0;
      $69($11_1, HEAP32[$6_1 + 5872 >> 2], HEAP32[$6_1 + 5876 >> 2], 0, 0, 15632, 16, 0, 0);
      $1_1 = $4_1;
      $3_1 = $3_1 << 1 | $1_1 >>> 31;
      $39_1 = $6_1 + 5824 | 0;
      $20_1 = $1_1 << 1;
      $21_1 = $3_1;
      $69($39_1, $20_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
      $38_1 = $6_1 + 5920 | 0;
      $69($38_1, $12_1, $17_1, 0, 0, $7_1, $10_1, 0, 0);
      $35_1 = $6_1 + 5984 | 0;
      $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
      $22_1 = $6_1 + 5840 | 0;
      $1_1 = $19_1 + 8 | 0;
      $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $36_1 = $6_1 + 6112 | 0;
      $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
      $31_1 = $6_1 + 5808 | 0;
      $69($31_1, $20_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
      $37_1 = $6_1 + 5888 | 0;
      $10_1 = $17_1;
      $9_1 = $18_1;
      $17_1 = $5_1;
      $69($37_1, $12_1, $10_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
      $8_1 = HEAP32[$6_1 + 5936 >> 2];
      $4_1 = HEAP32[$6_1 + 5968 >> 2];
      $1_1 = $8_1 + $4_1 | 0;
      $13_1 = HEAP32[$6_1 + 5940 >> 2];
      $3_1 = $13_1 + HEAP32[$6_1 + 5972 >> 2] | 0;
      $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 5856 >> 2];
      $18_1 = $4_1 + $1_1 | 0;
      $5_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 5860 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
      $3_1 = $11_1 + 8 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $7_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = ($5_1 | 0) == ($13_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $13_1 >>> 0;
      $3_1 = $23_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $25_1 + 8 | 0;
      $13_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $13_1 | 0;
      $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $11_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $14_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $4_1;
      $11_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $30_1 = HEAP32[$6_1 + 5920 >> 2];
      $1_1 = HEAP32[$6_1 + 5984 >> 2];
      $13_1 = $30_1 + $1_1 | 0;
      $34_1 = HEAP32[$6_1 + 5924 >> 2];
      $3_1 = $34_1 + HEAP32[$6_1 + 5988 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 5824 >> 2];
      $14_1 = $1_1 + $13_1 | 0;
      $4_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 5828 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 5840 >> 2];
      $7_1 = $1_1 + $14_1 | 0;
      $16_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 5844 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $32_1 = $6_1 + 5712 | 0;
      $29_1 = $32_1;
      $11_1 = $7_1 + $11_1 | 0;
      $8_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $27_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
      $25_1 = ($1_1 | 0) == ($16_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
      $1_1 = $22_1 + 8 | 0;
      $23_1 = HEAP32[$1_1 >> 2];
      $19_1 = HEAP32[$1_1 + 4 >> 2];
      $22_1 = ($4_1 | 0) == ($16_1 | 0) & $13_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 > $16_1 >>> 0;
      $1_1 = $39_1 + 8 | 0;
      $16_1 = HEAP32[$1_1 >> 2];
      $14_1 = HEAP32[$1_1 + 4 >> 2];
      $7_1 = ($4_1 | 0) == ($34_1 | 0) & $13_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
      $3_1 = $35_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $38_1 + 8 | 0;
      $13_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $7_1 + $13_1 | 0;
      $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $14_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $22_1 | 0;
      $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $23_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1 + $25_1 | 0;
      $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $27_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $8_1;
      $7_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $19_1 = HEAP32[$6_1 + 5808 >> 2];
      $1_1 = HEAP32[$6_1 + 5888 >> 2];
      $14_1 = $19_1 + $1_1 | 0;
      $23_1 = HEAP32[$6_1 + 5812 >> 2];
      $3_1 = $23_1 + HEAP32[$6_1 + 5892 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $7_1 = $7_1 + $14_1 | 0;
      $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $22_1 = $7_1 << 4 & -16;
      $8_1 = $3_1;
      $13_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
      $16_1 = $4_1;
      $69($29_1, $22_1 | $4_1 >>> 16 & 15, $13_1, 0, 0, 977, 1, 0, 0);
      $29_1 = $6_1 + 6048 | 0;
      $69($29_1, $28_1, $33_1, 0, 0, $26_1, $24_1, 0, 0);
      $27_1 = $6_1 + 5792 | 0;
      $69($27_1, $20_1, $21_1, 0, 0, $17_1, $9_1, 0, 0);
      $25_1 = $6_1 + 5904 | 0;
      $69($25_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
      $22_1 = $6_1 + 5776 | 0;
      $13_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
      $3_1 = $37_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $31_1 + 8 | 0;
      $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $14_1 | 0;
      $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $13_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $8_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $13_1 = HEAP32[$6_1 + 5792 >> 2];
      $1_1 = HEAP32[$6_1 + 5904 >> 2];
      $7_1 = $13_1 + $1_1 | 0;
      $30_1 = HEAP32[$6_1 + 5796 >> 2];
      $3_1 = $30_1 + HEAP32[$6_1 + 5908 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $8_1 = $7_1 + $8_1 | 0;
      $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $3_1;
      $69($22_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $23_1 = $6_1 + 6e3 | 0;
      $69($23_1, $17_1, $9_1, 0, 0, $26_1, $24_1, 0, 0);
      $19_1 = $6_1 + 6064 | 0;
      $69($19_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
      $14_1 = $6_1 + 5760 | 0;
      $69($14_1, $12_1, $10_1, 0, 0, $20_1, $21_1, 0, 0);
      $21_1 = $6_1 + 5744 | 0;
      $10_1 = $21_1;
      $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $7_1 = ($1_1 | 0) == ($30_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
      $3_1 = $25_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $1_1 = $27_1 + 8 | 0;
      $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $7_1 + $12_1 | 0;
      $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $5_1 >>> 20;
      $5_1 = HEAP32[$6_1 + 5760 >> 2];
      $9_1 = $8_1 + $5_1 | 0;
      $4_1 = $3_1;
      $1_1 = $3_1 << 12 | $1_1 >>> 20;
      $3_1 = $1_1 + HEAP32[$6_1 + 5764 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $27_1 = $6_1 + 5728 | 0;
      $7_1 = $27_1;
      $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $1_1 = $14_1 + 8 | 0;
      $5_1 = HEAP32[$1_1 >> 2];
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $4_1 = HEAP32[$6_1 + 5712 >> 2];
      $1_1 = HEAP32[$6_1 + 6112 >> 2];
      $7_1 = $4_1 + $1_1 | 0;
      $8_1 = HEAP32[$6_1 + 5716 >> 2];
      $3_1 = $8_1 + HEAP32[$6_1 + 6116 >> 2] | 0;
      $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
      $3_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $32_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $9_1 | 0;
      $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $5_1;
      $8_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $10_1 = HEAP32[$6_1 + 5776 >> 2];
      $1_1 = HEAP32[$6_1 + 6048 >> 2];
      $9_1 = $10_1 + $1_1 | 0;
      $14_1 = HEAP32[$6_1 + 5780 >> 2];
      $3_1 = $14_1 + HEAP32[$6_1 + 6052 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $8_1 = $8_1 + $9_1 | 0;
      $5_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
      $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
      $3_1 = $29_1 + 8 | 0;
      $9_1 = HEAP32[$3_1 >> 2];
      $1_1 = $22_1 + 8 | 0;
      $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $10_1 + $14_1 | 0;
      $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $12_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $5_1;
      $9_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $22_1 = HEAP32[$6_1 + 6e3 >> 2];
      $1_1 = HEAP32[$6_1 + 6064 >> 2];
      $12_1 = $22_1 + $1_1 | 0;
      $29_1 = HEAP32[$6_1 + 6004 >> 2];
      $3_1 = $29_1 + HEAP32[$6_1 + 6068 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 5744 >> 2];
      $10_1 = $1_1 + $12_1 | 0;
      $17_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 5748 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $25_1 = $6_1 + 5632 | 0;
      $28_1 = $25_1;
      $5_1 = $9_1 + $10_1 | 0;
      $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
      $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
      $1_1 = $21_1 + 8 | 0;
      $26_1 = HEAP32[$1_1 >> 2];
      $21_1 = HEAP32[$1_1 + 4 >> 2];
      $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
      $3_1 = $19_1 + 8 | 0;
      $10_1 = HEAP32[$3_1 >> 2];
      $1_1 = $23_1 + 8 | 0;
      $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $12_1 + $17_1 | 0;
      $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
      $12_1 = $1_1;
      $1_1 = $1_1 + $26_1 | 0;
      $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $1_1 + $24_1 | 0;
      $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $10_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $9_1;
      $12_1 = $1_1 << 12 | $9_1 >>> 20;
      $4_1 = $3_1;
      $17_1 = $3_1 << 12 | $1_1 >>> 20;
      $29_1 = HEAP32[$6_1 + 5732 >> 2];
      $3_1 = $29_1 + ($15_1 & 1048575) | 0;
      $22_1 = HEAP32[$6_1 + 5728 >> 2];
      $1_1 = $18_1 & -2;
      $9_1 = $22_1 + $1_1 | 0;
      $15_1 = $9_1;
      $12_1 = $9_1 + $12_1 | 0;
      $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $17_1 | 0;
      $9_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = $9_1 & 1048575;
      $18_1 = $20_1;
      $3_1 = $13_1 & 1048575;
      $32_1 = $3_1;
      $13_1 = $7_1;
      $3_1 = $3_1 << 1 | $7_1 >>> 31;
      $21_1 = $7_1 << 1;
      $26_1 = $3_1;
      $69($28_1, $12_1, $18_1, 0, 0, $21_1, $3_1, 0, 0);
      $3_1 = $14_1 & 1048575;
      $33_1 = $3_1;
      $23_1 = $6_1 + 5584 | 0;
      $18_1 = $10_1 & 1048575;
      $7_1 = $8_1 << 1;
      $28_1 = $8_1;
      $10_1 = $3_1 << 1 | $8_1 >>> 31;
      $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
      $19_1 = $6_1 + 5536 | 0;
      $17_1 = $16_1 & 65535;
      $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
      $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
      $1_1 = $27_1 + 8 | 0;
      $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $9_1 >>> 20;
      $4_1 = $8_1 + $11_1 | 0;
      $3_1 = $17_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
      $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($19_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
      $11_1 = $6_1 + 5520 | 0;
      $69($11_1, HEAP32[$6_1 + 5536 >> 2], HEAP32[$6_1 + 5540 >> 2], 0, 0, 15632, 16, 0, 0);
      $1_1 = $4_1;
      $3_1 = $3_1 << 1 | $1_1 >>> 31;
      $39_1 = $6_1 + 5488 | 0;
      $24_1 = $1_1 << 1;
      $17_1 = $3_1;
      $69($39_1, $24_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
      $38_1 = $6_1 + 5568 | 0;
      $69($38_1, $12_1, $20_1, 0, 0, $7_1, $10_1, 0, 0);
      $35_1 = $6_1 + 5680 | 0;
      $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
      $22_1 = $6_1 + 5504 | 0;
      $1_1 = $19_1 + 8 | 0;
      $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $36_1 = $6_1 + 5648 | 0;
      $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
      $31_1 = $6_1 + 5472 | 0;
      $69($31_1, $24_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
      $37_1 = $6_1 + 5552 | 0;
      $16_1 = $12_1;
      $13_1 = $20_1;
      $9_1 = $18_1;
      $18_1 = $5_1;
      $69($37_1, $12_1, $13_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
      $8_1 = HEAP32[$6_1 + 5632 >> 2];
      $4_1 = HEAP32[$6_1 + 5584 >> 2];
      $1_1 = $8_1 + $4_1 | 0;
      $12_1 = HEAP32[$6_1 + 5636 >> 2];
      $3_1 = $12_1 + HEAP32[$6_1 + 5588 >> 2] | 0;
      $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 5520 >> 2];
      $14_1 = $4_1 + $1_1 | 0;
      $5_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 5524 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
      $3_1 = $11_1 + 8 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $7_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = ($5_1 | 0) == ($12_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $12_1 >>> 0;
      $3_1 = $23_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $25_1 + 8 | 0;
      $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $12_1 | 0;
      $3_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $11_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $4_1;
      $7_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $30_1 = HEAP32[$6_1 + 5568 >> 2];
      $1_1 = HEAP32[$6_1 + 5680 >> 2];
      $15_1 = $30_1 + $1_1 | 0;
      $34_1 = HEAP32[$6_1 + 5572 >> 2];
      $3_1 = $34_1 + HEAP32[$6_1 + 5684 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 5488 >> 2];
      $10_1 = $1_1 + $15_1 | 0;
      $4_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 5492 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 5504 >> 2];
      $11_1 = $1_1 + $10_1 | 0;
      $20_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 5508 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $32_1 = $6_1 + 5376 | 0;
      $29_1 = $32_1;
      $8_1 = $7_1 + $11_1 | 0;
      $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $27_1 = ($1_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
      $25_1 = ($1_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 < $20_1 >>> 0;
      $1_1 = $22_1 + 8 | 0;
      $23_1 = HEAP32[$1_1 >> 2];
      $19_1 = HEAP32[$1_1 + 4 >> 2];
      $22_1 = ($4_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $20_1 >>> 0;
      $1_1 = $39_1 + 8 | 0;
      $20_1 = HEAP32[$1_1 >> 2];
      $10_1 = HEAP32[$1_1 + 4 >> 2];
      $11_1 = ($4_1 | 0) == ($34_1 | 0) & $15_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
      $3_1 = $35_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $38_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $11_1 + $15_1 | 0;
      $3_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $22_1 | 0;
      $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $23_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1 + $25_1 | 0;
      $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $27_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1;
      $11_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $1_1 >>> 20;
      $19_1 = HEAP32[$6_1 + 5472 >> 2];
      $1_1 = HEAP32[$6_1 + 5552 >> 2];
      $15_1 = $19_1 + $1_1 | 0;
      $30_1 = HEAP32[$6_1 + 5476 >> 2];
      $3_1 = $30_1 + HEAP32[$6_1 + 5556 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $7_1 | 0;
      $11_1 = $11_1 + $15_1 | 0;
      $3_1 = $11_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $22_1 = $11_1 << 4 & -16;
      $7_1 = $3_1;
      $20_1 = ($3_1 << 4 | $11_1 >>> 28) & 16777215;
      $10_1 = $4_1;
      $69($29_1, $22_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
      $29_1 = $6_1 + 5616 | 0;
      $69($29_1, $28_1, $33_1, 0, 0, $21_1, $26_1, 0, 0);
      $27_1 = $6_1 + 5456 | 0;
      $69($27_1, $24_1, $17_1, 0, 0, $18_1, $9_1, 0, 0);
      $25_1 = $6_1 + 5696 | 0;
      $69($25_1, $16_1, $13_1, 0, 0, $16_1, $13_1, 0, 0);
      $23_1 = $6_1 + 5440 | 0;
      $22_1 = $23_1;
      $20_1 = ($1_1 | 0) == ($3_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $11_1 = ($1_1 | 0) == ($30_1 | 0) & $15_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
      $3_1 = $37_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $31_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $11_1 + $15_1 | 0;
      $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $7_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $20_1 = HEAP32[$6_1 + 5456 >> 2];
      $1_1 = HEAP32[$6_1 + 5696 >> 2];
      $11_1 = $20_1 + $1_1 | 0;
      $30_1 = HEAP32[$6_1 + 5460 >> 2];
      $3_1 = $30_1 + HEAP32[$6_1 + 5700 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $7_1 = $7_1 + $11_1 | 0;
      $3_1 = $7_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $3_1;
      $69($22_1, $7_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $19_1 = $6_1 + 5600 | 0;
      $69($19_1, $18_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
      $22_1 = $6_1 + 5664 | 0;
      $69($22_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
      $15_1 = $6_1 + 5424 | 0;
      $69($15_1, $16_1, $13_1, 0, 0, $24_1, $17_1, 0, 0);
      $18_1 = $6_1 + 5408 | 0;
      $13_1 = $18_1;
      $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $11_1 = ($1_1 | 0) == ($30_1 | 0) & $11_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
      $3_1 = $25_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $1_1 = $27_1 + 8 | 0;
      $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $11_1 + $16_1 | 0;
      $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $7_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $5_1 >>> 20;
      $5_1 = HEAP32[$6_1 + 5424 >> 2];
      $9_1 = $7_1 + $5_1 | 0;
      $4_1 = $3_1;
      $1_1 = $3_1 << 12 | $1_1 >>> 20;
      $3_1 = $1_1 + HEAP32[$6_1 + 5428 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($13_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $20_1 = $6_1 + 5392 | 0;
      $11_1 = $20_1;
      $7_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $1_1 = $15_1 + 8 | 0;
      $5_1 = HEAP32[$1_1 >> 2];
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $7_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($11_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $4_1 = HEAP32[$6_1 + 5376 >> 2];
      $1_1 = HEAP32[$6_1 + 5648 >> 2];
      $9_1 = $4_1 + $1_1 | 0;
      $7_1 = HEAP32[$6_1 + 5380 >> 2];
      $3_1 = $7_1 + HEAP32[$6_1 + 5652 >> 2] | 0;
      $30_1 = $6_1 + 7496 | 0;
      $27_1 = $30_1 + 8 | 0;
      $16_1 = $27_1;
      $5_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = ($7_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $9_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
      $3_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $32_1 + 8 | 0;
      $11_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $7_1 + $11_1 | 0;
      $3_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $11_1 = $5_1;
      $7_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $15_1 = HEAP32[$6_1 + 5440 >> 2];
      $1_1 = HEAP32[$6_1 + 5616 >> 2];
      $13_1 = $15_1 + $1_1 | 0;
      $21_1 = HEAP32[$6_1 + 5444 >> 2];
      $3_1 = $21_1 + HEAP32[$6_1 + 5620 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $7_1 = $7_1 + $13_1 | 0;
      $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$16_1 >> 2] = $7_1;
      $5_1 = $3_1;
      HEAP32[$16_1 + 4 >> 2] = $3_1 & 1048575;
      $25_1 = $30_1 + 16 | 0;
      $17_1 = $25_1;
      $16_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $13_1 = ($1_1 | 0) == ($21_1 | 0) & $13_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $21_1 >>> 0;
      $3_1 = $29_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $1_1 = $23_1 + 8 | 0;
      $15_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $13_1 + $15_1 | 0;
      $3_1 = $7_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $7_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $24_1 = HEAP32[$6_1 + 5600 >> 2];
      $1_1 = HEAP32[$6_1 + 5664 >> 2];
      $16_1 = $24_1 + $1_1 | 0;
      $23_1 = HEAP32[$6_1 + 5604 >> 2];
      $3_1 = $23_1 + HEAP32[$6_1 + 5668 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 5408 >> 2];
      $13_1 = $1_1 + $16_1 | 0;
      $15_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 5412 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $7_1 = $7_1 + $13_1 | 0;
      $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$17_1 >> 2] = $7_1;
      $5_1 = $3_1;
      HEAP32[$17_1 + 4 >> 2] = $3_1 & 1048575;
      $28_1 = $30_1 + 24 | 0;
      $26_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $21_1 = ($1_1 | 0) == ($15_1 | 0) & $13_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
      $1_1 = $18_1 + 8 | 0;
      $17_1 = HEAP32[$1_1 >> 2];
      $18_1 = HEAP32[$1_1 + 4 >> 2];
      $13_1 = ($15_1 | 0) == ($23_1 | 0) & $16_1 >>> 0 < $24_1 >>> 0 | $15_1 >>> 0 < $23_1 >>> 0;
      $3_1 = $22_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $1_1 = $19_1 + 8 | 0;
      $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $13_1 + $16_1 | 0;
      $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
      $7_1 = $1_1;
      $1_1 = $1_1 + $17_1 | 0;
      $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 + $21_1 | 0;
      $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $7_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $26_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $7_1 = $3_1 << 12 | $1_1 >>> 20;
      $16_1 = HEAP32[$6_1 + 5392 >> 2];
      $5_1 = $14_1 & -2;
      $1_1 = $16_1 + $5_1 | 0;
      $17_1 = HEAP32[$6_1 + 5396 >> 2];
      $3_1 = $17_1 + ($12_1 & 1048575) | 0;
      $14_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $14_1 + $7_1 | 0;
      $12_1 = $1_1;
      $5_1 = $1_1 + $13_1 | 0;
      HEAP32[$28_1 >> 2] = $5_1;
      $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$28_1 + 4 >> 2] = $1_1 & 1048575;
      $18_1 = $30_1 + 32 | 0;
      $15_1 = $18_1;
      $7_1 = $8_1;
      $13_1 = $10_1 & 65535;
      $10_1 = ($1_1 | 0) == ($14_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
      $5_1 = ($14_1 | 0) == ($17_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $14_1 >>> 0 < $17_1 >>> 0;
      $3_1 = $20_1 + 8 | 0;
      $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $4_1 << 12 | $1_1 >>> 20;
      $5_1 = $1_1 + $7_1 | 0;
      $3_1 = $13_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
      HEAP32[$15_1 >> 2] = $5_1;
      HEAP32[$15_1 + 4 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 7496 >> 2] = $9_1;
      HEAP32[$6_1 + 7500 >> 2] = $11_1 & 1048575;
      $34($30_1, $30_1, $42_1);
      $1_1 = HEAP32[$6_1 + 7500 >> 2];
      $22_1 = $1_1;
      $20_1 = HEAP32[$6_1 + 7496 >> 2];
      $7_1 = $20_1;
      $3_1 = $1_1 << 1 | $7_1 >>> 31;
      $15_1 = $6_1 + 5216 | 0;
      $12_1 = HEAP32[$28_1 >> 2];
      $10_1 = HEAP32[$28_1 + 4 >> 2];
      $21_1 = $7_1 << 1;
      $26_1 = $3_1;
      $69($15_1, $12_1, $10_1, 0, 0, $21_1, $3_1, 0, 0);
      $1_1 = HEAP32[$27_1 + 4 >> 2];
      $41_1 = $1_1;
      $33_1 = HEAP32[$27_1 >> 2];
      $4_1 = $33_1;
      $3_1 = $1_1 << 1 | $4_1 >>> 31;
      $16_1 = $6_1 + 5312 | 0;
      $13_1 = HEAP32[$25_1 >> 2];
      $9_1 = HEAP32[$25_1 + 4 >> 2];
      $4_1 = $4_1 << 1;
      $5_1 = $3_1;
      $69($16_1, $13_1, $9_1, 0, 0, $4_1, $3_1, 0, 0);
      $14_1 = $6_1 + 5200 | 0;
      $8_1 = HEAP32[$18_1 >> 2];
      $1_1 = HEAP32[$18_1 + 4 >> 2];
      $69($14_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
      $11_1 = $6_1 + 5184 | 0;
      $69($11_1, HEAP32[$6_1 + 5200 >> 2], HEAP32[$6_1 + 5204 >> 2], 0, 0, 15632, 16, 0, 0);
      $3_1 = $1_1 << 1 | $8_1 >>> 31;
      $39_1 = $6_1 + 5152 | 0;
      $24_1 = $8_1 << 1;
      $17_1 = $3_1;
      $69($39_1, $24_1, $3_1, 0, 0, $7_1, $22_1, 0, 0);
      $38_1 = $6_1 + 5232 | 0;
      $69($38_1, $12_1, $10_1, 0, 0, $4_1, $5_1, 0, 0);
      $35_1 = $6_1 + 5296 | 0;
      $69($35_1, $13_1, $9_1, 0, 0, $13_1, $9_1, 0, 0);
      $28_1 = $6_1 + 5168 | 0;
      $1_1 = $14_1 + 8 | 0;
      $69($28_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $36_1 = $6_1 + 5360 | 0;
      $69($36_1, $7_1, $22_1, 0, 0, $7_1, $22_1, 0, 0);
      $31_1 = $6_1 + 5136 | 0;
      $69($31_1, $24_1, $3_1, 0, 0, $33_1, $41_1, 0, 0);
      $37_1 = $6_1 + 5248 | 0;
      $69($37_1, $12_1, $10_1, 0, 0, $13_1 << 1, $9_1 << 1 | $13_1 >>> 31, 0, 0);
      $20_1 = HEAP32[$6_1 + 5220 >> 2];
      $3_1 = $20_1 + HEAP32[$6_1 + 5316 >> 2] | 0;
      $8_1 = HEAP32[$6_1 + 5216 >> 2];
      $4_1 = HEAP32[$6_1 + 5312 >> 2];
      $1_1 = $8_1 + $4_1 | 0;
      $5_1 = HEAP32[$6_1 + 5184 >> 2];
      $18_1 = $1_1 + $5_1 | 0;
      $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + HEAP32[$6_1 + 5188 >> 2] | 0;
      $5_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
      $3_1 = $11_1 + 8 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $7_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = ($4_1 | 0) == ($20_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0;
      $3_1 = $16_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $15_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $16_1 | 0;
      $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $11_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $14_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $5_1;
      $11_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $30_1 = HEAP32[$6_1 + 5232 >> 2];
      $1_1 = HEAP32[$6_1 + 5296 >> 2];
      $14_1 = $30_1 + $1_1 | 0;
      $34_1 = HEAP32[$6_1 + 5236 >> 2];
      $3_1 = $34_1 + HEAP32[$6_1 + 5300 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 5152 >> 2];
      $7_1 = $1_1 + $14_1 | 0;
      $20_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 5156 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 5168 >> 2];
      $5_1 = $1_1 + $7_1 | 0;
      $16_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 5172 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $32_1 = $6_1 + 5120 | 0;
      $29_1 = $32_1;
      $11_1 = $5_1 + $11_1 | 0;
      $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $27_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
      $25_1 = ($1_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
      $1_1 = $28_1 + 8 | 0;
      $23_1 = HEAP32[$1_1 >> 2];
      $19_1 = HEAP32[$1_1 + 4 >> 2];
      $22_1 = ($16_1 | 0) == ($20_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $16_1 >>> 0 < $20_1 >>> 0;
      $1_1 = $39_1 + 8 | 0;
      $28_1 = HEAP32[$1_1 >> 2];
      $16_1 = HEAP32[$1_1 + 4 >> 2];
      $7_1 = ($20_1 | 0) == ($34_1 | 0) & $14_1 >>> 0 < $30_1 >>> 0 | $20_1 >>> 0 < $34_1 >>> 0;
      $3_1 = $35_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $38_1 + 8 | 0;
      $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $7_1 + $14_1 | 0;
      $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $28_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $22_1 | 0;
      $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $23_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1 + $25_1 | 0;
      $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $27_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $8_1;
      $7_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $19_1 = HEAP32[$6_1 + 5136 >> 2];
      $1_1 = HEAP32[$6_1 + 5248 >> 2];
      $14_1 = $19_1 + $1_1 | 0;
      $23_1 = HEAP32[$6_1 + 5140 >> 2];
      $3_1 = $23_1 + HEAP32[$6_1 + 5252 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $7_1 = $7_1 + $14_1 | 0;
      $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $28_1 = $7_1 << 4 & -16;
      $8_1 = $3_1;
      $20_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
      $16_1 = $4_1;
      $69($29_1, $28_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
      $29_1 = $6_1 + 5344 | 0;
      $69($29_1, $33_1, $41_1, 0, 0, $21_1, $26_1, 0, 0);
      $25_1 = $6_1 + 5088 | 0;
      $69($25_1, $24_1, $17_1, 0, 0, $13_1, $9_1, 0, 0);
      $22_1 = $6_1 + 5264 | 0;
      $69($22_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
      $28_1 = $6_1 + 5072 | 0;
      $20_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
      $3_1 = $37_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $31_1 + 8 | 0;
      $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $14_1 | 0;
      $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $8_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $20_1 = HEAP32[$6_1 + 5088 >> 2];
      $1_1 = HEAP32[$6_1 + 5264 >> 2];
      $7_1 = $20_1 + $1_1 | 0;
      $27_1 = HEAP32[$6_1 + 5092 >> 2];
      $3_1 = $27_1 + HEAP32[$6_1 + 5268 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $8_1 = $7_1 + $8_1 | 0;
      $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $3_1;
      $69($28_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $23_1 = $6_1 + 5280 | 0;
      $69($23_1, $13_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
      $19_1 = $6_1 + 5328 | 0;
      $69($19_1, $33_1, $41_1, 0, 0, $33_1, $41_1, 0, 0);
      $14_1 = $6_1 + 5024 | 0;
      $69($14_1, $24_1, $17_1, 0, 0, $12_1, $10_1, 0, 0);
      $21_1 = $6_1 + 5008 | 0;
      $10_1 = $21_1;
      $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $7_1 = ($1_1 | 0) == ($27_1 | 0) & $7_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
      $3_1 = $22_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $1_1 = $25_1 + 8 | 0;
      $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $7_1 + $12_1 | 0;
      $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $5_1 >>> 20;
      $5_1 = HEAP32[$6_1 + 5024 >> 2];
      $9_1 = $8_1 + $5_1 | 0;
      $4_1 = $3_1;
      $1_1 = $3_1 << 12 | $1_1 >>> 20;
      $3_1 = $1_1 + HEAP32[$6_1 + 5028 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $27_1 = $6_1 + 4944 | 0;
      $7_1 = $27_1;
      $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $1_1 = $14_1 + 8 | 0;
      $5_1 = HEAP32[$1_1 >> 2];
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $4_1 = HEAP32[$6_1 + 5120 >> 2];
      $1_1 = HEAP32[$6_1 + 5360 >> 2];
      $7_1 = $4_1 + $1_1 | 0;
      $8_1 = HEAP32[$6_1 + 5124 >> 2];
      $3_1 = $8_1 + HEAP32[$6_1 + 5364 >> 2] | 0;
      $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
      $3_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $32_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $9_1 | 0;
      $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $5_1;
      $8_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $10_1 = HEAP32[$6_1 + 5072 >> 2];
      $1_1 = HEAP32[$6_1 + 5344 >> 2];
      $9_1 = $10_1 + $1_1 | 0;
      $14_1 = HEAP32[$6_1 + 5076 >> 2];
      $3_1 = $14_1 + HEAP32[$6_1 + 5348 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $8_1 = $8_1 + $9_1 | 0;
      $5_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
      $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
      $3_1 = $29_1 + 8 | 0;
      $9_1 = HEAP32[$3_1 >> 2];
      $1_1 = $28_1 + 8 | 0;
      $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $10_1 + $14_1 | 0;
      $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $12_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $5_1;
      $9_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $22_1 = HEAP32[$6_1 + 5280 >> 2];
      $1_1 = HEAP32[$6_1 + 5328 >> 2];
      $12_1 = $22_1 + $1_1 | 0;
      $29_1 = HEAP32[$6_1 + 5284 >> 2];
      $3_1 = $29_1 + HEAP32[$6_1 + 5332 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 5008 >> 2];
      $10_1 = $1_1 + $12_1 | 0;
      $17_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 5012 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $25_1 = $6_1 + 4928 | 0;
      $28_1 = $25_1;
      $5_1 = $9_1 + $10_1 | 0;
      $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
      $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
      $1_1 = $21_1 + 8 | 0;
      $26_1 = HEAP32[$1_1 >> 2];
      $21_1 = HEAP32[$1_1 + 4 >> 2];
      $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
      $3_1 = $19_1 + 8 | 0;
      $10_1 = HEAP32[$3_1 >> 2];
      $1_1 = $23_1 + 8 | 0;
      $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $12_1 + $17_1 | 0;
      $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
      $12_1 = $1_1;
      $1_1 = $1_1 + $26_1 | 0;
      $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $1_1 + $24_1 | 0;
      $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $10_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $9_1;
      $12_1 = $1_1 << 12 | $9_1 >>> 20;
      $4_1 = $3_1;
      $17_1 = $3_1 << 12 | $1_1 >>> 20;
      $29_1 = HEAP32[$6_1 + 4948 >> 2];
      $3_1 = $29_1 + ($15_1 & 1048575) | 0;
      $22_1 = HEAP32[$6_1 + 4944 >> 2];
      $1_1 = $18_1 & -2;
      $9_1 = $22_1 + $1_1 | 0;
      $15_1 = $9_1;
      $12_1 = $9_1 + $12_1 | 0;
      $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $17_1 | 0;
      $9_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $17_1 = $9_1 & 1048575;
      $3_1 = $13_1 & 1048575;
      $32_1 = $3_1;
      $13_1 = $7_1;
      $3_1 = $3_1 << 1 | $7_1 >>> 31;
      $26_1 = $7_1 << 1;
      $24_1 = $3_1;
      $69($28_1, $12_1, $17_1, 0, 0, $26_1, $3_1, 0, 0);
      $3_1 = $14_1 & 1048575;
      $33_1 = $3_1;
      $23_1 = $6_1 + 4960 | 0;
      $18_1 = $10_1 & 1048575;
      $7_1 = $8_1 << 1;
      $28_1 = $8_1;
      $10_1 = $3_1 << 1 | $8_1 >>> 31;
      $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
      $19_1 = $6_1 + 4864 | 0;
      $20_1 = $19_1;
      $21_1 = $16_1 & 65535;
      $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
      $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
      $1_1 = $27_1 + 8 | 0;
      $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $9_1 >>> 20;
      $4_1 = $8_1 + $11_1 | 0;
      $3_1 = $21_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
      $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($20_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
      $11_1 = $6_1 + 4848 | 0;
      $69($11_1, HEAP32[$6_1 + 4864 >> 2], HEAP32[$6_1 + 4868 >> 2], 0, 0, 15632, 16, 0, 0);
      $1_1 = $4_1;
      $3_1 = $3_1 << 1 | $1_1 >>> 31;
      $39_1 = $6_1 + 4816 | 0;
      $20_1 = $1_1 << 1;
      $21_1 = $3_1;
      $69($39_1, $20_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
      $38_1 = $6_1 + 4912 | 0;
      $69($38_1, $12_1, $17_1, 0, 0, $7_1, $10_1, 0, 0);
      $35_1 = $6_1 + 4976 | 0;
      $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
      $22_1 = $6_1 + 4832 | 0;
      $1_1 = $19_1 + 8 | 0;
      $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $36_1 = $6_1 + 5104 | 0;
      $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
      $31_1 = $6_1 + 4800 | 0;
      $69($31_1, $20_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
      $37_1 = $6_1 + 4880 | 0;
      $10_1 = $17_1;
      $9_1 = $18_1;
      $17_1 = $5_1;
      $69($37_1, $12_1, $10_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
      $8_1 = HEAP32[$6_1 + 4928 >> 2];
      $4_1 = HEAP32[$6_1 + 4960 >> 2];
      $1_1 = $8_1 + $4_1 | 0;
      $13_1 = HEAP32[$6_1 + 4932 >> 2];
      $3_1 = $13_1 + HEAP32[$6_1 + 4964 >> 2] | 0;
      $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 4848 >> 2];
      $18_1 = $4_1 + $1_1 | 0;
      $5_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 4852 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
      $3_1 = $11_1 + 8 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $7_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = ($5_1 | 0) == ($13_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $13_1 >>> 0;
      $3_1 = $23_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $25_1 + 8 | 0;
      $13_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $13_1 | 0;
      $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $11_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $14_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $4_1;
      $11_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $30_1 = HEAP32[$6_1 + 4912 >> 2];
      $1_1 = HEAP32[$6_1 + 4976 >> 2];
      $13_1 = $30_1 + $1_1 | 0;
      $34_1 = HEAP32[$6_1 + 4916 >> 2];
      $3_1 = $34_1 + HEAP32[$6_1 + 4980 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 4816 >> 2];
      $14_1 = $1_1 + $13_1 | 0;
      $4_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 4820 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 4832 >> 2];
      $7_1 = $1_1 + $14_1 | 0;
      $16_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 4836 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $32_1 = $6_1 + 4704 | 0;
      $29_1 = $32_1;
      $11_1 = $7_1 + $11_1 | 0;
      $8_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $27_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
      $25_1 = ($1_1 | 0) == ($16_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
      $1_1 = $22_1 + 8 | 0;
      $23_1 = HEAP32[$1_1 >> 2];
      $19_1 = HEAP32[$1_1 + 4 >> 2];
      $22_1 = ($4_1 | 0) == ($16_1 | 0) & $13_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 > $16_1 >>> 0;
      $1_1 = $39_1 + 8 | 0;
      $16_1 = HEAP32[$1_1 >> 2];
      $14_1 = HEAP32[$1_1 + 4 >> 2];
      $7_1 = ($4_1 | 0) == ($34_1 | 0) & $13_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
      $3_1 = $35_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $38_1 + 8 | 0;
      $13_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $7_1 + $13_1 | 0;
      $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $14_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $22_1 | 0;
      $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $23_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1 + $25_1 | 0;
      $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $27_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $8_1;
      $7_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $19_1 = HEAP32[$6_1 + 4800 >> 2];
      $1_1 = HEAP32[$6_1 + 4880 >> 2];
      $14_1 = $19_1 + $1_1 | 0;
      $23_1 = HEAP32[$6_1 + 4804 >> 2];
      $3_1 = $23_1 + HEAP32[$6_1 + 4884 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $7_1 = $7_1 + $14_1 | 0;
      $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $22_1 = $7_1 << 4 & -16;
      $8_1 = $3_1;
      $13_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
      $16_1 = $4_1;
      $69($29_1, $22_1 | $4_1 >>> 16 & 15, $13_1, 0, 0, 977, 1, 0, 0);
      $29_1 = $6_1 + 5040 | 0;
      $69($29_1, $28_1, $33_1, 0, 0, $26_1, $24_1, 0, 0);
      $27_1 = $6_1 + 4784 | 0;
      $69($27_1, $20_1, $21_1, 0, 0, $17_1, $9_1, 0, 0);
      $25_1 = $6_1 + 4896 | 0;
      $69($25_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
      $22_1 = $6_1 + 4768 | 0;
      $13_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
      $3_1 = $37_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $31_1 + 8 | 0;
      $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $14_1 | 0;
      $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $13_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $8_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $13_1 = HEAP32[$6_1 + 4784 >> 2];
      $1_1 = HEAP32[$6_1 + 4896 >> 2];
      $7_1 = $13_1 + $1_1 | 0;
      $30_1 = HEAP32[$6_1 + 4788 >> 2];
      $3_1 = $30_1 + HEAP32[$6_1 + 4900 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $8_1 = $7_1 + $8_1 | 0;
      $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $3_1;
      $69($22_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $23_1 = $6_1 + 4992 | 0;
      $69($23_1, $17_1, $9_1, 0, 0, $26_1, $24_1, 0, 0);
      $19_1 = $6_1 + 5056 | 0;
      $69($19_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
      $14_1 = $6_1 + 4752 | 0;
      $69($14_1, $12_1, $10_1, 0, 0, $20_1, $21_1, 0, 0);
      $21_1 = $6_1 + 4736 | 0;
      $10_1 = $21_1;
      $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $7_1 = ($1_1 | 0) == ($30_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
      $3_1 = $25_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $1_1 = $27_1 + 8 | 0;
      $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $7_1 + $12_1 | 0;
      $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $5_1 >>> 20;
      $5_1 = HEAP32[$6_1 + 4752 >> 2];
      $9_1 = $8_1 + $5_1 | 0;
      $4_1 = $3_1;
      $1_1 = $3_1 << 12 | $1_1 >>> 20;
      $3_1 = $1_1 + HEAP32[$6_1 + 4756 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $27_1 = $6_1 + 4720 | 0;
      $7_1 = $27_1;
      $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $1_1 = $14_1 + 8 | 0;
      $5_1 = HEAP32[$1_1 >> 2];
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $4_1 = HEAP32[$6_1 + 4704 >> 2];
      $1_1 = HEAP32[$6_1 + 5104 >> 2];
      $7_1 = $4_1 + $1_1 | 0;
      $8_1 = HEAP32[$6_1 + 4708 >> 2];
      $3_1 = $8_1 + HEAP32[$6_1 + 5108 >> 2] | 0;
      $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
      $3_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $32_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $9_1 | 0;
      $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $5_1;
      $8_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $12_1 = $3_1 << 12 | $1_1 >>> 20;
      $14_1 = HEAP32[$6_1 + 4772 >> 2];
      $3_1 = $14_1 + HEAP32[$6_1 + 5044 >> 2] | 0;
      $10_1 = HEAP32[$6_1 + 4768 >> 2];
      $1_1 = HEAP32[$6_1 + 5040 >> 2];
      $5_1 = $10_1 + $1_1 | 0;
      $9_1 = $5_1;
      $8_1 = $5_1 + $8_1 | 0;
      $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $12_1 | 0;
      $5_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
      $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
      $3_1 = $29_1 + 8 | 0;
      $9_1 = HEAP32[$3_1 >> 2];
      $1_1 = $22_1 + 8 | 0;
      $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $10_1 + $14_1 | 0;
      $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $12_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $5_1;
      $9_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $22_1 = HEAP32[$6_1 + 4992 >> 2];
      $1_1 = HEAP32[$6_1 + 5056 >> 2];
      $12_1 = $22_1 + $1_1 | 0;
      $29_1 = HEAP32[$6_1 + 4996 >> 2];
      $3_1 = $29_1 + HEAP32[$6_1 + 5060 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 4736 >> 2];
      $10_1 = $1_1 + $12_1 | 0;
      $17_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 4740 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $25_1 = $6_1 + 4624 | 0;
      $28_1 = $25_1;
      $5_1 = $9_1 + $10_1 | 0;
      $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
      $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
      $1_1 = $21_1 + 8 | 0;
      $26_1 = HEAP32[$1_1 >> 2];
      $21_1 = HEAP32[$1_1 + 4 >> 2];
      $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
      $3_1 = $19_1 + 8 | 0;
      $10_1 = HEAP32[$3_1 >> 2];
      $1_1 = $23_1 + 8 | 0;
      $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $12_1 + $17_1 | 0;
      $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
      $12_1 = $1_1;
      $1_1 = $1_1 + $26_1 | 0;
      $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $1_1 + $24_1 | 0;
      $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $10_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $9_1;
      $17_1 = $1_1 << 12 | $9_1 >>> 20;
      $4_1 = $3_1;
      $12_1 = $3_1 << 12 | $1_1 >>> 20;
      $29_1 = HEAP32[$6_1 + 4724 >> 2];
      $3_1 = $29_1 + ($15_1 & 1048575) | 0;
      $22_1 = HEAP32[$6_1 + 4720 >> 2];
      $9_1 = $18_1 & -2;
      $1_1 = $22_1 + $9_1 | 0;
      $15_1 = $1_1;
      $1_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $12_1 | 0;
      $12_1 = $15_1 + $17_1 | 0;
      $9_1 = $12_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = $9_1 & 1048575;
      $18_1 = $20_1;
      $3_1 = $13_1 & 1048575;
      $32_1 = $3_1;
      $13_1 = $7_1;
      $3_1 = $3_1 << 1 | $7_1 >>> 31;
      $21_1 = $7_1 << 1;
      $26_1 = $3_1;
      $69($28_1, $12_1, $18_1, 0, 0, $21_1, $3_1, 0, 0);
      $3_1 = $14_1 & 1048575;
      $33_1 = $3_1;
      $23_1 = $6_1 + 4576 | 0;
      $18_1 = $10_1 & 1048575;
      $7_1 = $8_1 << 1;
      $28_1 = $8_1;
      $10_1 = $3_1 << 1 | $8_1 >>> 31;
      $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
      $19_1 = $6_1 + 4528 | 0;
      $17_1 = $16_1 & 65535;
      $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
      $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
      $1_1 = $27_1 + 8 | 0;
      $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $9_1 >>> 20;
      $4_1 = $8_1 + $11_1 | 0;
      $3_1 = $17_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
      $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($19_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
      $11_1 = $6_1 + 4512 | 0;
      $69($11_1, HEAP32[$6_1 + 4528 >> 2], HEAP32[$6_1 + 4532 >> 2], 0, 0, 15632, 16, 0, 0);
      $1_1 = $4_1;
      $3_1 = $3_1 << 1 | $1_1 >>> 31;
      $39_1 = $6_1 + 4480 | 0;
      $24_1 = $1_1 << 1;
      $17_1 = $3_1;
      $69($39_1, $24_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
      $38_1 = $6_1 + 4560 | 0;
      $69($38_1, $12_1, $20_1, 0, 0, $7_1, $10_1, 0, 0);
      $35_1 = $6_1 + 4672 | 0;
      $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
      $22_1 = $6_1 + 4496 | 0;
      $1_1 = $19_1 + 8 | 0;
      $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $36_1 = $6_1 + 4640 | 0;
      $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
      $31_1 = $6_1 + 4464 | 0;
      $69($31_1, $24_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
      $37_1 = $6_1 + 4544 | 0;
      $16_1 = $12_1;
      $13_1 = $20_1;
      $9_1 = $18_1;
      $18_1 = $5_1;
      $69($37_1, $12_1, $13_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
      $8_1 = HEAP32[$6_1 + 4624 >> 2];
      $4_1 = HEAP32[$6_1 + 4576 >> 2];
      $1_1 = $8_1 + $4_1 | 0;
      $12_1 = HEAP32[$6_1 + 4628 >> 2];
      $3_1 = $12_1 + HEAP32[$6_1 + 4580 >> 2] | 0;
      $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 4512 >> 2];
      $14_1 = $4_1 + $1_1 | 0;
      $5_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 4516 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
      $3_1 = $11_1 + 8 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $7_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = ($5_1 | 0) == ($12_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $12_1 >>> 0;
      $3_1 = $23_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $25_1 + 8 | 0;
      $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $12_1 | 0;
      $3_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $11_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $4_1;
      $7_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $30_1 = HEAP32[$6_1 + 4560 >> 2];
      $1_1 = HEAP32[$6_1 + 4672 >> 2];
      $15_1 = $30_1 + $1_1 | 0;
      $34_1 = HEAP32[$6_1 + 4564 >> 2];
      $3_1 = $34_1 + HEAP32[$6_1 + 4676 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 4480 >> 2];
      $10_1 = $1_1 + $15_1 | 0;
      $4_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 4484 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 4496 >> 2];
      $11_1 = $1_1 + $10_1 | 0;
      $20_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 4500 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $32_1 = $6_1 + 4368 | 0;
      $29_1 = $32_1;
      $8_1 = $7_1 + $11_1 | 0;
      $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $27_1 = ($1_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
      $25_1 = ($1_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 < $20_1 >>> 0;
      $1_1 = $22_1 + 8 | 0;
      $23_1 = HEAP32[$1_1 >> 2];
      $19_1 = HEAP32[$1_1 + 4 >> 2];
      $22_1 = ($4_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $20_1 >>> 0;
      $1_1 = $39_1 + 8 | 0;
      $20_1 = HEAP32[$1_1 >> 2];
      $10_1 = HEAP32[$1_1 + 4 >> 2];
      $11_1 = ($4_1 | 0) == ($34_1 | 0) & $15_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
      $3_1 = $35_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $38_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $11_1 + $15_1 | 0;
      $3_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $22_1 | 0;
      $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $23_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1 + $25_1 | 0;
      $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $27_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1;
      $11_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $1_1 >>> 20;
      $19_1 = HEAP32[$6_1 + 4464 >> 2];
      $1_1 = HEAP32[$6_1 + 4544 >> 2];
      $15_1 = $19_1 + $1_1 | 0;
      $30_1 = HEAP32[$6_1 + 4468 >> 2];
      $3_1 = $30_1 + HEAP32[$6_1 + 4548 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $7_1 | 0;
      $11_1 = $11_1 + $15_1 | 0;
      $3_1 = $11_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $22_1 = $11_1 << 4 & -16;
      $7_1 = $3_1;
      $20_1 = ($3_1 << 4 | $11_1 >>> 28) & 16777215;
      $10_1 = $4_1;
      $69($29_1, $22_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
      $29_1 = $6_1 + 4608 | 0;
      $69($29_1, $28_1, $33_1, 0, 0, $21_1, $26_1, 0, 0);
      $27_1 = $6_1 + 4448 | 0;
      $69($27_1, $24_1, $17_1, 0, 0, $18_1, $9_1, 0, 0);
      $25_1 = $6_1 + 4688 | 0;
      $69($25_1, $16_1, $13_1, 0, 0, $16_1, $13_1, 0, 0);
      $23_1 = $6_1 + 4432 | 0;
      $22_1 = $23_1;
      $20_1 = ($1_1 | 0) == ($3_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $11_1 = ($1_1 | 0) == ($30_1 | 0) & $15_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
      $3_1 = $37_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $31_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $11_1 + $15_1 | 0;
      $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $7_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $20_1 = HEAP32[$6_1 + 4448 >> 2];
      $1_1 = HEAP32[$6_1 + 4688 >> 2];
      $11_1 = $20_1 + $1_1 | 0;
      $30_1 = HEAP32[$6_1 + 4452 >> 2];
      $3_1 = $30_1 + HEAP32[$6_1 + 4692 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $7_1 = $7_1 + $11_1 | 0;
      $3_1 = $7_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $3_1;
      $69($22_1, $7_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $19_1 = $6_1 + 4592 | 0;
      $69($19_1, $18_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
      $22_1 = $6_1 + 4656 | 0;
      $69($22_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
      $15_1 = $6_1 + 4416 | 0;
      $69($15_1, $16_1, $13_1, 0, 0, $24_1, $17_1, 0, 0);
      $18_1 = $6_1 + 4400 | 0;
      $13_1 = $18_1;
      $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $11_1 = ($1_1 | 0) == ($30_1 | 0) & $11_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
      $3_1 = $25_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $1_1 = $27_1 + 8 | 0;
      $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $11_1 + $16_1 | 0;
      $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $7_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $5_1 >>> 20;
      $5_1 = HEAP32[$6_1 + 4416 >> 2];
      $9_1 = $7_1 + $5_1 | 0;
      $4_1 = $3_1;
      $1_1 = $3_1 << 12 | $1_1 >>> 20;
      $3_1 = $1_1 + HEAP32[$6_1 + 4420 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($13_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $20_1 = $6_1 + 4384 | 0;
      $11_1 = $20_1;
      $7_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $1_1 = $15_1 + 8 | 0;
      $5_1 = HEAP32[$1_1 >> 2];
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $7_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($11_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $4_1 = HEAP32[$6_1 + 4368 >> 2];
      $1_1 = HEAP32[$6_1 + 4640 >> 2];
      $9_1 = $4_1 + $1_1 | 0;
      $7_1 = HEAP32[$6_1 + 4372 >> 2];
      $3_1 = $7_1 + HEAP32[$6_1 + 4644 >> 2] | 0;
      $30_1 = $6_1 + 7456 | 0;
      $27_1 = $30_1 + 8 | 0;
      $17_1 = $27_1;
      $5_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = ($7_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $9_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
      $3_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $32_1 + 8 | 0;
      $11_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $7_1 + $11_1 | 0;
      $3_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $11_1 = $5_1;
      $7_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $16_1 = $3_1 << 12 | $1_1 >>> 20;
      $21_1 = HEAP32[$6_1 + 4436 >> 2];
      $3_1 = $21_1 + HEAP32[$6_1 + 4612 >> 2] | 0;
      $15_1 = HEAP32[$6_1 + 4432 >> 2];
      $1_1 = HEAP32[$6_1 + 4608 >> 2];
      $5_1 = $15_1 + $1_1 | 0;
      $13_1 = $5_1;
      $7_1 = $5_1 + $7_1 | 0;
      $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $16_1 | 0;
      HEAP32[$17_1 >> 2] = $7_1;
      $5_1 = $7_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$17_1 + 4 >> 2] = $5_1 & 1048575;
      $25_1 = $30_1 + 16 | 0;
      $17_1 = $25_1;
      $16_1 = ($1_1 | 0) == ($5_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
      $13_1 = ($1_1 | 0) == ($21_1 | 0) & $13_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $21_1 >>> 0;
      $3_1 = $29_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $1_1 = $23_1 + 8 | 0;
      $15_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $13_1 + $15_1 | 0;
      $3_1 = $7_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $7_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $24_1 = HEAP32[$6_1 + 4592 >> 2];
      $1_1 = HEAP32[$6_1 + 4656 >> 2];
      $16_1 = $24_1 + $1_1 | 0;
      $23_1 = HEAP32[$6_1 + 4596 >> 2];
      $3_1 = $23_1 + HEAP32[$6_1 + 4660 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 4400 >> 2];
      $13_1 = $1_1 + $16_1 | 0;
      $15_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 4404 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $7_1 = $7_1 + $13_1 | 0;
      $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$17_1 >> 2] = $7_1;
      $5_1 = $3_1;
      HEAP32[$17_1 + 4 >> 2] = $3_1 & 1048575;
      $28_1 = $30_1 + 24 | 0;
      $26_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $21_1 = ($1_1 | 0) == ($15_1 | 0) & $13_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
      $1_1 = $18_1 + 8 | 0;
      $17_1 = HEAP32[$1_1 >> 2];
      $18_1 = HEAP32[$1_1 + 4 >> 2];
      $13_1 = ($15_1 | 0) == ($23_1 | 0) & $16_1 >>> 0 < $24_1 >>> 0 | $15_1 >>> 0 < $23_1 >>> 0;
      $3_1 = $22_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $1_1 = $19_1 + 8 | 0;
      $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $13_1 + $16_1 | 0;
      $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
      $7_1 = $1_1;
      $1_1 = $1_1 + $17_1 | 0;
      $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 + $21_1 | 0;
      $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $7_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $26_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $7_1 = $3_1 << 12 | $1_1 >>> 20;
      $16_1 = HEAP32[$6_1 + 4384 >> 2];
      $5_1 = $14_1 & -2;
      $1_1 = $16_1 + $5_1 | 0;
      $17_1 = HEAP32[$6_1 + 4388 >> 2];
      $3_1 = $17_1 + ($12_1 & 1048575) | 0;
      $14_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $14_1 + $7_1 | 0;
      $12_1 = $1_1;
      $5_1 = $1_1 + $13_1 | 0;
      HEAP32[$28_1 >> 2] = $5_1;
      $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$28_1 + 4 >> 2] = $1_1 & 1048575;
      $18_1 = $30_1 + 32 | 0;
      $15_1 = $18_1;
      $7_1 = $8_1;
      $13_1 = $10_1 & 65535;
      $10_1 = ($1_1 | 0) == ($14_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
      $5_1 = ($14_1 | 0) == ($17_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $14_1 >>> 0 < $17_1 >>> 0;
      $3_1 = $20_1 + 8 | 0;
      $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $4_1 << 12 | $1_1 >>> 20;
      $5_1 = $1_1 + $7_1 | 0;
      $3_1 = $13_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
      HEAP32[$15_1 >> 2] = $5_1;
      HEAP32[$15_1 + 4 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 7456 >> 2] = $9_1;
      HEAP32[$6_1 + 7460 >> 2] = $11_1 & 1048575;
      $34($30_1, $30_1, $42_1);
      $1_1 = HEAP32[$6_1 + 7460 >> 2];
      $22_1 = $1_1;
      $20_1 = HEAP32[$6_1 + 7456 >> 2];
      $7_1 = $20_1;
      $3_1 = $1_1 << 1 | $7_1 >>> 31;
      $15_1 = $6_1 + 4208 | 0;
      $12_1 = HEAP32[$28_1 >> 2];
      $10_1 = HEAP32[$28_1 + 4 >> 2];
      $21_1 = $7_1 << 1;
      $26_1 = $3_1;
      $69($15_1, $12_1, $10_1, 0, 0, $21_1, $3_1, 0, 0);
      $1_1 = HEAP32[$27_1 + 4 >> 2];
      $41_1 = $1_1;
      $33_1 = HEAP32[$27_1 >> 2];
      $4_1 = $33_1;
      $3_1 = $1_1 << 1 | $4_1 >>> 31;
      $16_1 = $6_1 + 4304 | 0;
      $13_1 = HEAP32[$25_1 >> 2];
      $9_1 = HEAP32[$25_1 + 4 >> 2];
      $4_1 = $4_1 << 1;
      $5_1 = $3_1;
      $69($16_1, $13_1, $9_1, 0, 0, $4_1, $3_1, 0, 0);
      $14_1 = $6_1 + 4192 | 0;
      $8_1 = HEAP32[$18_1 >> 2];
      $1_1 = HEAP32[$18_1 + 4 >> 2];
      $69($14_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
      $11_1 = $6_1 + 4176 | 0;
      $69($11_1, HEAP32[$6_1 + 4192 >> 2], HEAP32[$6_1 + 4196 >> 2], 0, 0, 15632, 16, 0, 0);
      $3_1 = $1_1 << 1 | $8_1 >>> 31;
      $39_1 = $6_1 + 4144 | 0;
      $24_1 = $8_1 << 1;
      $17_1 = $3_1;
      $69($39_1, $24_1, $3_1, 0, 0, $7_1, $22_1, 0, 0);
      $38_1 = $6_1 + 4224 | 0;
      $69($38_1, $12_1, $10_1, 0, 0, $4_1, $5_1, 0, 0);
      $35_1 = $6_1 + 4288 | 0;
      $69($35_1, $13_1, $9_1, 0, 0, $13_1, $9_1, 0, 0);
      $28_1 = $6_1 + 4160 | 0;
      $1_1 = $14_1 + 8 | 0;
      $69($28_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $36_1 = $6_1 + 4352 | 0;
      $69($36_1, $7_1, $22_1, 0, 0, $7_1, $22_1, 0, 0);
      $31_1 = $6_1 + 4128 | 0;
      $69($31_1, $24_1, $3_1, 0, 0, $33_1, $41_1, 0, 0);
      $37_1 = $6_1 + 4240 | 0;
      $69($37_1, $12_1, $10_1, 0, 0, $13_1 << 1, $9_1 << 1 | $13_1 >>> 31, 0, 0);
      $20_1 = HEAP32[$6_1 + 4212 >> 2];
      $3_1 = $20_1 + HEAP32[$6_1 + 4308 >> 2] | 0;
      $8_1 = HEAP32[$6_1 + 4208 >> 2];
      $4_1 = HEAP32[$6_1 + 4304 >> 2];
      $1_1 = $8_1 + $4_1 | 0;
      $5_1 = HEAP32[$6_1 + 4176 >> 2];
      $18_1 = $1_1 + $5_1 | 0;
      $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + HEAP32[$6_1 + 4180 >> 2] | 0;
      $5_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
      $3_1 = $11_1 + 8 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $7_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = ($4_1 | 0) == ($20_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0;
      $3_1 = $16_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $15_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $16_1 | 0;
      $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $11_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $14_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $5_1;
      $11_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $30_1 = HEAP32[$6_1 + 4224 >> 2];
      $1_1 = HEAP32[$6_1 + 4288 >> 2];
      $14_1 = $30_1 + $1_1 | 0;
      $34_1 = HEAP32[$6_1 + 4228 >> 2];
      $3_1 = $34_1 + HEAP32[$6_1 + 4292 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 4144 >> 2];
      $7_1 = $1_1 + $14_1 | 0;
      $20_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 4148 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 4160 >> 2];
      $5_1 = $1_1 + $7_1 | 0;
      $16_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 4164 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $32_1 = $6_1 + 4112 | 0;
      $29_1 = $32_1;
      $11_1 = $5_1 + $11_1 | 0;
      $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $27_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
      $25_1 = ($1_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
      $1_1 = $28_1 + 8 | 0;
      $23_1 = HEAP32[$1_1 >> 2];
      $19_1 = HEAP32[$1_1 + 4 >> 2];
      $22_1 = ($16_1 | 0) == ($20_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $16_1 >>> 0 < $20_1 >>> 0;
      $1_1 = $39_1 + 8 | 0;
      $28_1 = HEAP32[$1_1 >> 2];
      $16_1 = HEAP32[$1_1 + 4 >> 2];
      $7_1 = ($20_1 | 0) == ($34_1 | 0) & $14_1 >>> 0 < $30_1 >>> 0 | $20_1 >>> 0 < $34_1 >>> 0;
      $3_1 = $35_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $38_1 + 8 | 0;
      $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $7_1 + $14_1 | 0;
      $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $28_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $22_1 | 0;
      $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $23_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1 + $25_1 | 0;
      $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $27_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $8_1;
      $7_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $19_1 = HEAP32[$6_1 + 4128 >> 2];
      $1_1 = HEAP32[$6_1 + 4240 >> 2];
      $14_1 = $19_1 + $1_1 | 0;
      $23_1 = HEAP32[$6_1 + 4132 >> 2];
      $3_1 = $23_1 + HEAP32[$6_1 + 4244 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $7_1 = $7_1 + $14_1 | 0;
      $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $28_1 = $7_1 << 4 & -16;
      $8_1 = $3_1;
      $20_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
      $16_1 = $4_1;
      $69($29_1, $28_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
      $29_1 = $6_1 + 4336 | 0;
      $69($29_1, $33_1, $41_1, 0, 0, $21_1, $26_1, 0, 0);
      $25_1 = $6_1 + 4080 | 0;
      $69($25_1, $24_1, $17_1, 0, 0, $13_1, $9_1, 0, 0);
      $22_1 = $6_1 + 4256 | 0;
      $69($22_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
      $28_1 = $6_1 + 4064 | 0;
      $20_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
      $3_1 = $37_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $31_1 + 8 | 0;
      $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $14_1 | 0;
      $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $8_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $20_1 = HEAP32[$6_1 + 4080 >> 2];
      $1_1 = HEAP32[$6_1 + 4256 >> 2];
      $7_1 = $20_1 + $1_1 | 0;
      $27_1 = HEAP32[$6_1 + 4084 >> 2];
      $3_1 = $27_1 + HEAP32[$6_1 + 4260 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $8_1 = $7_1 + $8_1 | 0;
      $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $3_1;
      $69($28_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $23_1 = $6_1 + 4272 | 0;
      $69($23_1, $13_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
      $19_1 = $6_1 + 4320 | 0;
      $69($19_1, $33_1, $41_1, 0, 0, $33_1, $41_1, 0, 0);
      $14_1 = $6_1 + 4016 | 0;
      $69($14_1, $24_1, $17_1, 0, 0, $12_1, $10_1, 0, 0);
      $21_1 = $6_1 + 4e3 | 0;
      $10_1 = $21_1;
      $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $7_1 = ($1_1 | 0) == ($27_1 | 0) & $7_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
      $3_1 = $22_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $1_1 = $25_1 + 8 | 0;
      $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $7_1 + $12_1 | 0;
      $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $5_1 >>> 20;
      $5_1 = HEAP32[$6_1 + 4016 >> 2];
      $9_1 = $8_1 + $5_1 | 0;
      $4_1 = $3_1;
      $1_1 = $3_1 << 12 | $1_1 >>> 20;
      $3_1 = $1_1 + HEAP32[$6_1 + 4020 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $27_1 = $6_1 + 3936 | 0;
      $7_1 = $27_1;
      $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $1_1 = $14_1 + 8 | 0;
      $5_1 = HEAP32[$1_1 >> 2];
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $4_1 = HEAP32[$6_1 + 4112 >> 2];
      $1_1 = HEAP32[$6_1 + 4352 >> 2];
      $7_1 = $4_1 + $1_1 | 0;
      $8_1 = HEAP32[$6_1 + 4116 >> 2];
      $3_1 = $8_1 + HEAP32[$6_1 + 4356 >> 2] | 0;
      $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
      $3_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $32_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $9_1 | 0;
      $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $5_1;
      $8_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $10_1 = HEAP32[$6_1 + 4064 >> 2];
      $1_1 = HEAP32[$6_1 + 4336 >> 2];
      $9_1 = $10_1 + $1_1 | 0;
      $14_1 = HEAP32[$6_1 + 4068 >> 2];
      $3_1 = $14_1 + HEAP32[$6_1 + 4340 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $8_1 = $8_1 + $9_1 | 0;
      $5_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
      $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
      $3_1 = $29_1 + 8 | 0;
      $9_1 = HEAP32[$3_1 >> 2];
      $1_1 = $28_1 + 8 | 0;
      $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $10_1 + $14_1 | 0;
      $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $12_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $5_1;
      $9_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $22_1 = HEAP32[$6_1 + 4272 >> 2];
      $1_1 = HEAP32[$6_1 + 4320 >> 2];
      $12_1 = $22_1 + $1_1 | 0;
      $29_1 = HEAP32[$6_1 + 4276 >> 2];
      $3_1 = $29_1 + HEAP32[$6_1 + 4324 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 4e3 >> 2];
      $10_1 = $1_1 + $12_1 | 0;
      $17_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 4004 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $25_1 = $6_1 + 3920 | 0;
      $28_1 = $25_1;
      $5_1 = $9_1 + $10_1 | 0;
      $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
      $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
      $1_1 = $21_1 + 8 | 0;
      $26_1 = HEAP32[$1_1 >> 2];
      $21_1 = HEAP32[$1_1 + 4 >> 2];
      $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
      $3_1 = $19_1 + 8 | 0;
      $10_1 = HEAP32[$3_1 >> 2];
      $1_1 = $23_1 + 8 | 0;
      $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $12_1 + $17_1 | 0;
      $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
      $12_1 = $1_1;
      $1_1 = $1_1 + $26_1 | 0;
      $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $1_1 + $24_1 | 0;
      $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $10_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $9_1;
      $12_1 = $1_1 << 12 | $9_1 >>> 20;
      $4_1 = $3_1;
      $17_1 = $3_1 << 12 | $1_1 >>> 20;
      $29_1 = HEAP32[$6_1 + 3940 >> 2];
      $3_1 = $29_1 + ($15_1 & 1048575) | 0;
      $22_1 = HEAP32[$6_1 + 3936 >> 2];
      $1_1 = $18_1 & -2;
      $9_1 = $22_1 + $1_1 | 0;
      $15_1 = $9_1;
      $12_1 = $9_1 + $12_1 | 0;
      $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $17_1 | 0;
      $9_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = $9_1 & 1048575;
      $18_1 = $20_1;
      $3_1 = $13_1 & 1048575;
      $32_1 = $3_1;
      $13_1 = $7_1;
      $3_1 = $3_1 << 1 | $7_1 >>> 31;
      $21_1 = $7_1 << 1;
      $26_1 = $3_1;
      $69($28_1, $12_1, $18_1, 0, 0, $21_1, $3_1, 0, 0);
      $3_1 = $14_1 & 1048575;
      $33_1 = $3_1;
      $23_1 = $6_1 + 3952 | 0;
      $18_1 = $10_1 & 1048575;
      $7_1 = $8_1 << 1;
      $28_1 = $8_1;
      $10_1 = $3_1 << 1 | $8_1 >>> 31;
      $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
      $19_1 = $6_1 + 3856 | 0;
      $17_1 = $16_1 & 65535;
      $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
      $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
      $1_1 = $27_1 + 8 | 0;
      $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $9_1 >>> 20;
      $4_1 = $8_1 + $11_1 | 0;
      $3_1 = $17_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
      $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($19_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
      $11_1 = $6_1 + 3840 | 0;
      $69($11_1, HEAP32[$6_1 + 3856 >> 2], HEAP32[$6_1 + 3860 >> 2], 0, 0, 15632, 16, 0, 0);
      $1_1 = $4_1;
      $3_1 = $3_1 << 1 | $1_1 >>> 31;
      $39_1 = $6_1 + 3808 | 0;
      $24_1 = $1_1 << 1;
      $17_1 = $3_1;
      $69($39_1, $24_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
      $38_1 = $6_1 + 3904 | 0;
      $69($38_1, $12_1, $20_1, 0, 0, $7_1, $10_1, 0, 0);
      $35_1 = $6_1 + 3968 | 0;
      $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
      $22_1 = $6_1 + 3824 | 0;
      $1_1 = $19_1 + 8 | 0;
      $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $36_1 = $6_1 + 4096 | 0;
      $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
      $31_1 = $6_1 + 3792 | 0;
      $69($31_1, $24_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
      $37_1 = $6_1 + 3872 | 0;
      $16_1 = $12_1;
      $13_1 = $20_1;
      $9_1 = $18_1;
      $18_1 = $5_1;
      $69($37_1, $12_1, $13_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
      $8_1 = HEAP32[$6_1 + 3920 >> 2];
      $4_1 = HEAP32[$6_1 + 3952 >> 2];
      $1_1 = $8_1 + $4_1 | 0;
      $12_1 = HEAP32[$6_1 + 3924 >> 2];
      $3_1 = $12_1 + HEAP32[$6_1 + 3956 >> 2] | 0;
      $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 3840 >> 2];
      $14_1 = $4_1 + $1_1 | 0;
      $5_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 3844 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
      $3_1 = $11_1 + 8 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $7_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = ($5_1 | 0) == ($12_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $12_1 >>> 0;
      $3_1 = $23_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $25_1 + 8 | 0;
      $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $12_1 | 0;
      $3_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $11_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $4_1;
      $7_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $30_1 = HEAP32[$6_1 + 3904 >> 2];
      $1_1 = HEAP32[$6_1 + 3968 >> 2];
      $15_1 = $30_1 + $1_1 | 0;
      $34_1 = HEAP32[$6_1 + 3908 >> 2];
      $3_1 = $34_1 + HEAP32[$6_1 + 3972 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 3808 >> 2];
      $10_1 = $1_1 + $15_1 | 0;
      $4_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 3812 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 3824 >> 2];
      $11_1 = $1_1 + $10_1 | 0;
      $20_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 3828 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $32_1 = $6_1 + 3696 | 0;
      $29_1 = $32_1;
      $8_1 = $7_1 + $11_1 | 0;
      $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $27_1 = ($1_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
      $25_1 = ($1_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 < $20_1 >>> 0;
      $1_1 = $22_1 + 8 | 0;
      $23_1 = HEAP32[$1_1 >> 2];
      $19_1 = HEAP32[$1_1 + 4 >> 2];
      $22_1 = ($4_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $20_1 >>> 0;
      $1_1 = $39_1 + 8 | 0;
      $20_1 = HEAP32[$1_1 >> 2];
      $10_1 = HEAP32[$1_1 + 4 >> 2];
      $11_1 = ($4_1 | 0) == ($34_1 | 0) & $15_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
      $3_1 = $35_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $38_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $11_1 + $15_1 | 0;
      $3_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $22_1 | 0;
      $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $23_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1 + $25_1 | 0;
      $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $27_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1;
      $11_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $1_1 >>> 20;
      $19_1 = HEAP32[$6_1 + 3792 >> 2];
      $1_1 = HEAP32[$6_1 + 3872 >> 2];
      $15_1 = $19_1 + $1_1 | 0;
      $30_1 = HEAP32[$6_1 + 3796 >> 2];
      $3_1 = $30_1 + HEAP32[$6_1 + 3876 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $7_1 | 0;
      $11_1 = $11_1 + $15_1 | 0;
      $3_1 = $11_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $22_1 = $11_1 << 4 & -16;
      $7_1 = $3_1;
      $20_1 = ($3_1 << 4 | $11_1 >>> 28) & 16777215;
      $10_1 = $4_1;
      $69($29_1, $22_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
      $29_1 = $6_1 + 4032 | 0;
      $69($29_1, $28_1, $33_1, 0, 0, $21_1, $26_1, 0, 0);
      $27_1 = $6_1 + 3776 | 0;
      $69($27_1, $24_1, $17_1, 0, 0, $18_1, $9_1, 0, 0);
      $25_1 = $6_1 + 3888 | 0;
      $69($25_1, $16_1, $13_1, 0, 0, $16_1, $13_1, 0, 0);
      $23_1 = $6_1 + 3760 | 0;
      $22_1 = $23_1;
      $20_1 = ($1_1 | 0) == ($3_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $11_1 = ($1_1 | 0) == ($30_1 | 0) & $15_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
      $3_1 = $37_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $31_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $11_1 + $15_1 | 0;
      $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $7_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $20_1 = HEAP32[$6_1 + 3776 >> 2];
      $1_1 = HEAP32[$6_1 + 3888 >> 2];
      $11_1 = $20_1 + $1_1 | 0;
      $30_1 = HEAP32[$6_1 + 3780 >> 2];
      $3_1 = $30_1 + HEAP32[$6_1 + 3892 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $7_1 = $7_1 + $11_1 | 0;
      $3_1 = $7_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $3_1;
      $69($22_1, $7_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $19_1 = $6_1 + 3984 | 0;
      $69($19_1, $18_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
      $22_1 = $6_1 + 4048 | 0;
      $69($22_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
      $15_1 = $6_1 + 3744 | 0;
      $69($15_1, $16_1, $13_1, 0, 0, $24_1, $17_1, 0, 0);
      $18_1 = $6_1 + 3728 | 0;
      $13_1 = $18_1;
      $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $11_1 = ($1_1 | 0) == ($30_1 | 0) & $11_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
      $3_1 = $25_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $1_1 = $27_1 + 8 | 0;
      $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $11_1 + $16_1 | 0;
      $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $7_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $5_1 >>> 20;
      $5_1 = HEAP32[$6_1 + 3744 >> 2];
      $9_1 = $7_1 + $5_1 | 0;
      $4_1 = $3_1;
      $1_1 = $3_1 << 12 | $1_1 >>> 20;
      $3_1 = $1_1 + HEAP32[$6_1 + 3748 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($13_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $20_1 = $6_1 + 3712 | 0;
      $11_1 = $20_1;
      $7_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $1_1 = $15_1 + 8 | 0;
      $5_1 = HEAP32[$1_1 >> 2];
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $7_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($11_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $4_1 = HEAP32[$6_1 + 3696 >> 2];
      $1_1 = HEAP32[$6_1 + 4096 >> 2];
      $9_1 = $4_1 + $1_1 | 0;
      $7_1 = HEAP32[$6_1 + 3700 >> 2];
      $3_1 = $7_1 + HEAP32[$6_1 + 4100 >> 2] | 0;
      $30_1 = $6_1 + 7416 | 0;
      $27_1 = $30_1 + 8 | 0;
      $17_1 = $27_1;
      $5_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = ($7_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $9_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
      $3_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $32_1 + 8 | 0;
      $11_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $7_1 + $11_1 | 0;
      $3_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $11_1 = $5_1;
      $7_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $16_1 = $3_1 << 12 | $1_1 >>> 20;
      $21_1 = HEAP32[$6_1 + 3764 >> 2];
      $3_1 = $21_1 + HEAP32[$6_1 + 4036 >> 2] | 0;
      $15_1 = HEAP32[$6_1 + 3760 >> 2];
      $1_1 = HEAP32[$6_1 + 4032 >> 2];
      $5_1 = $15_1 + $1_1 | 0;
      $13_1 = $5_1;
      $7_1 = $5_1 + $7_1 | 0;
      $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $16_1 | 0;
      HEAP32[$17_1 >> 2] = $7_1;
      $5_1 = $7_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$17_1 + 4 >> 2] = $5_1 & 1048575;
      $25_1 = $30_1 + 16 | 0;
      $17_1 = $25_1;
      $16_1 = ($1_1 | 0) == ($5_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
      $13_1 = ($1_1 | 0) == ($21_1 | 0) & $13_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $21_1 >>> 0;
      $3_1 = $29_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $1_1 = $23_1 + 8 | 0;
      $15_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $13_1 + $15_1 | 0;
      $3_1 = $7_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $7_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $24_1 = HEAP32[$6_1 + 3984 >> 2];
      $1_1 = HEAP32[$6_1 + 4048 >> 2];
      $16_1 = $24_1 + $1_1 | 0;
      $23_1 = HEAP32[$6_1 + 3988 >> 2];
      $3_1 = $23_1 + HEAP32[$6_1 + 4052 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 3728 >> 2];
      $13_1 = $1_1 + $16_1 | 0;
      $15_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 3732 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $7_1 = $7_1 + $13_1 | 0;
      $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$17_1 >> 2] = $7_1;
      $5_1 = $3_1;
      HEAP32[$17_1 + 4 >> 2] = $3_1 & 1048575;
      $28_1 = $30_1 + 24 | 0;
      $26_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $21_1 = ($1_1 | 0) == ($15_1 | 0) & $13_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
      $1_1 = $18_1 + 8 | 0;
      $17_1 = HEAP32[$1_1 >> 2];
      $18_1 = HEAP32[$1_1 + 4 >> 2];
      $13_1 = ($15_1 | 0) == ($23_1 | 0) & $16_1 >>> 0 < $24_1 >>> 0 | $15_1 >>> 0 < $23_1 >>> 0;
      $3_1 = $22_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $1_1 = $19_1 + 8 | 0;
      $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $13_1 + $16_1 | 0;
      $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
      $7_1 = $1_1;
      $1_1 = $1_1 + $17_1 | 0;
      $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 + $21_1 | 0;
      $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $7_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $26_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $7_1 = $3_1 << 12 | $1_1 >>> 20;
      $16_1 = HEAP32[$6_1 + 3712 >> 2];
      $5_1 = $14_1 & -2;
      $1_1 = $16_1 + $5_1 | 0;
      $18_1 = HEAP32[$6_1 + 3716 >> 2];
      $3_1 = $18_1 + ($12_1 & 1048575) | 0;
      $14_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $14_1 + $7_1 | 0;
      $12_1 = $1_1;
      $5_1 = $1_1 + $13_1 | 0;
      HEAP32[$28_1 >> 2] = $5_1;
      $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$28_1 + 4 >> 2] = $1_1 & 1048575;
      $15_1 = $30_1 + 32 | 0;
      $7_1 = $8_1;
      $13_1 = $10_1 & 65535;
      $10_1 = ($1_1 | 0) == ($14_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
      $5_1 = ($14_1 | 0) == ($18_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $14_1 >>> 0 < $18_1 >>> 0;
      $3_1 = $20_1 + 8 | 0;
      $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $4_1 << 12 | $1_1 >>> 20;
      $5_1 = $1_1 + $7_1 | 0;
      $3_1 = $13_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
      HEAP32[$15_1 >> 2] = $5_1;
      HEAP32[$15_1 + 4 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 7416 >> 2] = $9_1;
      HEAP32[$6_1 + 7420 >> 2] = $11_1 & 1048575;
      $34($30_1, $30_1, $40_1);
      $9_1 = HEAP32[$15_1 + 4 >> 2];
      $3_1 = $6_1 + 7376 | 0;
      $1_1 = $3_1 + 32 | 0;
      $4_1 = HEAP32[$15_1 >> 2];
      HEAP32[$1_1 >> 2] = $4_1;
      HEAP32[$1_1 + 4 >> 2] = $9_1;
      $10_1 = HEAP32[$28_1 + 4 >> 2];
      $1_1 = $3_1 + 24 | 0;
      $11_1 = HEAP32[$28_1 >> 2];
      HEAP32[$1_1 >> 2] = $11_1;
      HEAP32[$1_1 + 4 >> 2] = $10_1;
      $13_1 = HEAP32[$25_1 + 4 >> 2];
      $1_1 = $3_1 + 16 | 0;
      $7_1 = HEAP32[$25_1 >> 2];
      HEAP32[$1_1 >> 2] = $7_1;
      HEAP32[$1_1 + 4 >> 2] = $13_1;
      $14_1 = HEAP32[$27_1 + 4 >> 2];
      $1_1 = $3_1 + 8 | 0;
      $8_1 = HEAP32[$27_1 >> 2];
      HEAP32[$1_1 >> 2] = $8_1;
      HEAP32[$1_1 + 4 >> 2] = $14_1;
      $12_1 = HEAP32[$6_1 + 7420 >> 2];
      $5_1 = HEAP32[$6_1 + 7416 >> 2];
      HEAP32[$6_1 + 7376 >> 2] = $5_1;
      HEAP32[$6_1 + 7380 >> 2] = $12_1;
      $1_1 = 11;
      while (1) {
        $15_1 = $5_1;
        $3_1 = $12_1 << 1 | $5_1 >>> 31;
        $25_1 = $6_1 + 3664 | 0;
        $20_1 = $5_1 << 1;
        $28_1 = $3_1;
        $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
        $19_1 = $6_1 + 3584 | 0;
        $5_1 = $8_1 << 1;
        $16_1 = $14_1;
        $24_1 = $8_1;
        $8_1 = $14_1 << 1 | $8_1 >>> 31;
        $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
        $17_1 = $6_1 + 3520 | 0;
        $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
        $18_1 = $6_1 + 3504 | 0;
        $69($18_1, HEAP32[$6_1 + 3520 >> 2], HEAP32[$6_1 + 3524 >> 2], 0, 0, 15632, 16, 0, 0);
        $3_1 = $9_1 << 1 | $4_1 >>> 31;
        $33_1 = $6_1 + 3472 | 0;
        $22_1 = $4_1 << 1;
        $26_1 = $3_1;
        $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
        $34_1 = $6_1 + 3632 | 0;
        $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
        $39_1 = $6_1 + 3568 | 0;
        $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
        $23_1 = $6_1 + 3488 | 0;
        $3_1 = $17_1 + 8 | 0;
        $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
        $38_1 = $6_1 + 3680 | 0;
        $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
        $35_1 = $6_1 + 3456 | 0;
        $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
        $36_1 = $6_1 + 3536 | 0;
        $12_1 = $11_1;
        $21_1 = $7_1;
        $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
        $15_1 = HEAP32[$6_1 + 3668 >> 2];
        $3_1 = $15_1 + HEAP32[$6_1 + 3588 >> 2] | 0;
        $7_1 = HEAP32[$6_1 + 3664 >> 2];
        $5_1 = HEAP32[$6_1 + 3584 >> 2];
        $4_1 = $7_1 + $5_1 | 0;
        $8_1 = HEAP32[$6_1 + 3504 >> 2];
        $17_1 = $4_1 + $8_1 | 0;
        $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $5_1 + HEAP32[$6_1 + 3508 >> 2] | 0;
        $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
        $3_1 = $18_1 + 8 | 0;
        $9_1 = HEAP32[$3_1 >> 2];
        $11_1 = HEAP32[$3_1 + 4 >> 2];
        $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
        $5_1 = $19_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $25_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $7_1 + $15_1 | 0;
        $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
        $5_1 = $4_1;
        $4_1 = $4_1 + $9_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $14_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = $8_1;
        $9_1 = $4_1 << 12 | $8_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 3632 >> 2];
        $4_1 = HEAP32[$6_1 + 3568 >> 2];
        $15_1 = $31_1 + $4_1 | 0;
        $40_1 = HEAP32[$6_1 + 3636 >> 2];
        $3_1 = $40_1 + HEAP32[$6_1 + 3572 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 3472 >> 2];
        $11_1 = $4_1 + $15_1 | 0;
        $19_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 3476 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 3488 >> 2];
        $8_1 = $4_1 + $11_1 | 0;
        $18_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 3492 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $7_1 | 0;
        $37_1 = $6_1 + 3440 | 0;
        $9_1 = $8_1 + $9_1 | 0;
        $7_1 = $9_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
        $3_1 = $23_1 + 8 | 0;
        $29_1 = HEAP32[$3_1 >> 2];
        $27_1 = HEAP32[$3_1 + 4 >> 2];
        $25_1 = ($18_1 | 0) == ($19_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
        $3_1 = $33_1 + 8 | 0;
        $23_1 = HEAP32[$3_1 >> 2];
        $18_1 = HEAP32[$3_1 + 4 >> 2];
        $11_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
        $8_1 = $39_1 + 8 | 0;
        $4_1 = HEAP32[$8_1 >> 2];
        $3_1 = $34_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $11_1 + $15_1 | 0;
        $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + $23_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1;
        $4_1 = $4_1 + $25_1 | 0;
        $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + $29_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1 + $32_1 | 0;
        $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $30_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $7_1;
        $11_1 = $4_1 << 12 | $5_1 >>> 20;
        $8_1 = $3_1;
        $18_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 3460 >> 2];
        $3_1 = $31_1 + HEAP32[$6_1 + 3540 >> 2] | 0;
        $25_1 = HEAP32[$6_1 + 3456 >> 2];
        $4_1 = HEAP32[$6_1 + 3536 >> 2];
        $7_1 = $25_1 + $4_1 | 0;
        $15_1 = $7_1;
        $11_1 = $7_1 + $11_1 | 0;
        $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $18_1 | 0;
        $23_1 = $11_1 << 4 & -16;
        $7_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $19_1 = ($7_1 << 4 | $11_1 >>> 28) & 16777215;
        $18_1 = $5_1;
        $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
        $30_1 = $6_1 + 3616 | 0;
        $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
        $32_1 = $6_1 + 3424 | 0;
        $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
        $29_1 = $6_1 + 3648 | 0;
        $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
        $27_1 = $6_1 + 3408 | 0;
        $23_1 = $27_1;
        $19_1 = ($4_1 | 0) == ($7_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $11_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
        $5_1 = $36_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $35_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $11_1 + $15_1 | 0;
        $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $8_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $19_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $4_1 << 12 | $7_1 >>> 20;
        $5_1 = $3_1;
        $19_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 3428 >> 2];
        $3_1 = $31_1 + HEAP32[$6_1 + 3652 >> 2] | 0;
        $15_1 = HEAP32[$6_1 + 3424 >> 2];
        $4_1 = HEAP32[$6_1 + 3648 >> 2];
        $8_1 = $15_1 + $4_1 | 0;
        $11_1 = $8_1;
        $7_1 = $8_1 + $7_1 | 0;
        $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $19_1 | 0;
        $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
        $25_1 = $6_1 + 3552 | 0;
        $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
        $23_1 = $6_1 + 3600 | 0;
        $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
        $13_1 = $6_1 + 3392 | 0;
        $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
        $26_1 = $6_1 + 3376 | 0;
        $12_1 = $26_1;
        $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
        $11_1 = ($4_1 | 0) == ($31_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
        $7_1 = $29_1 + 8 | 0;
        $4_1 = HEAP32[$7_1 >> 2];
        $3_1 = $32_1 + 8 | 0;
        $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $11_1 + $16_1 | 0;
        $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $7_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $4_1 << 12 | $8_1 >>> 20;
        $8_1 = HEAP32[$6_1 + 3392 >> 2];
        $10_1 = $7_1 + $8_1 | 0;
        $5_1 = $3_1;
        $4_1 = $3_1 << 12 | $4_1 >>> 20;
        $3_1 = $4_1 + HEAP32[$6_1 + 3396 >> 2] | 0;
        $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
        $19_1 = $6_1 + 3360 | 0;
        $11_1 = $19_1;
        $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
        $3_1 = $13_1 + 8 | 0;
        $8_1 = HEAP32[$3_1 >> 2];
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $7_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($11_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
        $5_1 = HEAP32[$6_1 + 3440 >> 2];
        $4_1 = HEAP32[$6_1 + 3680 >> 2];
        $12_1 = $5_1 + $4_1 | 0;
        $7_1 = HEAP32[$6_1 + 3444 >> 2];
        $3_1 = $7_1 + HEAP32[$6_1 + 3684 >> 2] | 0;
        $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
        $5_1 = $38_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $37_1 + 8 | 0;
        $11_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $7_1 + $11_1 | 0;
        $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $15_1 = $8_1;
        $7_1 = $4_1 << 12 | $8_1 >>> 20;
        $5_1 = $3_1;
        $8_1 = $3_1 << 12 | $4_1 >>> 20;
        $10_1 = HEAP32[$6_1 + 3408 >> 2];
        $4_1 = HEAP32[$6_1 + 3616 >> 2];
        $11_1 = $10_1 + $4_1 | 0;
        $16_1 = HEAP32[$6_1 + 3412 >> 2];
        $3_1 = $16_1 + HEAP32[$6_1 + 3620 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $8_1 | 0;
        $8_1 = $7_1 + $11_1 | 0;
        $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $10_1 = ($4_1 | 0) == ($16_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
        $11_1 = $30_1 + 8 | 0;
        $4_1 = HEAP32[$11_1 >> 2];
        $3_1 = $27_1 + 8 | 0;
        $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$11_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $11_1 = $10_1 + $16_1 | 0;
        $3_1 = $11_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $11_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $13_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $16_1 = $7_1;
        $11_1 = $4_1 << 12 | $7_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $22_1 = HEAP32[$6_1 + 3552 >> 2];
        $4_1 = HEAP32[$6_1 + 3600 >> 2];
        $13_1 = $22_1 + $4_1 | 0;
        $27_1 = HEAP32[$6_1 + 3556 >> 2];
        $3_1 = $27_1 + HEAP32[$6_1 + 3604 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 3376 >> 2];
        $10_1 = $4_1 + $13_1 | 0;
        $21_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 3380 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $7_1 | 0;
        $7_1 = $10_1 + $11_1 | 0;
        $11_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $28_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
        $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
        $3_1 = $26_1 + 8 | 0;
        $24_1 = HEAP32[$3_1 >> 2];
        $26_1 = HEAP32[$3_1 + 4 >> 2];
        $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
        $10_1 = $23_1 + 8 | 0;
        $4_1 = HEAP32[$10_1 >> 2];
        $3_1 = $25_1 + 8 | 0;
        $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $13_1 + $21_1 | 0;
        $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
        $13_1 = $4_1;
        $4_1 = $4_1 + $24_1 | 0;
        $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $4_1 + $20_1 | 0;
        $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $28_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = $11_1;
        $21_1 = $4_1 << 12 | $11_1 >>> 20;
        $5_1 = $3_1;
        $10_1 = $3_1 << 12 | $4_1 >>> 20;
        $24_1 = HEAP32[$6_1 + 3360 >> 2];
        $11_1 = $24_1 + ($17_1 & -2) | 0;
        $26_1 = HEAP32[$6_1 + 3364 >> 2];
        $3_1 = $26_1 + ($14_1 & 1048575) | 0;
        $3_1 = $11_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $17_1 = $11_1;
        $11_1 = $11_1 + $21_1 | 0;
        $4_1 = $3_1;
        $3_1 = $3_1 + $10_1 | 0;
        $14_1 = $9_1;
        $21_1 = $18_1 & 65535;
        $10_1 = $11_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $18_1 = ($4_1 | 0) == ($10_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $10_1 >>> 0;
        $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
        $3_1 = $19_1 + 8 | 0;
        $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $9_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $18_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $9_1 = $4_1 << 12 | $10_1 >>> 20;
        $5_1 = $9_1 + $14_1 | 0;
        $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
        $4_1 = $5_1;
        $9_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $10_1 & 1048575;
        $13_1 = $13_1 & 1048575;
        $14_1 = $16_1 & 1048575;
        $5_1 = $12_1;
        $12_1 = $15_1 & 1048575;
        $1_1 = $1_1 - 1 | 0;
        if ($1_1) {
          continue;
        }
        break;
      }
      ;
      $1_1 = $6_1 + 7376 | 0;
      $17_1 = $1_1 + 32 | 0;
      HEAP32[$17_1 >> 2] = $4_1;
      HEAP32[$17_1 + 4 >> 2] = $9_1;
      $18_1 = $1_1 + 24 | 0;
      HEAP32[$18_1 >> 2] = $11_1;
      HEAP32[$18_1 + 4 >> 2] = $10_1;
      $15_1 = $1_1 + 16 | 0;
      HEAP32[$15_1 >> 2] = $7_1;
      HEAP32[$15_1 + 4 >> 2] = $13_1;
      $16_1 = $1_1 + 8 | 0;
      HEAP32[$16_1 >> 2] = $8_1;
      HEAP32[$16_1 + 4 >> 2] = $14_1;
      HEAP32[$6_1 + 7376 >> 2] = $5_1;
      HEAP32[$6_1 + 7380 >> 2] = $12_1;
      $34($1_1, $1_1, $6_1 + 7416 | 0);
      $9_1 = HEAP32[$17_1 + 4 >> 2];
      $3_1 = $6_1 + 7336 | 0;
      $1_1 = $3_1 + 32 | 0;
      $4_1 = HEAP32[$17_1 >> 2];
      HEAP32[$1_1 >> 2] = $4_1;
      HEAP32[$1_1 + 4 >> 2] = $9_1;
      $10_1 = HEAP32[$18_1 + 4 >> 2];
      $1_1 = $3_1 + 24 | 0;
      $11_1 = HEAP32[$18_1 >> 2];
      HEAP32[$1_1 >> 2] = $11_1;
      HEAP32[$1_1 + 4 >> 2] = $10_1;
      $13_1 = HEAP32[$15_1 + 4 >> 2];
      $1_1 = $3_1 + 16 | 0;
      $7_1 = HEAP32[$15_1 >> 2];
      HEAP32[$1_1 >> 2] = $7_1;
      HEAP32[$1_1 + 4 >> 2] = $13_1;
      $14_1 = HEAP32[$16_1 + 4 >> 2];
      $1_1 = $3_1 + 8 | 0;
      $8_1 = HEAP32[$16_1 >> 2];
      HEAP32[$1_1 >> 2] = $8_1;
      HEAP32[$1_1 + 4 >> 2] = $14_1;
      $12_1 = HEAP32[$6_1 + 7380 >> 2];
      $5_1 = HEAP32[$6_1 + 7376 >> 2];
      HEAP32[$6_1 + 7336 >> 2] = $5_1;
      HEAP32[$6_1 + 7340 >> 2] = $12_1;
      $1_1 = 22;
      while (1) {
        $15_1 = $5_1;
        $3_1 = $12_1 << 1 | $5_1 >>> 31;
        $25_1 = $6_1 + 3328 | 0;
        $20_1 = $5_1 << 1;
        $28_1 = $3_1;
        $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
        $19_1 = $6_1 + 3248 | 0;
        $5_1 = $8_1 << 1;
        $16_1 = $14_1;
        $24_1 = $8_1;
        $8_1 = $14_1 << 1 | $8_1 >>> 31;
        $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
        $17_1 = $6_1 + 3184 | 0;
        $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
        $18_1 = $6_1 + 3168 | 0;
        $69($18_1, HEAP32[$6_1 + 3184 >> 2], HEAP32[$6_1 + 3188 >> 2], 0, 0, 15632, 16, 0, 0);
        $3_1 = $9_1 << 1 | $4_1 >>> 31;
        $33_1 = $6_1 + 3136 | 0;
        $22_1 = $4_1 << 1;
        $26_1 = $3_1;
        $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
        $34_1 = $6_1 + 3296 | 0;
        $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
        $39_1 = $6_1 + 3232 | 0;
        $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
        $23_1 = $6_1 + 3152 | 0;
        $3_1 = $17_1 + 8 | 0;
        $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
        $38_1 = $6_1 + 3344 | 0;
        $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
        $35_1 = $6_1 + 3120 | 0;
        $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
        $36_1 = $6_1 + 3200 | 0;
        $12_1 = $11_1;
        $21_1 = $7_1;
        $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
        $15_1 = HEAP32[$6_1 + 3332 >> 2];
        $3_1 = $15_1 + HEAP32[$6_1 + 3252 >> 2] | 0;
        $7_1 = HEAP32[$6_1 + 3328 >> 2];
        $5_1 = HEAP32[$6_1 + 3248 >> 2];
        $4_1 = $7_1 + $5_1 | 0;
        $8_1 = HEAP32[$6_1 + 3168 >> 2];
        $17_1 = $4_1 + $8_1 | 0;
        $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $5_1 + HEAP32[$6_1 + 3172 >> 2] | 0;
        $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
        $3_1 = $18_1 + 8 | 0;
        $9_1 = HEAP32[$3_1 >> 2];
        $11_1 = HEAP32[$3_1 + 4 >> 2];
        $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
        $5_1 = $19_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $25_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $7_1 + $15_1 | 0;
        $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
        $5_1 = $4_1;
        $4_1 = $4_1 + $9_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $14_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = $8_1;
        $11_1 = $4_1 << 12 | $8_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 3296 >> 2];
        $4_1 = HEAP32[$6_1 + 3232 >> 2];
        $15_1 = $31_1 + $4_1 | 0;
        $40_1 = HEAP32[$6_1 + 3300 >> 2];
        $3_1 = $40_1 + HEAP32[$6_1 + 3236 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 3136 >> 2];
        $9_1 = $4_1 + $15_1 | 0;
        $19_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 3140 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 3152 >> 2];
        $8_1 = $4_1 + $9_1 | 0;
        $18_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 3156 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $7_1 | 0;
        $37_1 = $6_1 + 3104 | 0;
        $11_1 = $8_1 + $11_1 | 0;
        $7_1 = $11_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
        $3_1 = $23_1 + 8 | 0;
        $29_1 = HEAP32[$3_1 >> 2];
        $27_1 = HEAP32[$3_1 + 4 >> 2];
        $25_1 = ($18_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
        $3_1 = $33_1 + 8 | 0;
        $23_1 = HEAP32[$3_1 >> 2];
        $18_1 = HEAP32[$3_1 + 4 >> 2];
        $9_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
        $8_1 = $39_1 + 8 | 0;
        $4_1 = HEAP32[$8_1 >> 2];
        $3_1 = $34_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $9_1 + $15_1 | 0;
        $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + $23_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1;
        $4_1 = $4_1 + $25_1 | 0;
        $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + $29_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1 + $32_1 | 0;
        $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $30_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $7_1;
        $9_1 = $4_1 << 12 | $5_1 >>> 20;
        $8_1 = $3_1;
        $18_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 3124 >> 2];
        $3_1 = $31_1 + HEAP32[$6_1 + 3204 >> 2] | 0;
        $25_1 = HEAP32[$6_1 + 3120 >> 2];
        $4_1 = HEAP32[$6_1 + 3200 >> 2];
        $7_1 = $25_1 + $4_1 | 0;
        $15_1 = $7_1;
        $9_1 = $7_1 + $9_1 | 0;
        $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $18_1 | 0;
        $23_1 = $9_1 << 4 & -16;
        $7_1 = $9_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $19_1 = ($7_1 << 4 | $9_1 >>> 28) & 16777215;
        $18_1 = $5_1;
        $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
        $30_1 = $6_1 + 3280 | 0;
        $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
        $32_1 = $6_1 + 3088 | 0;
        $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
        $29_1 = $6_1 + 3312 | 0;
        $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
        $27_1 = $6_1 + 3072 | 0;
        $23_1 = $27_1;
        $19_1 = ($4_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $9_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
        $5_1 = $36_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $35_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $9_1 + $15_1 | 0;
        $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $8_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $19_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $4_1 << 12 | $7_1 >>> 20;
        $5_1 = $3_1;
        $19_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 3092 >> 2];
        $3_1 = $31_1 + HEAP32[$6_1 + 3316 >> 2] | 0;
        $15_1 = HEAP32[$6_1 + 3088 >> 2];
        $4_1 = HEAP32[$6_1 + 3312 >> 2];
        $8_1 = $15_1 + $4_1 | 0;
        $9_1 = $8_1;
        $7_1 = $8_1 + $7_1 | 0;
        $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $19_1 | 0;
        $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
        $25_1 = $6_1 + 3216 | 0;
        $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
        $23_1 = $6_1 + 3264 | 0;
        $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
        $13_1 = $6_1 + 3056 | 0;
        $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
        $26_1 = $6_1 + 3040 | 0;
        $12_1 = $26_1;
        $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
        $9_1 = ($4_1 | 0) == ($31_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
        $7_1 = $29_1 + 8 | 0;
        $4_1 = HEAP32[$7_1 >> 2];
        $3_1 = $32_1 + 8 | 0;
        $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $9_1 + $16_1 | 0;
        $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $7_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $4_1 << 12 | $8_1 >>> 20;
        $8_1 = HEAP32[$6_1 + 3056 >> 2];
        $10_1 = $7_1 + $8_1 | 0;
        $5_1 = $3_1;
        $4_1 = $3_1 << 12 | $4_1 >>> 20;
        $3_1 = $4_1 + HEAP32[$6_1 + 3060 >> 2] | 0;
        $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
        $19_1 = $6_1 + 3024 | 0;
        $9_1 = $19_1;
        $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
        $3_1 = $13_1 + 8 | 0;
        $8_1 = HEAP32[$3_1 >> 2];
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $7_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($9_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
        $5_1 = HEAP32[$6_1 + 3104 >> 2];
        $4_1 = HEAP32[$6_1 + 3344 >> 2];
        $12_1 = $5_1 + $4_1 | 0;
        $7_1 = HEAP32[$6_1 + 3108 >> 2];
        $3_1 = $7_1 + HEAP32[$6_1 + 3348 >> 2] | 0;
        $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
        $5_1 = $38_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $37_1 + 8 | 0;
        $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $7_1 + $9_1 | 0;
        $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $15_1 = $8_1;
        $9_1 = $4_1 << 12 | $8_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $10_1 = HEAP32[$6_1 + 3072 >> 2];
        $4_1 = HEAP32[$6_1 + 3280 >> 2];
        $8_1 = $10_1 + $4_1 | 0;
        $16_1 = HEAP32[$6_1 + 3076 >> 2];
        $3_1 = $16_1 + HEAP32[$6_1 + 3284 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $9_1;
        $9_1 = $8_1;
        $8_1 = $4_1 + $8_1 | 0;
        $4_1 = $3_1;
        $3_1 = $3_1 + $7_1 | 0;
        $7_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $10_1 = ($4_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
        $9_1 = $30_1 + 8 | 0;
        $4_1 = HEAP32[$9_1 >> 2];
        $3_1 = $27_1 + 8 | 0;
        $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $9_1 = $10_1 + $16_1 | 0;
        $3_1 = $9_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $9_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $13_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $16_1 = $7_1;
        $9_1 = $4_1 << 12 | $7_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $22_1 = HEAP32[$6_1 + 3216 >> 2];
        $4_1 = HEAP32[$6_1 + 3264 >> 2];
        $13_1 = $22_1 + $4_1 | 0;
        $27_1 = HEAP32[$6_1 + 3220 >> 2];
        $3_1 = $27_1 + HEAP32[$6_1 + 3268 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 3040 >> 2];
        $10_1 = $4_1 + $13_1 | 0;
        $21_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 3044 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $7_1 | 0;
        $7_1 = $9_1 + $10_1 | 0;
        $9_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $28_1 = ($4_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
        $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
        $3_1 = $26_1 + 8 | 0;
        $24_1 = HEAP32[$3_1 >> 2];
        $26_1 = HEAP32[$3_1 + 4 >> 2];
        $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
        $10_1 = $23_1 + 8 | 0;
        $4_1 = HEAP32[$10_1 >> 2];
        $3_1 = $25_1 + 8 | 0;
        $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $13_1 + $21_1 | 0;
        $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
        $13_1 = $4_1;
        $4_1 = $4_1 + $24_1 | 0;
        $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $4_1 + $20_1 | 0;
        $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $28_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = $9_1;
        $10_1 = $4_1 << 12 | $9_1 >>> 20;
        $5_1 = $3_1;
        $9_1 = $3_1 << 12 | $4_1 >>> 20;
        $24_1 = HEAP32[$6_1 + 3024 >> 2];
        $17_1 = $24_1 + ($17_1 & -2) | 0;
        $26_1 = HEAP32[$6_1 + 3028 >> 2];
        $3_1 = $26_1 + ($14_1 & 1048575) | 0;
        $4_1 = $17_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $9_1 | 0;
        $14_1 = $11_1;
        $21_1 = $18_1 & 65535;
        $10_1 = $10_1 + $17_1 | 0;
        $9_1 = $10_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $11_1 = $10_1;
        $18_1 = ($4_1 | 0) == ($9_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
        $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
        $3_1 = $19_1 + 8 | 0;
        $10_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $18_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $9_1;
        $10_1 = $4_1 << 12 | $5_1 >>> 20;
        $9_1 = $10_1 + $14_1 | 0;
        $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
        $4_1 = $9_1;
        $9_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $5_1 & 1048575;
        $13_1 = $13_1 & 1048575;
        $14_1 = $16_1 & 1048575;
        $5_1 = $12_1;
        $12_1 = $15_1 & 1048575;
        $1_1 = $1_1 - 1 | 0;
        if ($1_1) {
          continue;
        }
        break;
      }
      ;
      $1_1 = $6_1 + 7336 | 0;
      $17_1 = $1_1 + 32 | 0;
      HEAP32[$17_1 >> 2] = $4_1;
      HEAP32[$17_1 + 4 >> 2] = $9_1;
      $18_1 = $1_1 + 24 | 0;
      HEAP32[$18_1 >> 2] = $11_1;
      HEAP32[$18_1 + 4 >> 2] = $10_1;
      $15_1 = $1_1 + 16 | 0;
      HEAP32[$15_1 >> 2] = $7_1;
      HEAP32[$15_1 + 4 >> 2] = $13_1;
      $16_1 = $1_1 + 8 | 0;
      HEAP32[$16_1 >> 2] = $8_1;
      HEAP32[$16_1 + 4 >> 2] = $14_1;
      HEAP32[$6_1 + 7336 >> 2] = $5_1;
      HEAP32[$6_1 + 7340 >> 2] = $12_1;
      $34($1_1, $1_1, $6_1 + 7376 | 0);
      $9_1 = HEAP32[$17_1 + 4 >> 2];
      $3_1 = $6_1 + 7296 | 0;
      $1_1 = $3_1 + 32 | 0;
      $4_1 = HEAP32[$17_1 >> 2];
      HEAP32[$1_1 >> 2] = $4_1;
      HEAP32[$1_1 + 4 >> 2] = $9_1;
      $10_1 = HEAP32[$18_1 + 4 >> 2];
      $1_1 = $3_1 + 24 | 0;
      $11_1 = HEAP32[$18_1 >> 2];
      HEAP32[$1_1 >> 2] = $11_1;
      HEAP32[$1_1 + 4 >> 2] = $10_1;
      $13_1 = HEAP32[$15_1 + 4 >> 2];
      $1_1 = $3_1 + 16 | 0;
      $7_1 = HEAP32[$15_1 >> 2];
      HEAP32[$1_1 >> 2] = $7_1;
      HEAP32[$1_1 + 4 >> 2] = $13_1;
      $14_1 = HEAP32[$16_1 + 4 >> 2];
      $1_1 = $3_1 + 8 | 0;
      $8_1 = HEAP32[$16_1 >> 2];
      HEAP32[$1_1 >> 2] = $8_1;
      HEAP32[$1_1 + 4 >> 2] = $14_1;
      $12_1 = HEAP32[$6_1 + 7340 >> 2];
      $5_1 = HEAP32[$6_1 + 7336 >> 2];
      HEAP32[$6_1 + 7296 >> 2] = $5_1;
      HEAP32[$6_1 + 7300 >> 2] = $12_1;
      $1_1 = 44;
      while (1) {
        $15_1 = $5_1;
        $3_1 = $12_1 << 1 | $5_1 >>> 31;
        $25_1 = $6_1 + 2992 | 0;
        $20_1 = $5_1 << 1;
        $28_1 = $3_1;
        $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
        $19_1 = $6_1 + 2912 | 0;
        $5_1 = $8_1 << 1;
        $16_1 = $14_1;
        $24_1 = $8_1;
        $8_1 = $14_1 << 1 | $8_1 >>> 31;
        $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
        $17_1 = $6_1 + 2848 | 0;
        $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
        $18_1 = $6_1 + 2832 | 0;
        $69($18_1, HEAP32[$6_1 + 2848 >> 2], HEAP32[$6_1 + 2852 >> 2], 0, 0, 15632, 16, 0, 0);
        $3_1 = $9_1 << 1 | $4_1 >>> 31;
        $33_1 = $6_1 + 2800 | 0;
        $22_1 = $4_1 << 1;
        $26_1 = $3_1;
        $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
        $34_1 = $6_1 + 2960 | 0;
        $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
        $39_1 = $6_1 + 2896 | 0;
        $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
        $23_1 = $6_1 + 2816 | 0;
        $3_1 = $17_1 + 8 | 0;
        $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
        $38_1 = $6_1 + 3008 | 0;
        $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
        $35_1 = $6_1 + 2784 | 0;
        $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
        $36_1 = $6_1 + 2864 | 0;
        $12_1 = $11_1;
        $21_1 = $7_1;
        $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
        $15_1 = HEAP32[$6_1 + 2996 >> 2];
        $3_1 = $15_1 + HEAP32[$6_1 + 2916 >> 2] | 0;
        $7_1 = HEAP32[$6_1 + 2992 >> 2];
        $5_1 = HEAP32[$6_1 + 2912 >> 2];
        $4_1 = $7_1 + $5_1 | 0;
        $8_1 = HEAP32[$6_1 + 2832 >> 2];
        $17_1 = $4_1 + $8_1 | 0;
        $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $5_1 + HEAP32[$6_1 + 2836 >> 2] | 0;
        $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
        $3_1 = $18_1 + 8 | 0;
        $9_1 = HEAP32[$3_1 >> 2];
        $11_1 = HEAP32[$3_1 + 4 >> 2];
        $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
        $5_1 = $19_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $25_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $7_1 + $15_1 | 0;
        $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
        $5_1 = $4_1;
        $4_1 = $4_1 + $9_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $14_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = $8_1;
        $9_1 = $4_1 << 12 | $8_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 2960 >> 2];
        $4_1 = HEAP32[$6_1 + 2896 >> 2];
        $15_1 = $31_1 + $4_1 | 0;
        $40_1 = HEAP32[$6_1 + 2964 >> 2];
        $3_1 = $40_1 + HEAP32[$6_1 + 2900 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 2800 >> 2];
        $11_1 = $4_1 + $15_1 | 0;
        $19_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 2804 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 2816 >> 2];
        $8_1 = $4_1 + $11_1 | 0;
        $18_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 2820 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $7_1 | 0;
        $37_1 = $6_1 + 2768 | 0;
        $9_1 = $8_1 + $9_1 | 0;
        $7_1 = $9_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
        $3_1 = $23_1 + 8 | 0;
        $29_1 = HEAP32[$3_1 >> 2];
        $27_1 = HEAP32[$3_1 + 4 >> 2];
        $25_1 = ($18_1 | 0) == ($19_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
        $3_1 = $33_1 + 8 | 0;
        $23_1 = HEAP32[$3_1 >> 2];
        $18_1 = HEAP32[$3_1 + 4 >> 2];
        $11_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
        $8_1 = $39_1 + 8 | 0;
        $4_1 = HEAP32[$8_1 >> 2];
        $3_1 = $34_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $11_1 + $15_1 | 0;
        $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + $23_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1;
        $4_1 = $4_1 + $25_1 | 0;
        $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + $29_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1 + $32_1 | 0;
        $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $30_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $7_1;
        $11_1 = $4_1 << 12 | $5_1 >>> 20;
        $8_1 = $3_1;
        $18_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 2788 >> 2];
        $3_1 = $31_1 + HEAP32[$6_1 + 2868 >> 2] | 0;
        $25_1 = HEAP32[$6_1 + 2784 >> 2];
        $4_1 = HEAP32[$6_1 + 2864 >> 2];
        $7_1 = $25_1 + $4_1 | 0;
        $15_1 = $7_1;
        $11_1 = $7_1 + $11_1 | 0;
        $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $18_1 | 0;
        $23_1 = $11_1 << 4 & -16;
        $7_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $19_1 = ($7_1 << 4 | $11_1 >>> 28) & 16777215;
        $18_1 = $5_1;
        $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
        $30_1 = $6_1 + 2944 | 0;
        $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
        $32_1 = $6_1 + 2752 | 0;
        $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
        $29_1 = $6_1 + 2976 | 0;
        $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
        $27_1 = $6_1 + 2736 | 0;
        $23_1 = $27_1;
        $19_1 = ($4_1 | 0) == ($7_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $11_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
        $5_1 = $36_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $35_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $11_1 + $15_1 | 0;
        $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $8_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $19_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $4_1 << 12 | $7_1 >>> 20;
        $5_1 = $3_1;
        $19_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 2756 >> 2];
        $3_1 = $31_1 + HEAP32[$6_1 + 2980 >> 2] | 0;
        $15_1 = HEAP32[$6_1 + 2752 >> 2];
        $4_1 = HEAP32[$6_1 + 2976 >> 2];
        $8_1 = $15_1 + $4_1 | 0;
        $11_1 = $8_1;
        $7_1 = $8_1 + $7_1 | 0;
        $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $19_1 | 0;
        $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
        $25_1 = $6_1 + 2880 | 0;
        $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
        $23_1 = $6_1 + 2928 | 0;
        $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
        $13_1 = $6_1 + 2720 | 0;
        $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
        $26_1 = $6_1 + 2704 | 0;
        $12_1 = $26_1;
        $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
        $11_1 = ($4_1 | 0) == ($31_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
        $7_1 = $29_1 + 8 | 0;
        $4_1 = HEAP32[$7_1 >> 2];
        $3_1 = $32_1 + 8 | 0;
        $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $11_1 + $16_1 | 0;
        $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $7_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $4_1 << 12 | $8_1 >>> 20;
        $8_1 = HEAP32[$6_1 + 2720 >> 2];
        $10_1 = $7_1 + $8_1 | 0;
        $5_1 = $3_1;
        $4_1 = $3_1 << 12 | $4_1 >>> 20;
        $3_1 = $4_1 + HEAP32[$6_1 + 2724 >> 2] | 0;
        $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
        $19_1 = $6_1 + 2688 | 0;
        $11_1 = $19_1;
        $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
        $3_1 = $13_1 + 8 | 0;
        $8_1 = HEAP32[$3_1 >> 2];
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $7_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($11_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
        $5_1 = HEAP32[$6_1 + 2768 >> 2];
        $4_1 = HEAP32[$6_1 + 3008 >> 2];
        $12_1 = $5_1 + $4_1 | 0;
        $7_1 = HEAP32[$6_1 + 2772 >> 2];
        $3_1 = $7_1 + HEAP32[$6_1 + 3012 >> 2] | 0;
        $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
        $5_1 = $38_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $37_1 + 8 | 0;
        $11_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $7_1 + $11_1 | 0;
        $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $15_1 = $8_1;
        $7_1 = $4_1 << 12 | $8_1 >>> 20;
        $5_1 = $3_1;
        $8_1 = $3_1 << 12 | $4_1 >>> 20;
        $10_1 = HEAP32[$6_1 + 2736 >> 2];
        $4_1 = HEAP32[$6_1 + 2944 >> 2];
        $11_1 = $10_1 + $4_1 | 0;
        $16_1 = HEAP32[$6_1 + 2740 >> 2];
        $3_1 = $16_1 + HEAP32[$6_1 + 2948 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $8_1 | 0;
        $8_1 = $7_1 + $11_1 | 0;
        $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $10_1 = ($4_1 | 0) == ($16_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
        $11_1 = $30_1 + 8 | 0;
        $4_1 = HEAP32[$11_1 >> 2];
        $3_1 = $27_1 + 8 | 0;
        $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$11_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $11_1 = $10_1 + $16_1 | 0;
        $3_1 = $11_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $11_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $13_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $16_1 = $7_1;
        $11_1 = $4_1 << 12 | $7_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $22_1 = HEAP32[$6_1 + 2880 >> 2];
        $4_1 = HEAP32[$6_1 + 2928 >> 2];
        $13_1 = $22_1 + $4_1 | 0;
        $27_1 = HEAP32[$6_1 + 2884 >> 2];
        $3_1 = $27_1 + HEAP32[$6_1 + 2932 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 2704 >> 2];
        $10_1 = $4_1 + $13_1 | 0;
        $21_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 2708 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $7_1 | 0;
        $7_1 = $10_1 + $11_1 | 0;
        $11_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $28_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
        $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
        $3_1 = $26_1 + 8 | 0;
        $24_1 = HEAP32[$3_1 >> 2];
        $26_1 = HEAP32[$3_1 + 4 >> 2];
        $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
        $10_1 = $23_1 + 8 | 0;
        $4_1 = HEAP32[$10_1 >> 2];
        $3_1 = $25_1 + 8 | 0;
        $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $13_1 + $21_1 | 0;
        $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
        $13_1 = $4_1;
        $4_1 = $4_1 + $24_1 | 0;
        $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $4_1 + $20_1 | 0;
        $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $28_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = $11_1;
        $21_1 = $4_1 << 12 | $11_1 >>> 20;
        $5_1 = $3_1;
        $10_1 = $3_1 << 12 | $4_1 >>> 20;
        $24_1 = HEAP32[$6_1 + 2688 >> 2];
        $11_1 = $24_1 + ($17_1 & -2) | 0;
        $26_1 = HEAP32[$6_1 + 2692 >> 2];
        $3_1 = $26_1 + ($14_1 & 1048575) | 0;
        $3_1 = $11_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $17_1 = $11_1;
        $11_1 = $11_1 + $21_1 | 0;
        $4_1 = $3_1;
        $3_1 = $3_1 + $10_1 | 0;
        $14_1 = $9_1;
        $21_1 = $18_1 & 65535;
        $10_1 = $11_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $18_1 = ($4_1 | 0) == ($10_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $10_1 >>> 0;
        $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
        $3_1 = $19_1 + 8 | 0;
        $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $9_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $18_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $9_1 = $4_1 << 12 | $10_1 >>> 20;
        $5_1 = $9_1 + $14_1 | 0;
        $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
        $4_1 = $5_1;
        $9_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $10_1 & 1048575;
        $13_1 = $13_1 & 1048575;
        $14_1 = $16_1 & 1048575;
        $5_1 = $12_1;
        $12_1 = $15_1 & 1048575;
        $1_1 = $1_1 - 1 | 0;
        if ($1_1) {
          continue;
        }
        break;
      }
      ;
      $1_1 = $6_1 + 7296 | 0;
      $17_1 = $1_1 + 32 | 0;
      HEAP32[$17_1 >> 2] = $4_1;
      HEAP32[$17_1 + 4 >> 2] = $9_1;
      $18_1 = $1_1 + 24 | 0;
      HEAP32[$18_1 >> 2] = $11_1;
      HEAP32[$18_1 + 4 >> 2] = $10_1;
      $15_1 = $1_1 + 16 | 0;
      HEAP32[$15_1 >> 2] = $7_1;
      HEAP32[$15_1 + 4 >> 2] = $13_1;
      $16_1 = $1_1 + 8 | 0;
      HEAP32[$16_1 >> 2] = $8_1;
      HEAP32[$16_1 + 4 >> 2] = $14_1;
      HEAP32[$6_1 + 7296 >> 2] = $5_1;
      HEAP32[$6_1 + 7300 >> 2] = $12_1;
      $34($1_1, $1_1, $6_1 + 7336 | 0);
      $9_1 = HEAP32[$17_1 + 4 >> 2];
      $3_1 = $6_1 + 7256 | 0;
      $1_1 = $3_1 + 32 | 0;
      $4_1 = HEAP32[$17_1 >> 2];
      HEAP32[$1_1 >> 2] = $4_1;
      HEAP32[$1_1 + 4 >> 2] = $9_1;
      $10_1 = HEAP32[$18_1 + 4 >> 2];
      $1_1 = $3_1 + 24 | 0;
      $11_1 = HEAP32[$18_1 >> 2];
      HEAP32[$1_1 >> 2] = $11_1;
      HEAP32[$1_1 + 4 >> 2] = $10_1;
      $13_1 = HEAP32[$15_1 + 4 >> 2];
      $1_1 = $3_1 + 16 | 0;
      $7_1 = HEAP32[$15_1 >> 2];
      HEAP32[$1_1 >> 2] = $7_1;
      HEAP32[$1_1 + 4 >> 2] = $13_1;
      $14_1 = HEAP32[$16_1 + 4 >> 2];
      $1_1 = $3_1 + 8 | 0;
      $8_1 = HEAP32[$16_1 >> 2];
      HEAP32[$1_1 >> 2] = $8_1;
      HEAP32[$1_1 + 4 >> 2] = $14_1;
      $12_1 = HEAP32[$6_1 + 7300 >> 2];
      $5_1 = HEAP32[$6_1 + 7296 >> 2];
      HEAP32[$6_1 + 7256 >> 2] = $5_1;
      HEAP32[$6_1 + 7260 >> 2] = $12_1;
      $1_1 = 88;
      while (1) {
        $15_1 = $5_1;
        $3_1 = $12_1 << 1 | $5_1 >>> 31;
        $25_1 = $6_1 + 2656 | 0;
        $20_1 = $5_1 << 1;
        $28_1 = $3_1;
        $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
        $19_1 = $6_1 + 2576 | 0;
        $5_1 = $8_1 << 1;
        $16_1 = $14_1;
        $24_1 = $8_1;
        $8_1 = $14_1 << 1 | $8_1 >>> 31;
        $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
        $17_1 = $6_1 + 2512 | 0;
        $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
        $18_1 = $6_1 + 2496 | 0;
        $69($18_1, HEAP32[$6_1 + 2512 >> 2], HEAP32[$6_1 + 2516 >> 2], 0, 0, 15632, 16, 0, 0);
        $3_1 = $9_1 << 1 | $4_1 >>> 31;
        $33_1 = $6_1 + 2464 | 0;
        $22_1 = $4_1 << 1;
        $26_1 = $3_1;
        $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
        $34_1 = $6_1 + 2624 | 0;
        $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
        $39_1 = $6_1 + 2560 | 0;
        $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
        $23_1 = $6_1 + 2480 | 0;
        $3_1 = $17_1 + 8 | 0;
        $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
        $38_1 = $6_1 + 2672 | 0;
        $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
        $35_1 = $6_1 + 2448 | 0;
        $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
        $36_1 = $6_1 + 2528 | 0;
        $12_1 = $11_1;
        $21_1 = $7_1;
        $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
        $15_1 = HEAP32[$6_1 + 2660 >> 2];
        $3_1 = $15_1 + HEAP32[$6_1 + 2580 >> 2] | 0;
        $7_1 = HEAP32[$6_1 + 2656 >> 2];
        $5_1 = HEAP32[$6_1 + 2576 >> 2];
        $4_1 = $7_1 + $5_1 | 0;
        $8_1 = HEAP32[$6_1 + 2496 >> 2];
        $17_1 = $4_1 + $8_1 | 0;
        $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $5_1 + HEAP32[$6_1 + 2500 >> 2] | 0;
        $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
        $3_1 = $18_1 + 8 | 0;
        $9_1 = HEAP32[$3_1 >> 2];
        $11_1 = HEAP32[$3_1 + 4 >> 2];
        $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
        $5_1 = $19_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $25_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $7_1 + $15_1 | 0;
        $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
        $5_1 = $4_1;
        $4_1 = $4_1 + $9_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $14_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = $8_1;
        $11_1 = $4_1 << 12 | $8_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 2624 >> 2];
        $4_1 = HEAP32[$6_1 + 2560 >> 2];
        $15_1 = $31_1 + $4_1 | 0;
        $40_1 = HEAP32[$6_1 + 2628 >> 2];
        $3_1 = $40_1 + HEAP32[$6_1 + 2564 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 2464 >> 2];
        $9_1 = $4_1 + $15_1 | 0;
        $19_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 2468 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 2480 >> 2];
        $8_1 = $4_1 + $9_1 | 0;
        $18_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 2484 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $7_1 | 0;
        $37_1 = $6_1 + 2432 | 0;
        $11_1 = $8_1 + $11_1 | 0;
        $7_1 = $11_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
        $3_1 = $23_1 + 8 | 0;
        $29_1 = HEAP32[$3_1 >> 2];
        $27_1 = HEAP32[$3_1 + 4 >> 2];
        $25_1 = ($18_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
        $3_1 = $33_1 + 8 | 0;
        $23_1 = HEAP32[$3_1 >> 2];
        $18_1 = HEAP32[$3_1 + 4 >> 2];
        $9_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
        $8_1 = $39_1 + 8 | 0;
        $4_1 = HEAP32[$8_1 >> 2];
        $3_1 = $34_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $9_1 + $15_1 | 0;
        $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + $23_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1;
        $4_1 = $4_1 + $25_1 | 0;
        $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + $29_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1 + $32_1 | 0;
        $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $30_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $7_1;
        $9_1 = $4_1 << 12 | $5_1 >>> 20;
        $8_1 = $3_1;
        $18_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 2452 >> 2];
        $3_1 = $31_1 + HEAP32[$6_1 + 2532 >> 2] | 0;
        $25_1 = HEAP32[$6_1 + 2448 >> 2];
        $4_1 = HEAP32[$6_1 + 2528 >> 2];
        $7_1 = $25_1 + $4_1 | 0;
        $15_1 = $7_1;
        $9_1 = $7_1 + $9_1 | 0;
        $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $18_1 | 0;
        $23_1 = $9_1 << 4 & -16;
        $7_1 = $9_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $19_1 = ($7_1 << 4 | $9_1 >>> 28) & 16777215;
        $18_1 = $5_1;
        $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
        $30_1 = $6_1 + 2608 | 0;
        $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
        $32_1 = $6_1 + 2416 | 0;
        $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
        $29_1 = $6_1 + 2640 | 0;
        $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
        $27_1 = $6_1 + 2400 | 0;
        $23_1 = $27_1;
        $19_1 = ($4_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $9_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
        $5_1 = $36_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $35_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $9_1 + $15_1 | 0;
        $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $8_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $19_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $4_1 << 12 | $7_1 >>> 20;
        $5_1 = $3_1;
        $19_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 2420 >> 2];
        $3_1 = $31_1 + HEAP32[$6_1 + 2644 >> 2] | 0;
        $15_1 = HEAP32[$6_1 + 2416 >> 2];
        $4_1 = HEAP32[$6_1 + 2640 >> 2];
        $8_1 = $15_1 + $4_1 | 0;
        $9_1 = $8_1;
        $7_1 = $8_1 + $7_1 | 0;
        $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $19_1 | 0;
        $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
        $25_1 = $6_1 + 2544 | 0;
        $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
        $23_1 = $6_1 + 2592 | 0;
        $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
        $13_1 = $6_1 + 2384 | 0;
        $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
        $26_1 = $6_1 + 2368 | 0;
        $12_1 = $26_1;
        $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
        $9_1 = ($4_1 | 0) == ($31_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
        $7_1 = $29_1 + 8 | 0;
        $4_1 = HEAP32[$7_1 >> 2];
        $3_1 = $32_1 + 8 | 0;
        $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $9_1 + $16_1 | 0;
        $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $7_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $4_1 << 12 | $8_1 >>> 20;
        $8_1 = HEAP32[$6_1 + 2384 >> 2];
        $10_1 = $7_1 + $8_1 | 0;
        $5_1 = $3_1;
        $4_1 = $3_1 << 12 | $4_1 >>> 20;
        $3_1 = $4_1 + HEAP32[$6_1 + 2388 >> 2] | 0;
        $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
        $19_1 = $6_1 + 2352 | 0;
        $9_1 = $19_1;
        $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
        $3_1 = $13_1 + 8 | 0;
        $8_1 = HEAP32[$3_1 >> 2];
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $7_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($9_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
        $5_1 = HEAP32[$6_1 + 2432 >> 2];
        $4_1 = HEAP32[$6_1 + 2672 >> 2];
        $12_1 = $5_1 + $4_1 | 0;
        $7_1 = HEAP32[$6_1 + 2436 >> 2];
        $3_1 = $7_1 + HEAP32[$6_1 + 2676 >> 2] | 0;
        $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
        $5_1 = $38_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $37_1 + 8 | 0;
        $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $7_1 + $9_1 | 0;
        $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $15_1 = $8_1;
        $9_1 = $4_1 << 12 | $8_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $10_1 = HEAP32[$6_1 + 2400 >> 2];
        $4_1 = HEAP32[$6_1 + 2608 >> 2];
        $8_1 = $10_1 + $4_1 | 0;
        $16_1 = HEAP32[$6_1 + 2404 >> 2];
        $3_1 = $16_1 + HEAP32[$6_1 + 2612 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $9_1;
        $9_1 = $8_1;
        $8_1 = $4_1 + $8_1 | 0;
        $4_1 = $3_1;
        $3_1 = $3_1 + $7_1 | 0;
        $7_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $10_1 = ($4_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
        $9_1 = $30_1 + 8 | 0;
        $4_1 = HEAP32[$9_1 >> 2];
        $3_1 = $27_1 + 8 | 0;
        $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $9_1 = $10_1 + $16_1 | 0;
        $3_1 = $9_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $9_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $13_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $16_1 = $7_1;
        $9_1 = $4_1 << 12 | $7_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $22_1 = HEAP32[$6_1 + 2544 >> 2];
        $4_1 = HEAP32[$6_1 + 2592 >> 2];
        $13_1 = $22_1 + $4_1 | 0;
        $27_1 = HEAP32[$6_1 + 2548 >> 2];
        $3_1 = $27_1 + HEAP32[$6_1 + 2596 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 2368 >> 2];
        $10_1 = $4_1 + $13_1 | 0;
        $21_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 2372 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $7_1 | 0;
        $7_1 = $9_1 + $10_1 | 0;
        $9_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $28_1 = ($4_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
        $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
        $3_1 = $26_1 + 8 | 0;
        $24_1 = HEAP32[$3_1 >> 2];
        $26_1 = HEAP32[$3_1 + 4 >> 2];
        $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
        $10_1 = $23_1 + 8 | 0;
        $4_1 = HEAP32[$10_1 >> 2];
        $3_1 = $25_1 + 8 | 0;
        $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $13_1 + $21_1 | 0;
        $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
        $13_1 = $4_1;
        $4_1 = $4_1 + $24_1 | 0;
        $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $4_1 + $20_1 | 0;
        $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $28_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = $9_1;
        $10_1 = $4_1 << 12 | $9_1 >>> 20;
        $5_1 = $3_1;
        $9_1 = $3_1 << 12 | $4_1 >>> 20;
        $24_1 = HEAP32[$6_1 + 2352 >> 2];
        $17_1 = $24_1 + ($17_1 & -2) | 0;
        $26_1 = HEAP32[$6_1 + 2356 >> 2];
        $3_1 = $26_1 + ($14_1 & 1048575) | 0;
        $4_1 = $17_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $9_1 | 0;
        $14_1 = $11_1;
        $21_1 = $18_1 & 65535;
        $10_1 = $10_1 + $17_1 | 0;
        $9_1 = $10_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $11_1 = $10_1;
        $18_1 = ($4_1 | 0) == ($9_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
        $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
        $3_1 = $19_1 + 8 | 0;
        $10_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $18_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $9_1;
        $10_1 = $4_1 << 12 | $5_1 >>> 20;
        $9_1 = $10_1 + $14_1 | 0;
        $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
        $4_1 = $9_1;
        $9_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $5_1 & 1048575;
        $13_1 = $13_1 & 1048575;
        $14_1 = $16_1 & 1048575;
        $5_1 = $12_1;
        $12_1 = $15_1 & 1048575;
        $1_1 = $1_1 - 1 | 0;
        if ($1_1) {
          continue;
        }
        break;
      }
      ;
      $1_1 = $6_1 + 7256 | 0;
      $17_1 = $1_1 + 32 | 0;
      HEAP32[$17_1 >> 2] = $4_1;
      HEAP32[$17_1 + 4 >> 2] = $9_1;
      $18_1 = $1_1 + 24 | 0;
      HEAP32[$18_1 >> 2] = $11_1;
      HEAP32[$18_1 + 4 >> 2] = $10_1;
      $15_1 = $1_1 + 16 | 0;
      HEAP32[$15_1 >> 2] = $7_1;
      HEAP32[$15_1 + 4 >> 2] = $13_1;
      $16_1 = $1_1 + 8 | 0;
      HEAP32[$16_1 >> 2] = $8_1;
      HEAP32[$16_1 + 4 >> 2] = $14_1;
      HEAP32[$6_1 + 7256 >> 2] = $5_1;
      HEAP32[$6_1 + 7260 >> 2] = $12_1;
      $34($1_1, $1_1, $6_1 + 7296 | 0);
      $9_1 = HEAP32[$17_1 + 4 >> 2];
      $3_1 = $6_1 + 7216 | 0;
      $1_1 = $3_1 + 32 | 0;
      $4_1 = HEAP32[$17_1 >> 2];
      HEAP32[$1_1 >> 2] = $4_1;
      HEAP32[$1_1 + 4 >> 2] = $9_1;
      $10_1 = HEAP32[$18_1 + 4 >> 2];
      $1_1 = $3_1 + 24 | 0;
      $11_1 = HEAP32[$18_1 >> 2];
      HEAP32[$1_1 >> 2] = $11_1;
      HEAP32[$1_1 + 4 >> 2] = $10_1;
      $13_1 = HEAP32[$15_1 + 4 >> 2];
      $1_1 = $3_1 + 16 | 0;
      $7_1 = HEAP32[$15_1 >> 2];
      HEAP32[$1_1 >> 2] = $7_1;
      HEAP32[$1_1 + 4 >> 2] = $13_1;
      $14_1 = HEAP32[$16_1 + 4 >> 2];
      $1_1 = $3_1 + 8 | 0;
      $8_1 = HEAP32[$16_1 >> 2];
      HEAP32[$1_1 >> 2] = $8_1;
      HEAP32[$1_1 + 4 >> 2] = $14_1;
      $12_1 = HEAP32[$6_1 + 7260 >> 2];
      $5_1 = HEAP32[$6_1 + 7256 >> 2];
      HEAP32[$6_1 + 7216 >> 2] = $5_1;
      HEAP32[$6_1 + 7220 >> 2] = $12_1;
      $1_1 = 44;
      while (1) {
        $15_1 = $5_1;
        $3_1 = $12_1 << 1 | $5_1 >>> 31;
        $25_1 = $6_1 + 2320 | 0;
        $20_1 = $5_1 << 1;
        $28_1 = $3_1;
        $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
        $19_1 = $6_1 + 2240 | 0;
        $5_1 = $8_1 << 1;
        $16_1 = $14_1;
        $24_1 = $8_1;
        $8_1 = $14_1 << 1 | $8_1 >>> 31;
        $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
        $17_1 = $6_1 + 2176 | 0;
        $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
        $18_1 = $6_1 + 2160 | 0;
        $69($18_1, HEAP32[$6_1 + 2176 >> 2], HEAP32[$6_1 + 2180 >> 2], 0, 0, 15632, 16, 0, 0);
        $3_1 = $9_1 << 1 | $4_1 >>> 31;
        $33_1 = $6_1 + 2128 | 0;
        $22_1 = $4_1 << 1;
        $26_1 = $3_1;
        $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
        $34_1 = $6_1 + 2288 | 0;
        $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
        $39_1 = $6_1 + 2224 | 0;
        $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
        $23_1 = $6_1 + 2144 | 0;
        $3_1 = $17_1 + 8 | 0;
        $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
        $38_1 = $6_1 + 2336 | 0;
        $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
        $35_1 = $6_1 + 2112 | 0;
        $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
        $36_1 = $6_1 + 2192 | 0;
        $12_1 = $11_1;
        $21_1 = $7_1;
        $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
        $15_1 = HEAP32[$6_1 + 2324 >> 2];
        $3_1 = $15_1 + HEAP32[$6_1 + 2244 >> 2] | 0;
        $7_1 = HEAP32[$6_1 + 2320 >> 2];
        $5_1 = HEAP32[$6_1 + 2240 >> 2];
        $4_1 = $7_1 + $5_1 | 0;
        $8_1 = HEAP32[$6_1 + 2160 >> 2];
        $17_1 = $4_1 + $8_1 | 0;
        $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $5_1 + HEAP32[$6_1 + 2164 >> 2] | 0;
        $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
        $3_1 = $18_1 + 8 | 0;
        $9_1 = HEAP32[$3_1 >> 2];
        $11_1 = HEAP32[$3_1 + 4 >> 2];
        $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
        $5_1 = $19_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $25_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $7_1 + $15_1 | 0;
        $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
        $5_1 = $4_1;
        $4_1 = $4_1 + $9_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $14_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = $8_1;
        $9_1 = $4_1 << 12 | $8_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 2288 >> 2];
        $4_1 = HEAP32[$6_1 + 2224 >> 2];
        $15_1 = $31_1 + $4_1 | 0;
        $40_1 = HEAP32[$6_1 + 2292 >> 2];
        $3_1 = $40_1 + HEAP32[$6_1 + 2228 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 2128 >> 2];
        $11_1 = $4_1 + $15_1 | 0;
        $19_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 2132 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 2144 >> 2];
        $8_1 = $4_1 + $11_1 | 0;
        $18_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 2148 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $7_1 | 0;
        $37_1 = $6_1 + 2096 | 0;
        $9_1 = $8_1 + $9_1 | 0;
        $7_1 = $9_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
        $3_1 = $23_1 + 8 | 0;
        $29_1 = HEAP32[$3_1 >> 2];
        $27_1 = HEAP32[$3_1 + 4 >> 2];
        $25_1 = ($18_1 | 0) == ($19_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
        $3_1 = $33_1 + 8 | 0;
        $23_1 = HEAP32[$3_1 >> 2];
        $18_1 = HEAP32[$3_1 + 4 >> 2];
        $11_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
        $8_1 = $39_1 + 8 | 0;
        $4_1 = HEAP32[$8_1 >> 2];
        $3_1 = $34_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $11_1 + $15_1 | 0;
        $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + $23_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1;
        $4_1 = $4_1 + $25_1 | 0;
        $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + $29_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1 + $32_1 | 0;
        $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $30_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $7_1;
        $11_1 = $4_1 << 12 | $5_1 >>> 20;
        $8_1 = $3_1;
        $18_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 2116 >> 2];
        $3_1 = $31_1 + HEAP32[$6_1 + 2196 >> 2] | 0;
        $25_1 = HEAP32[$6_1 + 2112 >> 2];
        $4_1 = HEAP32[$6_1 + 2192 >> 2];
        $7_1 = $25_1 + $4_1 | 0;
        $15_1 = $7_1;
        $11_1 = $7_1 + $11_1 | 0;
        $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $18_1 | 0;
        $23_1 = $11_1 << 4 & -16;
        $7_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $19_1 = ($7_1 << 4 | $11_1 >>> 28) & 16777215;
        $18_1 = $5_1;
        $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
        $30_1 = $6_1 + 2272 | 0;
        $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
        $32_1 = $6_1 + 2080 | 0;
        $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
        $29_1 = $6_1 + 2304 | 0;
        $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
        $27_1 = $6_1 + 2064 | 0;
        $23_1 = $27_1;
        $19_1 = ($4_1 | 0) == ($7_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $11_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
        $5_1 = $36_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $35_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $11_1 + $15_1 | 0;
        $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $8_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $19_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $4_1 << 12 | $7_1 >>> 20;
        $5_1 = $3_1;
        $19_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 2084 >> 2];
        $3_1 = $31_1 + HEAP32[$6_1 + 2308 >> 2] | 0;
        $15_1 = HEAP32[$6_1 + 2080 >> 2];
        $4_1 = HEAP32[$6_1 + 2304 >> 2];
        $8_1 = $15_1 + $4_1 | 0;
        $11_1 = $8_1;
        $7_1 = $8_1 + $7_1 | 0;
        $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $19_1 | 0;
        $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
        $25_1 = $6_1 + 2208 | 0;
        $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
        $23_1 = $6_1 + 2256 | 0;
        $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
        $13_1 = $6_1 + 2048 | 0;
        $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
        $26_1 = $6_1 + 2032 | 0;
        $12_1 = $26_1;
        $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
        $11_1 = ($4_1 | 0) == ($31_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
        $7_1 = $29_1 + 8 | 0;
        $4_1 = HEAP32[$7_1 >> 2];
        $3_1 = $32_1 + 8 | 0;
        $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $11_1 + $16_1 | 0;
        $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $7_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $4_1 << 12 | $8_1 >>> 20;
        $8_1 = HEAP32[$6_1 + 2048 >> 2];
        $10_1 = $7_1 + $8_1 | 0;
        $5_1 = $3_1;
        $4_1 = $3_1 << 12 | $4_1 >>> 20;
        $3_1 = $4_1 + HEAP32[$6_1 + 2052 >> 2] | 0;
        $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
        $19_1 = $6_1 + 2016 | 0;
        $11_1 = $19_1;
        $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
        $3_1 = $13_1 + 8 | 0;
        $8_1 = HEAP32[$3_1 >> 2];
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $7_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($11_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
        $5_1 = HEAP32[$6_1 + 2096 >> 2];
        $4_1 = HEAP32[$6_1 + 2336 >> 2];
        $12_1 = $5_1 + $4_1 | 0;
        $7_1 = HEAP32[$6_1 + 2100 >> 2];
        $3_1 = $7_1 + HEAP32[$6_1 + 2340 >> 2] | 0;
        $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
        $5_1 = $38_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $37_1 + 8 | 0;
        $11_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $7_1 + $11_1 | 0;
        $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $15_1 = $8_1;
        $7_1 = $4_1 << 12 | $8_1 >>> 20;
        $5_1 = $3_1;
        $8_1 = $3_1 << 12 | $4_1 >>> 20;
        $10_1 = HEAP32[$6_1 + 2064 >> 2];
        $4_1 = HEAP32[$6_1 + 2272 >> 2];
        $11_1 = $10_1 + $4_1 | 0;
        $16_1 = HEAP32[$6_1 + 2068 >> 2];
        $3_1 = $16_1 + HEAP32[$6_1 + 2276 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $8_1 | 0;
        $8_1 = $7_1 + $11_1 | 0;
        $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $10_1 = ($4_1 | 0) == ($16_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
        $11_1 = $30_1 + 8 | 0;
        $4_1 = HEAP32[$11_1 >> 2];
        $3_1 = $27_1 + 8 | 0;
        $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$11_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $11_1 = $10_1 + $16_1 | 0;
        $3_1 = $11_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $11_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $13_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $16_1 = $7_1;
        $11_1 = $4_1 << 12 | $7_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $22_1 = HEAP32[$6_1 + 2208 >> 2];
        $4_1 = HEAP32[$6_1 + 2256 >> 2];
        $13_1 = $22_1 + $4_1 | 0;
        $27_1 = HEAP32[$6_1 + 2212 >> 2];
        $3_1 = $27_1 + HEAP32[$6_1 + 2260 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 2032 >> 2];
        $10_1 = $4_1 + $13_1 | 0;
        $21_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 2036 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $7_1 | 0;
        $7_1 = $10_1 + $11_1 | 0;
        $11_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $28_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
        $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
        $3_1 = $26_1 + 8 | 0;
        $24_1 = HEAP32[$3_1 >> 2];
        $26_1 = HEAP32[$3_1 + 4 >> 2];
        $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
        $10_1 = $23_1 + 8 | 0;
        $4_1 = HEAP32[$10_1 >> 2];
        $3_1 = $25_1 + 8 | 0;
        $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $13_1 + $21_1 | 0;
        $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
        $13_1 = $4_1;
        $4_1 = $4_1 + $24_1 | 0;
        $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $4_1 + $20_1 | 0;
        $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $28_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = $11_1;
        $21_1 = $4_1 << 12 | $11_1 >>> 20;
        $5_1 = $3_1;
        $10_1 = $3_1 << 12 | $4_1 >>> 20;
        $24_1 = HEAP32[$6_1 + 2016 >> 2];
        $11_1 = $24_1 + ($17_1 & -2) | 0;
        $26_1 = HEAP32[$6_1 + 2020 >> 2];
        $3_1 = $26_1 + ($14_1 & 1048575) | 0;
        $3_1 = $11_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $17_1 = $11_1;
        $11_1 = $11_1 + $21_1 | 0;
        $4_1 = $3_1;
        $3_1 = $3_1 + $10_1 | 0;
        $14_1 = $9_1;
        $21_1 = $18_1 & 65535;
        $10_1 = $11_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $18_1 = ($4_1 | 0) == ($10_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $10_1 >>> 0;
        $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
        $3_1 = $19_1 + 8 | 0;
        $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $9_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $18_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $9_1 = $4_1 << 12 | $10_1 >>> 20;
        $5_1 = $9_1 + $14_1 | 0;
        $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
        $4_1 = $5_1;
        $9_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $10_1 & 1048575;
        $13_1 = $13_1 & 1048575;
        $14_1 = $16_1 & 1048575;
        $5_1 = $12_1;
        $12_1 = $15_1 & 1048575;
        $1_1 = $1_1 - 1 | 0;
        if ($1_1) {
          continue;
        }
        break;
      }
      ;
      $3_1 = $6_1 + 7216 | 0;
      $24_1 = $3_1 + 32 | 0;
      HEAP32[$24_1 >> 2] = $4_1;
      HEAP32[$24_1 + 4 >> 2] = $9_1;
      $1_1 = $3_1 + 24 | 0;
      HEAP32[$1_1 >> 2] = $11_1;
      HEAP32[$1_1 + 4 >> 2] = $10_1;
      $9_1 = $3_1 + 16 | 0;
      HEAP32[$9_1 >> 2] = $7_1;
      HEAP32[$9_1 + 4 >> 2] = $13_1;
      $17_1 = $3_1 + 8 | 0;
      HEAP32[$17_1 >> 2] = $8_1;
      HEAP32[$17_1 + 4 >> 2] = $14_1;
      HEAP32[$6_1 + 7216 >> 2] = $5_1;
      HEAP32[$6_1 + 7220 >> 2] = $12_1;
      $34($3_1, $3_1, $6_1 + 7336 | 0);
      $12_1 = HEAP32[$1_1 >> 2];
      $5_1 = $12_1;
      $10_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $10_1;
      $1_1 = HEAP32[$6_1 + 7220 >> 2];
      $20_1 = $1_1;
      $18_1 = HEAP32[$6_1 + 7216 >> 2];
      $7_1 = $18_1;
      $3_1 = $1_1 << 1 | $7_1 >>> 31;
      $15_1 = $6_1 + 1856 | 0;
      $21_1 = $7_1 << 1;
      $26_1 = $3_1;
      $69($15_1, $5_1, $4_1, 0, 0, $21_1, $3_1, 0, 0);
      $1_1 = HEAP32[$17_1 + 4 >> 2];
      $40_1 = $1_1;
      $33_1 = HEAP32[$17_1 >> 2];
      $4_1 = $33_1;
      $3_1 = $1_1 << 1 | $4_1 >>> 31;
      $16_1 = $6_1 + 1952 | 0;
      $13_1 = HEAP32[$9_1 >> 2];
      $9_1 = HEAP32[$9_1 + 4 >> 2];
      $4_1 = $4_1 << 1;
      $5_1 = $3_1;
      $69($16_1, $13_1, $9_1, 0, 0, $4_1, $3_1, 0, 0);
      $14_1 = $6_1 + 1840 | 0;
      $8_1 = HEAP32[$24_1 >> 2];
      $1_1 = HEAP32[$24_1 + 4 >> 2];
      $69($14_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
      $11_1 = $6_1 + 1824 | 0;
      $69($11_1, HEAP32[$6_1 + 1840 >> 2], HEAP32[$6_1 + 1844 >> 2], 0, 0, 15632, 16, 0, 0);
      $3_1 = $1_1 << 1 | $8_1 >>> 31;
      $39_1 = $6_1 + 1792 | 0;
      $24_1 = $8_1 << 1;
      $17_1 = $3_1;
      $69($39_1, $24_1, $3_1, 0, 0, $7_1, $20_1, 0, 0);
      $38_1 = $6_1 + 1872 | 0;
      $69($38_1, $12_1, $10_1, 0, 0, $4_1, $5_1, 0, 0);
      $35_1 = $6_1 + 1936 | 0;
      $69($35_1, $13_1, $9_1, 0, 0, $13_1, $9_1, 0, 0);
      $28_1 = $6_1 + 1808 | 0;
      $1_1 = $14_1 + 8 | 0;
      $69($28_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $36_1 = $6_1 + 2e3 | 0;
      $69($36_1, $7_1, $20_1, 0, 0, $7_1, $20_1, 0, 0);
      $31_1 = $6_1 + 1776 | 0;
      $69($31_1, $24_1, $3_1, 0, 0, $33_1, $40_1, 0, 0);
      $37_1 = $6_1 + 1888 | 0;
      $69($37_1, $12_1, $10_1, 0, 0, $13_1 << 1, $9_1 << 1 | $13_1 >>> 31, 0, 0);
      $20_1 = HEAP32[$6_1 + 1860 >> 2];
      $3_1 = $20_1 + HEAP32[$6_1 + 1956 >> 2] | 0;
      $8_1 = HEAP32[$6_1 + 1856 >> 2];
      $4_1 = HEAP32[$6_1 + 1952 >> 2];
      $1_1 = $8_1 + $4_1 | 0;
      $5_1 = HEAP32[$6_1 + 1824 >> 2];
      $18_1 = $1_1 + $5_1 | 0;
      $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + HEAP32[$6_1 + 1828 >> 2] | 0;
      $5_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
      $3_1 = $11_1 + 8 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $7_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = ($4_1 | 0) == ($20_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0;
      $3_1 = $16_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $15_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $16_1 | 0;
      $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $11_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $14_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $5_1;
      $11_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $30_1 = HEAP32[$6_1 + 1872 >> 2];
      $1_1 = HEAP32[$6_1 + 1936 >> 2];
      $14_1 = $30_1 + $1_1 | 0;
      $34_1 = HEAP32[$6_1 + 1876 >> 2];
      $3_1 = $34_1 + HEAP32[$6_1 + 1940 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 1792 >> 2];
      $7_1 = $1_1 + $14_1 | 0;
      $20_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 1796 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 1808 >> 2];
      $5_1 = $1_1 + $7_1 | 0;
      $16_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 1812 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $32_1 = $6_1 + 1760 | 0;
      $29_1 = $32_1;
      $11_1 = $5_1 + $11_1 | 0;
      $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $27_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
      $25_1 = ($1_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
      $1_1 = $28_1 + 8 | 0;
      $23_1 = HEAP32[$1_1 >> 2];
      $19_1 = HEAP32[$1_1 + 4 >> 2];
      $22_1 = ($16_1 | 0) == ($20_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $16_1 >>> 0 < $20_1 >>> 0;
      $1_1 = $39_1 + 8 | 0;
      $28_1 = HEAP32[$1_1 >> 2];
      $16_1 = HEAP32[$1_1 + 4 >> 2];
      $7_1 = ($20_1 | 0) == ($34_1 | 0) & $14_1 >>> 0 < $30_1 >>> 0 | $20_1 >>> 0 < $34_1 >>> 0;
      $3_1 = $35_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $38_1 + 8 | 0;
      $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $7_1 + $14_1 | 0;
      $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $28_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $22_1 | 0;
      $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $23_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1 + $25_1 | 0;
      $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $27_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $8_1;
      $7_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $19_1 = HEAP32[$6_1 + 1776 >> 2];
      $1_1 = HEAP32[$6_1 + 1888 >> 2];
      $14_1 = $19_1 + $1_1 | 0;
      $23_1 = HEAP32[$6_1 + 1780 >> 2];
      $3_1 = $23_1 + HEAP32[$6_1 + 1892 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $7_1 = $7_1 + $14_1 | 0;
      $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $28_1 = $7_1 << 4 & -16;
      $8_1 = $3_1;
      $20_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
      $16_1 = $4_1;
      $69($29_1, $28_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
      $29_1 = $6_1 + 1984 | 0;
      $69($29_1, $33_1, $40_1, 0, 0, $21_1, $26_1, 0, 0);
      $25_1 = $6_1 + 1728 | 0;
      $69($25_1, $24_1, $17_1, 0, 0, $13_1, $9_1, 0, 0);
      $22_1 = $6_1 + 1904 | 0;
      $69($22_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
      $28_1 = $6_1 + 1712 | 0;
      $20_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
      $3_1 = $37_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $31_1 + 8 | 0;
      $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $14_1 | 0;
      $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $8_1 >>> 20;
      $4_1 = $3_1;
      $14_1 = $3_1 << 12 | $1_1 >>> 20;
      $27_1 = HEAP32[$6_1 + 1732 >> 2];
      $3_1 = $27_1 + HEAP32[$6_1 + 1908 >> 2] | 0;
      $20_1 = HEAP32[$6_1 + 1728 >> 2];
      $1_1 = HEAP32[$6_1 + 1904 >> 2];
      $5_1 = $20_1 + $1_1 | 0;
      $7_1 = $5_1;
      $8_1 = $5_1 + $8_1 | 0;
      $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $14_1 | 0;
      $5_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($28_1, $8_1, $5_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $23_1 = $6_1 + 1920 | 0;
      $69($23_1, $13_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
      $19_1 = $6_1 + 1968 | 0;
      $69($19_1, $33_1, $40_1, 0, 0, $33_1, $40_1, 0, 0);
      $14_1 = $6_1 + 1664 | 0;
      $69($14_1, $24_1, $17_1, 0, 0, $12_1, $10_1, 0, 0);
      $21_1 = $6_1 + 1648 | 0;
      $10_1 = $21_1;
      $9_1 = ($1_1 | 0) == ($5_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
      $7_1 = ($1_1 | 0) == ($27_1 | 0) & $7_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
      $3_1 = $22_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $1_1 = $25_1 + 8 | 0;
      $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $7_1 + $12_1 | 0;
      $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $5_1 >>> 20;
      $5_1 = HEAP32[$6_1 + 1664 >> 2];
      $9_1 = $8_1 + $5_1 | 0;
      $4_1 = $3_1;
      $1_1 = $3_1 << 12 | $1_1 >>> 20;
      $3_1 = $1_1 + HEAP32[$6_1 + 1668 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $27_1 = $6_1 + 1584 | 0;
      $7_1 = $27_1;
      $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $1_1 = $14_1 + 8 | 0;
      $5_1 = HEAP32[$1_1 >> 2];
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $4_1 = HEAP32[$6_1 + 1760 >> 2];
      $1_1 = HEAP32[$6_1 + 2e3 >> 2];
      $7_1 = $4_1 + $1_1 | 0;
      $8_1 = HEAP32[$6_1 + 1764 >> 2];
      $3_1 = $8_1 + HEAP32[$6_1 + 2004 >> 2] | 0;
      $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
      $3_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $32_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $9_1 | 0;
      $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $5_1;
      $8_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $12_1 = $3_1 << 12 | $1_1 >>> 20;
      $14_1 = HEAP32[$6_1 + 1716 >> 2];
      $3_1 = $14_1 + HEAP32[$6_1 + 1988 >> 2] | 0;
      $10_1 = HEAP32[$6_1 + 1712 >> 2];
      $1_1 = HEAP32[$6_1 + 1984 >> 2];
      $5_1 = $10_1 + $1_1 | 0;
      $9_1 = $5_1;
      $8_1 = $5_1 + $8_1 | 0;
      $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $12_1 | 0;
      $5_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
      $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
      $3_1 = $29_1 + 8 | 0;
      $9_1 = HEAP32[$3_1 >> 2];
      $1_1 = $28_1 + 8 | 0;
      $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $10_1 + $14_1 | 0;
      $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $12_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $5_1;
      $9_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $22_1 = HEAP32[$6_1 + 1920 >> 2];
      $1_1 = HEAP32[$6_1 + 1968 >> 2];
      $12_1 = $22_1 + $1_1 | 0;
      $29_1 = HEAP32[$6_1 + 1924 >> 2];
      $3_1 = $29_1 + HEAP32[$6_1 + 1972 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 1648 >> 2];
      $10_1 = $1_1 + $12_1 | 0;
      $17_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 1652 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $25_1 = $6_1 + 1568 | 0;
      $5_1 = $9_1 + $10_1 | 0;
      $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
      $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
      $1_1 = $21_1 + 8 | 0;
      $26_1 = HEAP32[$1_1 >> 2];
      $21_1 = HEAP32[$1_1 + 4 >> 2];
      $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
      $3_1 = $19_1 + 8 | 0;
      $10_1 = HEAP32[$3_1 >> 2];
      $1_1 = $23_1 + 8 | 0;
      $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $12_1 + $17_1 | 0;
      $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
      $12_1 = $1_1;
      $1_1 = $1_1 + $26_1 | 0;
      $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $1_1 + $24_1 | 0;
      $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $10_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $9_1;
      $17_1 = $1_1 << 12 | $9_1 >>> 20;
      $4_1 = $3_1;
      $12_1 = $3_1 << 12 | $1_1 >>> 20;
      $29_1 = HEAP32[$6_1 + 1588 >> 2];
      $3_1 = $29_1 + ($15_1 & 1048575) | 0;
      $22_1 = HEAP32[$6_1 + 1584 >> 2];
      $9_1 = $18_1 & -2;
      $1_1 = $22_1 + $9_1 | 0;
      $15_1 = $1_1;
      $1_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $12_1 | 0;
      $12_1 = $15_1 + $17_1 | 0;
      $9_1 = $12_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $17_1 = $9_1 & 1048575;
      $3_1 = $13_1 & 1048575;
      $32_1 = $3_1;
      $13_1 = $7_1;
      $3_1 = $3_1 << 1 | $7_1 >>> 31;
      $26_1 = $7_1 << 1;
      $24_1 = $3_1;
      $69($25_1, $12_1, $17_1, 0, 0, $26_1, $3_1, 0, 0);
      $3_1 = $14_1 & 1048575;
      $33_1 = $3_1;
      $23_1 = $6_1 + 1600 | 0;
      $18_1 = $10_1 & 1048575;
      $7_1 = $8_1 << 1;
      $28_1 = $8_1;
      $10_1 = $3_1 << 1 | $8_1 >>> 31;
      $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
      $19_1 = $6_1 + 1504 | 0;
      $21_1 = $16_1 & 65535;
      $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
      $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
      $1_1 = $27_1 + 8 | 0;
      $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $9_1 >>> 20;
      $4_1 = $8_1 + $11_1 | 0;
      $3_1 = $21_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
      $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($19_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
      $11_1 = $6_1 + 1488 | 0;
      $69($11_1, HEAP32[$6_1 + 1504 >> 2], HEAP32[$6_1 + 1508 >> 2], 0, 0, 15632, 16, 0, 0);
      $1_1 = $4_1;
      $3_1 = $3_1 << 1 | $1_1 >>> 31;
      $39_1 = $6_1 + 1456 | 0;
      $20_1 = $1_1 << 1;
      $21_1 = $3_1;
      $69($39_1, $20_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
      $38_1 = $6_1 + 1552 | 0;
      $69($38_1, $12_1, $17_1, 0, 0, $7_1, $10_1, 0, 0);
      $35_1 = $6_1 + 1616 | 0;
      $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
      $22_1 = $6_1 + 1472 | 0;
      $1_1 = $19_1 + 8 | 0;
      $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $36_1 = $6_1 + 1744 | 0;
      $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
      $31_1 = $6_1 + 1440 | 0;
      $69($31_1, $20_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
      $37_1 = $6_1 + 1520 | 0;
      $10_1 = $17_1;
      $9_1 = $18_1;
      $17_1 = $5_1;
      $69($37_1, $12_1, $10_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
      $8_1 = HEAP32[$6_1 + 1568 >> 2];
      $4_1 = HEAP32[$6_1 + 1600 >> 2];
      $1_1 = $8_1 + $4_1 | 0;
      $13_1 = HEAP32[$6_1 + 1572 >> 2];
      $3_1 = $13_1 + HEAP32[$6_1 + 1604 >> 2] | 0;
      $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 1488 >> 2];
      $18_1 = $4_1 + $1_1 | 0;
      $5_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 1492 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
      $3_1 = $11_1 + 8 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $7_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = ($5_1 | 0) == ($13_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $13_1 >>> 0;
      $3_1 = $23_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $25_1 + 8 | 0;
      $13_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $13_1 | 0;
      $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $11_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $14_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $4_1;
      $11_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $30_1 = HEAP32[$6_1 + 1552 >> 2];
      $1_1 = HEAP32[$6_1 + 1616 >> 2];
      $13_1 = $30_1 + $1_1 | 0;
      $34_1 = HEAP32[$6_1 + 1556 >> 2];
      $3_1 = $34_1 + HEAP32[$6_1 + 1620 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 1456 >> 2];
      $14_1 = $1_1 + $13_1 | 0;
      $4_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 1460 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 1472 >> 2];
      $7_1 = $1_1 + $14_1 | 0;
      $16_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 1476 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $32_1 = $6_1 + 1344 | 0;
      $29_1 = $32_1;
      $11_1 = $7_1 + $11_1 | 0;
      $8_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $27_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
      $25_1 = ($1_1 | 0) == ($16_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
      $1_1 = $22_1 + 8 | 0;
      $23_1 = HEAP32[$1_1 >> 2];
      $19_1 = HEAP32[$1_1 + 4 >> 2];
      $22_1 = ($4_1 | 0) == ($16_1 | 0) & $13_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 > $16_1 >>> 0;
      $1_1 = $39_1 + 8 | 0;
      $16_1 = HEAP32[$1_1 >> 2];
      $14_1 = HEAP32[$1_1 + 4 >> 2];
      $7_1 = ($4_1 | 0) == ($34_1 | 0) & $13_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
      $3_1 = $35_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $38_1 + 8 | 0;
      $13_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $7_1 + $13_1 | 0;
      $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $14_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $22_1 | 0;
      $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $23_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1 + $25_1 | 0;
      $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $27_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $8_1;
      $7_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $19_1 = HEAP32[$6_1 + 1440 >> 2];
      $1_1 = HEAP32[$6_1 + 1520 >> 2];
      $14_1 = $19_1 + $1_1 | 0;
      $23_1 = HEAP32[$6_1 + 1444 >> 2];
      $3_1 = $23_1 + HEAP32[$6_1 + 1524 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $7_1 = $7_1 + $14_1 | 0;
      $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $22_1 = $7_1 << 4 & -16;
      $8_1 = $3_1;
      $13_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
      $16_1 = $4_1;
      $69($29_1, $22_1 | $4_1 >>> 16 & 15, $13_1, 0, 0, 977, 1, 0, 0);
      $29_1 = $6_1 + 1680 | 0;
      $69($29_1, $28_1, $33_1, 0, 0, $26_1, $24_1, 0, 0);
      $27_1 = $6_1 + 1424 | 0;
      $69($27_1, $20_1, $21_1, 0, 0, $17_1, $9_1, 0, 0);
      $25_1 = $6_1 + 1536 | 0;
      $69($25_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
      $22_1 = $6_1 + 1408 | 0;
      $13_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
      $3_1 = $37_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $31_1 + 8 | 0;
      $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $14_1 | 0;
      $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $13_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $8_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $13_1 = HEAP32[$6_1 + 1424 >> 2];
      $1_1 = HEAP32[$6_1 + 1536 >> 2];
      $7_1 = $13_1 + $1_1 | 0;
      $30_1 = HEAP32[$6_1 + 1428 >> 2];
      $3_1 = $30_1 + HEAP32[$6_1 + 1540 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $8_1 = $7_1 + $8_1 | 0;
      $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $3_1;
      $69($22_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $23_1 = $6_1 + 1632 | 0;
      $69($23_1, $17_1, $9_1, 0, 0, $26_1, $24_1, 0, 0);
      $19_1 = $6_1 + 1696 | 0;
      $69($19_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
      $14_1 = $6_1 + 1392 | 0;
      $69($14_1, $12_1, $10_1, 0, 0, $20_1, $21_1, 0, 0);
      $21_1 = $6_1 + 1376 | 0;
      $10_1 = $21_1;
      $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $7_1 = ($1_1 | 0) == ($30_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
      $3_1 = $25_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $1_1 = $27_1 + 8 | 0;
      $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $7_1 + $12_1 | 0;
      $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $5_1 >>> 20;
      $5_1 = HEAP32[$6_1 + 1392 >> 2];
      $9_1 = $8_1 + $5_1 | 0;
      $4_1 = $3_1;
      $1_1 = $3_1 << 12 | $1_1 >>> 20;
      $3_1 = $1_1 + HEAP32[$6_1 + 1396 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $27_1 = $6_1 + 1360 | 0;
      $7_1 = $27_1;
      $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $1_1 = $14_1 + 8 | 0;
      $5_1 = HEAP32[$1_1 >> 2];
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $4_1 = HEAP32[$6_1 + 1344 >> 2];
      $1_1 = HEAP32[$6_1 + 1744 >> 2];
      $7_1 = $4_1 + $1_1 | 0;
      $8_1 = HEAP32[$6_1 + 1348 >> 2];
      $3_1 = $8_1 + HEAP32[$6_1 + 1748 >> 2] | 0;
      $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
      $3_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $32_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $9_1 | 0;
      $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $5_1;
      $8_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $10_1 = HEAP32[$6_1 + 1408 >> 2];
      $1_1 = HEAP32[$6_1 + 1680 >> 2];
      $9_1 = $10_1 + $1_1 | 0;
      $14_1 = HEAP32[$6_1 + 1412 >> 2];
      $3_1 = $14_1 + HEAP32[$6_1 + 1684 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $8_1 = $8_1 + $9_1 | 0;
      $5_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
      $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
      $3_1 = $29_1 + 8 | 0;
      $9_1 = HEAP32[$3_1 >> 2];
      $1_1 = $22_1 + 8 | 0;
      $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $10_1 + $14_1 | 0;
      $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $12_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $5_1;
      $9_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $22_1 = HEAP32[$6_1 + 1632 >> 2];
      $1_1 = HEAP32[$6_1 + 1696 >> 2];
      $12_1 = $22_1 + $1_1 | 0;
      $29_1 = HEAP32[$6_1 + 1636 >> 2];
      $3_1 = $29_1 + HEAP32[$6_1 + 1700 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 1376 >> 2];
      $10_1 = $1_1 + $12_1 | 0;
      $17_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 1380 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $25_1 = $6_1 + 1264 | 0;
      $5_1 = $9_1 + $10_1 | 0;
      $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
      $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
      $1_1 = $21_1 + 8 | 0;
      $26_1 = HEAP32[$1_1 >> 2];
      $21_1 = HEAP32[$1_1 + 4 >> 2];
      $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
      $3_1 = $19_1 + 8 | 0;
      $10_1 = HEAP32[$3_1 >> 2];
      $1_1 = $23_1 + 8 | 0;
      $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $12_1 + $17_1 | 0;
      $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
      $12_1 = $1_1;
      $1_1 = $1_1 + $26_1 | 0;
      $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $1_1 + $24_1 | 0;
      $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $10_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $9_1;
      $12_1 = $1_1 << 12 | $9_1 >>> 20;
      $4_1 = $3_1;
      $17_1 = $3_1 << 12 | $1_1 >>> 20;
      $29_1 = HEAP32[$6_1 + 1364 >> 2];
      $3_1 = $29_1 + ($15_1 & 1048575) | 0;
      $22_1 = HEAP32[$6_1 + 1360 >> 2];
      $1_1 = $18_1 & -2;
      $9_1 = $22_1 + $1_1 | 0;
      $15_1 = $9_1;
      $12_1 = $9_1 + $12_1 | 0;
      $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $17_1 | 0;
      $9_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = $9_1 & 1048575;
      $18_1 = $20_1;
      $3_1 = $13_1 & 1048575;
      $32_1 = $3_1;
      $13_1 = $7_1;
      $3_1 = $3_1 << 1 | $7_1 >>> 31;
      $21_1 = $7_1 << 1;
      $26_1 = $3_1;
      $69($25_1, $12_1, $18_1, 0, 0, $21_1, $3_1, 0, 0);
      $3_1 = $14_1 & 1048575;
      $33_1 = $3_1;
      $23_1 = $6_1 + 1216 | 0;
      $18_1 = $10_1 & 1048575;
      $7_1 = $8_1 << 1;
      $28_1 = $8_1;
      $10_1 = $3_1 << 1 | $8_1 >>> 31;
      $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
      $19_1 = $6_1 + 1168 | 0;
      $17_1 = $16_1 & 65535;
      $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
      $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
      $1_1 = $27_1 + 8 | 0;
      $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $8_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $9_1 >>> 20;
      $4_1 = $8_1 + $11_1 | 0;
      $3_1 = $17_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
      $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($19_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
      $11_1 = $6_1 + 1152 | 0;
      $69($11_1, HEAP32[$6_1 + 1168 >> 2], HEAP32[$6_1 + 1172 >> 2], 0, 0, 15632, 16, 0, 0);
      $1_1 = $4_1;
      $3_1 = $3_1 << 1 | $1_1 >>> 31;
      $39_1 = $6_1 + 1120 | 0;
      $24_1 = $1_1 << 1;
      $17_1 = $3_1;
      $69($39_1, $24_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
      $38_1 = $6_1 + 1200 | 0;
      $69($38_1, $12_1, $20_1, 0, 0, $7_1, $10_1, 0, 0);
      $35_1 = $6_1 + 1312 | 0;
      $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
      $22_1 = $6_1 + 1136 | 0;
      $1_1 = $19_1 + 8 | 0;
      $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $36_1 = $6_1 + 1280 | 0;
      $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
      $31_1 = $6_1 + 1104 | 0;
      $69($31_1, $24_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
      $37_1 = $6_1 + 1184 | 0;
      $16_1 = $12_1;
      $13_1 = $20_1;
      $9_1 = $18_1;
      $18_1 = $5_1;
      $69($37_1, $12_1, $13_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
      $8_1 = HEAP32[$6_1 + 1264 >> 2];
      $4_1 = HEAP32[$6_1 + 1216 >> 2];
      $1_1 = $8_1 + $4_1 | 0;
      $12_1 = HEAP32[$6_1 + 1268 >> 2];
      $3_1 = $12_1 + HEAP32[$6_1 + 1220 >> 2] | 0;
      $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 1152 >> 2];
      $14_1 = $4_1 + $1_1 | 0;
      $5_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 1156 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
      $3_1 = $11_1 + 8 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $7_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = ($5_1 | 0) == ($12_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $12_1 >>> 0;
      $3_1 = $23_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $25_1 + 8 | 0;
      $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $12_1 | 0;
      $3_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $11_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $4_1;
      $7_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $30_1 = HEAP32[$6_1 + 1200 >> 2];
      $1_1 = HEAP32[$6_1 + 1312 >> 2];
      $15_1 = $30_1 + $1_1 | 0;
      $34_1 = HEAP32[$6_1 + 1204 >> 2];
      $3_1 = $34_1 + HEAP32[$6_1 + 1316 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 1120 >> 2];
      $10_1 = $1_1 + $15_1 | 0;
      $4_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 1124 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 1136 >> 2];
      $11_1 = $1_1 + $10_1 | 0;
      $20_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 1140 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $32_1 = $6_1 + 1008 | 0;
      $29_1 = $32_1;
      $8_1 = $7_1 + $11_1 | 0;
      $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $27_1 = ($1_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
      $25_1 = ($1_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 < $20_1 >>> 0;
      $1_1 = $22_1 + 8 | 0;
      $23_1 = HEAP32[$1_1 >> 2];
      $19_1 = HEAP32[$1_1 + 4 >> 2];
      $22_1 = ($4_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $20_1 >>> 0;
      $1_1 = $39_1 + 8 | 0;
      $20_1 = HEAP32[$1_1 >> 2];
      $10_1 = HEAP32[$1_1 + 4 >> 2];
      $11_1 = ($4_1 | 0) == ($34_1 | 0) & $15_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
      $3_1 = $35_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $38_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $11_1 + $15_1 | 0;
      $3_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $22_1 | 0;
      $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $23_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1 + $25_1 | 0;
      $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $27_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1;
      $11_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $1_1 >>> 20;
      $19_1 = HEAP32[$6_1 + 1104 >> 2];
      $1_1 = HEAP32[$6_1 + 1184 >> 2];
      $15_1 = $19_1 + $1_1 | 0;
      $30_1 = HEAP32[$6_1 + 1108 >> 2];
      $3_1 = $30_1 + HEAP32[$6_1 + 1188 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $7_1 | 0;
      $11_1 = $11_1 + $15_1 | 0;
      $3_1 = $11_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $22_1 = $11_1 << 4 & -16;
      $7_1 = $3_1;
      $20_1 = ($3_1 << 4 | $11_1 >>> 28) & 16777215;
      $10_1 = $4_1;
      $69($29_1, $22_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
      $29_1 = $6_1 + 1248 | 0;
      $69($29_1, $28_1, $33_1, 0, 0, $21_1, $26_1, 0, 0);
      $27_1 = $6_1 + 1088 | 0;
      $69($27_1, $24_1, $17_1, 0, 0, $18_1, $9_1, 0, 0);
      $25_1 = $6_1 + 1328 | 0;
      $69($25_1, $16_1, $13_1, 0, 0, $16_1, $13_1, 0, 0);
      $23_1 = $6_1 + 1072 | 0;
      $22_1 = $23_1;
      $20_1 = ($1_1 | 0) == ($3_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $11_1 = ($1_1 | 0) == ($30_1 | 0) & $15_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
      $3_1 = $37_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $31_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $11_1 + $15_1 | 0;
      $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $7_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $20_1 = HEAP32[$6_1 + 1088 >> 2];
      $1_1 = HEAP32[$6_1 + 1328 >> 2];
      $11_1 = $20_1 + $1_1 | 0;
      $30_1 = HEAP32[$6_1 + 1092 >> 2];
      $3_1 = $30_1 + HEAP32[$6_1 + 1332 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $7_1 = $7_1 + $11_1 | 0;
      $3_1 = $7_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $3_1;
      $69($22_1, $7_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $19_1 = $6_1 + 1232 | 0;
      $69($19_1, $18_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
      $22_1 = $6_1 + 1296 | 0;
      $69($22_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
      $15_1 = $6_1 + 1056 | 0;
      $69($15_1, $16_1, $13_1, 0, 0, $24_1, $17_1, 0, 0);
      $18_1 = $6_1 + 1040 | 0;
      $13_1 = $18_1;
      $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $11_1 = ($1_1 | 0) == ($30_1 | 0) & $11_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
      $3_1 = $25_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $1_1 = $27_1 + 8 | 0;
      $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $11_1 + $16_1 | 0;
      $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $7_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $5_1 >>> 20;
      $5_1 = HEAP32[$6_1 + 1056 >> 2];
      $9_1 = $7_1 + $5_1 | 0;
      $4_1 = $3_1;
      $1_1 = $3_1 << 12 | $1_1 >>> 20;
      $3_1 = $1_1 + HEAP32[$6_1 + 1060 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($13_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $20_1 = $6_1 + 1024 | 0;
      $11_1 = $20_1;
      $7_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $1_1 = $15_1 + 8 | 0;
      $5_1 = HEAP32[$1_1 >> 2];
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $7_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($11_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $4_1 = HEAP32[$6_1 + 1008 >> 2];
      $1_1 = HEAP32[$6_1 + 1280 >> 2];
      $9_1 = $4_1 + $1_1 | 0;
      $7_1 = HEAP32[$6_1 + 1012 >> 2];
      $3_1 = $7_1 + HEAP32[$6_1 + 1284 >> 2] | 0;
      $30_1 = $6_1 + 7176 | 0;
      $27_1 = $30_1 + 8 | 0;
      $16_1 = $27_1;
      $5_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = ($7_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $9_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
      $3_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $32_1 + 8 | 0;
      $11_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $7_1 + $11_1 | 0;
      $3_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $11_1 = $5_1;
      $7_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $15_1 = HEAP32[$6_1 + 1072 >> 2];
      $1_1 = HEAP32[$6_1 + 1248 >> 2];
      $13_1 = $15_1 + $1_1 | 0;
      $21_1 = HEAP32[$6_1 + 1076 >> 2];
      $3_1 = $21_1 + HEAP32[$6_1 + 1252 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $7_1 = $7_1 + $13_1 | 0;
      $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$16_1 >> 2] = $7_1;
      $5_1 = $3_1;
      HEAP32[$16_1 + 4 >> 2] = $3_1 & 1048575;
      $25_1 = $30_1 + 16 | 0;
      $17_1 = $25_1;
      $16_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $13_1 = ($1_1 | 0) == ($21_1 | 0) & $13_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $21_1 >>> 0;
      $3_1 = $29_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $1_1 = $23_1 + 8 | 0;
      $15_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $13_1 + $15_1 | 0;
      $3_1 = $7_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $7_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $24_1 = HEAP32[$6_1 + 1232 >> 2];
      $1_1 = HEAP32[$6_1 + 1296 >> 2];
      $16_1 = $24_1 + $1_1 | 0;
      $23_1 = HEAP32[$6_1 + 1236 >> 2];
      $3_1 = $23_1 + HEAP32[$6_1 + 1300 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 1040 >> 2];
      $13_1 = $1_1 + $16_1 | 0;
      $15_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 1044 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $7_1 = $7_1 + $13_1 | 0;
      $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$17_1 >> 2] = $7_1;
      $5_1 = $3_1;
      HEAP32[$17_1 + 4 >> 2] = $3_1 & 1048575;
      $28_1 = $30_1 + 24 | 0;
      $26_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $21_1 = ($1_1 | 0) == ($15_1 | 0) & $13_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
      $1_1 = $18_1 + 8 | 0;
      $17_1 = HEAP32[$1_1 >> 2];
      $18_1 = HEAP32[$1_1 + 4 >> 2];
      $13_1 = ($15_1 | 0) == ($23_1 | 0) & $16_1 >>> 0 < $24_1 >>> 0 | $15_1 >>> 0 < $23_1 >>> 0;
      $3_1 = $22_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $1_1 = $19_1 + 8 | 0;
      $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $13_1 + $16_1 | 0;
      $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
      $7_1 = $1_1;
      $1_1 = $1_1 + $17_1 | 0;
      $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 + $21_1 | 0;
      $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $7_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $26_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $7_1 = $3_1 << 12 | $1_1 >>> 20;
      $16_1 = HEAP32[$6_1 + 1024 >> 2];
      $5_1 = $14_1 & -2;
      $1_1 = $16_1 + $5_1 | 0;
      $18_1 = HEAP32[$6_1 + 1028 >> 2];
      $3_1 = $18_1 + ($12_1 & 1048575) | 0;
      $14_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $14_1 + $7_1 | 0;
      $12_1 = $1_1;
      $5_1 = $1_1 + $13_1 | 0;
      $3_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$28_1 >> 2] = $5_1;
      $1_1 = $3_1;
      HEAP32[$28_1 + 4 >> 2] = $3_1 & 1048575;
      $15_1 = $30_1 + 32 | 0;
      $7_1 = $8_1;
      $13_1 = $10_1 & 65535;
      $10_1 = ($3_1 | 0) == ($14_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 < $14_1 >>> 0;
      $5_1 = ($14_1 | 0) == ($18_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $14_1 >>> 0 < $18_1 >>> 0;
      $3_1 = $20_1 + 8 | 0;
      $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $4_1 << 12 | $1_1 >>> 20;
      $5_1 = $1_1 + $7_1 | 0;
      $3_1 = $13_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
      HEAP32[$15_1 >> 2] = $5_1;
      HEAP32[$15_1 + 4 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 7176 >> 2] = $9_1;
      HEAP32[$6_1 + 7180 >> 2] = $11_1 & 1048575;
      $34($30_1, $30_1, $6_1 + 7536 | 0);
      $9_1 = HEAP32[$15_1 + 4 >> 2];
      $3_1 = $6_1 + 7136 | 0;
      $1_1 = $3_1 + 32 | 0;
      $4_1 = HEAP32[$15_1 >> 2];
      HEAP32[$1_1 >> 2] = $4_1;
      HEAP32[$1_1 + 4 >> 2] = $9_1;
      $10_1 = HEAP32[$28_1 + 4 >> 2];
      $1_1 = $3_1 + 24 | 0;
      $11_1 = HEAP32[$28_1 >> 2];
      HEAP32[$1_1 >> 2] = $11_1;
      HEAP32[$1_1 + 4 >> 2] = $10_1;
      $13_1 = HEAP32[$25_1 + 4 >> 2];
      $1_1 = $3_1 + 16 | 0;
      $7_1 = HEAP32[$25_1 >> 2];
      HEAP32[$1_1 >> 2] = $7_1;
      HEAP32[$1_1 + 4 >> 2] = $13_1;
      $14_1 = HEAP32[$27_1 + 4 >> 2];
      $1_1 = $3_1 + 8 | 0;
      $8_1 = HEAP32[$27_1 >> 2];
      HEAP32[$1_1 >> 2] = $8_1;
      HEAP32[$1_1 + 4 >> 2] = $14_1;
      $12_1 = HEAP32[$6_1 + 7180 >> 2];
      $5_1 = HEAP32[$6_1 + 7176 >> 2];
      HEAP32[$6_1 + 7136 >> 2] = $5_1;
      HEAP32[$6_1 + 7140 >> 2] = $12_1;
      $1_1 = 23;
      while (1) {
        $15_1 = $5_1;
        $3_1 = $12_1 << 1 | $5_1 >>> 31;
        $25_1 = $6_1 + 976 | 0;
        $20_1 = $5_1 << 1;
        $28_1 = $3_1;
        $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
        $19_1 = $6_1 + 896 | 0;
        $5_1 = $8_1 << 1;
        $16_1 = $14_1;
        $24_1 = $8_1;
        $8_1 = $14_1 << 1 | $8_1 >>> 31;
        $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
        $17_1 = $6_1 + 832 | 0;
        $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
        $18_1 = $6_1 + 816 | 0;
        $69($18_1, HEAP32[$6_1 + 832 >> 2], HEAP32[$6_1 + 836 >> 2], 0, 0, 15632, 16, 0, 0);
        $3_1 = $9_1 << 1 | $4_1 >>> 31;
        $33_1 = $6_1 + 784 | 0;
        $22_1 = $4_1 << 1;
        $26_1 = $3_1;
        $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
        $34_1 = $6_1 + 944 | 0;
        $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
        $39_1 = $6_1 + 880 | 0;
        $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
        $23_1 = $6_1 + 800 | 0;
        $3_1 = $17_1 + 8 | 0;
        $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
        $38_1 = $6_1 + 992 | 0;
        $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
        $35_1 = $6_1 + 768 | 0;
        $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
        $36_1 = $6_1 + 848 | 0;
        $12_1 = $11_1;
        $21_1 = $7_1;
        $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
        $15_1 = HEAP32[$6_1 + 980 >> 2];
        $3_1 = $15_1 + HEAP32[$6_1 + 900 >> 2] | 0;
        $7_1 = HEAP32[$6_1 + 976 >> 2];
        $5_1 = HEAP32[$6_1 + 896 >> 2];
        $4_1 = $7_1 + $5_1 | 0;
        $8_1 = HEAP32[$6_1 + 816 >> 2];
        $17_1 = $4_1 + $8_1 | 0;
        $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $5_1 + HEAP32[$6_1 + 820 >> 2] | 0;
        $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
        $3_1 = $18_1 + 8 | 0;
        $9_1 = HEAP32[$3_1 >> 2];
        $11_1 = HEAP32[$3_1 + 4 >> 2];
        $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
        $5_1 = $19_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $25_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $7_1 + $15_1 | 0;
        $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
        $5_1 = $4_1;
        $4_1 = $4_1 + $9_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $14_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = $8_1;
        $11_1 = $4_1 << 12 | $8_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 944 >> 2];
        $4_1 = HEAP32[$6_1 + 880 >> 2];
        $15_1 = $31_1 + $4_1 | 0;
        $40_1 = HEAP32[$6_1 + 948 >> 2];
        $3_1 = $40_1 + HEAP32[$6_1 + 884 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 784 >> 2];
        $9_1 = $4_1 + $15_1 | 0;
        $19_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 788 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 800 >> 2];
        $8_1 = $4_1 + $9_1 | 0;
        $18_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 804 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $7_1 | 0;
        $37_1 = $6_1 + 752 | 0;
        $11_1 = $8_1 + $11_1 | 0;
        $7_1 = $11_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
        $3_1 = $23_1 + 8 | 0;
        $29_1 = HEAP32[$3_1 >> 2];
        $27_1 = HEAP32[$3_1 + 4 >> 2];
        $25_1 = ($18_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
        $3_1 = $33_1 + 8 | 0;
        $23_1 = HEAP32[$3_1 >> 2];
        $18_1 = HEAP32[$3_1 + 4 >> 2];
        $9_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
        $8_1 = $39_1 + 8 | 0;
        $4_1 = HEAP32[$8_1 >> 2];
        $3_1 = $34_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $9_1 + $15_1 | 0;
        $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + $23_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1;
        $4_1 = $4_1 + $25_1 | 0;
        $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + $29_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1 + $32_1 | 0;
        $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $30_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $7_1;
        $9_1 = $4_1 << 12 | $5_1 >>> 20;
        $8_1 = $3_1;
        $18_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 772 >> 2];
        $3_1 = $31_1 + HEAP32[$6_1 + 852 >> 2] | 0;
        $25_1 = HEAP32[$6_1 + 768 >> 2];
        $4_1 = HEAP32[$6_1 + 848 >> 2];
        $7_1 = $25_1 + $4_1 | 0;
        $15_1 = $7_1;
        $9_1 = $7_1 + $9_1 | 0;
        $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $18_1 | 0;
        $23_1 = $9_1 << 4 & -16;
        $7_1 = $9_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $19_1 = ($7_1 << 4 | $9_1 >>> 28) & 16777215;
        $18_1 = $5_1;
        $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
        $30_1 = $6_1 + 928 | 0;
        $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
        $32_1 = $6_1 + 736 | 0;
        $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
        $29_1 = $6_1 + 960 | 0;
        $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
        $27_1 = $6_1 + 720 | 0;
        $23_1 = $27_1;
        $19_1 = ($4_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $9_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
        $5_1 = $36_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $35_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $9_1 + $15_1 | 0;
        $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $8_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $19_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $4_1 << 12 | $7_1 >>> 20;
        $5_1 = $3_1;
        $8_1 = $3_1 << 12 | $4_1 >>> 20;
        $15_1 = HEAP32[$6_1 + 736 >> 2];
        $4_1 = HEAP32[$6_1 + 960 >> 2];
        $9_1 = $15_1 + $4_1 | 0;
        $19_1 = HEAP32[$6_1 + 740 >> 2];
        $3_1 = $19_1 + HEAP32[$6_1 + 964 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $8_1 | 0;
        $7_1 = $7_1 + $9_1 | 0;
        $3_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $3_1;
        $69($23_1, $7_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
        $25_1 = $6_1 + 864 | 0;
        $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
        $23_1 = $6_1 + 912 | 0;
        $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
        $13_1 = $6_1 + 704 | 0;
        $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
        $26_1 = $6_1 + 688 | 0;
        $12_1 = $26_1;
        $10_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
        $9_1 = ($4_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $19_1 >>> 0;
        $7_1 = $29_1 + 8 | 0;
        $4_1 = HEAP32[$7_1 >> 2];
        $3_1 = $32_1 + 8 | 0;
        $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $9_1 + $16_1 | 0;
        $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $7_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $4_1 << 12 | $8_1 >>> 20;
        $8_1 = HEAP32[$6_1 + 704 >> 2];
        $10_1 = $7_1 + $8_1 | 0;
        $5_1 = $3_1;
        $4_1 = $3_1 << 12 | $4_1 >>> 20;
        $3_1 = $4_1 + HEAP32[$6_1 + 708 >> 2] | 0;
        $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
        $19_1 = $6_1 + 672 | 0;
        $9_1 = $19_1;
        $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
        $3_1 = $13_1 + 8 | 0;
        $8_1 = HEAP32[$3_1 >> 2];
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $7_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($9_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
        $5_1 = HEAP32[$6_1 + 752 >> 2];
        $4_1 = HEAP32[$6_1 + 992 >> 2];
        $12_1 = $5_1 + $4_1 | 0;
        $7_1 = HEAP32[$6_1 + 756 >> 2];
        $3_1 = $7_1 + HEAP32[$6_1 + 996 >> 2] | 0;
        $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
        $5_1 = $38_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $37_1 + 8 | 0;
        $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $7_1 + $9_1 | 0;
        $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $15_1 = $8_1;
        $9_1 = $4_1 << 12 | $8_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $10_1 = HEAP32[$6_1 + 720 >> 2];
        $4_1 = HEAP32[$6_1 + 928 >> 2];
        $8_1 = $10_1 + $4_1 | 0;
        $16_1 = HEAP32[$6_1 + 724 >> 2];
        $3_1 = $16_1 + HEAP32[$6_1 + 932 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $9_1;
        $9_1 = $8_1;
        $8_1 = $4_1 + $8_1 | 0;
        $4_1 = $3_1;
        $3_1 = $3_1 + $7_1 | 0;
        $7_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $10_1 = ($4_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
        $9_1 = $30_1 + 8 | 0;
        $4_1 = HEAP32[$9_1 >> 2];
        $3_1 = $27_1 + 8 | 0;
        $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $9_1 = $10_1 + $16_1 | 0;
        $3_1 = $9_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $9_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $13_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $16_1 = $7_1;
        $9_1 = $4_1 << 12 | $7_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $22_1 = HEAP32[$6_1 + 864 >> 2];
        $4_1 = HEAP32[$6_1 + 912 >> 2];
        $13_1 = $22_1 + $4_1 | 0;
        $27_1 = HEAP32[$6_1 + 868 >> 2];
        $3_1 = $27_1 + HEAP32[$6_1 + 916 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 688 >> 2];
        $10_1 = $4_1 + $13_1 | 0;
        $21_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 692 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $7_1 | 0;
        $7_1 = $9_1 + $10_1 | 0;
        $9_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $28_1 = ($4_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
        $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
        $3_1 = $26_1 + 8 | 0;
        $24_1 = HEAP32[$3_1 >> 2];
        $26_1 = HEAP32[$3_1 + 4 >> 2];
        $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
        $10_1 = $23_1 + 8 | 0;
        $4_1 = HEAP32[$10_1 >> 2];
        $3_1 = $25_1 + 8 | 0;
        $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $13_1 + $21_1 | 0;
        $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
        $13_1 = $4_1;
        $4_1 = $4_1 + $24_1 | 0;
        $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $4_1 + $20_1 | 0;
        $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $28_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = $9_1;
        $10_1 = $4_1 << 12 | $9_1 >>> 20;
        $5_1 = $3_1;
        $9_1 = $3_1 << 12 | $4_1 >>> 20;
        $24_1 = HEAP32[$6_1 + 672 >> 2];
        $17_1 = $24_1 + ($17_1 & -2) | 0;
        $26_1 = HEAP32[$6_1 + 676 >> 2];
        $3_1 = $26_1 + ($14_1 & 1048575) | 0;
        $4_1 = $17_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $9_1 | 0;
        $14_1 = $11_1;
        $21_1 = $18_1 & 65535;
        $10_1 = $10_1 + $17_1 | 0;
        $9_1 = $10_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $11_1 = $10_1;
        $18_1 = ($4_1 | 0) == ($9_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
        $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
        $3_1 = $19_1 + 8 | 0;
        $10_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $18_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $9_1;
        $10_1 = $4_1 << 12 | $5_1 >>> 20;
        $9_1 = $10_1 + $14_1 | 0;
        $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
        $4_1 = $9_1;
        $9_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $5_1 & 1048575;
        $13_1 = $13_1 & 1048575;
        $14_1 = $16_1 & 1048575;
        $5_1 = $12_1;
        $12_1 = $15_1 & 1048575;
        $1_1 = $1_1 - 1 | 0;
        if ($1_1) {
          continue;
        }
        break;
      }
      ;
      HEAP32[$6_1 + 7168 >> 2] = $4_1;
      HEAP32[$6_1 + 7172 >> 2] = $9_1;
      HEAP32[$6_1 + 7160 >> 2] = $11_1;
      HEAP32[$6_1 + 7164 >> 2] = $10_1;
      HEAP32[$6_1 + 7152 >> 2] = $7_1;
      HEAP32[$6_1 + 7156 >> 2] = $13_1;
      HEAP32[$6_1 + 7144 >> 2] = $8_1;
      HEAP32[$6_1 + 7148 >> 2] = $14_1;
      HEAP32[$6_1 + 7136 >> 2] = $5_1;
      HEAP32[$6_1 + 7140 >> 2] = $12_1;
      $1_1 = $6_1 + 7136 | 0;
      $34($1_1, $1_1, $6_1 + 7376 | 0);
      $1_1 = 6;
      $4_1 = HEAP32[$6_1 + 7168 >> 2];
      $9_1 = HEAP32[$6_1 + 7172 >> 2];
      $11_1 = HEAP32[$6_1 + 7160 >> 2];
      $10_1 = HEAP32[$6_1 + 7164 >> 2];
      $7_1 = HEAP32[$6_1 + 7152 >> 2];
      $13_1 = HEAP32[$6_1 + 7156 >> 2];
      $8_1 = HEAP32[$6_1 + 7144 >> 2];
      $14_1 = HEAP32[$6_1 + 7148 >> 2];
      $5_1 = HEAP32[$6_1 + 7136 >> 2];
      $12_1 = HEAP32[$6_1 + 7140 >> 2];
      while (1) {
        $15_1 = $5_1;
        $3_1 = $12_1 << 1 | $5_1 >>> 31;
        $25_1 = $6_1 + 640 | 0;
        $20_1 = $5_1 << 1;
        $28_1 = $3_1;
        $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
        $19_1 = $6_1 + 560 | 0;
        $5_1 = $8_1 << 1;
        $16_1 = $14_1;
        $24_1 = $8_1;
        $8_1 = $14_1 << 1 | $8_1 >>> 31;
        $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
        $17_1 = $6_1 + 496 | 0;
        $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
        $18_1 = $6_1 + 480 | 0;
        $69($18_1, HEAP32[$6_1 + 496 >> 2], HEAP32[$6_1 + 500 >> 2], 0, 0, 15632, 16, 0, 0);
        $3_1 = $9_1 << 1 | $4_1 >>> 31;
        $33_1 = $6_1 + 448 | 0;
        $22_1 = $4_1 << 1;
        $26_1 = $3_1;
        $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
        $34_1 = $6_1 + 608 | 0;
        $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
        $39_1 = $6_1 + 544 | 0;
        $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
        $23_1 = $6_1 + 464 | 0;
        $3_1 = $17_1 + 8 | 0;
        $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
        $38_1 = $6_1 + 656 | 0;
        $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
        $35_1 = $6_1 + 432 | 0;
        $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
        $36_1 = $6_1 + 512 | 0;
        $12_1 = $11_1;
        $21_1 = $7_1;
        $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
        $15_1 = HEAP32[$6_1 + 644 >> 2];
        $3_1 = $15_1 + HEAP32[$6_1 + 564 >> 2] | 0;
        $7_1 = HEAP32[$6_1 + 640 >> 2];
        $5_1 = HEAP32[$6_1 + 560 >> 2];
        $4_1 = $7_1 + $5_1 | 0;
        $8_1 = HEAP32[$6_1 + 480 >> 2];
        $17_1 = $4_1 + $8_1 | 0;
        $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $5_1 + HEAP32[$6_1 + 484 >> 2] | 0;
        $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
        $3_1 = $18_1 + 8 | 0;
        $9_1 = HEAP32[$3_1 >> 2];
        $11_1 = HEAP32[$3_1 + 4 >> 2];
        $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
        $5_1 = $19_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $25_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $7_1 + $15_1 | 0;
        $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
        $5_1 = $4_1;
        $4_1 = $4_1 + $9_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $14_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = $8_1;
        $11_1 = $4_1 << 12 | $8_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 608 >> 2];
        $4_1 = HEAP32[$6_1 + 544 >> 2];
        $15_1 = $31_1 + $4_1 | 0;
        $40_1 = HEAP32[$6_1 + 612 >> 2];
        $3_1 = $40_1 + HEAP32[$6_1 + 548 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 448 >> 2];
        $9_1 = $4_1 + $15_1 | 0;
        $19_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 452 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 464 >> 2];
        $8_1 = $4_1 + $9_1 | 0;
        $18_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 468 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $7_1 | 0;
        $37_1 = $6_1 + 416 | 0;
        $11_1 = $8_1 + $11_1 | 0;
        $7_1 = $11_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
        $3_1 = $23_1 + 8 | 0;
        $29_1 = HEAP32[$3_1 >> 2];
        $27_1 = HEAP32[$3_1 + 4 >> 2];
        $25_1 = ($18_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
        $3_1 = $33_1 + 8 | 0;
        $23_1 = HEAP32[$3_1 >> 2];
        $18_1 = HEAP32[$3_1 + 4 >> 2];
        $9_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
        $8_1 = $39_1 + 8 | 0;
        $4_1 = HEAP32[$8_1 >> 2];
        $3_1 = $34_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $9_1 + $15_1 | 0;
        $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + $23_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1;
        $4_1 = $4_1 + $25_1 | 0;
        $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + $29_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1 + $32_1 | 0;
        $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $30_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $7_1;
        $9_1 = $4_1 << 12 | $5_1 >>> 20;
        $8_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $25_1 = HEAP32[$6_1 + 432 >> 2];
        $4_1 = HEAP32[$6_1 + 512 >> 2];
        $15_1 = $25_1 + $4_1 | 0;
        $31_1 = HEAP32[$6_1 + 436 >> 2];
        $3_1 = $31_1 + HEAP32[$6_1 + 516 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $7_1 | 0;
        $9_1 = $9_1 + $15_1 | 0;
        $3_1 = $9_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $23_1 = $9_1 << 4 & -16;
        $7_1 = $3_1;
        $19_1 = ($3_1 << 4 | $9_1 >>> 28) & 16777215;
        $18_1 = $5_1;
        $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
        $30_1 = $6_1 + 592 | 0;
        $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
        $32_1 = $6_1 + 400 | 0;
        $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
        $29_1 = $6_1 + 624 | 0;
        $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
        $27_1 = $6_1 + 384 | 0;
        $23_1 = $27_1;
        $19_1 = ($4_1 | 0) == ($3_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $3_1 >>> 0;
        $9_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
        $5_1 = $36_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $35_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $9_1 + $15_1 | 0;
        $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $8_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $19_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $4_1 << 12 | $7_1 >>> 20;
        $5_1 = $3_1;
        $19_1 = $3_1 << 12 | $4_1 >>> 20;
        $31_1 = HEAP32[$6_1 + 404 >> 2];
        $3_1 = $31_1 + HEAP32[$6_1 + 628 >> 2] | 0;
        $15_1 = HEAP32[$6_1 + 400 >> 2];
        $4_1 = HEAP32[$6_1 + 624 >> 2];
        $8_1 = $15_1 + $4_1 | 0;
        $9_1 = $8_1;
        $7_1 = $8_1 + $7_1 | 0;
        $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $19_1 | 0;
        $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
        $25_1 = $6_1 + 528 | 0;
        $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
        $23_1 = $6_1 + 576 | 0;
        $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
        $13_1 = $6_1 + 368 | 0;
        $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
        $26_1 = $6_1 + 352 | 0;
        $12_1 = $26_1;
        $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
        $9_1 = ($4_1 | 0) == ($31_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
        $7_1 = $29_1 + 8 | 0;
        $4_1 = HEAP32[$7_1 >> 2];
        $3_1 = $32_1 + 8 | 0;
        $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $9_1 + $16_1 | 0;
        $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $7_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $4_1 << 12 | $8_1 >>> 20;
        $8_1 = HEAP32[$6_1 + 368 >> 2];
        $10_1 = $7_1 + $8_1 | 0;
        $5_1 = $3_1;
        $4_1 = $3_1 << 12 | $4_1 >>> 20;
        $3_1 = $4_1 + HEAP32[$6_1 + 372 >> 2] | 0;
        $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
        $19_1 = $6_1 + 336 | 0;
        $9_1 = $19_1;
        $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
        $3_1 = $13_1 + 8 | 0;
        $8_1 = HEAP32[$3_1 >> 2];
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $7_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($9_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
        $5_1 = HEAP32[$6_1 + 416 >> 2];
        $4_1 = HEAP32[$6_1 + 656 >> 2];
        $12_1 = $5_1 + $4_1 | 0;
        $7_1 = HEAP32[$6_1 + 420 >> 2];
        $3_1 = $7_1 + HEAP32[$6_1 + 660 >> 2] | 0;
        $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
        $5_1 = $38_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $37_1 + 8 | 0;
        $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $7_1 + $9_1 | 0;
        $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $15_1 = $8_1;
        $9_1 = $4_1 << 12 | $8_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $10_1 = HEAP32[$6_1 + 384 >> 2];
        $4_1 = HEAP32[$6_1 + 592 >> 2];
        $8_1 = $10_1 + $4_1 | 0;
        $16_1 = HEAP32[$6_1 + 388 >> 2];
        $3_1 = $16_1 + HEAP32[$6_1 + 596 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $9_1;
        $9_1 = $8_1;
        $8_1 = $4_1 + $8_1 | 0;
        $4_1 = $3_1;
        $3_1 = $3_1 + $7_1 | 0;
        $7_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $10_1 = ($4_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
        $9_1 = $30_1 + 8 | 0;
        $4_1 = HEAP32[$9_1 >> 2];
        $3_1 = $27_1 + 8 | 0;
        $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $9_1 = $10_1 + $16_1 | 0;
        $3_1 = $9_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $9_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $13_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $16_1 = $7_1;
        $9_1 = $4_1 << 12 | $7_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $22_1 = HEAP32[$6_1 + 528 >> 2];
        $4_1 = HEAP32[$6_1 + 576 >> 2];
        $13_1 = $22_1 + $4_1 | 0;
        $27_1 = HEAP32[$6_1 + 532 >> 2];
        $3_1 = $27_1 + HEAP32[$6_1 + 580 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 352 >> 2];
        $10_1 = $4_1 + $13_1 | 0;
        $21_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 356 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $7_1 | 0;
        $7_1 = $9_1 + $10_1 | 0;
        $9_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $28_1 = ($4_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
        $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
        $3_1 = $26_1 + 8 | 0;
        $24_1 = HEAP32[$3_1 >> 2];
        $26_1 = HEAP32[$3_1 + 4 >> 2];
        $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
        $10_1 = $23_1 + 8 | 0;
        $4_1 = HEAP32[$10_1 >> 2];
        $3_1 = $25_1 + 8 | 0;
        $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $13_1 + $21_1 | 0;
        $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
        $13_1 = $4_1;
        $4_1 = $4_1 + $24_1 | 0;
        $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $4_1 + $20_1 | 0;
        $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $28_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = $9_1;
        $10_1 = $4_1 << 12 | $9_1 >>> 20;
        $5_1 = $3_1;
        $9_1 = $3_1 << 12 | $4_1 >>> 20;
        $24_1 = HEAP32[$6_1 + 336 >> 2];
        $17_1 = $24_1 + ($17_1 & -2) | 0;
        $26_1 = HEAP32[$6_1 + 340 >> 2];
        $3_1 = $26_1 + ($14_1 & 1048575) | 0;
        $4_1 = $17_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $9_1 | 0;
        $14_1 = $11_1;
        $21_1 = $18_1 & 65535;
        $10_1 = $10_1 + $17_1 | 0;
        $9_1 = $10_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $11_1 = $10_1;
        $18_1 = ($4_1 | 0) == ($9_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
        $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
        $3_1 = $19_1 + 8 | 0;
        $10_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $18_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $9_1;
        $10_1 = $4_1 << 12 | $5_1 >>> 20;
        $9_1 = $10_1 + $14_1 | 0;
        $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
        $4_1 = $9_1;
        $9_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $5_1 & 1048575;
        $13_1 = $13_1 & 1048575;
        $14_1 = $16_1 & 1048575;
        $5_1 = $12_1;
        $12_1 = $15_1 & 1048575;
        $1_1 = $1_1 - 1 | 0;
        if ($1_1) {
          continue;
        }
        break;
      }
      ;
      HEAP32[$6_1 + 7168 >> 2] = $4_1;
      HEAP32[$6_1 + 7172 >> 2] = $9_1;
      HEAP32[$6_1 + 7160 >> 2] = $11_1;
      HEAP32[$6_1 + 7164 >> 2] = $10_1;
      HEAP32[$6_1 + 7152 >> 2] = $7_1;
      HEAP32[$6_1 + 7156 >> 2] = $13_1;
      HEAP32[$6_1 + 7144 >> 2] = $8_1;
      HEAP32[$6_1 + 7148 >> 2] = $14_1;
      HEAP32[$6_1 + 7136 >> 2] = $5_1;
      HEAP32[$6_1 + 7140 >> 2] = $12_1;
      $39_1 = $6_1 + 7136 | 0;
      $34($39_1, $39_1, $6_1 + 7576 | 0);
      $1_1 = HEAP32[$6_1 + 7140 >> 2];
      $16_1 = $1_1;
      $14_1 = HEAP32[$6_1 + 7136 >> 2];
      $7_1 = $14_1;
      $3_1 = $1_1 << 1 | $7_1 >>> 31;
      $12_1 = $6_1 - -64 | 0;
      $21_1 = HEAP32[$6_1 + 7160 >> 2];
      $17_1 = HEAP32[$6_1 + 7164 >> 2];
      $28_1 = $7_1 << 1;
      $22_1 = $3_1;
      $69($12_1, $21_1, $17_1, 0, 0, $28_1, $3_1, 0, 0);
      $1_1 = HEAP32[$6_1 + 7148 >> 2];
      $33_1 = $1_1;
      $34_1 = HEAP32[$6_1 + 7144 >> 2];
      $4_1 = $34_1;
      $3_1 = $1_1 << 1 | $4_1 >>> 31;
      $10_1 = $6_1 + 272 | 0;
      $24_1 = HEAP32[$6_1 + 7152 >> 2];
      $18_1 = HEAP32[$6_1 + 7156 >> 2];
      $4_1 = $4_1 << 1;
      $5_1 = $3_1;
      $69($10_1, $24_1, $18_1, 0, 0, $4_1, $3_1, 0, 0);
      $9_1 = $6_1 + 224 | 0;
      $8_1 = HEAP32[$6_1 + 7168 >> 2];
      $1_1 = HEAP32[$6_1 + 7172 >> 2];
      $69($9_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
      $11_1 = $6_1 + 208 | 0;
      $69($11_1, HEAP32[$6_1 + 224 >> 2], HEAP32[$6_1 + 228 >> 2], 0, 0, 15632, 16, 0, 0);
      $3_1 = $1_1 << 1 | $8_1 >>> 31;
      $37_1 = $6_1 + 176 | 0;
      $23_1 = $8_1 << 1;
      $20_1 = $3_1;
      $69($37_1, $23_1, $3_1, 0, 0, $7_1, $16_1, 0, 0);
      $30_1 = $6_1 + 80 | 0;
      $69($30_1, $21_1, $17_1, 0, 0, $4_1, $5_1, 0, 0);
      $32_1 = $6_1 + 256 | 0;
      $69($32_1, $24_1, $18_1, 0, 0, $24_1, $18_1, 0, 0);
      $13_1 = $6_1 + 192 | 0;
      $1_1 = $9_1 + 8 | 0;
      $69($13_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $38_1 = $6_1 + 320 | 0;
      $69($38_1, $7_1, $16_1, 0, 0, $7_1, $16_1, 0, 0);
      $35_1 = $6_1 + 160 | 0;
      $69($35_1, $23_1, $3_1, 0, 0, $34_1, $33_1, 0, 0);
      $36_1 = $6_1 + 96 | 0;
      $69($36_1, $21_1, $17_1, 0, 0, $24_1 << 1, $18_1 << 1 | $24_1 >>> 31, 0, 0);
      $14_1 = HEAP32[$6_1 + 68 >> 2];
      $3_1 = $14_1 + HEAP32[$6_1 + 276 >> 2] | 0;
      $8_1 = HEAP32[$6_1 + 64 >> 2];
      $4_1 = HEAP32[$6_1 + 272 >> 2];
      $1_1 = $8_1 + $4_1 | 0;
      $5_1 = HEAP32[$6_1 + 208 >> 2];
      $15_1 = $1_1 + $5_1 | 0;
      $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + HEAP32[$6_1 + 212 >> 2] | 0;
      $5_1 = $5_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $15_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
      $3_1 = $11_1 + 8 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $7_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = ($4_1 | 0) == ($14_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $14_1 >>> 0;
      $3_1 = $10_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $12_1 + 8 | 0;
      $10_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $8_1 + $10_1 | 0;
      $3_1 = ($1_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $11_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $16_1 = $5_1;
      $7_1 = $1_1 << 12 | $5_1 >>> 20;
      $4_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $29_1 = HEAP32[$6_1 + 80 >> 2];
      $1_1 = HEAP32[$6_1 + 256 >> 2];
      $10_1 = $29_1 + $1_1 | 0;
      $31_1 = HEAP32[$6_1 + 84 >> 2];
      $3_1 = $31_1 + HEAP32[$6_1 + 260 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 176 >> 2];
      $9_1 = $1_1 + $10_1 | 0;
      $14_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 180 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 192 >> 2];
      $5_1 = $1_1 + $9_1 | 0;
      $12_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 196 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $8_1 = $6_1;
      $11_1 = $5_1 + $7_1 | 0;
      $7_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $27_1 = ($1_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
      $25_1 = ($1_1 | 0) == ($12_1 | 0) & $5_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 < $12_1 >>> 0;
      $1_1 = $13_1 + 8 | 0;
      $19_1 = HEAP32[$1_1 >> 2];
      $26_1 = HEAP32[$1_1 + 4 >> 2];
      $6_1 = ($12_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $12_1 >>> 0 < $14_1 >>> 0;
      $1_1 = $37_1 + 8 | 0;
      $13_1 = HEAP32[$1_1 >> 2];
      $12_1 = HEAP32[$1_1 + 4 >> 2];
      $9_1 = ($14_1 | 0) == ($31_1 | 0) & $10_1 >>> 0 < $29_1 >>> 0 | $14_1 >>> 0 < $31_1 >>> 0;
      $3_1 = $32_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $30_1 + 8 | 0;
      $10_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $9_1 + $10_1 | 0;
      $3_1 = ($1_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $12_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $13_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $6_1 | 0;
      $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $19_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1 + $25_1 | 0;
      $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $5_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $27_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1;
      $10_1 = $1_1 << 12 | $4_1 >>> 20;
      $5_1 = $3_1;
      $9_1 = $3_1 << 12 | $1_1 >>> 20;
      $13_1 = HEAP32[$8_1 + 160 >> 2];
      $1_1 = HEAP32[$8_1 + 96 >> 2];
      $7_1 = $13_1 + $1_1 | 0;
      $19_1 = HEAP32[$8_1 + 164 >> 2];
      $3_1 = $19_1 + HEAP32[$8_1 + 100 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $9_1 | 0;
      $12_1 = $7_1;
      $7_1 = $7_1 + $10_1 | 0;
      $14_1 = $7_1 << 4 & -16;
      $9_1 = $7_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = ($9_1 << 4 | $7_1 >>> 28) & 16777215;
      $6_1 = $4_1;
      $69($8_1, $14_1 | $4_1 >>> 16 & 15, $10_1, 0, 0, 977, 1, 0, 0);
      $27_1 = HEAP32[$8_1 + 4 >> 2];
      $3_1 = $27_1 + HEAP32[$8_1 + 324 >> 2] | 0;
      $25_1 = HEAP32[$8_1 >> 2];
      $4_1 = HEAP32[$8_1 + 320 >> 2];
      $10_1 = $25_1 + $4_1 | 0;
      HEAP32[$8_1 + 7136 >> 2] = $10_1;
      $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$8_1 + 7140 >> 2] = $4_1 & 1048575;
      $31_1 = $8_1 + 304 | 0;
      $69($31_1, $34_1, $33_1, 0, 0, $28_1, $22_1, 0, 0);
      $37_1 = $8_1 + 144 | 0;
      $69($37_1, $23_1, $20_1, 0, 0, $24_1, $18_1, 0, 0);
      $30_1 = $8_1 + 112 | 0;
      $69($30_1, $21_1, $17_1, 0, 0, $21_1, $17_1, 0, 0);
      $32_1 = $8_1 + 48 | 0;
      $26_1 = $32_1;
      $14_1 = ($1_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
      $12_1 = ($1_1 | 0) == ($19_1 | 0) & $12_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $19_1 >>> 0;
      $3_1 = $36_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $1_1 = $35_1 + 8 | 0;
      $13_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $12_1 + $13_1 | 0;
      $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $1_1 = $5_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $14_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $1_1 << 12 | $9_1 >>> 20;
      $7_1 = $3_1;
      $9_1 = $3_1 << 12 | $1_1 >>> 20;
      $35_1 = HEAP32[$8_1 + 148 >> 2];
      $3_1 = $35_1 + HEAP32[$8_1 + 116 >> 2] | 0;
      $29_1 = HEAP32[$8_1 + 144 >> 2];
      $5_1 = HEAP32[$8_1 + 112 >> 2];
      $1_1 = $29_1 + $5_1 | 0;
      $19_1 = $1_1;
      $13_1 = $1_1 + $12_1 | 0;
      $5_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $5_1 + $9_1 | 0;
      $12_1 = $13_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($26_1, $13_1, $12_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $9_1 = $8_1;
      $10_1 = ($4_1 | 0) == ($27_1 | 0) & $10_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $27_1 >>> 0;
      $3_1 = $38_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $1_1 = $9_1 + 8 | 0;
      $14_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $10_1 + $14_1 | 0;
      $3_1 = $1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $1_1 << 12 | $4_1 >>> 20;
      $8_1 = $3_1;
      $10_1 = $3_1 << 12 | $1_1 >>> 20;
      $27_1 = HEAP32[$9_1 + 48 >> 2];
      $1_1 = HEAP32[$9_1 + 304 >> 2];
      $26_1 = $27_1 + $1_1 | 0;
      $36_1 = HEAP32[$9_1 + 52 >> 2];
      $3_1 = $36_1 + HEAP32[$9_1 + 308 >> 2] | 0;
      $4_1 = $1_1 >>> 0 > $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $10_1 | 0;
      $14_1 = $14_1 + $26_1 | 0;
      $3_1 = $14_1 >>> 0 < $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$9_1 + 7144 >> 2] = $14_1;
      $10_1 = $3_1;
      HEAP32[$9_1 + 7148 >> 2] = $3_1 & 1048575;
      $25_1 = $9_1 + 240 | 0;
      $69($25_1, $24_1, $18_1, 0, 0, $28_1, $22_1, 0, 0);
      $22_1 = $9_1 + 288 | 0;
      $69($22_1, $34_1, $33_1, 0, 0, $34_1, $33_1, 0, 0);
      $28_1 = $9_1 + 128 | 0;
      $69($28_1, $23_1, $20_1, 0, 0, $21_1, $17_1, 0, 0);
      $24_1 = $9_1 + 32 | 0;
      $21_1 = $24_1;
      $18_1 = ($5_1 | 0) == ($12_1 | 0) & $13_1 >>> 0 < $19_1 >>> 0 | $5_1 >>> 0 > $12_1 >>> 0;
      $13_1 = ($5_1 | 0) == ($35_1 | 0) & $19_1 >>> 0 < $29_1 >>> 0 | $5_1 >>> 0 < $35_1 >>> 0;
      $3_1 = $30_1 + 8 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $1_1 = $37_1 + 8 | 0;
      $17_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $13_1 + $17_1 | 0;
      $3_1 = $5_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $7_1 >>> 20 | 0;
      $1_1 = $5_1 + $7_1 | 0;
      $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $18_1 | 0;
      $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $17_1 = $1_1 << 12 | $12_1 >>> 20;
      $7_1 = HEAP32[$9_1 + 128 >> 2];
      $12_1 = $17_1 + $7_1 | 0;
      $5_1 = $3_1;
      $19_1 = $3_1 << 12 | $1_1 >>> 20;
      $3_1 = $19_1 + HEAP32[$9_1 + 132 >> 2] | 0;
      $13_1 = $7_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($21_1, $12_1, $13_1, 0, 0, 15632, 16, 0, 0);
      $7_1 = $9_1;
      $14_1 = ($4_1 | 0) == ($10_1 | 0) & $14_1 >>> 0 < $26_1 >>> 0 | $4_1 >>> 0 > $10_1 >>> 0;
      $9_1 = ($4_1 | 0) == ($36_1 | 0) & $26_1 >>> 0 < $27_1 >>> 0 | $4_1 >>> 0 < $36_1 >>> 0;
      $3_1 = $31_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $32_1 + 8 | 0;
      $18_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $9_1 + $18_1 | 0;
      $3_1 = $4_1 >>> 0 < $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $8_1 >>> 20 | 0;
      $1_1 = $4_1 + $8_1 | 0;
      $3_1 = $8_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $14_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $1_1 << 12 | $10_1 >>> 20;
      $4_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $26_1 = HEAP32[$7_1 + 240 >> 2];
      $1_1 = HEAP32[$7_1 + 288 >> 2];
      $14_1 = $26_1 + $1_1 | 0;
      $20_1 = HEAP32[$7_1 + 244 >> 2];
      $3_1 = $20_1 + HEAP32[$7_1 + 292 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$7_1 + 32 >> 2];
      $10_1 = $1_1 + $14_1 | 0;
      $18_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$7_1 + 36 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $9_1 = $9_1 + $10_1 | 0;
      $3_1 = $9_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$7_1 + 7152 >> 2] = $9_1;
      $8_1 = $3_1;
      HEAP32[$7_1 + 7156 >> 2] = $3_1 & 1048575;
      $21_1 = $7_1 + 16 | 0;
      $17_1 = ($13_1 | 0) == ($19_1 | 0) & $12_1 >>> 0 < $17_1 >>> 0 | $13_1 >>> 0 < $19_1 >>> 0;
      $3_1 = $28_1 + 8 | 0;
      $13_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $5_1 = $5_1 >>> 20 | 0;
      $12_1 = $5_1;
      $5_1 = $5_1 + $13_1 | 0;
      $3_1 = $12_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $5_1;
      $5_1 = $5_1 + $17_1 | 0;
      $3_1 = $12_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($21_1, $5_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $5_1 = $7_1;
      $17_1 = ($1_1 | 0) == ($8_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
      $13_1 = ($1_1 | 0) == ($18_1 | 0) & $10_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $18_1 >>> 0;
      $1_1 = $24_1 + 8 | 0;
      $12_1 = HEAP32[$1_1 >> 2];
      $10_1 = HEAP32[$1_1 + 4 >> 2];
      $9_1 = ($18_1 | 0) == ($20_1 | 0) & $14_1 >>> 0 < $26_1 >>> 0 | $18_1 >>> 0 < $20_1 >>> 0;
      $3_1 = $22_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $1_1 = $25_1 + 8 | 0;
      $14_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $9_1 + $14_1 | 0;
      $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
      $7_1 = $1_1;
      $1_1 = $1_1 + $12_1 | 0;
      $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 + $13_1 | 0;
      $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $4_1 + $7_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $17_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $8_1 >>> 20;
      $4_1 = $3_1;
      $10_1 = $3_1 << 12 | $1_1 >>> 20;
      $14_1 = HEAP32[$5_1 + 16 >> 2];
      $8_1 = $15_1 & -2;
      $1_1 = $14_1 + $8_1 | 0;
      $13_1 = HEAP32[$5_1 + 20 >> 2];
      $3_1 = $13_1 + ($16_1 & 1048575) | 0;
      $9_1 = $1_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $9_1 + $10_1 | 0;
      $8_1 = $7_1;
      $7_1 = $1_1;
      $8_1 = $8_1 + $1_1 | 0;
      HEAP32[$5_1 + 7160 >> 2] = $8_1;
      $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$5_1 + 7164 >> 2] = $1_1 & 1048575;
      $16_1 = $5_1;
      $12_1 = $6_1 & 65535;
      $10_1 = ($1_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 < $9_1 >>> 0;
      $5_1 = ($9_1 | 0) == ($13_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $9_1 >>> 0 < $13_1 >>> 0;
      $3_1 = $21_1 + 8 | 0;
      $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $4_1 << 12 | $1_1 >>> 20;
      $5_1 = $1_1 + $11_1 | 0;
      $3_1 = $12_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
      HEAP32[$16_1 + 7168 >> 2] = $5_1;
      HEAP32[$16_1 + 7172 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $0_1 + 40 | 0;
      $54($1_1, $39_1);
      $54($39_1, $1_1);
      $3_1 = HEAP32[$16_1 + 7080 >> 2];
      $1_1 = HEAP32[$16_1 + 7160 >> 2];
      $18_1 = $3_1 - $1_1 | 0;
      $15_1 = HEAP32[$16_1 + 7084 >> 2] - (HEAP32[$16_1 + 7164 >> 2] + ($1_1 >>> 0 > $3_1 >>> 0) | 0) | 0;
      $3_1 = HEAP32[$16_1 + 7072 >> 2];
      $1_1 = HEAP32[$16_1 + 7152 >> 2];
      $6_1 = $3_1 - $1_1 | 0;
      $13_1 = HEAP32[$16_1 + 7076 >> 2] - (HEAP32[$16_1 + 7156 >> 2] + ($1_1 >>> 0 > $3_1 >>> 0) | 0) | 0;
      $3_1 = HEAP32[$16_1 + 7064 >> 2];
      $1_1 = HEAP32[$16_1 + 7144 >> 2];
      $9_1 = $3_1 - $1_1 | 0;
      $11_1 = HEAP32[$16_1 + 7068 >> 2] - (HEAP32[$16_1 + 7148 >> 2] + ($1_1 >>> 0 > $3_1 >>> 0) | 0) | 0;
      $3_1 = HEAP32[$16_1 + 7056 >> 2];
      $1_1 = HEAP32[$16_1 + 7136 >> 2];
      $7_1 = $3_1 - $1_1 | 0;
      $5_1 = HEAP32[$16_1 + 7060 >> 2] - (HEAP32[$16_1 + 7140 >> 2] + ($1_1 >>> 0 > $3_1 >>> 0) | 0) | 0;
      $4_1 = HEAP32[$16_1 + 7088 >> 2];
      $3_1 = HEAP32[$16_1 + 7168 >> 2];
      $1_1 = ($4_1 - $3_1 | 0) - 4 | 0;
      $3_1 = (HEAP32[$16_1 + 7092 >> 2] - (HEAP32[$16_1 + 7172 >> 2] + ($3_1 >>> 0 > $4_1 >>> 0) | 0) | 0) + 262143 | 0;
      $8_1 = $1_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = __wasm_i64_mul($8_1 >>> 16 | 0, 0, 977, 1);
      $7_1 = $4_1 + $7_1 | 0;
      $3_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
      $3_1 = ($4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + 4194299 | 0;
      $4_1 = $7_1 - 3908 | 0;
      $3_1 = $4_1 >>> 0 < 4294963388 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $4_1;
      $12_1 = $3_1;
      $3_1 = $11_1;
      $4_1 = $12_1 >>> 20 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $9_1 | 0;
      $3_1 = ($5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + 4194303 | 0;
      $4_1 = $4_1 - 4 | 0;
      $3_1 = $4_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $4_1;
      $9_1 = $3_1;
      $3_1 = $13_1;
      $4_1 = $9_1 >>> 20 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $6_1 | 0;
      $3_1 = ($5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + 4194303 | 0;
      $4_1 = $4_1 - 4 | 0;
      $3_1 = $4_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
      $11_1 = $4_1;
      $7_1 = $3_1;
      $3_1 = $15_1;
      $4_1 = $7_1 >>> 20 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $18_1 | 0;
      $3_1 = ($5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + 4194303 | 0;
      $5_1 = $4_1 - 4 | 0;
      $4_1 = $5_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $8_1 & 65535;
      $8_1 = $5_1;
      $3_1 = $13_1;
      $5_1 = $4_1 >>> 20 | 0;
      $15_1 = $5_1;
      $5_1 = $1_1 + $5_1 | 0;
      $3_1 = $15_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      label$8: {
        if ($5_1 | ($8_1 | ($10_1 | $14_1 | $11_1)) | ($3_1 | ($9_1 | $12_1 | $7_1 | $4_1) & 1048575)) {
          $1_1 = 0;
          if (($10_1 & ($14_1 ^ 976) & $11_1 & $8_1 & $5_1) != -1) {
            $3_1 = 1;
          } else {
            $3_1 = ($9_1 & ($12_1 ^ 1) & $7_1 & $4_1 & ($3_1 ^ 983040)) != 1048575;
          }
          if ($3_1) {
            break label$8;
          }
        }
        $1_1 = $0_1 + 48 | 0;
        $11_1 = HEAP32[$1_1 >> 2];
        $8_1 = HEAP32[$1_1 + 4 >> 2];
        $4_1 = HEAP32[$0_1 + 44 >> 2];
        $1_1 = $0_1 + 72 | 0;
        $10_1 = HEAP32[$1_1 >> 2];
        $1_1 = HEAP32[$1_1 + 4 >> 2];
        $15_1 = $1_1;
        $3_1 = HEAP32[$0_1 + 40 >> 2];
        $1_1 = __wasm_i64_mul($1_1 >>> 16 | 0, 0, 977, 1);
        $7_1 = $3_1 + $1_1 | 0;
        $3_1 = $4_1 + i64toi32_i32$HIGH_BITS | 0;
        $13_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $8_1;
        $1_1 = $13_1 >>> 20 | 0;
        $8_1 = $1_1 + $11_1 | 0;
        $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = $1_1 & 1048575;
        $3_1 = $0_1 - -64 | 0;
        $12_1 = HEAP32[$3_1 >> 2];
        $9_1 = HEAP32[$3_1 + 4 >> 2];
        $3_1 = $0_1 + 56 | 0;
        $5_1 = HEAP32[$3_1 >> 2];
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $11_1 = $1_1 >>> 20 | 0;
        $4_1 = $5_1 + $11_1 | 0;
        $11_1 = $11_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $9_1;
        $5_1 = $11_1 >>> 20 | 0;
        $9_1 = $5_1;
        $5_1 = $5_1 + $12_1 | 0;
        $3_1 = $9_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $12_1 = $3_1 & 1048575;
        $9_1 = $11_1 & 1048575;
        $6_1 = ($4_1 & $8_1 & $5_1) == -1 & ($1_1 & $9_1 & $3_1) == 1048575;
        $1_1 = $3_1;
        $3_1 = $15_1 & 65535;
        $1_1 = $1_1 >>> 20 | 0;
        $11_1 = $1_1 + $10_1 | 0;
        $3_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $3_1;
        $13_1 = $13_1 & 1048575;
        if ($6_1 & (($11_1 | 0) == -1 & ($3_1 | 0) == 65535) & (($13_1 | 0) == 1048574 & $7_1 >>> 0 > 4294966318 | $13_1 >>> 0 > 1048574) | $3_1 >>> 16) {
          $3_1 = $13_1 + 1 | 0;
          $7_1 = $7_1 + 977 | 0;
          $3_1 = $7_1 >>> 0 < 977 ? $3_1 + 1 | 0 : $3_1;
          $13_1 = $3_1 & 1048575;
          $1_1 = $3_1;
          $3_1 = $14_1;
          $1_1 = $1_1 >>> 20 | 0;
          $8_1 = $1_1 + $8_1 | 0;
          $3_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
          $14_1 = $3_1 & 1048575;
          $1_1 = $3_1;
          $3_1 = $9_1;
          $1_1 = $1_1 >>> 20 | 0;
          $4_1 = $1_1 + $4_1 | 0;
          $3_1 = $1_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
          $9_1 = $3_1 & 1048575;
          $1_1 = $3_1;
          $3_1 = $12_1;
          $1_1 = $1_1 >>> 20 | 0;
          $5_1 = $1_1 + $5_1 | 0;
          $3_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
          $12_1 = $3_1 & 1048575;
          $1_1 = $3_1;
          $3_1 = $10_1;
          $15_1 = $11_1;
          $11_1 = ($1_1 >>> 20 | 0) + $11_1 | 0;
          $10_1 = ($15_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) & 65535;
        }
        HEAP32[$0_1 + 72 >> 2] = $11_1;
        HEAP32[$0_1 + 76 >> 2] = $10_1;
        HEAP32[$0_1 + 64 >> 2] = $5_1;
        HEAP32[$0_1 + 68 >> 2] = $12_1;
        HEAP32[$0_1 + 56 >> 2] = $4_1;
        HEAP32[$0_1 + 60 >> 2] = $9_1;
        HEAP32[$0_1 + 48 >> 2] = $8_1;
        HEAP32[$0_1 + 52 >> 2] = $14_1;
        HEAP32[$0_1 + 40 >> 2] = $7_1;
        HEAP32[$0_1 + 44 >> 2] = $13_1;
        $1_1 = 1;
        if (($7_1 & 1) == ($2_1 | 0)) {
          break label$8;
        }
        HEAP32[$0_1 + 72 >> 2] = -4 - $11_1;
        HEAP32[$0_1 + 76 >> 2] = 262143 - (($11_1 >>> 0 > 4294967292) + $10_1 | 0);
        HEAP32[$0_1 + 64 >> 2] = -4 - $5_1;
        HEAP32[$0_1 + 68 >> 2] = 4194303 - (($5_1 >>> 0 > 4294967292) + $12_1 | 0);
        HEAP32[$0_1 + 56 >> 2] = -4 - $4_1;
        HEAP32[$0_1 + 60 >> 2] = 4194303 - (($4_1 >>> 0 > 4294967292) + $9_1 | 0);
        HEAP32[$0_1 + 48 >> 2] = -4 - $8_1;
        HEAP32[$0_1 + 52 >> 2] = 4194303 - (($8_1 >>> 0 > 4294967292) + $14_1 | 0);
        HEAP32[$0_1 + 40 >> 2] = -3908 - $7_1;
        HEAP32[$0_1 + 44 >> 2] = 4194299 - (($7_1 >>> 0 > 4294963388) + $13_1 | 0);
      }
      global$0 = $16_1 + 7616 | 0;
      return $1_1;
    }
    function $34($0_1, $1_1, $2_1) {
      var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0, $51_1 = 0, $52_1 = 0, $53_1 = 0, $54_1 = 0, $55_1 = 0, $56_1 = 0, $57_1 = 0, $58_1 = 0, $59_1 = 0, $60_1 = 0, $61_1 = 0, $62_1 = 0, $63_1 = 0, $64_1 = 0;
      $3_1 = global$0 - 496 | 0;
      global$0 = $3_1;
      $19_1 = $3_1 - -64 | 0;
      $31_1 = HEAP32[$2_1 + 24 >> 2];
      $32_1 = HEAP32[$2_1 + 28 >> 2];
      $33_1 = HEAP32[$1_1 >> 2];
      $34_1 = HEAP32[$1_1 + 4 >> 2];
      $69($19_1, $31_1, $32_1, 0, 0, $33_1, $34_1, 0, 0);
      $21_1 = $3_1 + 208 | 0;
      $35_1 = HEAP32[$2_1 + 16 >> 2];
      $36_1 = HEAP32[$2_1 + 20 >> 2];
      $37_1 = HEAP32[$1_1 + 8 >> 2];
      $38_1 = HEAP32[$1_1 + 12 >> 2];
      $69($21_1, $35_1, $36_1, 0, 0, $37_1, $38_1, 0, 0);
      $16_1 = $3_1 + 320 | 0;
      $39_1 = HEAP32[$2_1 + 8 >> 2];
      $40_1 = HEAP32[$2_1 + 12 >> 2];
      $41_1 = HEAP32[$1_1 + 16 >> 2];
      $42_1 = HEAP32[$1_1 + 20 >> 2];
      $69($16_1, $39_1, $40_1, 0, 0, $41_1, $42_1, 0, 0);
      $10_1 = $3_1 + 400 | 0;
      $43_1 = HEAP32[$2_1 >> 2];
      $44_1 = HEAP32[$2_1 + 4 >> 2];
      $45_1 = HEAP32[$1_1 + 24 >> 2];
      $46_1 = HEAP32[$1_1 + 28 >> 2];
      $69($10_1, $43_1, $44_1, 0, 0, $45_1, $46_1, 0, 0);
      $4_1 = $3_1 + 480 | 0;
      $47_1 = HEAP32[$2_1 + 32 >> 2];
      $48_1 = HEAP32[$2_1 + 36 >> 2];
      $49_1 = HEAP32[$1_1 + 32 >> 2];
      $24_1 = HEAP32[$1_1 + 36 >> 2];
      $69($4_1, $47_1, $48_1, 0, 0, $49_1, $24_1, 0, 0);
      $9_1 = $3_1 + 464 | 0;
      $69($9_1, HEAP32[$3_1 + 480 >> 2], HEAP32[$3_1 + 484 >> 2], 0, 0, 15632, 16, 0, 0);
      $20_1 = $3_1 + 80 | 0;
      $69($20_1, $47_1, $48_1, 0, 0, $33_1, $34_1, 0, 0);
      $50_1 = $3_1 + 144 | 0;
      $69($50_1, $31_1, $32_1, 0, 0, $37_1, $38_1, 0, 0);
      $51_1 = $3_1 + 272 | 0;
      $69($51_1, $35_1, $36_1, 0, 0, $41_1, $42_1, 0, 0);
      $52_1 = $3_1 + 368 | 0;
      $69($52_1, $39_1, $40_1, 0, 0, $45_1, $46_1, 0, 0);
      $26_1 = $3_1 + 432 | 0;
      $69($26_1, $43_1, $44_1, 0, 0, $49_1, $24_1, 0, 0);
      $15_1 = $3_1 + 448 | 0;
      $1_1 = $4_1 + 8 | 0;
      $69($15_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $53_1 = $3_1 + 96 | 0;
      $69($53_1, $43_1, $44_1, 0, 0, $33_1, $34_1, 0, 0);
      $54_1 = $3_1 + 224 | 0;
      $69($54_1, $47_1, $48_1, 0, 0, $37_1, $38_1, 0, 0);
      $55_1 = $3_1 + 160 | 0;
      $69($55_1, $31_1, $32_1, 0, 0, $41_1, $42_1, 0, 0);
      $56_1 = $3_1 + 288 | 0;
      $69($56_1, $35_1, $36_1, 0, 0, $45_1, $46_1, 0, 0);
      $28_1 = $3_1 + 384 | 0;
      $69($28_1, $39_1, $40_1, 0, 0, $49_1, $24_1, 0, 0);
      $14_1 = HEAP32[$3_1 + 208 >> 2];
      $2_1 = HEAP32[$3_1 + 64 >> 2];
      $18_1 = $14_1 + $2_1 | 0;
      $17_1 = HEAP32[$3_1 + 212 >> 2];
      $1_1 = $17_1 + HEAP32[$3_1 + 68 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $18_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = HEAP32[$3_1 + 320 >> 2];
      $8_1 = $2_1 + $18_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$3_1 + 324 >> 2] | 0;
      $7_1 = $2_1 >>> 0 > $8_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $7_1 + HEAP32[$3_1 + 404 >> 2] | 0;
      $2_1 = HEAP32[$3_1 + 400 >> 2];
      $6_1 = $2_1 + $8_1 | 0;
      $5_1 = HEAP32[$3_1 + 464 >> 2];
      $57_1 = $6_1 + $5_1 | 0;
      $2_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $2_1 + HEAP32[$3_1 + 468 >> 2] | 0;
      $5_1 = $5_1 >>> 0 > $57_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $12_1 = ($2_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 > $57_1 >>> 0 | $2_1 >>> 0 > $5_1 >>> 0;
      $1_1 = $9_1 + 8 | 0;
      $58_1 = HEAP32[$1_1 >> 2];
      $27_1 = HEAP32[$1_1 + 4 >> 2];
      $11_1 = ($2_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $6_1 >>> 0 | $2_1 >>> 0 < $7_1 >>> 0;
      $1_1 = $10_1 + 8 | 0;
      $13_1 = HEAP32[$1_1 >> 2];
      $10_1 = HEAP32[$1_1 + 4 >> 2];
      $9_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $18_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $1_1 = $16_1 + 8 | 0;
      $7_1 = HEAP32[$1_1 >> 2];
      $8_1 = HEAP32[$1_1 + 4 >> 2];
      $6_1 = ($4_1 | 0) == ($17_1 | 0) & $14_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 < $17_1 >>> 0;
      $4_1 = $19_1 + 8 | 0;
      $2_1 = HEAP32[$4_1 >> 2];
      $1_1 = $21_1 + 8 | 0;
      $18_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
      $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $18_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = $6_1 + $18_1 | 0;
      $1_1 = ($2_1 >>> 0 < $18_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $8_1 | 0;
      $4_1 = $2_1;
      $2_1 = $2_1 + $7_1 | 0;
      $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $4_1 = $2_1;
      $2_1 = $2_1 + $9_1 | 0;
      $1_1 = ($4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $10_1 | 0;
      $4_1 = $2_1;
      $2_1 = $2_1 + $13_1 | 0;
      $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $4_1 = $2_1;
      $2_1 = $2_1 + $11_1 | 0;
      $1_1 = ($4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $27_1 | 0;
      $4_1 = $2_1;
      $2_1 = $2_1 + $58_1 | 0;
      $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $4_1 = $2_1;
      $2_1 = $2_1 + $12_1 | 0;
      $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $58_1 = $5_1;
      $18_1 = $2_1 << 12 | $5_1 >>> 20;
      $4_1 = $1_1;
      $6_1 = $1_1 << 12 | $2_1 >>> 20;
      $22_1 = HEAP32[$3_1 + 272 >> 2];
      $2_1 = HEAP32[$3_1 + 144 >> 2];
      $10_1 = $22_1 + $2_1 | 0;
      $29_1 = HEAP32[$3_1 + 276 >> 2];
      $1_1 = $29_1 + HEAP32[$3_1 + 148 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = HEAP32[$3_1 + 368 >> 2];
      $9_1 = $2_1 + $10_1 | 0;
      $12_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$3_1 + 372 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = HEAP32[$3_1 + 432 >> 2];
      $7_1 = $2_1 + $9_1 | 0;
      $27_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$3_1 + 436 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = HEAP32[$3_1 + 80 >> 2];
      $8_1 = $2_1 + $7_1 | 0;
      $11_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$3_1 + 84 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $8_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = HEAP32[$3_1 + 448 >> 2];
      $5_1 = $2_1 + $8_1 | 0;
      $13_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$3_1 + 452 >> 2] | 0;
      $2_1 = $2_1 >>> 0 > $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $2_1 + $6_1 | 0;
      $18_1 = $5_1 + $18_1 | 0;
      $6_1 = $18_1 >>> 0 < $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $25_1 = ($2_1 | 0) == ($6_1 | 0) & $5_1 >>> 0 > $18_1 >>> 0 | $2_1 >>> 0 > $6_1 >>> 0;
      $23_1 = ($2_1 | 0) == ($13_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $2_1 >>> 0 < $13_1 >>> 0;
      $1_1 = $15_1 + 8 | 0;
      $17_1 = HEAP32[$1_1 >> 2];
      $19_1 = HEAP32[$1_1 + 4 >> 2];
      $21_1 = ($11_1 | 0) == ($13_1 | 0) & $8_1 >>> 0 < $7_1 >>> 0 | $11_1 >>> 0 > $13_1 >>> 0;
      $1_1 = $20_1 + 8 | 0;
      $16_1 = HEAP32[$1_1 >> 2];
      $20_1 = HEAP32[$1_1 + 4 >> 2];
      $15_1 = ($11_1 | 0) == ($27_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $11_1 >>> 0 < $27_1 >>> 0;
      $1_1 = $26_1 + 8 | 0;
      $14_1 = HEAP32[$1_1 >> 2];
      $11_1 = HEAP32[$1_1 + 4 >> 2];
      $13_1 = ($12_1 | 0) == ($27_1 | 0) & $10_1 >>> 0 > $9_1 >>> 0 | $12_1 >>> 0 > $27_1 >>> 0;
      $1_1 = $52_1 + 8 | 0;
      $9_1 = HEAP32[$1_1 >> 2];
      $7_1 = HEAP32[$1_1 + 4 >> 2];
      $8_1 = ($12_1 | 0) == ($29_1 | 0) & $10_1 >>> 0 < $22_1 >>> 0 | $12_1 >>> 0 < $29_1 >>> 0;
      $5_1 = $50_1 + 8 | 0;
      $2_1 = HEAP32[$5_1 >> 2];
      $1_1 = $51_1 + 8 | 0;
      $10_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
      $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = $8_1 + $10_1 | 0;
      $1_1 = ($2_1 >>> 0 < $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $7_1 | 0;
      $5_1 = $2_1;
      $2_1 = $2_1 + $9_1 | 0;
      $1_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $5_1 = $2_1;
      $2_1 = $2_1 + $13_1 | 0;
      $1_1 = ($5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $11_1 | 0;
      $5_1 = $2_1;
      $2_1 = $2_1 + $14_1 | 0;
      $1_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $5_1 = $2_1;
      $2_1 = $2_1 + $15_1 | 0;
      $1_1 = ($5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $20_1 | 0;
      $5_1 = $2_1;
      $2_1 = $2_1 + $16_1 | 0;
      $1_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $5_1 = $2_1;
      $2_1 = $2_1 + $21_1 | 0;
      $1_1 = ($5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $19_1 | 0;
      $5_1 = $2_1;
      $2_1 = $2_1 + $17_1 | 0;
      $1_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $5_1 = $2_1 + $23_1 | 0;
      $1_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $4_1 = $4_1 >>> 20 | 0;
      $2_1 = $4_1 + $5_1 | 0;
      $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $4_1 = $2_1;
      $2_1 = $2_1 + $25_1 | 0;
      $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $4_1 = $6_1;
      $8_1 = $2_1 << 12 | $4_1 >>> 20;
      $5_1 = $1_1;
      $6_1 = $1_1 << 12 | $2_1 >>> 20;
      $23_1 = HEAP32[$3_1 + 288 >> 2];
      $2_1 = HEAP32[$3_1 + 160 >> 2];
      $11_1 = $23_1 + $2_1 | 0;
      $22_1 = HEAP32[$3_1 + 292 >> 2];
      $1_1 = $22_1 + HEAP32[$3_1 + 164 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = HEAP32[$3_1 + 384 >> 2];
      $13_1 = $2_1 + $11_1 | 0;
      $14_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$3_1 + 388 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = HEAP32[$3_1 + 224 >> 2];
      $10_1 = $2_1 + $13_1 | 0;
      $12_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$3_1 + 228 >> 2] | 0;
      $2_1 = $2_1 >>> 0 > $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $2_1 + $6_1 | 0;
      $8_1 = $8_1 + $10_1 | 0;
      $1_1 = $8_1 >>> 0 < $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $9_1 = $8_1 << 4 & -16;
      $6_1 = $1_1;
      $7_1 = ($1_1 << 4 | $8_1 >>> 28) & 16777215;
      $27_1 = $4_1;
      $69($3_1, $9_1 | $4_1 >>> 16 & 15, $7_1, 0, 0, 977, 1, 0, 0);
      $25_1 = HEAP32[$3_1 + 4 >> 2];
      $1_1 = $25_1 + HEAP32[$3_1 + 100 >> 2] | 0;
      $7_1 = $0_1;
      $17_1 = HEAP32[$3_1 >> 2];
      $0_1 = HEAP32[$3_1 + 96 >> 2];
      $9_1 = $17_1 + $0_1 | 0;
      HEAP32[$7_1 >> 2] = $9_1;
      $4_1 = $0_1 >>> 0 > $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      HEAP32[$7_1 + 4 >> 2] = $4_1 & 1048575;
      $61_1 = $3_1 + 112 | 0;
      $69($61_1, $39_1, $40_1, 0, 0, $33_1, $34_1, 0, 0);
      $62_1 = $3_1 + 240 | 0;
      $69($62_1, $43_1, $44_1, 0, 0, $37_1, $38_1, 0, 0);
      $63_1 = $3_1 + 336 | 0;
      $69($63_1, $47_1, $48_1, 0, 0, $41_1, $42_1, 0, 0);
      $30_1 = $3_1 + 176 | 0;
      $69($30_1, $31_1, $32_1, 0, 0, $45_1, $46_1, 0, 0);
      $26_1 = $3_1 + 304 | 0;
      $69($26_1, $35_1, $36_1, 0, 0, $49_1, $24_1, 0, 0);
      $64_1 = $3_1 + 48 | 0;
      $19_1 = $64_1;
      $21_1 = ($2_1 | 0) == ($6_1 | 0) & $8_1 >>> 0 < $10_1 >>> 0 | $2_1 >>> 0 > $6_1 >>> 0;
      $16_1 = ($2_1 | 0) == ($12_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $2_1 >>> 0 < $12_1 >>> 0;
      $0_1 = $54_1 + 8 | 0;
      $20_1 = HEAP32[$0_1 >> 2];
      $15_1 = HEAP32[$0_1 + 4 >> 2];
      $12_1 = ($12_1 | 0) == ($14_1 | 0) & $11_1 >>> 0 > $13_1 >>> 0 | $12_1 >>> 0 < $14_1 >>> 0;
      $0_1 = $28_1 + 8 | 0;
      $13_1 = HEAP32[$0_1 >> 2];
      $10_1 = HEAP32[$0_1 + 4 >> 2];
      $8_1 = ($14_1 | 0) == ($22_1 | 0) & $11_1 >>> 0 < $23_1 >>> 0 | $14_1 >>> 0 < $22_1 >>> 0;
      $1_1 = $55_1 + 8 | 0;
      $2_1 = HEAP32[$1_1 >> 2];
      $0_1 = $56_1 + 8 | 0;
      $11_1 = $2_1 + HEAP32[$0_1 >> 2] | 0;
      $1_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$1_1 + 4 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $0_1 = $8_1 + $11_1 | 0;
      $1_1 = ($0_1 >>> 0 < $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $10_1 | 0;
      $2_1 = $0_1;
      $0_1 = $0_1 + $13_1 | 0;
      $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = $0_1;
      $0_1 = $0_1 + $12_1 | 0;
      $1_1 = ($2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $15_1 | 0;
      $2_1 = $0_1;
      $0_1 = $0_1 + $20_1 | 0;
      $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = $0_1 + $16_1 | 0;
      $1_1 = $2_1 >>> 0 < $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $5_1 = $5_1 >>> 20 | 0;
      $0_1 = $2_1 + $5_1 | 0;
      $1_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = $0_1;
      $0_1 = $0_1 + $21_1 | 0;
      $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $5_1 = $0_1 << 12 | $6_1 >>> 20;
      $8_1 = $1_1;
      $2_1 = $1_1 << 12 | $0_1 >>> 20;
      $28_1 = HEAP32[$3_1 + 304 >> 2];
      $0_1 = HEAP32[$3_1 + 176 >> 2];
      $14_1 = $28_1 + $0_1 | 0;
      $59_1 = HEAP32[$3_1 + 308 >> 2];
      $1_1 = $59_1 + HEAP32[$3_1 + 180 >> 2] | 0;
      $1_1 = $0_1 >>> 0 > $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $0_1 = HEAP32[$3_1 + 336 >> 2];
      $12_1 = $0_1 + $14_1 | 0;
      $15_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$3_1 + 340 >> 2] | 0;
      $6_1 = $0_1 >>> 0 > $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $6_1 + $2_1 | 0;
      $11_1 = $5_1 + $12_1 | 0;
      $1_1 = $11_1 >>> 0 < $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $10_1 = $1_1;
      $69($19_1, $11_1, $1_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $5_1 = ($4_1 | 0) == ($25_1 | 0) & $9_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 < $25_1 >>> 0;
      $1_1 = $53_1 + 8 | 0;
      $2_1 = HEAP32[$1_1 >> 2];
      $0_1 = $3_1 + 8 | 0;
      $9_1 = $2_1 + HEAP32[$0_1 >> 2] | 0;
      $1_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$1_1 + 4 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $0_1 = $5_1 + $9_1 | 0;
      $1_1 = $0_1 >>> 0 < $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $13_1 = $0_1 << 12 | $4_1 >>> 20;
      $5_1 = $1_1;
      $9_1 = $1_1 << 12 | $0_1 >>> 20;
      $29_1 = HEAP32[$3_1 + 240 >> 2];
      $0_1 = HEAP32[$3_1 + 112 >> 2];
      $16_1 = $29_1 + $0_1 | 0;
      $60_1 = HEAP32[$3_1 + 244 >> 2];
      $1_1 = $60_1 + HEAP32[$3_1 + 116 >> 2] | 0;
      $23_1 = $0_1 >>> 0 > $16_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $23_1 + HEAP32[$3_1 + 52 >> 2] | 0;
      $2_1 = HEAP32[$3_1 + 48 >> 2];
      $0_1 = $2_1 + $16_1 | 0;
      $21_1 = $0_1;
      $13_1 = $0_1 + $13_1 | 0;
      $4_1 = $0_1 >>> 0 < $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $4_1 + $9_1 | 0;
      HEAP32[$7_1 + 8 >> 2] = $13_1;
      $9_1 = $13_1 >>> 0 < $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      HEAP32[$7_1 + 12 >> 2] = $9_1 & 1048575;
      $50_1 = $3_1 + 128 | 0;
      $69($50_1, $35_1, $36_1, 0, 0, $33_1, $34_1, 0, 0);
      $51_1 = $3_1 + 256 | 0;
      $69($51_1, $39_1, $40_1, 0, 0, $37_1, $38_1, 0, 0);
      $52_1 = $3_1 + 352 | 0;
      $69($52_1, $43_1, $44_1, 0, 0, $41_1, $42_1, 0, 0);
      $53_1 = $3_1 + 416 | 0;
      $69($53_1, $47_1, $48_1, 0, 0, $45_1, $46_1, 0, 0);
      $54_1 = $3_1 + 192 | 0;
      $69($54_1, $31_1, $32_1, 0, 0, $49_1, $24_1, 0, 0);
      $55_1 = $3_1 + 32 | 0;
      $22_1 = $55_1;
      $56_1 = HEAP32[$3_1 + 416 >> 2];
      $0_1 = HEAP32[$3_1 + 192 >> 2];
      $20_1 = $56_1 + $0_1 | 0;
      $24_1 = HEAP32[$3_1 + 420 >> 2];
      $1_1 = $24_1 + HEAP32[$3_1 + 196 >> 2] | 0;
      $2_1 = $0_1 >>> 0 > $20_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $25_1 = ($6_1 | 0) == ($10_1 | 0) & $11_1 >>> 0 < $12_1 >>> 0 | $6_1 >>> 0 > $10_1 >>> 0;
      $17_1 = ($6_1 | 0) == ($15_1 | 0) & $12_1 >>> 0 < $14_1 >>> 0 | $6_1 >>> 0 < $15_1 >>> 0;
      $0_1 = $63_1 + 8 | 0;
      $19_1 = HEAP32[$0_1 >> 2];
      $12_1 = HEAP32[$0_1 + 4 >> 2];
      $11_1 = ($15_1 | 0) == ($59_1 | 0) & $14_1 >>> 0 < $28_1 >>> 0 | $15_1 >>> 0 < $59_1 >>> 0;
      $1_1 = $30_1 + 8 | 0;
      $6_1 = HEAP32[$1_1 >> 2];
      $0_1 = $26_1 + 8 | 0;
      $14_1 = $6_1 + HEAP32[$0_1 >> 2] | 0;
      $1_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$1_1 + 4 >> 2] | 0;
      $1_1 = $6_1 >>> 0 > $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $0_1 = $11_1 + $14_1 | 0;
      $1_1 = ($0_1 >>> 0 < $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $12_1 | 0;
      $6_1 = $0_1;
      $0_1 = $0_1 + $19_1 | 0;
      $1_1 = $6_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $6_1 = $0_1 + $17_1 | 0;
      $1_1 = $6_1 >>> 0 < $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $8_1 = $8_1 >>> 20 | 0;
      $0_1 = $8_1 + $6_1 | 0;
      $1_1 = $8_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $6_1 = $0_1;
      $0_1 = $0_1 + $25_1 | 0;
      $1_1 = $6_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $8_1 = $0_1 << 12 | $10_1 >>> 20;
      $10_1 = $8_1 + $20_1 | 0;
      $6_1 = $1_1;
      $1_1 = $2_1 + ($1_1 << 12 | $0_1 >>> 20) | 0;
      $15_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $69($22_1, $10_1, $15_1, 0, 0, 15632, 16, 0, 0);
      $8_1 = $7_1;
      $26_1 = HEAP32[$3_1 + 256 >> 2];
      $0_1 = HEAP32[$3_1 + 128 >> 2];
      $14_1 = $26_1 + $0_1 | 0;
      $30_1 = HEAP32[$3_1 + 260 >> 2];
      $1_1 = $30_1 + HEAP32[$3_1 + 132 >> 2] | 0;
      $1_1 = $0_1 >>> 0 > $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $0_1 = HEAP32[$3_1 + 352 >> 2];
      $12_1 = $0_1 + $14_1 | 0;
      $17_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$3_1 + 356 >> 2] | 0;
      $1_1 = $0_1 >>> 0 > $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $0_1 = HEAP32[$3_1 + 32 >> 2];
      $11_1 = $0_1 + $12_1 | 0;
      $19_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$3_1 + 36 >> 2] | 0;
      $0_1 = $0_1 >>> 0 > $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $28_1 = ($4_1 | 0) == ($9_1 | 0) & $13_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
      $22_1 = ($4_1 | 0) == ($23_1 | 0) & $16_1 >>> 0 > $21_1 >>> 0 | $4_1 >>> 0 < $23_1 >>> 0;
      $1_1 = $64_1 + 8 | 0;
      $25_1 = HEAP32[$1_1 >> 2];
      $21_1 = HEAP32[$1_1 + 4 >> 2];
      $13_1 = ($23_1 | 0) == ($60_1 | 0) & $16_1 >>> 0 < $29_1 >>> 0 | $23_1 >>> 0 < $60_1 >>> 0;
      $7_1 = $61_1 + 8 | 0;
      $4_1 = HEAP32[$7_1 >> 2];
      $1_1 = $62_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
      $1_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $4_1 = $13_1 + $16_1 | 0;
      $1_1 = ($4_1 >>> 0 < $16_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $21_1 | 0;
      $7_1 = $4_1;
      $4_1 = $4_1 + $25_1 | 0;
      $1_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $7_1 = $4_1 + $22_1 | 0;
      $1_1 = $7_1 >>> 0 < $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $7_1 | 0;
      $1_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $28_1 | 0;
      $1_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $7_1 = $4_1 << 12 | $9_1 >>> 20;
      $9_1 = $7_1 + $11_1 | 0;
      $5_1 = $1_1;
      $1_1 = $0_1 + ($1_1 << 12 | $4_1 >>> 20) | 0;
      HEAP32[$8_1 + 16 >> 2] = $9_1;
      $7_1 = $7_1 >>> 0 > $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      HEAP32[$8_1 + 20 >> 2] = $7_1 & 1048575;
      $16_1 = $3_1 + 16 | 0;
      $13_1 = ($2_1 | 0) == ($15_1 | 0) & $10_1 >>> 0 < $20_1 >>> 0 | $2_1 >>> 0 > $15_1 >>> 0;
      $10_1 = ($2_1 | 0) == ($24_1 | 0) & $20_1 >>> 0 < $56_1 >>> 0 | $2_1 >>> 0 < $24_1 >>> 0;
      $4_1 = $54_1 + 8 | 0;
      $2_1 = HEAP32[$4_1 >> 2];
      $1_1 = $53_1 + 8 | 0;
      $15_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
      $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $15_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $4_1 = $10_1 + $15_1 | 0;
      $1_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $6_1 = $6_1 >>> 20 | 0;
      $2_1 = $4_1 + $6_1 | 0;
      $1_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $4_1 = $2_1;
      $2_1 = $2_1 + $13_1 | 0;
      $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $69($16_1, $2_1, $1_1, 0, 0, 64028672, 65536, 0, 0);
      $4_1 = $8_1;
      $20_1 = ($0_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 < $11_1 >>> 0 | $0_1 >>> 0 > $7_1 >>> 0;
      $15_1 = ($0_1 | 0) == ($19_1 | 0) & $11_1 >>> 0 < $12_1 >>> 0 | $0_1 >>> 0 < $19_1 >>> 0;
      $0_1 = $55_1 + 8 | 0;
      $11_1 = HEAP32[$0_1 >> 2];
      $13_1 = HEAP32[$0_1 + 4 >> 2];
      $10_1 = ($17_1 | 0) == ($19_1 | 0) & $12_1 >>> 0 < $14_1 >>> 0 | $17_1 >>> 0 > $19_1 >>> 0;
      $0_1 = $52_1 + 8 | 0;
      $9_1 = HEAP32[$0_1 >> 2];
      $8_1 = HEAP32[$0_1 + 4 >> 2];
      $6_1 = ($17_1 | 0) == ($30_1 | 0) & $14_1 >>> 0 < $26_1 >>> 0 | $17_1 >>> 0 < $30_1 >>> 0;
      $1_1 = $50_1 + 8 | 0;
      $2_1 = HEAP32[$1_1 >> 2];
      $0_1 = $51_1 + 8 | 0;
      $12_1 = $2_1 + HEAP32[$0_1 >> 2] | 0;
      $1_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$1_1 + 4 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $0_1 = $6_1 + $12_1 | 0;
      $1_1 = ($0_1 >>> 0 < $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $8_1 | 0;
      $2_1 = $0_1;
      $0_1 = $0_1 + $9_1 | 0;
      $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = $0_1;
      $0_1 = $0_1 + $10_1 | 0;
      $1_1 = ($2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $13_1 | 0;
      $2_1 = $0_1;
      $0_1 = $0_1 + $11_1 | 0;
      $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = $0_1 + $15_1 | 0;
      $1_1 = $2_1 >>> 0 < $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $5_1 = $5_1 >>> 20 | 0;
      $0_1 = $2_1 + $5_1 | 0;
      $1_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = $0_1;
      $0_1 = $0_1 + $20_1 | 0;
      $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $5_1 = $0_1 << 12 | $7_1 >>> 20;
      $2_1 = $1_1;
      $6_1 = $1_1 << 12 | $0_1 >>> 20;
      $11_1 = HEAP32[$3_1 + 20 >> 2];
      $1_1 = $11_1 + ($58_1 & 1048575) | 0;
      $13_1 = HEAP32[$3_1 + 16 >> 2];
      $0_1 = $57_1 + $13_1 | 0;
      $7_1 = $0_1 >>> 0 < $57_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $7_1 + $6_1 | 0;
      $8_1 = $0_1;
      $5_1 = $0_1 + $5_1 | 0;
      HEAP32[$4_1 + 24 >> 2] = $5_1;
      $0_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      HEAP32[$4_1 + 28 >> 2] = $0_1 & 1048575;
      $6_1 = $4_1;
      $10_1 = $27_1 & 65535;
      $9_1 = ($0_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $0_1 >>> 0 < $7_1 >>> 0;
      $4_1 = ($7_1 | 0) == ($11_1 | 0) & $8_1 >>> 0 < $13_1 >>> 0 | $7_1 >>> 0 < $11_1 >>> 0;
      $1_1 = $16_1 + 8 | 0;
      $5_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $1_1 = HEAP32[$1_1 + 4 >> 2];
      $1_1 = $4_1 >>> 0 > $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = $2_1 >>> 20 | 0;
      $4_1 = $2_1;
      $2_1 = $2_1 + $5_1 | 0;
      $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $4_1 = $2_1;
      $2_1 = $2_1 + $9_1 | 0;
      $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $0_1 = $2_1 << 12 | $0_1 >>> 20;
      $4_1 = $0_1 + $18_1 | 0;
      $1_1 = $10_1 + ($1_1 << 12 | $2_1 >>> 20) | 0;
      HEAP32[$6_1 + 32 >> 2] = $4_1;
      HEAP32[$6_1 + 36 >> 2] = $0_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      global$0 = $3_1 + 496 | 0;
    }
    function $35($0_1, $1_1) {
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0;
      $3_1 = $1_1 - -64 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $8_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $1_1 + 56 | 0;
      $6_1 = HEAP32[$3_1 >> 2];
      $17_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $1_1 + 48 | 0;
      $18_1 = HEAP32[$3_1 >> 2];
      $12_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $1_1 + 72 | 0;
      $14_1 = HEAP32[$3_1 >> 2];
      $5_1 = HEAP32[$3_1 + 4 >> 2];
      $20_1 = HEAP32[$1_1 + 40 >> 2];
      $22_1 = HEAP32[$1_1 + 44 >> 2];
      $19_1 = HEAP32[$1_1 + 24 >> 2];
      $13_1 = HEAP32[$1_1 + 28 >> 2];
      $7_1 = HEAP32[$1_1 + 16 >> 2];
      $16_1 = HEAP32[$1_1 + 20 >> 2];
      $2_1 = HEAP32[$1_1 + 8 >> 2];
      $9_1 = HEAP32[$1_1 + 12 >> 2];
      $10_1 = HEAP32[$1_1 + 4 >> 2];
      $21_1 = HEAP32[$1_1 + 32 >> 2];
      $4_1 = HEAP32[$1_1 + 36 >> 2];
      $24_1 = $4_1;
      $1_1 = HEAP32[$1_1 >> 2];
      $3_1 = __wasm_i64_mul($4_1 >>> 16 | 0, 0, 977, 1);
      $4_1 = $1_1 + $3_1 | 0;
      $1_1 = $10_1 + i64toi32_i32$HIGH_BITS | 0;
      $10_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $9_1;
      $3_1 = $10_1 >>> 20 | 0;
      $9_1 = $3_1;
      $3_1 = $2_1 + $3_1 | 0;
      $9_1 = $9_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $16_1;
      $2_1 = $9_1 >>> 20 | 0;
      $15_1 = $2_1;
      $2_1 = $2_1 + $7_1 | 0;
      $16_1 = $15_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $13_1;
      $7_1 = $16_1 >>> 20 | 0;
      $13_1 = $7_1;
      $7_1 = $7_1 + $19_1 | 0;
      $19_1 = $13_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $25_1 = $9_1 & 1048575;
      $1_1 = $10_1 & 1048575;
      $15_1 = $1_1;
      $13_1 = $3_1;
      $10_1 = $2_1;
      $23_1 = $16_1 & 1048575;
      $2_1 = ($3_1 & $2_1 & $7_1) == -1 & ($23_1 & $9_1 & $19_1) == 1048575;
      $1_1 = $24_1 & 65535;
      $3_1 = $19_1 >>> 20 | 0;
      $9_1 = $3_1;
      $3_1 = $3_1 + $21_1 | 0;
      $1_1 = $9_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $21_1 = $3_1;
      $9_1 = $1_1;
      $3_1 = __wasm_i64_mul($2_1 & (($3_1 | 0) == -1 & ($1_1 | 0) == 65535) & (($15_1 | 0) == 1048574 & $4_1 >>> 0 > 4294966318 | $15_1 >>> 0 > 1048574) | $1_1 >>> 16, 0, 977, 1);
      $4_1 = $3_1 + $4_1 | 0;
      $1_1 = $15_1 + i64toi32_i32$HIGH_BITS | 0;
      $2_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $25_1;
      $3_1 = $2_1 >>> 20 | 0;
      $16_1 = $3_1 + $13_1 | 0;
      $3_1 = $3_1 >>> 0 > $16_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      HEAP8[$0_1 | 0] = $4_1;
      HEAP8[$0_1 + 1 | 0] = $4_1 >>> 8;
      HEAP8[$0_1 + 2 | 0] = $4_1 >>> 16;
      HEAP8[$0_1 + 3 | 0] = $4_1 >>> 24;
      $1_1 = $2_1 & 1048575 | $16_1 << 20;
      HEAP8[$0_1 + 4 | 0] = $1_1;
      HEAP8[$0_1 + 5 | 0] = $1_1 >>> 8;
      HEAP8[$0_1 + 6 | 0] = $1_1 >>> 16;
      HEAP8[$0_1 + 7 | 0] = $1_1 >>> 24;
      $13_1 = $14_1;
      $15_1 = $5_1 & 65535;
      $14_1 = $11_1;
      $11_1 = $6_1;
      $2_1 = __wasm_i64_mul($5_1 >>> 16 | 0, 0, 977, 1);
      $4_1 = $2_1 + $20_1 | 0;
      $1_1 = $22_1 + i64toi32_i32$HIGH_BITS | 0;
      $20_1 = $2_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $12_1;
      $2_1 = $20_1 >>> 20 | 0;
      $5_1 = $2_1;
      $2_1 = $2_1 + $18_1 | 0;
      $6_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $17_1;
      $5_1 = $6_1 >>> 20 | 0;
      $11_1 = $5_1 + $11_1 | 0;
      $12_1 = $5_1 >>> 0 > $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $8_1;
      $5_1 = $12_1 >>> 20 | 0;
      $8_1 = $5_1;
      $5_1 = $5_1 + $14_1 | 0;
      $17_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $15_1;
      $8_1 = $17_1 >>> 20 | 0;
      $14_1 = $8_1;
      $8_1 = $8_1 + $13_1 | 0;
      $1_1 = $14_1 >>> 0 > $8_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $18_1 = $8_1;
      $8_1 = $1_1;
      $22_1 = $6_1 & 1048575;
      $1_1 = $20_1 & 1048575;
      $15_1 = $4_1;
      $14_1 = $2_1;
      $13_1 = $12_1 & 1048575;
      $4_1 = __wasm_i64_mul(($11_1 & $2_1 & $5_1) == -1 & ($13_1 & $6_1 & $17_1) == 1048575 & (($18_1 | 0) == -1 & ($8_1 | 0) == 65535) & (($1_1 | 0) == 1048574 & $4_1 >>> 0 > 4294966318 | $1_1 >>> 0 > 1048574) | $8_1 >>> 16, 0, 977, 1);
      $2_1 = $15_1 + $4_1 | 0;
      $1_1 = $1_1 + i64toi32_i32$HIGH_BITS | 0;
      $6_1 = $2_1 >>> 0 < $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $22_1;
      $4_1 = $6_1 >>> 20 | 0;
      $12_1 = $4_1 + $14_1 | 0;
      $4_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      HEAP8[$0_1 + 32 | 0] = $2_1;
      HEAP8[$0_1 + 33 | 0] = $2_1 >>> 8;
      HEAP8[$0_1 + 34 | 0] = $2_1 >>> 16;
      HEAP8[$0_1 + 35 | 0] = $2_1 >>> 24;
      $1_1 = $6_1 & 1048575 | $12_1 << 20;
      HEAP8[$0_1 + 36 | 0] = $1_1;
      HEAP8[$0_1 + 37 | 0] = $1_1 >>> 8;
      HEAP8[$0_1 + 38 | 0] = $1_1 >>> 16;
      HEAP8[$0_1 + 39 | 0] = $1_1 >>> 24;
      $6_1 = ($3_1 & 4095) << 20 | $16_1 >>> 12;
      $14_1 = $3_1 >>> 12 & 255;
      $1_1 = $23_1;
      $2_1 = ($3_1 >>> 20 | 0) + $10_1 | 0;
      $3_1 = $2_1 >>> 0 < $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $10_1 = $2_1;
      $1_1 = $2_1 << 8;
      $2_1 = $0_1;
      HEAP8[$2_1 + 8 | 0] = $6_1;
      HEAP8[$2_1 + 9 | 0] = $6_1 >>> 8;
      HEAP8[$2_1 + 10 | 0] = $6_1 >>> 16;
      HEAP8[$2_1 + 11 | 0] = $6_1 >>> 24;
      $1_1 = $1_1 | $14_1;
      HEAP8[$2_1 + 12 | 0] = $1_1;
      HEAP8[$2_1 + 13 | 0] = $1_1 >>> 8;
      HEAP8[$2_1 + 14 | 0] = $1_1 >>> 16;
      HEAP8[$2_1 + 15 | 0] = $1_1 >>> 24;
      $6_1 = ($4_1 & 4095) << 20 | $12_1 >>> 12;
      $12_1 = $4_1 >>> 12 & 255;
      $1_1 = $13_1;
      $2_1 = ($4_1 >>> 20 | 0) + $11_1 | 0;
      $4_1 = $2_1 >>> 0 < $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $11_1 = $2_1;
      $1_1 = $2_1 << 8;
      $2_1 = $0_1;
      HEAP8[$2_1 + 40 | 0] = $6_1;
      HEAP8[$2_1 + 41 | 0] = $6_1 >>> 8;
      HEAP8[$2_1 + 42 | 0] = $6_1 >>> 16;
      HEAP8[$2_1 + 43 | 0] = $6_1 >>> 24;
      $1_1 = $1_1 | $12_1;
      HEAP8[$2_1 + 44 | 0] = $1_1;
      HEAP8[$2_1 + 45 | 0] = $1_1 >>> 8;
      HEAP8[$2_1 + 46 | 0] = $1_1 >>> 16;
      HEAP8[$2_1 + 47 | 0] = $1_1 >>> 24;
      $10_1 = (($3_1 & 16777215) << 8 | $10_1 >>> 24) & 268435455;
      $1_1 = $19_1 & 1048575;
      $3_1 = $3_1 >>> 20 | 0;
      $2_1 = $3_1 + $7_1 | 0;
      $3_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $3_1 << 28 | $2_1 >>> 4;
      $7_1 = $2_1 << 28;
      $2_1 = $0_1;
      $7_1 = $7_1 | $10_1;
      HEAP8[$2_1 + 16 | 0] = $7_1;
      HEAP8[$2_1 + 17 | 0] = $7_1 >>> 8;
      HEAP8[$2_1 + 18 | 0] = $7_1 >>> 16;
      HEAP8[$2_1 + 19 | 0] = $7_1 >>> 24;
      HEAP8[$2_1 + 20 | 0] = $1_1;
      HEAP8[$2_1 + 21 | 0] = $1_1 >>> 8;
      HEAP8[$2_1 + 22 | 0] = $1_1 >>> 16;
      HEAP8[$2_1 + 23 | 0] = $1_1 >>> 24;
      $7_1 = (($4_1 & 16777215) << 8 | $11_1 >>> 24) & 268435455;
      $1_1 = $17_1 & 1048575;
      $4_1 = $4_1 >>> 20 | 0;
      $2_1 = $4_1 + $5_1 | 0;
      $4_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $4_1 << 28 | $2_1 >>> 4;
      $5_1 = $2_1 << 28;
      $2_1 = $0_1;
      $5_1 = $5_1 | $7_1;
      HEAP8[$2_1 + 48 | 0] = $5_1;
      HEAP8[$2_1 + 49 | 0] = $5_1 >>> 8;
      HEAP8[$2_1 + 50 | 0] = $5_1 >>> 16;
      HEAP8[$2_1 + 51 | 0] = $5_1 >>> 24;
      HEAP8[$2_1 + 52 | 0] = $1_1;
      HEAP8[$2_1 + 53 | 0] = $1_1 >>> 8;
      HEAP8[$2_1 + 54 | 0] = $1_1 >>> 16;
      HEAP8[$2_1 + 55 | 0] = $1_1 >>> 24;
      $2_1 = $3_1 >>> 4 & 65535;
      $1_1 = $9_1;
      $3_1 = ($3_1 >>> 20 | 0) + $21_1 | 0;
      $1_1 = ($3_1 >>> 0 < $21_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) << 16 | $3_1 >>> 16;
      $5_1 = $3_1 << 16;
      $3_1 = $0_1;
      $2_1 = $2_1 | $5_1;
      HEAP8[$3_1 + 24 | 0] = $2_1;
      HEAP8[$3_1 + 25 | 0] = $2_1 >>> 8;
      HEAP8[$3_1 + 26 | 0] = $2_1 >>> 16;
      HEAP8[$3_1 + 27 | 0] = $2_1 >>> 24;
      HEAP8[$3_1 + 28 | 0] = $1_1;
      HEAP8[$3_1 + 29 | 0] = $1_1 >>> 8;
      HEAP8[$3_1 + 30 | 0] = $1_1 >>> 16;
      HEAP8[$3_1 + 31 | 0] = $1_1 >>> 24;
      $2_1 = $4_1 >>> 4 & 65535;
      $1_1 = $8_1;
      $3_1 = ($4_1 >>> 20 | 0) + $18_1 | 0;
      $1_1 = ($3_1 >>> 0 < $18_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) << 16 | $3_1 >>> 16;
      $3_1 = $3_1 << 16 | $2_1;
      HEAP8[$0_1 + 56 | 0] = $3_1;
      HEAP8[$0_1 + 57 | 0] = $3_1 >>> 8;
      HEAP8[$0_1 + 58 | 0] = $3_1 >>> 16;
      HEAP8[$0_1 + 59 | 0] = $3_1 >>> 24;
      HEAP8[$0_1 + 60 | 0] = $1_1;
      HEAP8[$0_1 + 61 | 0] = $1_1 >>> 8;
      HEAP8[$0_1 + 62 | 0] = $1_1 >>> 16;
      HEAP8[$0_1 + 63 | 0] = $1_1 >>> 24;
    }
    function $36($0_1, $1_1, $2_1, $3_1) {
      var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0;
      $8_1 = global$0 - 96 | 0;
      global$0 = $8_1;
      label$1: {
        if (!$1_1) {
          FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689730, HEAP32[$0_1 + 172 >> 2]);
          break label$1;
        }
        $5_1 = HEAP32[$1_1 >> 2];
        $26_1 = $3_1 & 256;
        if ($5_1 >>> 0 < ($26_1 ? 33 : 65) >>> 0) {
          FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](690157, HEAP32[$0_1 + 172 >> 2]);
          break label$1;
        }
        HEAP32[$1_1 >> 2] = 0;
        $22_1 = $68(690820, $5_1);
        if (!$2_1) {
          FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689638, HEAP32[$0_1 + 172 >> 2]);
          break label$1;
        }
        if (($3_1 & 255) != 2) {
          FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689499, HEAP32[$0_1 + 172 >> 2]);
          break label$1;
        }
        HEAP32[$8_1 + 88 >> 2] = 0;
        $3_1 = HEAPU8[$2_1 + 12 | 0] | HEAPU8[$2_1 + 13 | 0] << 8 | (HEAPU8[$2_1 + 14 | 0] << 16 | HEAPU8[$2_1 + 15 | 0] << 24);
        $6_1 = $3_1;
        $5_1 = HEAPU8[$2_1 + 8 | 0] | HEAPU8[$2_1 + 9 | 0] << 8 | (HEAPU8[$2_1 + 10 | 0] << 16 | HEAPU8[$2_1 + 11 | 0] << 24);
        $7_1 = ($3_1 << 12 | $5_1 >>> 20) & 1048575;
        $9_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $4_1 = $9_1;
        $5_1 = $5_1 << 12 & -4096 | $4_1 >>> 20;
        $20_1 = $7_1;
        $7_1 = HEAPU8[$2_1 + 16 | 0] | HEAPU8[$2_1 + 17 | 0] << 8 | (HEAPU8[$2_1 + 18 | 0] << 16 | HEAPU8[$2_1 + 19 | 0] << 24);
        $11_1 = $7_1;
        $3_1 = HEAPU8[$2_1 + 20 | 0] | HEAPU8[$2_1 + 21 | 0] << 8 | (HEAPU8[$2_1 + 22 | 0] << 16 | HEAPU8[$2_1 + 23 | 0] << 24);
        $9_1 = $3_1;
        $12_1 = ($3_1 << 24 | $7_1 >>> 8) & 1048575;
        $16_1 = $7_1 << 24 & -16777216 | $6_1 >>> 8;
        $23_1 = $12_1;
        $10_1 = $12_1;
        $7_1 = HEAPU8[$2_1 + 28 | 0] | HEAPU8[$2_1 + 29 | 0] << 8 | (HEAPU8[$2_1 + 30 | 0] << 16 | HEAPU8[$2_1 + 31 | 0] << 24);
        $3_1 = $7_1 >>> 16 | 0;
        $6_1 = HEAPU8[$2_1 + 24 | 0] | HEAPU8[$2_1 + 25 | 0] << 8 | (HEAPU8[$2_1 + 26 | 0] << 16 | HEAPU8[$2_1 + 27 | 0] << 24);
        $7_1 = ($7_1 & 65535) << 16 | $6_1 >>> 16;
        $17_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        $15_1 = $16_1 | ($7_1 | ($17_1 | $5_1));
        $24_1 = $3_1;
        $18_1 = $4_1 & 1048575;
        $4_1 = $10_1 | ($3_1 | ($18_1 | $20_1));
        $10_1 = $6_1 << 4 & 1048560;
        $6_1 = $9_1;
        $3_1 = $6_1 >>> 28 | 0;
        $12_1 = ($6_1 & 268435455) << 4 | $11_1 >>> 28;
        $9_1 = $15_1 | $12_1;
        $15_1 = $3_1 | $10_1;
        if (!($9_1 | ($4_1 | $15_1))) {
          FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](690116, HEAP32[$0_1 + 172 >> 2]);
          break label$1;
        }
        $6_1 = HEAPU8[$2_1 + 52 | 0] | HEAPU8[$2_1 + 53 | 0] << 8 | (HEAPU8[$2_1 + 54 | 0] << 16 | HEAPU8[$2_1 + 55 | 0] << 24);
        $3_1 = $6_1 >>> 28 | 0;
        $0_1 = HEAPU8[$2_1 + 48 | 0] | HEAPU8[$2_1 + 49 | 0] << 8 | (HEAPU8[$2_1 + 50 | 0] << 16 | HEAPU8[$2_1 + 51 | 0] << 24);
        $9_1 = ($6_1 & 268435455) << 4 | $0_1 >>> 28;
        $11_1 = $3_1;
        $3_1 = HEAPU8[$2_1 + 56 | 0] | HEAPU8[$2_1 + 57 | 0] << 8 | (HEAPU8[$2_1 + 58 | 0] << 16 | HEAPU8[$2_1 + 59 | 0] << 24);
        $27_1 = $3_1;
        $13_1 = HEAPU8[$2_1 + 60 | 0] | HEAPU8[$2_1 + 61 | 0] << 8 | (HEAPU8[$2_1 + 62 | 0] << 16 | HEAPU8[$2_1 + 63 | 0] << 24);
        $28_1 = $3_1 << 4 & 1048560;
        $4_1 = HEAPU8[$2_1 + 40 | 0] | HEAPU8[$2_1 + 41 | 0] << 8 | (HEAPU8[$2_1 + 42 | 0] << 16 | HEAPU8[$2_1 + 43 | 0] << 24);
        $10_1 = HEAPU8[$2_1 + 44 | 0] | HEAPU8[$2_1 + 45 | 0] << 8 | (HEAPU8[$2_1 + 46 | 0] << 16 | HEAPU8[$2_1 + 47 | 0] << 24);
        $19_1 = $10_1 >>> 8 | 0;
        $3_1 = $6_1 << 24 | $0_1 >>> 8;
        $29_1 = $0_1 << 24 & -16777216;
        $30_1 = $3_1 & 1048575;
        $6_1 = HEAPU8[$2_1 + 32 | 0] | HEAPU8[$2_1 + 33 | 0] << 8 | (HEAPU8[$2_1 + 34 | 0] << 16 | HEAPU8[$2_1 + 35 | 0] << 24);
        $0_1 = HEAPU8[$2_1 + 36 | 0] | HEAPU8[$2_1 + 37 | 0] << 8 | (HEAPU8[$2_1 + 38 | 0] << 16 | HEAPU8[$2_1 + 39 | 0] << 24);
        $14_1 = $0_1;
        $2_1 = $0_1 >>> 20 | 0;
        $0_1 = $4_1;
        $3_1 = $10_1 << 12 | $0_1 >>> 20;
        $10_1 = $0_1 << 12 & -4096;
        $25_1 = $3_1 & 1048575;
        $21_1 = $14_1 & 1048575;
        label$7: {
          if (($18_1 | 0) == 1048574 & $17_1 >>> 0 < 4294966319 | $18_1 >>> 0 < 1048574) {
            break label$7;
          }
          if (($5_1 & $16_1 & $12_1) != -1 | ($20_1 & $23_1 & $15_1) != 1048575) {
            break label$7;
          }
          if (($7_1 | 0) != -1 | ($24_1 | 0) != 65535) {
            break label$7;
          }
          $0_1 = $18_1 + 1 | 0;
          $17_1 = $17_1 + 977 | 0;
          $0_1 = $17_1 >>> 0 < 977 ? $0_1 + 1 | 0 : $0_1;
          $18_1 = $0_1 & 1048575;
          $4_1 = $0_1 >>> 20 | 0;
          $0_1 = $20_1;
          $5_1 = $4_1 + $5_1 | 0;
          $0_1 = $5_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $20_1 = $0_1 & 1048575;
          $3_1 = $23_1;
          $0_1 = $0_1 >>> 20 | 0;
          $16_1 = $0_1 + $16_1 | 0;
          $3_1 = $0_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
          $23_1 = $3_1 & 1048575;
          $4_1 = $3_1 >>> 20 | 0;
          $0_1 = $15_1;
          $12_1 = $4_1 + $12_1 | 0;
          $0_1 = $12_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $15_1 = $0_1 & 1048575;
          $4_1 = $0_1 >>> 20 | 0;
          $0_1 = $24_1;
          $3_1 = $7_1;
          $7_1 = $4_1 + $7_1 | 0;
          $24_1 = ($3_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) & 65535;
        }
        $4_1 = $9_1;
        $14_1 = $11_1 | $28_1;
        $11_1 = $19_1 | $29_1;
        $19_1 = $30_1;
        $10_1 = $2_1 | $10_1;
        $0_1 = $13_1;
        $3_1 = $0_1 >>> 16 | 0;
        $9_1 = ($0_1 & 65535) << 16 | $27_1 >>> 16;
        $13_1 = $3_1;
        $2_1 = $8_1;
        HEAP32[$2_1 + 40 >> 2] = $7_1;
        HEAP32[$2_1 + 44 >> 2] = $24_1;
        HEAP32[$2_1 + 32 >> 2] = $12_1;
        HEAP32[$2_1 + 36 >> 2] = $15_1;
        HEAP32[$2_1 + 24 >> 2] = $16_1;
        HEAP32[$2_1 + 28 >> 2] = $23_1;
        HEAP32[$2_1 + 16 >> 2] = $5_1;
        HEAP32[$2_1 + 20 >> 2] = $20_1;
        HEAP32[$2_1 + 8 >> 2] = $17_1;
        HEAP32[$2_1 + 12 >> 2] = $18_1;
        label$8: {
          if (($21_1 | 0) == 1048574 & $6_1 >>> 0 < 4294966319 | $21_1 >>> 0 < 1048574) {
            break label$8;
          }
          if (($10_1 & $11_1 & $4_1) != -1 | ($25_1 & $19_1 & $14_1) != 1048575) {
            break label$8;
          }
          if (($9_1 | 0) != -1 | ($13_1 | 0) != 65535) {
            break label$8;
          }
          $3_1 = $21_1 + 1 | 0;
          $6_1 = $6_1 + 977 | 0;
          $3_1 = $6_1 >>> 0 < 977 ? $3_1 + 1 | 0 : $3_1;
          $21_1 = $3_1 & 1048575;
          $0_1 = $25_1;
          $3_1 = $3_1 >>> 20 | 0;
          $10_1 = $3_1 + $10_1 | 0;
          $0_1 = $3_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $25_1 = $0_1 & 1048575;
          $5_1 = $0_1 >>> 20 | 0;
          $3_1 = $19_1;
          $11_1 = $5_1 + $11_1 | 0;
          $3_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
          $19_1 = $3_1 & 1048575;
          $5_1 = $3_1 >>> 20 | 0;
          $3_1 = $14_1;
          $4_1 = $4_1 + $5_1 | 0;
          $3_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
          $14_1 = $3_1 & 1048575;
          $0_1 = $13_1;
          $13_1 = $9_1;
          $9_1 = ($3_1 >>> 20 | 0) + $9_1 | 0;
          $13_1 = ($13_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) & 65535;
        }
        HEAP32[$2_1 + 80 >> 2] = $9_1;
        HEAP32[$8_1 + 84 >> 2] = $13_1;
        HEAP32[$8_1 + 72 >> 2] = $4_1;
        HEAP32[$8_1 + 76 >> 2] = $14_1;
        HEAP32[$8_1 + 64 >> 2] = $11_1;
        HEAP32[$8_1 + 68 >> 2] = $19_1;
        HEAP32[$8_1 + 56 >> 2] = $10_1;
        HEAP32[$8_1 + 60 >> 2] = $25_1;
        HEAP32[$8_1 + 48 >> 2] = $6_1;
        HEAP32[$8_1 + 52 >> 2] = $21_1;
        $37($22_1 + 1 | 0, $8_1 + 8 | 0);
        label$9: {
          if ($26_1) {
            HEAP8[$22_1 | 0] = $6_1 & 1 ? 3 : 2;
            $0_1 = 33;
            break label$9;
          }
          HEAP8[$22_1 | 0] = 4;
          $37($22_1 + 33 | 0, $8_1 + 48 | 0);
          $0_1 = 65;
        }
        HEAP32[$1_1 >> 2] = $0_1;
        $14_1 = 1;
      }
      global$0 = $8_1 + 96 | 0;
      return $14_1;
    }
    function $37($0_1, $1_1) {
      HEAP8[$0_1 | 0] = HEAP32[$1_1 + 36 >> 2] >>> 8;
      HEAP8[$0_1 + 1 | 0] = HEAP32[$1_1 + 36 >> 2];
      HEAP8[$0_1 + 2 | 0] = (HEAP32[$1_1 + 36 >> 2] & 16777215) << 8 | HEAP32[$1_1 + 32 >> 2] >>> 24;
      HEAP8[$0_1 + 3 | 0] = (HEAP32[$1_1 + 36 >> 2] & 65535) << 16 | HEAP32[$1_1 + 32 >> 2] >>> 16;
      HEAP8[$0_1 + 4 | 0] = (HEAP32[$1_1 + 36 >> 2] & 255) << 24 | HEAP32[$1_1 + 32 >> 2] >>> 8;
      HEAP8[$0_1 + 5 | 0] = HEAP32[$1_1 + 32 >> 2];
      HEAP8[$0_1 + 6 | 0] = HEAP32[$1_1 + 28 >> 2] >>> 12;
      HEAP8[$0_1 + 7 | 0] = HEAP32[$1_1 + 28 >> 2] >>> 4;
      HEAP8[$0_1 + 8 | 0] = (HEAP32[$1_1 + 28 >> 2] & 268435455) << 4 | HEAP32[$1_1 + 24 >> 2] >>> 28;
      HEAP8[$0_1 + 9 | 0] = (HEAP32[$1_1 + 28 >> 2] & 1048575) << 12 | HEAP32[$1_1 + 24 >> 2] >>> 20;
      HEAP8[$0_1 + 10 | 0] = (HEAP32[$1_1 + 28 >> 2] & 4095) << 20 | HEAP32[$1_1 + 24 >> 2] >>> 12;
      HEAP8[$0_1 + 11 | 0] = (HEAP32[$1_1 + 28 >> 2] & 15) << 28 | HEAP32[$1_1 + 24 >> 2] >>> 4;
      HEAP8[$0_1 + 12 | 0] = HEAPU16[$1_1 + 22 >> 1] & 15 | HEAP32[$1_1 + 24 >> 2] << 4;
      HEAP8[$0_1 + 13 | 0] = HEAP32[$1_1 + 20 >> 2] >>> 8;
      HEAP8[$0_1 + 14 | 0] = HEAP32[$1_1 + 20 >> 2];
      HEAP8[$0_1 + 15 | 0] = (HEAP32[$1_1 + 20 >> 2] & 16777215) << 8 | HEAP32[$1_1 + 16 >> 2] >>> 24;
      HEAP8[$0_1 + 16 | 0] = (HEAP32[$1_1 + 20 >> 2] & 65535) << 16 | HEAP32[$1_1 + 16 >> 2] >>> 16;
      HEAP8[$0_1 + 17 | 0] = (HEAP32[$1_1 + 20 >> 2] & 255) << 24 | HEAP32[$1_1 + 16 >> 2] >>> 8;
      HEAP8[$0_1 + 18 | 0] = HEAP32[$1_1 + 16 >> 2];
      HEAP8[$0_1 + 19 | 0] = HEAP32[$1_1 + 12 >> 2] >>> 12;
      HEAP8[$0_1 + 20 | 0] = HEAP32[$1_1 + 12 >> 2] >>> 4;
      HEAP8[$0_1 + 21 | 0] = (HEAP32[$1_1 + 12 >> 2] & 268435455) << 4 | HEAP32[$1_1 + 8 >> 2] >>> 28;
      HEAP8[$0_1 + 22 | 0] = (HEAP32[$1_1 + 12 >> 2] & 1048575) << 12 | HEAP32[$1_1 + 8 >> 2] >>> 20;
      HEAP8[$0_1 + 23 | 0] = (HEAP32[$1_1 + 12 >> 2] & 4095) << 20 | HEAP32[$1_1 + 8 >> 2] >>> 12;
      HEAP8[$0_1 + 24 | 0] = (HEAP32[$1_1 + 12 >> 2] & 15) << 28 | HEAP32[$1_1 + 8 >> 2] >>> 4;
      HEAP8[$0_1 + 25 | 0] = HEAPU16[$1_1 + 6 >> 1] & 15 | HEAP32[$1_1 + 8 >> 2] << 4;
      HEAP8[$0_1 + 26 | 0] = HEAP32[$1_1 + 4 >> 2] >>> 8;
      HEAP8[$0_1 + 27 | 0] = HEAP32[$1_1 + 4 >> 2];
      HEAP8[$0_1 + 28 | 0] = (HEAP32[$1_1 + 4 >> 2] & 16777215) << 8 | HEAP32[$1_1 >> 2] >>> 24;
      HEAP8[$0_1 + 29 | 0] = (HEAP32[$1_1 + 4 >> 2] & 65535) << 16 | HEAP32[$1_1 >> 2] >>> 16;
      HEAP8[$0_1 + 30 | 0] = (HEAP32[$1_1 + 4 >> 2] & 255) << 24 | HEAP32[$1_1 >> 2] >>> 8;
      HEAP8[$0_1 + 31 | 0] = HEAP32[$1_1 >> 2];
    }
    function $38($0_1, $1_1, $2_1) {
      var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0;
      $6_1 = $0_1;
      $3_1 = $1_1;
      $1_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
      $5_1 = $1_1 << 8 & 16711680;
      $12_1 = $1_1 << 24 | $5_1;
      $4_1 = $1_1 >>> 8 | 0;
      $0_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
      $5_1 = ($4_1 | $0_1 << 24) & 65280;
      $1_1 = $1_1 >>> 24 | 0;
      $5_1 = $12_1 | ($5_1 | ($1_1 | $0_1 << 8) & 255);
      $4_1 = ($1_1 | ($0_1 & 16777215) << 8) & 16711680 | ($4_1 | ($0_1 & 255) << 24) & -16777216;
      $8_1 = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $4_1;
      HEAP32[$6_1 >> 2] = $8_1;
      HEAP32[$6_1 + 4 >> 2] = $5_1;
      $1_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
      $7_1 = $1_1 << 8 & 16711680 | $1_1 << 24;
      $0_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
      $4_1 = ($0_1 << 24 | $1_1 >>> 8) & 65280;
      $12_1 = $7_1 | ($4_1 | ($0_1 << 8 | $1_1 >>> 24) & 255);
      $4_1 = (($0_1 & 255) << 24 | $1_1 >>> 8) & -16777216;
      $7_1 = $4_1 | (($0_1 & 16777215) << 8 | $1_1 >>> 24) & 16711680;
      $15_1 = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $7_1;
      HEAP32[$6_1 + 8 >> 2] = $15_1;
      $9_1 = $12_1;
      HEAP32[$6_1 + 12 >> 2] = $9_1;
      $1_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
      $7_1 = $1_1 << 8 & 16711680;
      $13_1 = $1_1 << 24 | $7_1;
      $0_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
      $7_1 = ($0_1 << 24 | $1_1 >>> 8) & 65280;
      $7_1 = $13_1 | ($7_1 | ($0_1 << 8 | $1_1 >>> 24) & 255);
      $4_1 = (($0_1 & 255) << 24 | $1_1 >>> 8) & -16777216;
      $4_1 = $4_1 | (($0_1 & 16777215) << 8 | $1_1 >>> 24) & 16711680;
      $14_1 = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $4_1;
      HEAP32[$6_1 + 16 >> 2] = $14_1;
      $13_1 = $7_1;
      HEAP32[$6_1 + 20 >> 2] = $7_1;
      $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
      $1_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
      $7_1 = $1_1 << 8 & 16711680 | $1_1 << 24;
      $12_1 = $7_1 | (($0_1 << 8 | $1_1 >>> 24) & 255 | ($0_1 << 24 | $1_1 >>> 8) & 65280);
      $3_1 = (($0_1 & 255) << 24 | $1_1 >>> 8) & -16777216;
      $10_1 = $3_1 | (($0_1 & 16777215) << 8 | $1_1 >>> 24) & 16711680;
      $7_1 = $0_1 >>> 8 & 65280;
      $1_1 = $0_1 >>> 24 | 0;
      $0_1 = $12_1;
      $3_1 = ($13_1 | 0) == -1;
      $7_1 = $1_1 | $7_1 | $10_1;
      $1_1 = $3_1 & $14_1 >>> 0 < 4294967294 | ($13_1 | 0) != -1 | ($0_1 & $7_1) != -1;
      $4_1 = ($9_1 | 0) == -1162945306;
      $0_1 = ($1_1 | ($4_1 & $15_1 >>> 0 < 2940772411 | $9_1 >>> 0 < 3132021990)) ^ -1;
      $10_1 = $0_1 & (($5_1 | 0) == -1076732276 & $8_1 >>> 0 > 3493216576 | $5_1 >>> 0 > 3218235020) | ($0_1 & ($4_1 & $15_1 >>> 0 > 2940772411 | $9_1 >>> 0 > 3132021990) | ($14_1 | 0) == -1 & $3_1 & ($1_1 ^ -1));
      $11_1 = __wasm_i64_mul($10_1, 0, 801750719, 1076732275);
      $4_1 = i64toi32_i32$HIGH_BITS;
      $3_1 = $4_1 + $5_1 | 0;
      $0_1 = $8_1 + $11_1 | 0;
      $3_1 = $0_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 >> 2] = $0_1;
      HEAP32[$6_1 + 4 >> 2] = $3_1;
      $1_1 = $6_1;
      $3_1 = ($3_1 | 0) == ($4_1 | 0) & $0_1 >>> 0 < $11_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $11_1 = __wasm_i64_mul($10_1, 0, 1354194884, 1162945305);
      $5_1 = i64toi32_i32$HIGH_BITS;
      $8_1 = $5_1 + $9_1 | 0;
      $6_1 = $11_1 + $15_1 | 0;
      $0_1 = $6_1 >>> 0 < $11_1 >>> 0 ? $8_1 + 1 | 0 : $8_1;
      $3_1 = $3_1 + $6_1 | 0;
      $4_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      HEAP32[$1_1 + 8 >> 2] = $3_1;
      HEAP32[$1_1 + 12 >> 2] = $4_1;
      $9_1 = ($0_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $11_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
      $0_1 = ($0_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 > $4_1 >>> 0;
      $5_1 = $9_1 + $0_1 | 0;
      $4_1 = $13_1;
      $3_1 = $0_1 >>> 0 > $5_1 >>> 0;
      $6_1 = $10_1 + $14_1 | 0;
      $0_1 = $6_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $8_1 = $3_1 + $0_1 | 0;
      $4_1 = $6_1;
      $5_1 = $4_1 + $5_1 | 0;
      $8_1 = $4_1 >>> 0 > $5_1 >>> 0 ? $8_1 + 1 | 0 : $8_1;
      HEAP32[$1_1 + 16 >> 2] = $5_1;
      HEAP32[$1_1 + 20 >> 2] = $8_1;
      $3_1 = $1_1;
      $6_1 = $7_1;
      $1_1 = !$0_1 & $4_1 >>> 0 < $10_1 >>> 0;
      $0_1 = ($0_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $5_1 >>> 0 | $0_1 >>> 0 > $8_1 >>> 0;
      $5_1 = $1_1 + $0_1 | 0;
      $1_1 = ($0_1 >>> 0 > $5_1 >>> 0) + $12_1 | 0;
      $0_1 = $5_1 + $6_1 | 0;
      $1_1 = $0_1 >>> 0 < $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      HEAP32[$3_1 + 24 >> 2] = $0_1;
      HEAP32[$3_1 + 28 >> 2] = $1_1;
      if ($2_1) {
        HEAP32[$2_1 >> 2] = $10_1;
      }
    }
    function $39($0_1, $1_1) {
      HEAP8[$0_1 | 0] = HEAPU8[$1_1 + 31 | 0];
      HEAP8[$0_1 + 1 | 0] = HEAPU16[$1_1 + 30 >> 1];
      HEAP8[$0_1 + 2 | 0] = HEAP32[$1_1 + 28 >> 2] >>> 8;
      HEAP8[$0_1 + 3 | 0] = HEAP32[$1_1 + 28 >> 2];
      HEAP8[$0_1 + 4 | 0] = (HEAP32[$1_1 + 28 >> 2] & 16777215) << 8 | HEAP32[$1_1 + 24 >> 2] >>> 24;
      HEAP8[$0_1 + 5 | 0] = (HEAP32[$1_1 + 28 >> 2] & 65535) << 16 | HEAP32[$1_1 + 24 >> 2] >>> 16;
      HEAP8[$0_1 + 6 | 0] = (HEAP32[$1_1 + 28 >> 2] & 255) << 24 | HEAP32[$1_1 + 24 >> 2] >>> 8;
      HEAP8[$0_1 + 7 | 0] = HEAP32[$1_1 + 24 >> 2];
      HEAP8[$0_1 + 8 | 0] = HEAPU8[$1_1 + 23 | 0];
      HEAP8[$0_1 + 9 | 0] = HEAPU16[$1_1 + 22 >> 1];
      HEAP8[$0_1 + 10 | 0] = HEAP32[$1_1 + 20 >> 2] >>> 8;
      HEAP8[$0_1 + 11 | 0] = HEAP32[$1_1 + 20 >> 2];
      HEAP8[$0_1 + 12 | 0] = (HEAP32[$1_1 + 20 >> 2] & 16777215) << 8 | HEAP32[$1_1 + 16 >> 2] >>> 24;
      HEAP8[$0_1 + 13 | 0] = (HEAP32[$1_1 + 20 >> 2] & 65535) << 16 | HEAP32[$1_1 + 16 >> 2] >>> 16;
      HEAP8[$0_1 + 14 | 0] = (HEAP32[$1_1 + 20 >> 2] & 255) << 24 | HEAP32[$1_1 + 16 >> 2] >>> 8;
      HEAP8[$0_1 + 15 | 0] = HEAP32[$1_1 + 16 >> 2];
      HEAP8[$0_1 + 16 | 0] = HEAPU8[$1_1 + 15 | 0];
      HEAP8[$0_1 + 17 | 0] = HEAPU16[$1_1 + 14 >> 1];
      HEAP8[$0_1 + 18 | 0] = HEAP32[$1_1 + 12 >> 2] >>> 8;
      HEAP8[$0_1 + 19 | 0] = HEAP32[$1_1 + 12 >> 2];
      HEAP8[$0_1 + 20 | 0] = (HEAP32[$1_1 + 12 >> 2] & 16777215) << 8 | HEAP32[$1_1 + 8 >> 2] >>> 24;
      HEAP8[$0_1 + 21 | 0] = (HEAP32[$1_1 + 12 >> 2] & 65535) << 16 | HEAP32[$1_1 + 8 >> 2] >>> 16;
      HEAP8[$0_1 + 22 | 0] = (HEAP32[$1_1 + 12 >> 2] & 255) << 24 | HEAP32[$1_1 + 8 >> 2] >>> 8;
      HEAP8[$0_1 + 23 | 0] = HEAP32[$1_1 + 8 >> 2];
      HEAP8[$0_1 + 24 | 0] = HEAPU8[$1_1 + 7 | 0];
      HEAP8[$0_1 + 25 | 0] = HEAPU16[$1_1 + 6 >> 1];
      HEAP8[$0_1 + 26 | 0] = HEAP32[$1_1 + 4 >> 2] >>> 8;
      HEAP8[$0_1 + 27 | 0] = HEAP32[$1_1 + 4 >> 2];
      HEAP8[$0_1 + 28 | 0] = (HEAP32[$1_1 + 4 >> 2] & 16777215) << 8 | HEAP32[$1_1 >> 2] >>> 24;
      HEAP8[$0_1 + 29 | 0] = (HEAP32[$1_1 + 4 >> 2] & 65535) << 16 | HEAP32[$1_1 >> 2] >>> 16;
      HEAP8[$0_1 + 30 | 0] = (HEAP32[$1_1 + 4 >> 2] & 255) << 24 | HEAP32[$1_1 >> 2] >>> 8;
      HEAP8[$0_1 + 31 | 0] = HEAP32[$1_1 >> 2];
    }
    function $40($0_1, $1_1) {
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0;
      $6_1 = global$0 - 320 | 0;
      global$0 = $6_1;
      $2_1 = $6_1 + 280 | 0;
      $3_1 = $2_1 + 32 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $3_1 = $2_1 + 24 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $3_1 = $2_1 + 16 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $2_1 = $2_1 + 8 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      HEAP32[$6_1 + 280 >> 2] = 0;
      HEAP32[$6_1 + 284 >> 2] = 0;
      $2_1 = $6_1 + 240 | 0;
      $3_1 = $2_1 + 32 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $3_1 = $2_1 + 24 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $2_1 = $2_1 + 16 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      HEAP32[$6_1 + 248 >> 2] = 0;
      HEAP32[$6_1 + 252 >> 2] = 0;
      HEAP32[$6_1 + 240 >> 2] = 1;
      HEAP32[$6_1 + 244 >> 2] = 0;
      $3_1 = $1_1 + 32 | 0;
      $4_1 = HEAP32[$3_1 + 4 >> 2];
      $2_1 = $6_1 + 200 | 0;
      $5_1 = $2_1 + 32 | 0;
      HEAP32[$5_1 >> 2] = HEAP32[$3_1 >> 2];
      HEAP32[$5_1 + 4 >> 2] = $4_1;
      $3_1 = $1_1 + 24 | 0;
      $4_1 = HEAP32[$3_1 + 4 >> 2];
      $5_1 = $2_1 + 24 | 0;
      HEAP32[$5_1 >> 2] = HEAP32[$3_1 >> 2];
      HEAP32[$5_1 + 4 >> 2] = $4_1;
      $3_1 = $1_1 + 16 | 0;
      $4_1 = HEAP32[$3_1 + 4 >> 2];
      $5_1 = $2_1 + 16 | 0;
      HEAP32[$5_1 >> 2] = HEAP32[$3_1 >> 2];
      HEAP32[$5_1 + 4 >> 2] = $4_1;
      $3_1 = $1_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 + 4 >> 2];
      $2_1 = $2_1 + 8 | 0;
      HEAP32[$2_1 >> 2] = HEAP32[$3_1 >> 2];
      HEAP32[$2_1 + 4 >> 2] = $4_1;
      $2_1 = HEAP32[$1_1 + 4 >> 2];
      HEAP32[$6_1 + 200 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$6_1 + 204 >> 2] = $2_1;
      $3_1 = $0_1 + 32 | 0;
      $4_1 = HEAP32[$3_1 + 4 >> 2];
      $2_1 = $6_1 + 160 | 0;
      $30_1 = $2_1 + 32 | 0;
      HEAP32[$30_1 >> 2] = HEAP32[$3_1 >> 2];
      HEAP32[$30_1 + 4 >> 2] = $4_1;
      $3_1 = $0_1 + 24 | 0;
      $4_1 = HEAP32[$3_1 + 4 >> 2];
      $5_1 = $2_1 + 24 | 0;
      HEAP32[$5_1 >> 2] = HEAP32[$3_1 >> 2];
      HEAP32[$5_1 + 4 >> 2] = $4_1;
      $3_1 = $0_1 + 16 | 0;
      $4_1 = HEAP32[$3_1 + 4 >> 2];
      $5_1 = $2_1 + 16 | 0;
      HEAP32[$5_1 >> 2] = HEAP32[$3_1 >> 2];
      HEAP32[$5_1 + 4 >> 2] = $4_1;
      $3_1 = $0_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 + 4 >> 2];
      $2_1 = $2_1 + 8 | 0;
      HEAP32[$2_1 >> 2] = HEAP32[$3_1 >> 2];
      HEAP32[$2_1 + 4 >> 2] = $4_1;
      $2_1 = HEAP32[$0_1 + 4 >> 2];
      HEAP32[$6_1 + 160 >> 2] = HEAP32[$0_1 >> 2];
      HEAP32[$6_1 + 164 >> 2] = $2_1;
      $24_1 = 5;
      $22_1 = -1;
      $25_1 = -1;
      while (1) {
        $2_1 = $22_1;
        $20_1 = HEAP32[$6_1 + 160 >> 2];
        $16_1 = HEAP32[$6_1 + 164 >> 2];
        $3_1 = __wasm_ctz_i64($20_1, $16_1 | -1073741824);
        $22_1 = $2_1 - $3_1 | 0;
        $25_1 = $25_1 - (i64toi32_i32$HIGH_BITS + ($2_1 >>> 0 < $3_1 >>> 0) | 0) | 0;
        $2_1 = $3_1 & 31;
        if (($3_1 & 63) >>> 0 >= 32) {
          $8_1 = 0;
          $14_1 = 1 << $2_1;
        } else {
          $8_1 = 1 << $2_1;
          $14_1 = $8_1 - 1 & 1 >>> 32 - $2_1;
        }
        $28_1 = HEAP32[$6_1 + 200 >> 2];
        $26_1 = HEAP32[$6_1 + 204 >> 2];
        $5_1 = $3_1;
        label$2: {
          if (($3_1 | 0) == 62) {
            $7_1 = 0;
            $5_1 = 0;
            $13_1 = 1;
            $11_1 = 0;
            $21_1 = 0;
            $18_1 = 0;
            break label$2;
          }
          $3_1 = $5_1 & 31;
          if (($5_1 & 63) >>> 0 >= 32) {
            $4_1 = $16_1 >>> $3_1 | 0;
            $3_1 = 0;
          } else {
            $4_1 = ((1 << $3_1) - 1 & $16_1) << 32 - $3_1 | $20_1 >>> $3_1;
            $3_1 = $16_1 >>> $3_1 | 0;
          }
          $12_1 = 62 - $5_1 | 0;
          $13_1 = 1;
          $11_1 = 0;
          $21_1 = 0;
          $18_1 = 0;
          $10_1 = $28_1;
          $9_1 = $26_1;
          $7_1 = 0;
          $5_1 = 0;
          while (1) {
            label$5: {
              if (($25_1 | 0) < 0) {
                $2_1 = __wasm_i64_mul($4_1, $3_1, $4_1, $3_1);
                $17_1 = $2_1 - 2 | 0;
                $23_1 = i64toi32_i32$HIGH_BITS - ($2_1 >>> 0 < 2) | 0;
                $19_1 = 0 - $10_1 | 0;
                $2_1 = 0 - ((($10_1 | 0) != 0) + $9_1 | 0) | 0;
                $10_1 = __wasm_i64_mul($17_1, $23_1, __wasm_i64_mul($19_1, $2_1, $4_1, $3_1), i64toi32_i32$HIGH_BITS);
                $25_1 = 0 - ((($22_1 | 0) != 0) + $25_1 | 0) | 0;
                $22_1 = 0 - $22_1 | 0;
                $9_1 = $22_1 + 1 | 0;
                $15_1 = 64 - (($9_1 | 0) > ($12_1 | 0) ? $12_1 : $9_1) | 0;
                $9_1 = $15_1 & 31;
                if (($15_1 & 63) >>> 0 >= 32) {
                  $9_1 = -1 >>> $9_1 | 0;
                } else {
                  $9_1 = (1 << $9_1) - 1 << 32 - $9_1 | -1 >>> $9_1;
                }
                $31_1 = $9_1 & $10_1 & 63;
                $15_1 = 0 - $21_1 | 0;
                $17_1 = 0 - ((($21_1 | 0) != 0) + $18_1 | 0) | 0;
                $23_1 = 0 - $8_1 | 0;
                $33_1 = 0 - ((($8_1 | 0) != 0) + $14_1 | 0) | 0;
                $10_1 = $4_1;
                $9_1 = $3_1;
                break label$5;
              }
              $15_1 = ($10_1 << 1) + 2 | 0;
              $2_1 = $9_1;
              $17_1 = $15_1 & 8;
              $15_1 = $17_1 + $10_1 | 0;
              $15_1 = 0 - __wasm_i64_mul($15_1, $15_1 >>> 0 < $17_1 >>> 0 ? $2_1 + 1 | 0 : $2_1, $4_1, $3_1) | 0;
              $2_1 = $22_1 + 1 | 0;
              $17_1 = 64 - (($2_1 | 0) > ($12_1 | 0) ? $12_1 : $2_1) | 0;
              $2_1 = $17_1 & 31;
              if (($17_1 & 63) >>> 0 >= 32) {
                $2_1 = -1 >>> $2_1 | 0;
              } else {
                $2_1 = (1 << $2_1) - 1 << 32 - $2_1 | -1 >>> $2_1;
              }
              $31_1 = $2_1 & $15_1 & 15;
              $23_1 = $7_1;
              $33_1 = $5_1;
              $15_1 = $13_1;
              $17_1 = $11_1;
              $19_1 = $4_1;
              $2_1 = $3_1;
              $7_1 = $8_1;
              $5_1 = $14_1;
              $13_1 = $21_1;
              $11_1 = $18_1;
            }
            $8_1 = $22_1;
            $3_1 = __wasm_i64_mul($10_1, $9_1, $31_1, 0) + $19_1 | 0;
            $2_1 = i64toi32_i32$HIGH_BITS + $2_1 | 0;
            $4_1 = $3_1 >>> 0 < $19_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $2_1 = $12_1 & 31;
            if (($12_1 & 63) >>> 0 >= 32) {
              $14_1 = 0;
              $2_1 = -1 << $2_1;
            } else {
              $14_1 = -1 << $2_1;
              $2_1 = $14_1 | (1 << $2_1) - 1 & -1 >>> 32 - $2_1;
            }
            $19_1 = __wasm_ctz_i64($3_1 | $14_1, $2_1 | $4_1);
            $22_1 = $8_1 - $19_1 | 0;
            $25_1 = $25_1 - (i64toi32_i32$HIGH_BITS + ($8_1 >>> 0 < $19_1 >>> 0) | 0) | 0;
            $8_1 = $19_1 & 31;
            if (($19_1 & 63) >>> 0 >= 32) {
              $21_1 = 0;
              $18_1 = $13_1 << $8_1;
            } else {
              $21_1 = $13_1 << $8_1;
              $18_1 = (1 << $8_1) - 1 & $13_1 >>> 32 - $8_1 | $11_1 << $8_1;
            }
            $8_1 = $19_1 & 31;
            if (($19_1 & 63) >>> 0 >= 32) {
              $2_1 = $7_1 << $8_1;
              $8_1 = 0;
            } else {
              $2_1 = (1 << $8_1) - 1 & $7_1 >>> 32 - $8_1 | $5_1 << $8_1;
              $8_1 = $7_1 << $8_1;
            }
            $14_1 = $2_1;
            $29_1 = $19_1 & 31;
            if (($19_1 & 63) >>> 0 >= 32) {
              $2_1 = 0;
              $4_1 = $4_1 >>> $29_1 | 0;
            } else {
              $2_1 = $4_1 >>> $29_1 | 0;
              $4_1 = ((1 << $29_1) - 1 & $4_1) << 32 - $29_1 | $3_1 >>> $29_1;
            }
            $3_1 = $2_1;
            $13_1 = __wasm_i64_mul($13_1, $11_1, $31_1, 0) + $15_1 | 0;
            $2_1 = i64toi32_i32$HIGH_BITS + $17_1 | 0;
            $11_1 = $13_1 >>> 0 < $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $7_1 = __wasm_i64_mul($7_1, $5_1, $31_1, 0) + $23_1 | 0;
            $2_1 = i64toi32_i32$HIGH_BITS + $33_1 | 0;
            $5_1 = $7_1 >>> 0 < $23_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $12_1 = $12_1 - $19_1 | 0;
            if ($12_1) {
              continue;
            }
            break;
          }
          ;
        }
        HEAP32[$6_1 + 152 >> 2] = $13_1;
        HEAP32[$6_1 + 156 >> 2] = $11_1;
        HEAP32[$6_1 + 144 >> 2] = $7_1;
        HEAP32[$6_1 + 148 >> 2] = $5_1;
        HEAP32[$6_1 + 136 >> 2] = $21_1;
        HEAP32[$6_1 + 140 >> 2] = $18_1;
        HEAP32[$6_1 + 128 >> 2] = $8_1;
        HEAP32[$6_1 + 132 >> 2] = $14_1;
        $67($6_1 + 280 | 0, $6_1 + 240 | 0, $6_1 + 128 | 0, $1_1);
        $23_1 = $14_1;
        $2_1 = $14_1 >> 31;
        $14_1 = $2_1;
        $10_1 = $2_1;
        $2_1 = $26_1 >> 31;
        $9_1 = $6_1 + 112 | 0;
        $19_1 = $8_1;
        $3_1 = $2_1;
        $69($9_1, $8_1, $23_1, $10_1, $10_1, $28_1, $26_1, $2_1, $2_1);
        $33_1 = $21_1;
        $2_1 = $18_1 >> 31;
        $21_1 = $2_1;
        $8_1 = $2_1;
        $2_1 = $16_1 >> 31;
        $10_1 = $6_1 + 80 | 0;
        $29_1 = $18_1;
        $4_1 = $2_1;
        $69($10_1, $33_1, $18_1, $8_1, $8_1, $20_1, $16_1, $2_1, $2_1);
        $2_1 = $5_1 >> 31;
        $8_1 = $6_1 + 96 | 0;
        $31_1 = $7_1;
        $42_1 = $5_1;
        $36_1 = $2_1;
        $69($8_1, $7_1, $5_1, $2_1, $2_1, $28_1, $26_1, $3_1, $3_1);
        $2_1 = $11_1 >> 31;
        $12_1 = $6_1 - -64 | 0;
        $28_1 = $13_1;
        $26_1 = $11_1;
        $37_1 = $2_1;
        $69($12_1, $13_1, $11_1, $2_1, $2_1, $20_1, $16_1, $4_1, $4_1);
        $7_1 = HEAP32[$6_1 + 80 >> 2];
        $4_1 = HEAP32[$6_1 + 112 >> 2];
        $3_1 = $7_1 + $4_1 | 0;
        $5_1 = HEAP32[$6_1 + 84 >> 2];
        $2_1 = $5_1 + HEAP32[$6_1 + 116 >> 2] | 0;
        $2_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $3_1;
        $3_1 = $2_1;
        $5_1 = ($5_1 | 0) == ($2_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $5_1 >>> 0;
        $2_1 = $9_1 + 8 | 0;
        $7_1 = HEAP32[$2_1 >> 2];
        $9_1 = $10_1 + 8 | 0;
        $4_1 = $7_1 + HEAP32[$9_1 >> 2] | 0;
        $2_1 = HEAP32[$9_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
        $2_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $7_1 = $4_1;
        $4_1 = $4_1 + $5_1 | 0;
        $5_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $7_1 = $5_1 << 2 | $4_1 >>> 30;
        $4_1 = $4_1 << 2 | $3_1 >>> 30;
        $3_1 = $7_1;
        $11_1 = HEAP32[$6_1 + 64 >> 2];
        $9_1 = HEAP32[$6_1 + 96 >> 2];
        $7_1 = $11_1 + $9_1 | 0;
        $10_1 = HEAP32[$6_1 + 68 >> 2];
        $2_1 = $10_1 + HEAP32[$6_1 + 100 >> 2] | 0;
        $2_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $9_1 = $7_1;
        $7_1 = $2_1;
        $10_1 = ($10_1 | 0) == ($2_1 | 0) & $9_1 >>> 0 < $11_1 >>> 0 | $2_1 >>> 0 < $10_1 >>> 0;
        $2_1 = $8_1 + 8 | 0;
        $11_1 = HEAP32[$2_1 >> 2];
        $8_1 = $12_1 + 8 | 0;
        $9_1 = $11_1 + HEAP32[$8_1 >> 2] | 0;
        $2_1 = HEAP32[$8_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
        $2_1 = $9_1 >>> 0 < $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $8_1 = $9_1;
        $9_1 = $10_1 + $9_1 | 0;
        $11_1 = $8_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $8_1 = $11_1 << 2 | $9_1 >>> 30;
        $10_1 = $9_1 << 2 | $7_1 >>> 30;
        $9_1 = $8_1;
        $38_1 = ($24_1 | 0) < 2;
        if (!$38_1) {
          $2_1 = $5_1 >> 31;
          $5_1 = $5_1 >> 30;
          $8_1 = $2_1;
          $15_1 = $11_1 >> 30;
          $17_1 = $11_1 >> 31;
          $27_1 = $24_1 - 1 | 0;
          $12_1 = $6_1 + 160 | 0;
          $11_1 = $6_1 + 200 | 0;
          while (1) {
            $13_1 = $11_1 + 8 | 0;
            $16_1 = HEAP32[$13_1 >> 2];
            $2_1 = HEAP32[$13_1 + 4 >> 2];
            $20_1 = $2_1;
            $2_1 = $2_1 >> 31;
            $7_1 = $2_1;
            $69($6_1, $16_1, $20_1, $2_1, $2_1, $19_1, $23_1, $14_1, $14_1);
            $39_1 = $6_1 + 32 | 0;
            $18_1 = $12_1 + 8 | 0;
            $34_1 = HEAP32[$18_1 >> 2];
            $2_1 = HEAP32[$18_1 + 4 >> 2];
            $32_1 = $2_1;
            $2_1 = $2_1 >> 31;
            $69($39_1, $34_1, $32_1, $2_1, $2_1, $33_1, $29_1, $21_1, $21_1);
            $40_1 = $6_1 + 16 | 0;
            $69($40_1, $16_1, $20_1, $7_1, $7_1, $31_1, $42_1, $36_1, $36_1);
            $41_1 = $6_1 + 48 | 0;
            $69($41_1, $34_1, $32_1, $2_1, $2_1, $28_1, $26_1, $37_1, $37_1);
            $7_1 = HEAP32[$6_1 >> 2];
            $43_1 = $7_1;
            $32_1 = HEAP32[$6_1 + 4 >> 2];
            $2_1 = $32_1 + $3_1 | 0;
            $16_1 = $4_1 + $7_1 | 0;
            $4_1 = $16_1 >>> 0 < $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $2_1 = $4_1 + HEAP32[$6_1 + 36 >> 2] | 0;
            $3_1 = HEAP32[$6_1 + 32 >> 2];
            $7_1 = $3_1 + $16_1 | 0;
            $20_1 = $7_1;
            HEAP32[$11_1 >> 2] = $7_1;
            $3_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            HEAP32[$11_1 + 4 >> 2] = $3_1 & 1073741823;
            $7_1 = HEAP32[$6_1 + 16 >> 2];
            $44_1 = $7_1;
            $35_1 = HEAP32[$6_1 + 20 >> 2];
            $2_1 = $35_1 + $9_1 | 0;
            $11_1 = $7_1 + $10_1 | 0;
            $10_1 = $11_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $2_1 = $10_1 + HEAP32[$6_1 + 52 >> 2] | 0;
            $7_1 = HEAP32[$6_1 + 48 >> 2];
            $9_1 = $7_1 + $11_1 | 0;
            $34_1 = $9_1;
            HEAP32[$12_1 >> 2] = $9_1;
            $7_1 = $7_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            HEAP32[$12_1 + 4 >> 2] = $7_1 & 1073741823;
            $9_1 = ($3_1 | 0) == ($4_1 | 0) & $16_1 >>> 0 > $20_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
            $2_1 = $39_1 + 8 | 0;
            $12_1 = HEAP32[$2_1 >> 2];
            $20_1 = HEAP32[$2_1 + 4 >> 2];
            $16_1 = ($4_1 | 0) == ($32_1 | 0) & $16_1 >>> 0 < $43_1 >>> 0 | $4_1 >>> 0 < $32_1 >>> 0;
            $2_1 = $6_1 + 8 | 0;
            $4_1 = HEAP32[$2_1 >> 2] + $5_1 | 0;
            $2_1 = HEAP32[$2_1 + 4 >> 2] + $8_1 | 0;
            $2_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $8_1 = $4_1;
            $4_1 = $4_1 + $16_1 | 0;
            $2_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $20_1 | 0;
            $8_1 = $4_1;
            $4_1 = $4_1 + $12_1 | 0;
            $2_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $8_1 = $4_1;
            $4_1 = $4_1 + $9_1 | 0;
            $9_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $2_1 = $9_1 >> 31;
            $5_1 = $9_1 >> 30;
            $8_1 = $2_1;
            $12_1 = ($7_1 | 0) == ($10_1 | 0) & $11_1 >>> 0 > $34_1 >>> 0 | $7_1 >>> 0 < $10_1 >>> 0;
            $2_1 = $41_1 + 8 | 0;
            $16_1 = HEAP32[$2_1 >> 2];
            $20_1 = HEAP32[$2_1 + 4 >> 2];
            $11_1 = ($10_1 | 0) == ($35_1 | 0) & $11_1 >>> 0 < $44_1 >>> 0 | $10_1 >>> 0 < $35_1 >>> 0;
            $2_1 = $40_1 + 8 | 0;
            $10_1 = HEAP32[$2_1 >> 2] + $15_1 | 0;
            $2_1 = HEAP32[$2_1 + 4 >> 2] + $17_1 | 0;
            $2_1 = $10_1 >>> 0 < $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $17_1 = $10_1;
            $10_1 = $10_1 + $11_1 | 0;
            $2_1 = ($17_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $20_1 | 0;
            $11_1 = $10_1;
            $10_1 = $10_1 + $16_1 | 0;
            $2_1 = $11_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $11_1 = $10_1;
            $10_1 = $10_1 + $12_1 | 0;
            $11_1 = $11_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $2_1 = $11_1 >> 31;
            $15_1 = $11_1 >> 30;
            $17_1 = $2_1;
            $9_1 = $9_1 << 2 | $4_1 >>> 30;
            $4_1 = $4_1 << 2 | $3_1 >>> 30;
            $3_1 = $9_1;
            $11_1 = $11_1 << 2 | $10_1 >>> 30;
            $10_1 = $10_1 << 2 | $7_1 >>> 30;
            $9_1 = $11_1;
            $11_1 = $13_1;
            $12_1 = $18_1;
            $27_1 = $27_1 - 1 | 0;
            if ($27_1) {
              continue;
            }
            break;
          }
          ;
        }
        $8_1 = $24_1 - 1 | 0;
        $2_1 = $8_1 << 3;
        $5_1 = $2_1 + ($6_1 + 160 | 0) | 0;
        HEAP32[$5_1 >> 2] = $10_1;
        HEAP32[$5_1 + 4 >> 2] = $9_1;
        $2_1 = ($6_1 + 200 | 0) + $2_1 | 0;
        HEAP32[$2_1 >> 2] = $4_1;
        HEAP32[$2_1 + 4 >> 2] = $3_1;
        label$9: {
          if (!(HEAP32[$6_1 + 164 >> 2] | HEAP32[$6_1 + 160 >> 2])) {
            if ($38_1) {
              break label$9;
            }
            $11_1 = $8_1 & 3;
            label$11: {
              if ($24_1 - 2 >>> 0 < 3) {
                $7_1 = 0;
                $5_1 = 0;
                $2_1 = 1;
                break label$11;
              }
              $2_1 = $8_1 & -4;
              $27_1 = 0;
              $7_1 = 0;
              $5_1 = 0;
              $12_1 = $30_1;
              while (1) {
                $14_1 = $12_1 - 8 | 0;
                $13_1 = $12_1 - 16 | 0;
                $21_1 = $12_1 - 24 | 0;
                $7_1 = HEAP32[$12_1 >> 2] | (HEAP32[$14_1 >> 2] | (HEAP32[$13_1 >> 2] | (HEAP32[$21_1 >> 2] | $7_1)));
                $5_1 = HEAP32[$12_1 + 4 >> 2] | (HEAP32[$14_1 + 4 >> 2] | (HEAP32[$13_1 + 4 >> 2] | (HEAP32[$21_1 + 4 >> 2] | $5_1)));
                $12_1 = $12_1 + 32 | 0;
                $27_1 = $27_1 + 4 | 0;
                if (($2_1 | 0) != ($27_1 | 0)) {
                  continue;
                }
                break;
              }
              ;
              $2_1 = $27_1 + 1 | 0;
            }
            if ($11_1) {
              $12_1 = ($6_1 + 160 | 0) + ($2_1 << 3) | 0;
              while (1) {
                $7_1 = HEAP32[$12_1 >> 2] | $7_1;
                $5_1 = HEAP32[$12_1 + 4 >> 2] | $5_1;
                $12_1 = $12_1 + 8 | 0;
                $11_1 = $11_1 - 1 | 0;
                if ($11_1) {
                  continue;
                }
                break;
              }
              ;
            }
            if (!($5_1 | $7_1)) {
              break label$9;
            }
          }
          $2_1 = $9_1 >> 31;
          $5_1 = $2_1 ^ $10_1;
          $7_1 = $2_1 ^ $9_1;
          $2_1 = ($24_1 >> 31) - ($24_1 >>> 0 < 2) >> 31;
          $5_1 = $2_1 | $5_1;
          $7_1 = $2_1 | $7_1;
          $2_1 = $3_1 >> 31;
          if ($5_1 | $2_1 ^ $4_1 | ($7_1 | $2_1 ^ $3_1)) {
            continue;
          }
          $7_1 = ($24_1 << 3) - 16 | 0;
          $2_1 = $7_1 + ($6_1 + 200 | 0) | 0;
          $14_1 = HEAP32[$2_1 + 4 >> 2];
          HEAP32[$2_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$2_1 + 4 >> 2] = $4_1 << 30 | $14_1;
          $2_1 = ($6_1 + 160 | 0) + $7_1 | 0;
          $5_1 = HEAP32[$2_1 + 4 >> 2];
          HEAP32[$2_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$2_1 + 4 >> 2] = $10_1 << 30 | $5_1;
          $24_1 = $8_1;
          continue;
        }
        break;
      }
      ;
      $2_1 = $3_1 >> 31;
      $3_1 = $2_1;
      $11_1 = $6_1 + 280 | 0;
      $2_1 = $11_1 + 32 | 0;
      $8_1 = HEAP32[$2_1 >> 2];
      $2_1 = HEAP32[$2_1 + 4 >> 2];
      $14_1 = $2_1;
      $2_1 = $2_1 >> 31;
      $4_1 = $2_1;
      $9_1 = HEAP32[$1_1 >> 2];
      $13_1 = $2_1 & $9_1;
      $5_1 = $13_1 + HEAP32[$6_1 + 280 >> 2] | 0;
      $10_1 = HEAP32[$1_1 + 4 >> 2];
      $2_1 = HEAP32[$6_1 + 284 >> 2] + ($10_1 & $2_1) | 0;
      $2_1 = $5_1 >>> 0 < $13_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $5_1 = $3_1 ^ $5_1;
      $25_1 = $5_1 - $3_1 | 0;
      $5_1 = ($2_1 ^ $3_1) - (($3_1 >>> 0 > $5_1 >>> 0) + $3_1 | 0) | 0;
      $7_1 = $0_1;
      $12_1 = $9_1;
      $21_1 = $10_1;
      $0_1 = HEAP32[$1_1 + 32 >> 2];
      $16_1 = $0_1;
      $9_1 = $0_1 & $4_1;
      $0_1 = $9_1 + $8_1 | 0;
      $20_1 = HEAP32[$1_1 + 36 >> 2];
      $2_1 = $14_1 + ($20_1 & $4_1) | 0;
      $2_1 = $0_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = $0_1 ^ $3_1;
      $13_1 = $0_1 - $3_1 | 0;
      $22_1 = ($2_1 ^ $3_1) - (($0_1 >>> 0 < $3_1 >>> 0) + $3_1 | 0) | 0;
      $0_1 = HEAP32[$1_1 + 24 >> 2];
      $28_1 = $0_1;
      $10_1 = $0_1 & $4_1;
      $9_1 = $11_1 + 24 | 0;
      $0_1 = $10_1 + HEAP32[$9_1 >> 2] | 0;
      $26_1 = HEAP32[$1_1 + 28 >> 2];
      $2_1 = HEAP32[$9_1 + 4 >> 2] + ($26_1 & $4_1) | 0;
      $2_1 = $0_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = $0_1 ^ $3_1;
      $14_1 = $0_1 - $3_1 | 0;
      $17_1 = ($2_1 ^ $3_1) - (($0_1 >>> 0 < $3_1 >>> 0) + $3_1 | 0) | 0;
      $0_1 = HEAP32[$1_1 + 16 >> 2];
      $24_1 = $0_1;
      $8_1 = $0_1 & $4_1;
      $10_1 = $11_1 + 16 | 0;
      $0_1 = $8_1 + HEAP32[$10_1 >> 2] | 0;
      $19_1 = HEAP32[$1_1 + 20 >> 2];
      $2_1 = HEAP32[$10_1 + 4 >> 2] + ($19_1 & $4_1) | 0;
      $2_1 = $0_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = $0_1 ^ $3_1;
      $8_1 = $0_1 - $3_1 | 0;
      $15_1 = ($2_1 ^ $3_1) - (($0_1 >>> 0 < $3_1 >>> 0) + $3_1 | 0) | 0;
      $23_1 = HEAP32[$1_1 + 8 >> 2];
      $18_1 = $23_1 & $4_1;
      $11_1 = $11_1 + 8 | 0;
      $0_1 = $18_1 + HEAP32[$11_1 >> 2] | 0;
      $30_1 = HEAP32[$1_1 + 12 >> 2];
      $2_1 = HEAP32[$11_1 + 4 >> 2] + ($30_1 & $4_1) | 0;
      $2_1 = $0_1 >>> 0 < $18_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = $0_1 ^ $3_1;
      $1_1 = $0_1 - $3_1 | 0;
      $2_1 = (($2_1 ^ $3_1) - (($0_1 >>> 0 < $3_1 >>> 0) + $3_1 | 0) | 0) + ($5_1 >> 31) | 0;
      $0_1 = $5_1 >> 30;
      $4_1 = $0_1 + $1_1 | 0;
      $18_1 = $0_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = ($18_1 >> 31) + $15_1 | 0;
      $0_1 = $18_1 >> 30;
      $8_1 = $0_1 + $8_1 | 0;
      $15_1 = $0_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = ($15_1 >> 31) + $17_1 | 0;
      $0_1 = $15_1 >> 30;
      $14_1 = $0_1 + $14_1 | 0;
      $17_1 = $0_1 >>> 0 > $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = ($17_1 >> 31) + $22_1 | 0;
      $0_1 = $17_1 >> 30;
      $13_1 = $0_1 + $13_1 | 0;
      $22_1 = $0_1 >>> 0 > $13_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = $22_1 >> 31;
      $2_1 = ($0_1 & $21_1) + ($5_1 & 1073741823) | 0;
      $3_1 = $0_1;
      $1_1 = ($3_1 & $12_1) + $25_1 | 0;
      $0_1 = $1_1 >>> 0 < $25_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $0_1 & 1073741823;
      $12_1 = $2_1;
      HEAP32[$7_1 >> 2] = $1_1;
      HEAP32[$7_1 + 4 >> 2] = $2_1;
      $2_1 = ($3_1 & $30_1) + ($18_1 & 1073741823) | 0;
      $5_1 = $4_1;
      $4_1 = ($3_1 & $23_1) + $4_1 | 0;
      $2_1 = ($0_1 >> 31) + ($5_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) | 0;
      $0_1 = $0_1 >> 30;
      $5_1 = $0_1;
      $0_1 = $0_1 + $4_1 | 0;
      $2_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $4_1 = $0_1;
      HEAP32[$11_1 >> 2] = $4_1;
      $0_1 = $2_1;
      $2_1 = $2_1 & 1073741823;
      HEAP32[$11_1 + 4 >> 2] = $2_1;
      $5_1 = $7_1 + 8 | 0;
      HEAP32[$5_1 >> 2] = $4_1;
      HEAP32[$5_1 + 4 >> 2] = $2_1;
      $2_1 = ($3_1 & $19_1) + ($15_1 & 1073741823) | 0;
      $4_1 = ($3_1 & $24_1) + $8_1 | 0;
      $2_1 = ($0_1 >> 31) + ($4_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) | 0;
      $0_1 = $0_1 >> 30;
      $8_1 = $0_1;
      $0_1 = $0_1 + $4_1 | 0;
      $2_1 = $8_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $4_1 = $0_1;
      HEAP32[$10_1 >> 2] = $4_1;
      $0_1 = $2_1;
      $2_1 = $2_1 & 1073741823;
      HEAP32[$10_1 + 4 >> 2] = $2_1;
      $5_1 = $7_1 + 16 | 0;
      HEAP32[$5_1 >> 2] = $4_1;
      HEAP32[$5_1 + 4 >> 2] = $2_1;
      $2_1 = ($3_1 & $26_1) + ($17_1 & 1073741823) | 0;
      $4_1 = ($3_1 & $28_1) + $14_1 | 0;
      $2_1 = ($0_1 >> 31) + ($4_1 >>> 0 < $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) | 0;
      $0_1 = $0_1 >> 30;
      $8_1 = $0_1;
      $0_1 = $0_1 + $4_1 | 0;
      $2_1 = $8_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $4_1 = $0_1;
      HEAP32[$9_1 >> 2] = $4_1;
      $0_1 = $2_1;
      $2_1 = $2_1 & 1073741823;
      HEAP32[$9_1 + 4 >> 2] = $2_1;
      $5_1 = $7_1 + 24 | 0;
      HEAP32[$5_1 >> 2] = $4_1;
      HEAP32[$5_1 + 4 >> 2] = $2_1;
      $5_1 = $7_1 + 32 | 0;
      $2_1 = ($3_1 & $20_1) + $22_1 | 0;
      $3_1 = ($3_1 & $16_1) + $13_1 | 0;
      $2_1 = ($0_1 >> 31) + ($3_1 >>> 0 < $13_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) | 0;
      $0_1 = $0_1 >> 30;
      $4_1 = $0_1;
      $0_1 = $0_1 + $3_1 | 0;
      $2_1 = $4_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$5_1 >> 2] = $0_1;
      HEAP32[$5_1 + 4 >> 2] = $2_1;
      HEAP32[$6_1 + 280 >> 2] = $1_1;
      HEAP32[$6_1 + 284 >> 2] = $12_1;
      global$0 = $6_1 + 320 | 0;
    }
    function $41($0_1, $1_1, $2_1) {
      var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0;
      $5_1 = global$0 - 288 | 0;
      global$0 = $5_1;
      $66($5_1 + 224 | 0, $1_1, $2_1);
      $3_1 = $5_1 + 208 | 0;
      $22_1 = HEAP32[$5_1 + 256 >> 2];
      $17_1 = HEAP32[$5_1 + 260 >> 2];
      $69($3_1, $22_1, $17_1, 0, 0, 801750719, 1076732275, 0, 0);
      $18_1 = $5_1 + 176 | 0;
      $29_1 = HEAP32[$5_1 + 264 >> 2];
      $24_1 = HEAP32[$5_1 + 268 >> 2];
      $69($18_1, $29_1, $24_1, 0, 0, 801750719, 1076732275, 0, 0);
      $11_1 = $5_1 + 192 | 0;
      $69($11_1, $22_1, $17_1, 0, 0, 1354194884, 1162945305, 0, 0);
      $21_1 = $5_1 + 144 | 0;
      $30_1 = HEAP32[$5_1 + 272 >> 2];
      $26_1 = HEAP32[$5_1 + 276 >> 2];
      $69($21_1, $30_1, $26_1, 0, 0, 801750719, 1076732275, 0, 0);
      $16_1 = $5_1 + 160 | 0;
      $69($16_1, $29_1, $24_1, 0, 0, 1354194884, 1162945305, 0, 0);
      $27_1 = $5_1 + 112 | 0;
      $23_1 = HEAP32[$5_1 + 280 >> 2];
      $28_1 = HEAP32[$5_1 + 284 >> 2];
      $69($27_1, $23_1, $28_1, 0, 0, 801750719, 1076732275, 0, 0);
      $25_1 = $5_1 + 128 | 0;
      $69($25_1, $30_1, $26_1, 0, 0, 1354194884, 1162945305, 0, 0);
      $31_1 = $5_1 + 96 | 0;
      $69($31_1, $23_1, $28_1, 0, 0, 1354194884, 1162945305, 0, 0);
      $4_1 = HEAP32[$5_1 + 224 >> 2];
      $2_1 = HEAP32[$5_1 + 208 >> 2];
      $13_1 = $4_1 + $2_1 | 0;
      $8_1 = HEAP32[$5_1 + 228 >> 2];
      $1_1 = $8_1 + HEAP32[$5_1 + 212 >> 2] | 0;
      $19_1 = $2_1 >>> 0 > $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $4_1 = ($8_1 | 0) == ($19_1 | 0) & $4_1 >>> 0 > $13_1 >>> 0 | $8_1 >>> 0 > $19_1 >>> 0;
      $10_1 = HEAP32[$5_1 + 232 >> 2];
      $1_1 = $3_1 + 8 | 0;
      $2_1 = HEAP32[$1_1 >> 2];
      $3_1 = $10_1 + $2_1 | 0;
      $12_1 = HEAP32[$5_1 + 236 >> 2];
      $1_1 = $12_1 + HEAP32[$1_1 + 4 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = $3_1 + $4_1 | 0;
      $4_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $4_1 + HEAP32[$5_1 + 180 >> 2] | 0;
      $8_1 = $2_1;
      $2_1 = HEAP32[$5_1 + 176 >> 2];
      $3_1 = $8_1 + $2_1 | 0;
      $6_1 = HEAP32[$5_1 + 192 >> 2];
      $14_1 = $3_1 + $6_1 | 0;
      $2_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $2_1 + HEAP32[$5_1 + 196 >> 2] | 0;
      $15_1 = $6_1 >>> 0 > $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $9_1 = ($2_1 | 0) == ($15_1 | 0) & $3_1 >>> 0 > $14_1 >>> 0 | $2_1 >>> 0 > $15_1 >>> 0;
      $7_1 = ($2_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $8_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
      $6_1 = ($4_1 | 0) == ($12_1 | 0) & $8_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $12_1 >>> 0;
      $2_1 = HEAP32[$5_1 + 240 >> 2];
      $12_1 = $2_1;
      $3_1 = $11_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $18_1 + 8 | 0;
      $10_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $20_1 = HEAP32[$5_1 + 244 >> 2];
      $1_1 = $20_1 + ($4_1 >>> 0 > $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) | 0;
      $2_1 = $2_1 + $10_1 | 0;
      $1_1 = $2_1 >>> 0 < $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $6_1 | 0;
      $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $7_1 | 0;
      $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $9_1 | 0;
      $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $9_1 = $2_1;
      $2_1 = HEAP32[$5_1 + 144 >> 2];
      $7_1 = $9_1 + $2_1 | 0;
      $3_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$5_1 + 148 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = HEAP32[$5_1 + 160 >> 2];
      $6_1 = $2_1 + $7_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$5_1 + 164 >> 2] | 0;
      $2_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $17_1 + $2_1 | 0;
      $8_1 = $6_1 + $22_1 | 0;
      $17_1 = $8_1 >>> 0 < $22_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $18_1 = $8_1;
      $11_1 = ($2_1 | 0) == ($17_1 | 0) & $8_1 >>> 0 < $6_1 >>> 0 | $2_1 >>> 0 > $17_1 >>> 0;
      $10_1 = ($2_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
      $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
      $6_1 = ($3_1 | 0) == ($20_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 < $20_1 >>> 0;
      $2_1 = HEAP32[$5_1 + 248 >> 2];
      $20_1 = $2_1;
      $3_1 = $16_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $21_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $22_1 = HEAP32[$5_1 + 252 >> 2];
      $1_1 = $22_1 + ($4_1 >>> 0 > $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) | 0;
      $2_1 = $2_1 + $9_1 | 0;
      $1_1 = $2_1 >>> 0 < $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $6_1 | 0;
      $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $7_1 | 0;
      $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $10_1 | 0;
      $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $11_1 | 0;
      $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $9_1 = $2_1;
      $2_1 = HEAP32[$5_1 + 112 >> 2];
      $7_1 = $9_1 + $2_1 | 0;
      $3_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$5_1 + 116 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = HEAP32[$5_1 + 128 >> 2];
      $6_1 = $2_1 + $7_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$5_1 + 132 >> 2] | 0;
      $2_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $24_1 + $2_1 | 0;
      $24_1 = $5_1 + 80 | 0;
      $16_1 = $24_1;
      $8_1 = $6_1 + $29_1 | 0;
      $21_1 = $8_1 >>> 0 < $29_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $11_1 = $8_1;
      $12_1 = ($2_1 | 0) == ($21_1 | 0) & $8_1 >>> 0 < $6_1 >>> 0 | $2_1 >>> 0 > $21_1 >>> 0;
      $10_1 = ($2_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
      $6_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
      $8_1 = ($3_1 | 0) == ($22_1 | 0) & $9_1 >>> 0 < $20_1 >>> 0 | $3_1 >>> 0 < $22_1 >>> 0;
      $1_1 = $27_1 + 8 | 0;
      $3_1 = HEAP32[$1_1 >> 2];
      $4_1 = HEAP32[$1_1 + 4 >> 2];
      $7_1 = HEAP32[$5_1 + 96 >> 2];
      $1_1 = $25_1 + 8 | 0;
      $2_1 = HEAP32[$1_1 >> 2];
      $20_1 = $7_1 + $2_1 | 0;
      $9_1 = HEAP32[$5_1 + 100 >> 2];
      $1_1 = $9_1 + HEAP32[$1_1 + 4 >> 2] | 0;
      $1_1 = ($2_1 >>> 0 > $20_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $4_1 | 0;
      $2_1 = $3_1 + $20_1 | 0;
      $1_1 = $2_1 >>> 0 < $20_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $8_1 | 0;
      $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $6_1 | 0;
      $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $10_1 | 0;
      $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $4_1 = $2_1 + $12_1 | 0;
      $2_1 = $4_1 >>> 0 < $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $26_1 + $2_1 | 0;
      $3_1 = $4_1;
      $4_1 = $3_1 + $30_1 | 0;
      $1_1 = $4_1 >>> 0 < $30_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $25_1 = $4_1;
      $10_1 = $1_1;
      $69($16_1, $4_1, $1_1, 0, 0, 801750719, 1076732275, 0, 0);
      $26_1 = $5_1 + 48 | 0;
      $6_1 = $26_1;
      $8_1 = ($1_1 | 0) == ($2_1 | 0) & $3_1 >>> 0 > $4_1 >>> 0 | $1_1 >>> 0 < $2_1 >>> 0;
      $4_1 = ($2_1 | 0) == ($9_1 | 0) & $3_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $9_1 >>> 0;
      $1_1 = $31_1 + 8 | 0;
      $2_1 = HEAP32[$1_1 >> 2];
      $3_1 = $2_1 + $23_1 | 0;
      $1_1 = $28_1 + HEAP32[$1_1 + 4 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = $3_1 + $4_1 | 0;
      $1_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $8_1 | 0;
      $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $20_1 = $2_1;
      $16_1 = $1_1;
      $69($6_1, $2_1, $1_1, 0, 0, 801750719, 1076732275, 0, 0);
      $22_1 = $5_1 - -64 | 0;
      $69($22_1, $25_1, $10_1, 0, 0, 1354194884, 1162945305, 0, 0);
      $27_1 = $5_1 + 32 | 0;
      $69($27_1, $2_1, $1_1, 0, 0, 1354194884, 1162945305, 0, 0);
      $2_1 = HEAP32[$5_1 + 80 >> 2];
      $12_1 = $2_1 + $13_1 | 0;
      $1_1 = $19_1 + HEAP32[$5_1 + 84 >> 2] | 0;
      $8_1 = $2_1 >>> 0 > $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $4_1 = ($19_1 | 0) == ($8_1 | 0) & $12_1 >>> 0 < $13_1 >>> 0 | $8_1 >>> 0 < $19_1 >>> 0;
      $1_1 = $24_1 + 8 | 0;
      $2_1 = HEAP32[$1_1 >> 2];
      $3_1 = $2_1 + $14_1 | 0;
      $1_1 = $15_1 + HEAP32[$1_1 + 4 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = $3_1 + $4_1 | 0;
      $4_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $4_1 + HEAP32[$5_1 + 52 >> 2] | 0;
      $7_1 = $2_1;
      $2_1 = HEAP32[$5_1 + 48 >> 2];
      $3_1 = $7_1 + $2_1 | 0;
      $6_1 = HEAP32[$5_1 + 64 >> 2];
      $13_1 = $3_1 + $6_1 | 0;
      $2_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $2_1 + HEAP32[$5_1 + 68 >> 2] | 0;
      $23_1 = ($16_1 | 0) == ($28_1 | 0) & $20_1 >>> 0 < $23_1 >>> 0 | $16_1 >>> 0 < $28_1 >>> 0;
      $31_1 = $23_1 ? 801750719 : 0;
      $24_1 = $23_1 ? 1076732275 : 0;
      $6_1 = $6_1 >>> 0 > $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $19_1 = ($2_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 > $13_1 >>> 0 | $2_1 >>> 0 > $6_1 >>> 0;
      $9_1 = ($2_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
      $7_1 = ($4_1 | 0) == ($15_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $4_1 >>> 0 < $15_1 >>> 0;
      $1_1 = $26_1 + 8 | 0;
      $3_1 = HEAP32[$1_1 >> 2];
      $4_1 = HEAP32[$1_1 + 4 >> 2];
      $1_1 = $22_1 + 8 | 0;
      $2_1 = HEAP32[$1_1 >> 2];
      $14_1 = $2_1 + $18_1 | 0;
      $1_1 = $17_1 + HEAP32[$1_1 + 4 >> 2] | 0;
      $1_1 = ($2_1 >>> 0 > $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $4_1 | 0;
      $2_1 = $3_1 + $14_1 | 0;
      $1_1 = $2_1 >>> 0 < $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $7_1 | 0;
      $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $9_1 | 0;
      $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $19_1 | 0;
      $3_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $3_1 + $24_1 | 0;
      $15_1 = $2_1;
      $2_1 = $2_1 + $31_1 | 0;
      $1_1 = $15_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $9_1 = $2_1;
      $2_1 = HEAP32[$5_1 + 32 >> 2];
      $7_1 = $9_1 + $2_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$5_1 + 36 >> 2] | 0;
      $2_1 = $2_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $10_1 + $2_1 | 0;
      $14_1 = $7_1 + $25_1 | 0;
      $10_1 = $14_1 >>> 0 < $25_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $25_1 = ($2_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 > $14_1 >>> 0 | $2_1 >>> 0 > $10_1 >>> 0;
      $19_1 = ($2_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
      $7_1 = ($3_1 | 0) == ($4_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
      $4_1 = ($3_1 | 0) == ($17_1 | 0) & $15_1 >>> 0 < $18_1 >>> 0 | $3_1 >>> 0 < $17_1 >>> 0;
      $1_1 = $27_1 + 8 | 0;
      $2_1 = HEAP32[$1_1 >> 2];
      $3_1 = $2_1 + $11_1 | 0;
      $1_1 = $21_1 + HEAP32[$1_1 + 4 >> 2] | 0;
      $1_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = $3_1 + $4_1 | 0;
      $1_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $7_1 | 0;
      $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $19_1 | 0;
      $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $25_1 | 0;
      $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $7_1 = $2_1;
      $2_1 = $23_1 ? 1354194884 : 0;
      $3_1 = $7_1 + $2_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + ($23_1 ? 1162945305 : 0) | 0;
      $2_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $16_1 + $2_1 | 0;
      $17_1 = $5_1 + 16 | 0;
      $18_1 = $3_1 + $20_1 | 0;
      $9_1 = $18_1 >>> 0 < $20_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $15_1 = ($2_1 | 0) == ($9_1 | 0) & $3_1 >>> 0 > $18_1 >>> 0 | $2_1 >>> 0 > $9_1 >>> 0;
      $2_1 = ($2_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
      $4_1 = $23_1 + (($4_1 | 0) == ($21_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0) | 0;
      $1_1 = $23_1 >>> 0 > $4_1 >>> 0;
      $2_1 = $2_1 + $4_1 | 0;
      $1_1 = $2_1 >>> 0 < $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $11_1 = $2_1 + $15_1 | 0;
      $1_1 = $11_1 >>> 0 < $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $15_1 = $1_1;
      $69($17_1, $11_1, $1_1, 0, 0, 801750719, 1076732275, 0, 0);
      $69($5_1, $11_1, $1_1, 0, 0, 1354194884, 1162945305, 0, 0);
      $2_1 = HEAP32[$5_1 + 16 >> 2];
      $16_1 = $2_1;
      $19_1 = HEAP32[$5_1 + 20 >> 2];
      $1_1 = $19_1 + $8_1 | 0;
      $4_1 = $2_1 + $12_1 | 0;
      $8_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $2_1 = HEAP32[$5_1 >> 2];
      $7_1 = $2_1;
      $21_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $21_1 + $6_1 | 0;
      $3_1 = $2_1 + $13_1 | 0;
      $2_1 = $3_1 >>> 0 < $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $6_1 = $3_1;
      $3_1 = ($8_1 | 0) == ($19_1 | 0) & $4_1 >>> 0 < $16_1 >>> 0 | $8_1 >>> 0 < $19_1 >>> 0;
      $1_1 = $17_1 + 8 | 0;
      $13_1 = $3_1 + HEAP32[$1_1 >> 2] | 0;
      $1_1 = HEAP32[$1_1 + 4 >> 2];
      $1_1 = ($3_1 >>> 0 > $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $2_1 | 0;
      $3_1 = $6_1 + $13_1 | 0;
      $12_1 = $3_1 >>> 0 < $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $13_1 = $3_1;
      $3_1 = ($2_1 | 0) == ($12_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $2_1 >>> 0 > $12_1 >>> 0;
      $2_1 = ($2_1 | 0) == ($21_1 | 0) & $6_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $21_1 >>> 0;
      $1_1 = $5_1 + 8 | 0;
      $6_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
      $1_1 = HEAP32[$1_1 + 4 >> 2];
      $1_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $7_1 = $3_1 + $6_1 | 0;
      $6_1 = $7_1 >>> 0 < $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $10_1 + $15_1 | 0;
      $3_1 = $11_1 + $14_1 | 0;
      $2_1 = $3_1 >>> 0 < $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $2_1 + $6_1 | 0;
      $16_1 = ($2_1 | 0) == ($15_1 | 0) & $3_1 >>> 0 < $11_1 >>> 0 | $2_1 >>> 0 < $15_1 >>> 0;
      $10_1 = $3_1;
      $7_1 = $3_1 + $7_1 | 0;
      $3_1 = $7_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $10_1;
      $10_1 = $7_1;
      $6_1 = ($2_1 | 0) == ($3_1 | 0) & $1_1 >>> 0 > $7_1 >>> 0 | $2_1 >>> 0 > $3_1 >>> 0;
      $2_1 = $16_1 + $6_1 | 0;
      $6_1 = $2_1 >>> 0 < $6_1 >>> 0;
      $1_1 = $9_1 + $6_1 | 0;
      $9_1 = $2_1 + $18_1 | 0;
      $1_1 = $9_1 >>> 0 < $18_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $18_1 = ($3_1 | 0) == -1;
      $7_1 = $1_1;
      $11_1 = $18_1 & $10_1 >>> 0 < 4294967294 | ($3_1 | 0) != -1 | ($1_1 & $9_1) != -1;
      $14_1 = ($12_1 | 0) == -1162945306;
      $1_1 = ($11_1 | ($14_1 & $13_1 >>> 0 < 2940772411 | $12_1 >>> 0 < 3132021990)) ^ -1;
      $11_1 = ($1_1 & (($8_1 | 0) == -1076732276 & $4_1 >>> 0 > 3493216576 | $8_1 >>> 0 > 3218235020) | ($1_1 & ($14_1 & $13_1 >>> 0 > 2940772411 | $12_1 >>> 0 > 3132021990) | ($10_1 | 0) == -1 & $18_1 & ($11_1 ^ -1))) + (($6_1 | 0) == ($7_1 | 0) & $2_1 >>> 0 > $9_1 >>> 0 | $6_1 >>> 0 > $7_1 >>> 0) | 0;
      $2_1 = __wasm_i64_mul($11_1, 0, 801750719, 1076732275);
      $6_1 = $2_1 + $4_1 | 0;
      $1_1 = $8_1 + i64toi32_i32$HIGH_BITS | 0;
      HEAP32[$0_1 >> 2] = $6_1;
      $1_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      HEAP32[$0_1 + 4 >> 2] = $1_1;
      $2_1 = $0_1;
      $8_1 = ($1_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $6_1 >>> 0 | $1_1 >>> 0 < $8_1 >>> 0;
      $0_1 = __wasm_i64_mul($11_1, 0, 1354194884, 1162945305);
      $4_1 = $0_1 + $13_1 | 0;
      $1_1 = $12_1 + i64toi32_i32$HIGH_BITS | 0;
      $1_1 = $0_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $0_1 = $1_1;
      $8_1 = $4_1 + $8_1 | 0;
      $1_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      HEAP32[$2_1 + 8 >> 2] = $8_1;
      HEAP32[$2_1 + 12 >> 2] = $1_1;
      $16_1 = ($0_1 | 0) == ($12_1 | 0) & $4_1 >>> 0 < $13_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
      $0_1 = ($0_1 | 0) == ($1_1 | 0) & $4_1 >>> 0 > $8_1 >>> 0 | $0_1 >>> 0 > $1_1 >>> 0;
      $6_1 = $16_1 + $0_1 | 0;
      $8_1 = $0_1 >>> 0 > $6_1 >>> 0;
      $1_1 = $3_1;
      $4_1 = $10_1 + $11_1 | 0;
      $0_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $0_1 + $8_1 | 0;
      $8_1 = $4_1 + $6_1 | 0;
      $1_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      HEAP32[$2_1 + 16 >> 2] = $8_1;
      HEAP32[$2_1 + 20 >> 2] = $1_1;
      $3_1 = ($0_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 < $3_1 >>> 0;
      $0_1 = ($0_1 | 0) == ($1_1 | 0) & $4_1 >>> 0 > $8_1 >>> 0 | $0_1 >>> 0 > $1_1 >>> 0;
      $4_1 = $3_1 + $0_1 | 0;
      $1_1 = $7_1 + ($0_1 >>> 0 > $4_1 >>> 0) | 0;
      $0_1 = $4_1 + $9_1 | 0;
      $1_1 = $0_1 >>> 0 < $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      HEAP32[$2_1 + 24 >> 2] = $0_1;
      HEAP32[$2_1 + 28 >> 2] = $1_1;
      global$0 = $5_1 + 288 | 0;
    }
    function $42($0_1, $1_1, $2_1, $3_1) {
      var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0, $51_1 = 0, $52_1 = 0, $53_1 = 0, $54_1 = 0, $55_1 = 0, $56_1 = 0, $57_1 = 0, $58_1 = 0, $59_1 = 0, $60_1 = 0, $61_1 = 0, $62_1 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;
      $10_1 = global$0 - 3808 | 0;
      global$0 = $10_1;
      $4_1 = $10_1 + 3696 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $10_1 + 3704 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $10_1 + 3712 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      HEAP32[$10_1 + 3688 >> 2] = 0;
      HEAP32[$10_1 + 3692 >> 2] = 0;
      HEAP32[$10_1 + 3680 >> 2] = 1;
      HEAP32[$10_1 + 3684 >> 2] = 0;
      label$1: {
        if (!(HEAP32[$1_1 + 120 >> 2] ? 0 : HEAP32[$2_1 + 24 >> 2] | (HEAP32[$2_1 + 16 >> 2] | (HEAP32[$2_1 + 8 >> 2] | HEAP32[$2_1 >> 2])) | (HEAP32[$2_1 + 28 >> 2] | (HEAP32[$2_1 + 20 >> 2] | (HEAP32[$2_1 + 12 >> 2] | HEAP32[$2_1 + 4 >> 2]))))) {
          $2_1 = 0;
          $1_1 = 0;
          break label$1;
        }
        $5_1 = global$0 - 128 | 0;
        global$0 = $5_1;
        $7_1 = $5_1 - -64 | 0;
        $66($7_1, $2_1, 690640);
        HEAP32[$5_1 + 56 >> 2] = 0;
        HEAP32[$5_1 + 60 >> 2] = 0;
        $8_1 = ((HEAP32[$5_1 + 108 >> 2] >>> 31 | 0) - 1 >>> 8 ^ -1) & 1;
        $6_1 = HEAP32[$5_1 + 112 >> 2];
        $13_1 = $8_1 + $6_1 | 0;
        $4_1 = HEAP32[$5_1 + 116 >> 2];
        HEAP32[$5_1 + 32 >> 2] = $13_1;
        $4_1 = $6_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$5_1 + 36 >> 2] = $4_1;
        $8_1 = !$4_1 & $8_1 >>> 0 > $13_1 >>> 0;
        $6_1 = HEAP32[$5_1 + 120 >> 2];
        $13_1 = $8_1 + $6_1 | 0;
        $4_1 = HEAP32[$5_1 + 124 >> 2];
        HEAP32[$5_1 + 40 >> 2] = $13_1;
        $4_1 = $6_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$5_1 + 44 >> 2] = $4_1;
        HEAP32[$5_1 + 48 >> 2] = !$4_1 & $8_1 >>> 0 > $13_1 >>> 0;
        HEAP32[$5_1 + 52 >> 2] = 0;
        $66($7_1, $2_1, 690672);
        HEAP32[$5_1 + 24 >> 2] = 0;
        HEAP32[$5_1 + 28 >> 2] = 0;
        $8_1 = ((HEAP32[$5_1 + 108 >> 2] >>> 31 | 0) - 1 >>> 8 ^ -1) & 1;
        $6_1 = HEAP32[$5_1 + 112 >> 2];
        $7_1 = $8_1 + $6_1 | 0;
        $4_1 = HEAP32[$5_1 + 116 >> 2];
        HEAP32[$5_1 >> 2] = $7_1;
        $4_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$5_1 + 4 >> 2] = $4_1;
        $6_1 = !$4_1 & $7_1 >>> 0 < $8_1 >>> 0;
        $18_1 = $5_1;
        $5_1 = HEAP32[$5_1 + 120 >> 2];
        $8_1 = $6_1 + $5_1 | 0;
        $4_1 = HEAP32[$18_1 + 124 >> 2];
        HEAP32[$18_1 + 8 >> 2] = $8_1;
        $4_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$18_1 + 12 >> 2] = $4_1;
        HEAP32[$18_1 + 16 >> 2] = !$4_1 & $6_1 >>> 0 > $8_1 >>> 0;
        HEAP32[$18_1 + 20 >> 2] = 0;
        $4_1 = $18_1 + 32 | 0;
        $41($4_1, $4_1, 690576);
        $41($18_1, $18_1, 690608);
        $8_1 = HEAP32[$18_1 >> 2];
        $6_1 = HEAP32[$18_1 + 32 >> 2];
        $5_1 = $8_1 + $6_1 | 0;
        $7_1 = HEAP32[$18_1 + 4 >> 2];
        $4_1 = $7_1 + HEAP32[$18_1 + 36 >> 2] | 0;
        $19_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $12_1 = $5_1;
        $13_1 = ($7_1 | 0) == ($19_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $7_1 >>> 0 > $19_1 >>> 0;
        $5_1 = HEAP32[$18_1 + 40 >> 2];
        $8_1 = $13_1 + $5_1 | 0;
        $4_1 = HEAP32[$18_1 + 44 >> 2];
        $7_1 = HEAP32[$18_1 + 8 >> 2];
        $6_1 = $7_1 + $8_1 | 0;
        $5_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $5_1 + HEAP32[$18_1 + 12 >> 2] | 0;
        $9_1 = !$5_1 & $8_1 >>> 0 < $13_1 >>> 0;
        $17_1 = $6_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $16_1 = $6_1;
        $5_1 = ($5_1 | 0) == ($17_1 | 0) & $8_1 >>> 0 > $6_1 >>> 0 | $5_1 >>> 0 > $17_1 >>> 0;
        $6_1 = $9_1 + $5_1 | 0;
        $9_1 = $5_1 >>> 0 > $6_1 >>> 0;
        $4_1 = $9_1 + HEAP32[$18_1 + 52 >> 2] | 0;
        $5_1 = HEAP32[$18_1 + 48 >> 2];
        $13_1 = $5_1 + $6_1 | 0;
        $7_1 = HEAP32[$18_1 + 16 >> 2];
        $8_1 = $13_1 + $7_1 | 0;
        $5_1 = $5_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $5_1 + HEAP32[$18_1 + 20 >> 2] | 0;
        $6_1 = ($5_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 > $13_1 >>> 0 | $5_1 >>> 0 < $9_1 >>> 0;
        $7_1 = $7_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $20_1 = $8_1;
        $5_1 = ($5_1 | 0) == ($7_1 | 0) & $13_1 >>> 0 > $8_1 >>> 0 | $5_1 >>> 0 > $7_1 >>> 0;
        $6_1 = $6_1 + $5_1 | 0;
        $13_1 = $5_1 >>> 0 > $6_1 >>> 0;
        $4_1 = $13_1 + HEAP32[$18_1 + 60 >> 2] | 0;
        $5_1 = HEAP32[$18_1 + 56 >> 2];
        $8_1 = $5_1 + $6_1 | 0;
        $9_1 = HEAP32[$18_1 + 24 >> 2];
        $14_1 = $8_1 + $9_1 | 0;
        $5_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $5_1 + HEAP32[$18_1 + 28 >> 2] | 0;
        $15_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $9_1 = (($5_1 | 0) == ($13_1 | 0) & $6_1 >>> 0 > $8_1 >>> 0 | $5_1 >>> 0 < $13_1 >>> 0) + (($5_1 | 0) == ($15_1 | 0) & $8_1 >>> 0 > $14_1 >>> 0 | $5_1 >>> 0 > $15_1 >>> 0) | 0;
        $6_1 = ($7_1 | 0) == -1;
        $5_1 = $6_1 & $20_1 >>> 0 < 4294967294 | ($7_1 | 0) != -1 | ($14_1 & $15_1) != -1;
        $8_1 = ($17_1 | 0) == -1162945306;
        $4_1 = ($5_1 | ($8_1 & $16_1 >>> 0 < 2940772411 | $17_1 >>> 0 < 3132021990)) ^ -1;
        $23_1 = $9_1 + ($4_1 & (($19_1 | 0) == -1076732276 & $12_1 >>> 0 > 3493216576 | $19_1 >>> 0 > 3218235020) | ($4_1 & ($8_1 & $16_1 >>> 0 > 2940772411 | $17_1 >>> 0 > 3132021990) | ($20_1 | 0) == -1 & $6_1 & ($5_1 ^ -1))) | 0;
        $6_1 = __wasm_i64_mul($23_1, 0, 801750719, 1076732275);
        $5_1 = $6_1 + $12_1 | 0;
        $4_1 = $19_1 + i64toi32_i32$HIGH_BITS | 0;
        $9_1 = $10_1 + 3720 | 0;
        HEAP32[$9_1 >> 2] = $5_1;
        $13_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$9_1 + 4 >> 2] = $13_1;
        $8_1 = $9_1;
        $6_1 = __wasm_i64_mul($23_1, 0, 1354194884, 1162945305);
        $11_1 = $6_1 + $16_1 | 0;
        $4_1 = $17_1 + i64toi32_i32$HIGH_BITS | 0;
        $5_1 = ($13_1 | 0) == ($19_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $13_1 >>> 0 < $19_1 >>> 0;
        $9_1 = $11_1 + $5_1 | 0;
        $4_1 = $6_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $4_1;
        HEAP32[$8_1 + 8 >> 2] = $9_1;
        $12_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$8_1 + 12 >> 2] = $12_1;
        $4_1 = $7_1;
        $13_1 = $20_1 + $23_1 | 0;
        $5_1 = $13_1 >>> 0 < $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = ($6_1 | 0) == ($17_1 | 0) & $11_1 >>> 0 < $16_1 >>> 0 | $6_1 >>> 0 < $17_1 >>> 0;
        $6_1 = ($6_1 | 0) == ($12_1 | 0) & $9_1 >>> 0 < $11_1 >>> 0 | $6_1 >>> 0 > $12_1 >>> 0;
        $9_1 = $4_1 + $6_1 | 0;
        $4_1 = ($6_1 >>> 0 > $9_1 >>> 0) + $5_1 | 0;
        $6_1 = $9_1 + $13_1 | 0;
        $4_1 = $6_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$8_1 + 16 >> 2] = $6_1;
        HEAP32[$8_1 + 20 >> 2] = $4_1;
        $16_1 = $8_1;
        $7_1 = ($5_1 | 0) == ($7_1 | 0) & $13_1 >>> 0 < $20_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
        $5_1 = ($4_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
        $6_1 = $7_1 + $5_1 | 0;
        $4_1 = $15_1 + ($5_1 >>> 0 > $6_1 >>> 0) | 0;
        $5_1 = $6_1 + $14_1 | 0;
        $4_1 = $5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$8_1 + 24 >> 2] = $5_1;
        HEAP32[$8_1 + 28 >> 2] = $4_1;
        $8_1 = $10_1 + 2560 | 0;
        $41($8_1, $16_1, 690704);
        $24_1 = HEAP32[$8_1 + 24 >> 2];
        $14_1 = HEAP32[$8_1 + 16 >> 2];
        $13_1 = HEAP32[$8_1 + 8 >> 2];
        $5_1 = HEAP32[$8_1 >> 2];
        $12_1 = HEAP32[$8_1 + 28 >> 2];
        $9_1 = HEAP32[$8_1 + 20 >> 2];
        $11_1 = HEAP32[$8_1 + 12 >> 2];
        $7_1 = HEAP32[$8_1 + 4 >> 2];
        $4_1 = $24_1 | ($14_1 | ($13_1 | $5_1)) | ($12_1 | ($9_1 | ($11_1 | $7_1))) ? -1 : 0;
        $20_1 = $5_1 ^ -1;
        $6_1 = $20_1 - 801750718 | 0;
        $23_1 = $4_1 & $6_1;
        HEAP32[$8_1 >> 2] = $23_1;
        $5_1 = $4_1;
        $7_1 = $7_1 ^ -1;
        $4_1 = $7_1 - (($20_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
        $15_1 = $5_1 & $4_1;
        HEAP32[$8_1 + 4 >> 2] = $15_1;
        $6_1 = ($4_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 < $20_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
        $13_1 = $13_1 ^ -1;
        $19_1 = $6_1 + $13_1 | 0;
        $20_1 = $11_1 ^ -1;
        $4_1 = $20_1;
        $7_1 = $19_1 - 1354194885 | 0;
        $17_1 = $7_1 & $5_1;
        HEAP32[$8_1 + 8 >> 2] = $17_1;
        $4_1 = $6_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $11_1 = $4_1 - (($19_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
        $6_1 = $11_1 & $5_1;
        HEAP32[$8_1 + 12 >> 2] = $6_1;
        $7_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 < $19_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
        $13_1 = $7_1 + (($4_1 | 0) == ($20_1 | 0) & $13_1 >>> 0 > $19_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0) | 0;
        $20_1 = $14_1 ^ -1;
        $30_1 = $20_1 + $13_1 | 0;
        $14_1 = $9_1 ^ -1;
        $4_1 = $14_1 + ($7_1 >>> 0 > $13_1 >>> 0) | 0;
        $4_1 = $20_1 >>> 0 > $30_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $11_1 = $4_1 - ($30_1 >>> 0 < 2) | 0;
        $13_1 = $11_1 & $5_1;
        $19_1 = $13_1;
        $7_1 = $30_1 - 2 | 0;
        $9_1 = $7_1 & $5_1;
        HEAP32[$8_1 + 16 >> 2] = $9_1;
        HEAP32[$8_1 + 20 >> 2] = $13_1;
        $7_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
        $13_1 = $7_1 + (($4_1 | 0) == ($14_1 | 0) & $20_1 >>> 0 > $30_1 >>> 0 | $4_1 >>> 0 < $14_1 >>> 0) | 0;
        $4_1 = $7_1 >>> 0 > $13_1 >>> 0;
        $7_1 = $13_1 - $24_1 | 0;
        $30_1 = $7_1 - 2 & $5_1;
        HEAP32[$8_1 + 24 >> 2] = $30_1;
        $11_1 = ($4_1 - (($13_1 >>> 0 < $24_1 >>> 0) + $12_1 | 0) | 0) - ($7_1 >>> 0 < 2) & $5_1;
        HEAP32[$8_1 + 28 >> 2] = $11_1;
        $5_1 = HEAP32[$2_1 >> 2];
        $7_1 = $5_1;
        $13_1 = HEAP32[$2_1 + 4 >> 2];
        $4_1 = $13_1 + $15_1 | 0;
        $5_1 = $5_1 + $23_1 | 0;
        $4_1 = $5_1 >>> 0 < $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $15_1 = $5_1;
        HEAP32[$8_1 >> 2] = $5_1;
        $20_1 = $4_1;
        HEAP32[$8_1 + 4 >> 2] = $4_1;
        $4_1 = $6_1;
        $12_1 = ($13_1 | 0) == ($20_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $13_1 >>> 0 > $20_1 >>> 0;
        $5_1 = $12_1 + $17_1 | 0;
        $6_1 = $5_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $6_1 + HEAP32[$2_1 + 12 >> 2] | 0;
        $7_1 = $5_1;
        $13_1 = HEAP32[$2_1 + 8 >> 2];
        $5_1 = $5_1 + $13_1 | 0;
        $14_1 = $5_1;
        HEAP32[$8_1 + 8 >> 2] = $5_1;
        $17_1 = $5_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$8_1 + 12 >> 2] = $17_1;
        $25_1 = HEAP32[$2_1 + 16 >> 2];
        $9_1 = $25_1 + $9_1 | 0;
        $24_1 = HEAP32[$2_1 + 20 >> 2];
        $4_1 = $24_1 + $19_1 | 0;
        $5_1 = $9_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = !$6_1 & $7_1 >>> 0 < $12_1 >>> 0;
        $6_1 = ($6_1 | 0) == ($17_1 | 0) & $7_1 >>> 0 > $14_1 >>> 0 | $6_1 >>> 0 > $17_1 >>> 0;
        $7_1 = $4_1 + $6_1 | 0;
        $4_1 = ($6_1 >>> 0 > $7_1 >>> 0) + $5_1 | 0;
        $6_1 = $7_1 + $9_1 | 0;
        $4_1 = $6_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $19_1 = $6_1;
        HEAP32[$8_1 + 16 >> 2] = $6_1;
        $7_1 = $4_1;
        HEAP32[$8_1 + 20 >> 2] = $4_1;
        $6_1 = HEAP32[$2_1 + 24 >> 2];
        $12_1 = $6_1;
        $23_1 = HEAP32[$2_1 + 28 >> 2];
        $4_1 = $23_1 + $11_1 | 0;
        $6_1 = $6_1 + $30_1 | 0;
        $2_1 = $6_1 >>> 0 < $30_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $13_1 = $6_1;
        $4_1 = ($5_1 | 0) == ($24_1 | 0) & $9_1 >>> 0 < $25_1 >>> 0 | $5_1 >>> 0 < $24_1 >>> 0;
        $5_1 = ($5_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 > $19_1 >>> 0 | $5_1 >>> 0 > $7_1 >>> 0;
        $9_1 = $4_1 + $5_1 | 0;
        $4_1 = ($5_1 >>> 0 > $9_1 >>> 0) + $2_1 | 0;
        $11_1 = $6_1 + $9_1 | 0;
        $4_1 = $11_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $8_1;
        $9_1 = $4_1;
        $13_1 = (($2_1 | 0) == ($23_1 | 0) & $12_1 >>> 0 > $13_1 >>> 0 | $2_1 >>> 0 < $23_1 >>> 0) + (($2_1 | 0) == ($4_1 | 0) & $11_1 >>> 0 < $13_1 >>> 0 | $2_1 >>> 0 > $4_1 >>> 0) | 0;
        $5_1 = ($7_1 | 0) == -1;
        $4_1 = $5_1 & $19_1 >>> 0 < 4294967294 | ($7_1 | 0) != -1 | ($4_1 & $11_1) != -1;
        $8_1 = ($17_1 | 0) == -1162945306;
        $2_1 = ($4_1 | ($8_1 & $14_1 >>> 0 < 2940772411 | $17_1 >>> 0 < 3132021990)) ^ -1;
        $23_1 = $13_1 + ($2_1 & (($20_1 | 0) == -1076732276 & $15_1 >>> 0 > 3493216576 | $20_1 >>> 0 > 3218235020) | ($2_1 & ($8_1 & $14_1 >>> 0 > 2940772411 | $17_1 >>> 0 > 3132021990) | ($19_1 | 0) == -1 & $5_1 & ($4_1 ^ -1))) | 0;
        $5_1 = __wasm_i64_mul($23_1, 0, 801750719, 1076732275);
        $2_1 = $5_1 + $15_1 | 0;
        $4_1 = $20_1 + i64toi32_i32$HIGH_BITS | 0;
        HEAP32[$6_1 >> 2] = $2_1;
        $8_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$6_1 + 4 >> 2] = $8_1;
        $5_1 = __wasm_i64_mul($23_1, 0, 1354194884, 1162945305);
        $12_1 = $5_1 + $14_1 | 0;
        $4_1 = $17_1 + i64toi32_i32$HIGH_BITS | 0;
        $2_1 = ($8_1 | 0) == ($20_1 | 0) & $2_1 >>> 0 < $15_1 >>> 0 | $8_1 >>> 0 < $20_1 >>> 0;
        $13_1 = $12_1 + $2_1 | 0;
        $4_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $4_1;
        HEAP32[$6_1 + 8 >> 2] = $13_1;
        $15_1 = $2_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$6_1 + 12 >> 2] = $15_1;
        $4_1 = $7_1;
        $8_1 = $19_1 + $23_1 | 0;
        $2_1 = $8_1 >>> 0 < $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = ($5_1 | 0) == ($17_1 | 0) & $14_1 >>> 0 > $12_1 >>> 0 | $5_1 >>> 0 < $17_1 >>> 0;
        $5_1 = ($5_1 | 0) == ($15_1 | 0) & $12_1 >>> 0 > $13_1 >>> 0 | $5_1 >>> 0 > $15_1 >>> 0;
        $13_1 = $4_1 + $5_1 | 0;
        $4_1 = ($5_1 >>> 0 > $13_1 >>> 0) + $2_1 | 0;
        $5_1 = $8_1 + $13_1 | 0;
        $4_1 = $5_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$6_1 + 16 >> 2] = $5_1;
        HEAP32[$6_1 + 20 >> 2] = $4_1;
        $7_1 = ($2_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $19_1 >>> 0 | $2_1 >>> 0 < $7_1 >>> 0;
        $2_1 = ($2_1 | 0) == ($4_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $2_1 >>> 0 > $4_1 >>> 0;
        $5_1 = $7_1 + $2_1 | 0;
        $4_1 = $9_1 + ($2_1 >>> 0 > $5_1 >>> 0) | 0;
        $2_1 = $5_1 + $11_1 | 0;
        $4_1 = $2_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$6_1 + 24 >> 2] = $2_1;
        HEAP32[$6_1 + 28 >> 2] = $4_1;
        global$0 = $18_1 + 128 | 0;
        wasm2js_i32$0 = $10_1, wasm2js_i32$1 = $62($10_1 + 496 | 0, $6_1, 5), HEAP32[wasm2js_i32$0 + 1528 >> 2] = wasm2js_i32$1;
        $62_1 = $62($10_1 + 1012 | 0, $16_1, 5);
        HEAP32[$10_1 + 1532 >> 2] = $62_1;
        $52_1 = HEAP32[$10_1 + 1528 >> 2];
        $39_1 = $10_1 + 3088 | 0;
        $70($39_1, $1_1, 128);
        $2_1 = $10_1 + 1536 | 0;
        $46_1 = $10_1 + 2240 | 0;
        $51_1 = $10_1 + 3680 | 0;
        $12_1 = 0;
        $15_1 = 0;
        $11_1 = 0;
        $7_1 = 0;
        $17_1 = global$0 - 720 | 0;
        global$0 = $17_1;
        label$4: {
          if (HEAP32[$39_1 + 120 >> 2]) {
            HEAP32[$17_1 + 672 >> 2] = 1;
            $68($17_1 + 552 | 0, 120);
            $8_1 = 0;
            $6_1 = 0;
            break label$4;
          }
          $55($17_1 + 552 | 0, $39_1);
          $1_1 = $17_1 + 664 | 0;
          $11_1 = HEAP32[$1_1 >> 2];
          $7_1 = HEAP32[$1_1 + 4 >> 2];
          $1_1 = $17_1 + 648 | 0;
          $22_1 = HEAP32[$1_1 >> 2];
          $21_1 = HEAP32[$1_1 + 4 >> 2];
          $1_1 = $17_1 + 640 | 0;
          $27_1 = HEAP32[$1_1 >> 2];
          $26_1 = HEAP32[$1_1 + 4 >> 2];
          $12_1 = HEAP32[$17_1 + 632 >> 2];
          $15_1 = HEAP32[$17_1 + 636 >> 2];
          $1_1 = $17_1 + 656 | 0;
          $8_1 = HEAP32[$1_1 >> 2];
          $6_1 = HEAP32[$1_1 + 4 >> 2];
        }
        $32_1 = $17_1 + 552 | 0;
        $5_1 = $32_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $45_1 = $17_1 + 336 | 0;
        $1_1 = $45_1 + 8 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $32_1 + 16 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $45_1 + 16 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $32_1 + 24 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $45_1 + 24 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $32_1 + 32 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $45_1 + 32 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $32_1 + 48 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $45_1 + 48 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $32_1 + 56 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $45_1 + 56 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $32_1 - -64 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $45_1 - -64 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $32_1 + 72 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $45_1 + 72 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        HEAP32[$17_1 + 416 >> 2] = 0;
        $1_1 = HEAP32[$17_1 + 556 >> 2];
        HEAP32[$17_1 + 336 >> 2] = HEAP32[$17_1 + 552 >> 2];
        HEAP32[$17_1 + 340 >> 2] = $1_1;
        $1_1 = HEAP32[$17_1 + 596 >> 2];
        HEAP32[$17_1 + 376 >> 2] = HEAP32[$17_1 + 592 >> 2];
        HEAP32[$17_1 + 380 >> 2] = $1_1;
        $29_1 = $17_1 + 304 | 0;
        $31_1 = $12_1 << 1;
        $35_1 = $15_1 << 1 | $12_1 >>> 31;
        $69($29_1, $8_1, $6_1, 0, 0, $31_1, $35_1, 0, 0);
        $28_1 = $17_1 + 224 | 0;
        $5_1 = $22_1;
        $1_1 = $21_1;
        $13_1 = $27_1 << 1;
        $9_1 = $26_1 << 1 | $27_1 >>> 31;
        $69($28_1, $5_1, $1_1, 0, 0, $13_1, $9_1, 0, 0);
        $14_1 = $17_1 + 160 | 0;
        $4_1 = $7_1;
        $69($14_1, $11_1, $4_1, 0, 0, $11_1, $4_1, 0, 0);
        $20_1 = $17_1 + 144 | 0;
        $69($20_1, HEAP32[$17_1 + 160 >> 2], HEAP32[$17_1 + 164 >> 2], 0, 0, 15632, 16, 0, 0);
        $7_1 = $11_1;
        $4_1 = $4_1 << 1 | $7_1 >>> 31;
        $42_1 = $17_1 + 112 | 0;
        $43_1 = $7_1 << 1;
        $30_1 = $4_1;
        $69($42_1, $43_1, $4_1, 0, 0, $12_1, $15_1, 0, 0);
        $44_1 = $17_1 + 272 | 0;
        $69($44_1, $8_1, $6_1, 0, 0, $13_1, $9_1, 0, 0);
        $36_1 = $17_1 + 208 | 0;
        $69($36_1, $5_1, $1_1, 0, 0, $5_1, $1_1, 0, 0);
        $23_1 = $17_1 + 128 | 0;
        $4_1 = $14_1 + 8 | 0;
        $69($23_1, HEAP32[$4_1 >> 2], HEAP32[$4_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
        $50_1 = $17_1 + 320 | 0;
        $69($50_1, $12_1, $15_1, 0, 0, $12_1, $15_1, 0, 0);
        $47_1 = $17_1 + 96 | 0;
        $69($47_1, $43_1, $30_1, 0, 0, $27_1, $26_1, 0, 0);
        $19_1 = $1_1;
        $25_1 = $5_1;
        $4_1 = $1_1 << 1 | $5_1 >>> 31;
        $48_1 = $17_1 + 176 | 0;
        $22_1 = $8_1;
        $21_1 = $6_1;
        $69($48_1, $8_1, $6_1, 0, 0, $5_1 << 1, $4_1, 0, 0);
        $9_1 = HEAP32[$17_1 + 304 >> 2];
        $5_1 = HEAP32[$17_1 + 224 >> 2];
        $1_1 = $9_1 + $5_1 | 0;
        $33_1 = HEAP32[$17_1 + 308 >> 2];
        $4_1 = $33_1 + HEAP32[$17_1 + 228 >> 2] | 0;
        $4_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = HEAP32[$17_1 + 144 >> 2];
        $24_1 = $5_1 + $1_1 | 0;
        $6_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$17_1 + 148 >> 2] | 0;
        $13_1 = $5_1 >>> 0 > $24_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $40_1 = HEAP32[$17_1 + 272 >> 2];
        $5_1 = HEAP32[$17_1 + 208 >> 2];
        $14_1 = $40_1 + $5_1 | 0;
        $41_1 = HEAP32[$17_1 + 276 >> 2];
        $4_1 = $41_1 + HEAP32[$17_1 + 212 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = HEAP32[$17_1 + 112 >> 2];
        $16_1 = $5_1 + $14_1 | 0;
        $7_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$17_1 + 116 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = HEAP32[$17_1 + 128 >> 2];
        $12_1 = $5_1 + $16_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$17_1 + 132 >> 2] | 0;
        $5_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $18_1 = ($6_1 | 0) == ($13_1 | 0) & $1_1 >>> 0 > $24_1 >>> 0 | $6_1 >>> 0 > $13_1 >>> 0;
        $4_1 = $20_1 + 8 | 0;
        $11_1 = HEAP32[$4_1 >> 2];
        $15_1 = HEAP32[$4_1 + 4 >> 2];
        $9_1 = ($6_1 | 0) == ($33_1 | 0) & $1_1 >>> 0 < $9_1 >>> 0 | $6_1 >>> 0 < $33_1 >>> 0;
        $4_1 = $28_1 + 8 | 0;
        $6_1 = HEAP32[$4_1 >> 2];
        $1_1 = $29_1 + 8 | 0;
        $20_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $6_1 >>> 0 > $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = $9_1 + $20_1 | 0;
        $4_1 = ($1_1 >>> 0 < $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $15_1 | 0;
        $6_1 = $1_1;
        $1_1 = $1_1 + $11_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $1_1;
        $1_1 = $1_1 + $18_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $20_1 = $13_1;
        $13_1 = $1_1 << 12 | $13_1 >>> 20;
        $15_1 = $13_1 + $12_1 | 0;
        $6_1 = $4_1;
        $4_1 = $5_1 + ($4_1 << 12 | $1_1 >>> 20) | 0;
        $13_1 = $15_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $49_1 = $17_1 + 80 | 0;
        $33_1 = $49_1;
        $37_1 = HEAP32[$17_1 + 96 >> 2];
        $1_1 = HEAP32[$17_1 + 176 >> 2];
        $11_1 = $37_1 + $1_1 | 0;
        $34_1 = HEAP32[$17_1 + 100 >> 2];
        $4_1 = $34_1 + HEAP32[$17_1 + 180 >> 2] | 0;
        $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $29_1 = ($5_1 | 0) == ($13_1 | 0) & $12_1 >>> 0 > $15_1 >>> 0 | $5_1 >>> 0 > $13_1 >>> 0;
        $28_1 = ($5_1 | 0) == ($8_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
        $4_1 = $23_1 + 8 | 0;
        $23_1 = HEAP32[$4_1 >> 2];
        $18_1 = HEAP32[$4_1 + 4 >> 2];
        $16_1 = ($7_1 | 0) == ($8_1 | 0) & $14_1 >>> 0 > $16_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
        $4_1 = $42_1 + 8 | 0;
        $12_1 = HEAP32[$4_1 >> 2];
        $9_1 = HEAP32[$4_1 + 4 >> 2];
        $7_1 = ($7_1 | 0) == ($41_1 | 0) & $14_1 >>> 0 < $40_1 >>> 0 | $7_1 >>> 0 < $41_1 >>> 0;
        $8_1 = $36_1 + 8 | 0;
        $5_1 = HEAP32[$8_1 >> 2];
        $4_1 = $44_1 + 8 | 0;
        $14_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $7_1 + $14_1 | 0;
        $4_1 = ($5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $9_1 | 0;
        $7_1 = $5_1;
        $5_1 = $5_1 + $12_1 | 0;
        $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $5_1;
        $5_1 = $5_1 + $16_1 | 0;
        $4_1 = ($7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $18_1 | 0;
        $7_1 = $5_1;
        $5_1 = $5_1 + $23_1 | 0;
        $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $5_1 + $28_1 | 0;
        $4_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $6_1 >>> 20 | 0;
        $5_1 = $6_1 + $8_1 | 0;
        $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $5_1;
        $5_1 = $5_1 + $29_1 | 0;
        $6_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $6_1 << 12 | $5_1 >>> 20;
        $4_1 = $5_1 << 12;
        $5_1 = $13_1;
        $13_1 = $4_1 | $5_1 >>> 20;
        $7_1 = $13_1 + $11_1 | 0;
        $4_1 = $1_1 + $8_1 | 0;
        $13_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $7_1;
        $4_1 = $13_1 << 4 | $8_1 >>> 28;
        $9_1 = $8_1 << 4 & -16;
        $7_1 = $4_1 & 16777215;
        $18_1 = $5_1;
        $69($33_1, $9_1 | $5_1 >>> 16 & 15, $7_1, 0, 0, 977, 1, 0, 0);
        $9_1 = $17_1;
        $28_1 = HEAP32[$9_1 + 80 >> 2];
        $5_1 = HEAP32[$9_1 + 320 >> 2];
        $12_1 = $28_1 + $5_1 | 0;
        $38_1 = HEAP32[$9_1 + 84 >> 2];
        $4_1 = $38_1 + HEAP32[$9_1 + 324 >> 2] | 0;
        HEAP32[$9_1 + 424 >> 2] = $12_1;
        $7_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$9_1 + 428 >> 2] = $7_1 & 1048575;
        $42_1 = $9_1 + 256 | 0;
        $69($42_1, $27_1, $26_1, 0, 0, $31_1, $35_1, 0, 0);
        $44_1 = $9_1 - -64 | 0;
        $69($44_1, $43_1, $30_1, 0, 0, $25_1, $19_1, 0, 0);
        $36_1 = $9_1 + 288 | 0;
        $69($36_1, $22_1, $21_1, 0, 0, $22_1, $21_1, 0, 0);
        $40_1 = $9_1 + 48 | 0;
        $17_1 = $40_1;
        $33_1 = HEAP32[$9_1 + 64 >> 2];
        $5_1 = HEAP32[$9_1 + 288 >> 2];
        $23_1 = $33_1 + $5_1 | 0;
        $41_1 = HEAP32[$9_1 + 68 >> 2];
        $4_1 = $41_1 + HEAP32[$9_1 + 292 >> 2] | 0;
        $5_1 = $5_1 >>> 0 > $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $14_1 = $23_1;
        $16_1 = ($1_1 | 0) == ($13_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $13_1 >>> 0;
        $11_1 = ($1_1 | 0) == ($34_1 | 0) & $11_1 >>> 0 < $37_1 >>> 0 | $1_1 >>> 0 < $34_1 >>> 0;
        $4_1 = $48_1 + 8 | 0;
        $8_1 = HEAP32[$4_1 >> 2];
        $1_1 = $47_1 + 8 | 0;
        $29_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $8_1 >>> 0 > $29_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $11_1 + $29_1 | 0;
        $4_1 = $8_1 >>> 0 < $29_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $6_1 >>> 20 | 0;
        $1_1 = $6_1 + $8_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $1_1;
        $1_1 = $1_1 + $16_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $1_1 << 12 | $13_1 >>> 20;
        $14_1 = $6_1 + $14_1 | 0;
        $8_1 = $4_1;
        $4_1 = $5_1 + ($4_1 << 12 | $1_1 >>> 20) | 0;
        $11_1 = $6_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $69($17_1, $14_1, $11_1 & 1048575, 0, 0, 15632, 16, 0, 0);
        $29_1 = HEAP32[$9_1 + 48 >> 2];
        $1_1 = HEAP32[$9_1 + 256 >> 2];
        $17_1 = $29_1 + $1_1 | 0;
        $37_1 = HEAP32[$9_1 + 52 >> 2];
        $4_1 = $37_1 + HEAP32[$9_1 + 260 >> 2] | 0;
        $1_1 = $1_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $16_1 = $17_1;
        $12_1 = ($7_1 | 0) == ($38_1 | 0) & $12_1 >>> 0 < $28_1 >>> 0 | $7_1 >>> 0 < $38_1 >>> 0;
        $13_1 = $50_1 + 8 | 0;
        $6_1 = HEAP32[$13_1 >> 2];
        $4_1 = $49_1 + 8 | 0;
        $28_1 = $6_1 + HEAP32[$4_1 >> 2] | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$13_1 + 4 >> 2] | 0;
        $4_1 = $6_1 >>> 0 > $28_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $12_1 + $28_1 | 0;
        $4_1 = $6_1 >>> 0 < $28_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $6_1 << 12 | $7_1 >>> 20;
        $16_1 = $7_1 + $16_1 | 0;
        $13_1 = $4_1;
        $4_1 = $1_1 + ($4_1 << 12 | $6_1 >>> 20) | 0;
        HEAP32[$9_1 + 432 >> 2] = $16_1;
        $12_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$9_1 + 436 >> 2] = $12_1 & 1048575;
        $28_1 = $9_1 + 192 | 0;
        $69($28_1, $25_1, $19_1, 0, 0, $31_1, $35_1, 0, 0);
        $31_1 = $9_1 + 240 | 0;
        $69($31_1, $27_1, $26_1, 0, 0, $27_1, $26_1, 0, 0);
        $27_1 = $9_1 + 32 | 0;
        $69($27_1, $43_1, $30_1, 0, 0, $22_1, $21_1, 0, 0);
        $25_1 = $9_1 + 16 | 0;
        $19_1 = $25_1;
        $14_1 = ($5_1 | 0) == ($11_1 | 0) & $14_1 >>> 0 < $23_1 >>> 0 | $5_1 >>> 0 > $11_1 >>> 0;
        $7_1 = ($5_1 | 0) == ($41_1 | 0) & $23_1 >>> 0 < $33_1 >>> 0 | $5_1 >>> 0 < $41_1 >>> 0;
        $6_1 = $36_1 + 8 | 0;
        $5_1 = HEAP32[$6_1 >> 2];
        $4_1 = $44_1 + 8 | 0;
        $21_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$6_1 + 4 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $7_1 + $21_1 | 0;
        $4_1 = $6_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $8_1 >>> 20 | 0;
        $5_1 = $6_1 + $8_1 | 0;
        $4_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $5_1;
        $5_1 = $5_1 + $14_1 | 0;
        $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $23_1 = $5_1 << 12 | $11_1 >>> 20;
        $6_1 = HEAP32[$9_1 + 32 >> 2];
        $11_1 = $23_1 + $6_1 | 0;
        $7_1 = $4_1;
        $35_1 = $4_1 << 12 | $5_1 >>> 20;
        $4_1 = $35_1 + HEAP32[$9_1 + 36 >> 2] | 0;
        $21_1 = $6_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $69($19_1, $11_1, $21_1, 0, 0, 15632, 16, 0, 0);
        $26_1 = HEAP32[$9_1 + 192 >> 2];
        $5_1 = HEAP32[$9_1 + 240 >> 2];
        $19_1 = $26_1 + $5_1 | 0;
        $30_1 = HEAP32[$9_1 + 196 >> 2];
        $4_1 = $30_1 + HEAP32[$9_1 + 244 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = HEAP32[$9_1 + 16 >> 2];
        $14_1 = $5_1 + $19_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$9_1 + 20 >> 2] | 0;
        $5_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $22_1 = ($1_1 | 0) == ($12_1 | 0) & $16_1 >>> 0 < $17_1 >>> 0 | $1_1 >>> 0 > $12_1 >>> 0;
        $16_1 = ($1_1 | 0) == ($37_1 | 0) & $17_1 >>> 0 < $29_1 >>> 0 | $1_1 >>> 0 < $37_1 >>> 0;
        $4_1 = $42_1 + 8 | 0;
        $6_1 = HEAP32[$4_1 >> 2];
        $1_1 = $40_1 + 8 | 0;
        $17_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $6_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $16_1 + $17_1 | 0;
        $4_1 = $6_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $13_1 = $13_1 >>> 20 | 0;
        $1_1 = $6_1 + $13_1 | 0;
        $4_1 = $13_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $1_1;
        $1_1 = $1_1 + $22_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $13_1 = $1_1 << 12 | $12_1 >>> 20;
        $12_1 = $13_1 + $14_1 | 0;
        $6_1 = $4_1;
        $4_1 = $5_1 + ($4_1 << 12 | $1_1 >>> 20) | 0;
        HEAP32[$9_1 + 440 >> 2] = $12_1;
        $13_1 = $12_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$9_1 + 444 >> 2] = $13_1 & 1048575;
        $1_1 = $9_1;
        $16_1 = ($21_1 | 0) == ($35_1 | 0) & $11_1 >>> 0 < $23_1 >>> 0 | $21_1 >>> 0 < $35_1 >>> 0;
        $4_1 = $27_1 + 8 | 0;
        $11_1 = HEAP32[$4_1 >> 2];
        $4_1 = HEAP32[$4_1 + 4 >> 2];
        $7_1 = $7_1 >>> 20 | 0;
        $9_1 = $7_1;
        $7_1 = $7_1 + $11_1 | 0;
        $4_1 = $9_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $9_1 = $7_1;
        $7_1 = $7_1 + $16_1 | 0;
        $4_1 = $9_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $69($1_1, $7_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
        $7_1 = $1_1;
        $21_1 = HEAP32[$1_1 >> 2];
        $1_1 = $24_1 & -2;
        $9_1 = $21_1 + $1_1 | 0;
        $22_1 = HEAP32[$7_1 + 4 >> 2];
        $4_1 = $22_1 + ($20_1 & 1048575) | 0;
        $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $20_1 = ($5_1 | 0) == ($13_1 | 0) & $14_1 >>> 0 > $12_1 >>> 0 | $5_1 >>> 0 > $13_1 >>> 0;
        $14_1 = ($5_1 | 0) == ($8_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
        $4_1 = $25_1 + 8 | 0;
        $16_1 = HEAP32[$4_1 >> 2];
        $11_1 = HEAP32[$4_1 + 4 >> 2];
        $12_1 = ($8_1 | 0) == ($30_1 | 0) & $19_1 >>> 0 < $26_1 >>> 0 | $8_1 >>> 0 < $30_1 >>> 0;
        $8_1 = $31_1 + 8 | 0;
        $5_1 = HEAP32[$8_1 >> 2];
        $4_1 = $28_1 + 8 | 0;
        $19_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $12_1 + $19_1 | 0;
        $4_1 = ($5_1 >>> 0 < $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $11_1 | 0;
        $8_1 = $5_1;
        $5_1 = $5_1 + $16_1 | 0;
        $4_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $5_1 + $14_1 | 0;
        $4_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $6_1 >>> 20 | 0;
        $5_1 = $6_1 + $8_1 | 0;
        $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $5_1;
        $5_1 = $5_1 + $20_1 | 0;
        $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $13_1 = $5_1 << 12 | $13_1 >>> 20;
        $8_1 = $13_1 + $9_1 | 0;
        $6_1 = $4_1;
        $4_1 = $1_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
        HEAP32[$7_1 + 448 >> 2] = $8_1;
        $5_1 = $8_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$7_1 + 452 >> 2] = $5_1 & 1048575;
        $11_1 = $18_1 & 65535;
        $12_1 = ($1_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
        $13_1 = ($1_1 | 0) == ($22_1 | 0) & $9_1 >>> 0 < $21_1 >>> 0 | $1_1 >>> 0 < $22_1 >>> 0;
        $1_1 = $7_1 + 8 | 0;
        $8_1 = $13_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2];
        $4_1 = $8_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $6_1 >>> 20 | 0;
        $1_1 = $6_1 + $8_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $1_1;
        $1_1 = $1_1 + $12_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $1_1 << 12 | $5_1 >>> 20;
        $6_1 = $5_1 + $15_1 | 0;
        $4_1 = $11_1 + ($4_1 << 12 | $1_1 >>> 20) | 0;
        HEAP32[$7_1 + 456 >> 2] = $6_1;
        HEAP32[$7_1 + 460 >> 2] = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = $7_1 + 680 | 0;
        $19_1 = $7_1 + 424 | 0;
        $13_1 = $32_1 + 80 | 0;
        $34($1_1, $19_1, $13_1);
        $34($2_1, $39_1, $19_1);
        $34($2_1 + 40 | 0, $39_1 + 40 | 0, $1_1);
        $5_1 = HEAP32[$39_1 + 120 >> 2];
        HEAP32[$2_1 + 80 >> 2] = $5_1;
        $4_1 = $2_1 + 8 | 0;
        $1_1 = HEAP32[$4_1 + 4 >> 2];
        $20_1 = $19_1 + 8 | 0;
        HEAP32[$20_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$20_1 + 4 >> 2] = $1_1;
        $4_1 = $2_1 + 16 | 0;
        $1_1 = HEAP32[$4_1 + 4 >> 2];
        $18_1 = $19_1 + 16 | 0;
        HEAP32[$18_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$18_1 + 4 >> 2] = $1_1;
        $4_1 = $2_1 + 24 | 0;
        $1_1 = HEAP32[$4_1 + 4 >> 2];
        $14_1 = $19_1 + 24 | 0;
        HEAP32[$14_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$14_1 + 4 >> 2] = $1_1;
        $4_1 = $2_1 + 32 | 0;
        $1_1 = HEAP32[$4_1 + 4 >> 2];
        $16_1 = $19_1 + 32 | 0;
        HEAP32[$16_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$16_1 + 4 >> 2] = $1_1;
        $4_1 = $2_1 + 48 | 0;
        $1_1 = HEAP32[$4_1 + 4 >> 2];
        $11_1 = $19_1 + 48 | 0;
        HEAP32[$11_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$11_1 + 4 >> 2] = $1_1;
        $4_1 = $2_1 + 56 | 0;
        $1_1 = HEAP32[$4_1 + 4 >> 2];
        $12_1 = $19_1 + 56 | 0;
        HEAP32[$12_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$12_1 + 4 >> 2] = $1_1;
        $4_1 = $2_1 - -64 | 0;
        $1_1 = HEAP32[$4_1 + 4 >> 2];
        $15_1 = $19_1 - -64 | 0;
        HEAP32[$15_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$15_1 + 4 >> 2] = $1_1;
        $4_1 = $2_1 + 72 | 0;
        $1_1 = HEAP32[$4_1 + 4 >> 2];
        $9_1 = $19_1 + 72 | 0;
        HEAP32[$9_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$9_1 + 4 >> 2] = $1_1;
        HEAP32[$7_1 + 544 >> 2] = $5_1;
        $1_1 = HEAP32[$2_1 + 4 >> 2];
        HEAP32[$7_1 + 424 >> 2] = HEAP32[$2_1 >> 2];
        HEAP32[$7_1 + 428 >> 2] = $1_1;
        $1_1 = HEAP32[$2_1 + 44 >> 2];
        HEAP32[$7_1 + 464 >> 2] = HEAP32[$2_1 + 40 >> 2];
        HEAP32[$7_1 + 468 >> 2] = $1_1;
        $5_1 = $39_1 + 112 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $19_1 + 112 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $39_1 + 104 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $19_1 + 104 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $39_1 + 96 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $19_1 + 96 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $39_1 + 88 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $19_1 + 88 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $8_1 = HEAP32[$39_1 + 80 >> 2];
        $6_1 = HEAP32[$39_1 + 84 >> 2];
        $1_1 = HEAP32[$7_1 + 636 >> 2];
        HEAP32[$46_1 >> 2] = HEAP32[$7_1 + 632 >> 2];
        HEAP32[$46_1 + 4 >> 2] = $1_1;
        $5_1 = $32_1 + 88 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $46_1 + 8 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $32_1 + 96 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $46_1 + 16 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $32_1 + 104 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $46_1 + 24 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $32_1 + 112 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $46_1 + 32 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        HEAP32[$7_1 + 504 >> 2] = $8_1;
        HEAP32[$7_1 + 508 >> 2] = $6_1;
        $65($19_1, $19_1, $45_1, $46_1 + 40 | 0);
        HEAP32[$2_1 + 168 >> 2] = 0;
        $1_1 = HEAP32[$7_1 + 428 >> 2];
        HEAP32[$2_1 + 88 >> 2] = HEAP32[$7_1 + 424 >> 2];
        HEAP32[$2_1 + 92 >> 2] = $1_1;
        $4_1 = HEAP32[$20_1 + 4 >> 2];
        $1_1 = $2_1 + 96 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$18_1 + 4 >> 2];
        $1_1 = $2_1 + 104 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$14_1 + 4 >> 2];
        $1_1 = $2_1 + 112 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$16_1 + 4 >> 2];
        $1_1 = $2_1 + 120 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$7_1 + 468 >> 2];
        $1_1 = $2_1 + 128 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$11_1 + 4 >> 2];
        $1_1 = $2_1 + 136 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$12_1 + 4 >> 2];
        $1_1 = $2_1 + 144 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$15_1 + 4 >> 2];
        $1_1 = $2_1 + 152 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$9_1 + 4 >> 2];
        $1_1 = $2_1 + 160 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $65($19_1, $19_1, $45_1, $46_1 + 80 | 0);
        HEAP32[$2_1 + 256 >> 2] = 0;
        $1_1 = HEAP32[$7_1 + 428 >> 2];
        HEAP32[$2_1 + 176 >> 2] = HEAP32[$7_1 + 424 >> 2];
        HEAP32[$2_1 + 180 >> 2] = $1_1;
        $4_1 = HEAP32[$20_1 + 4 >> 2];
        $1_1 = $2_1 + 184 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$18_1 + 4 >> 2];
        $1_1 = $2_1 + 192 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$14_1 + 4 >> 2];
        $1_1 = $2_1 + 200 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$16_1 + 4 >> 2];
        $1_1 = $2_1 + 208 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$7_1 + 468 >> 2];
        $1_1 = $2_1 + 216 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$11_1 + 4 >> 2];
        $1_1 = $2_1 + 224 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$12_1 + 4 >> 2];
        $1_1 = $2_1 + 232 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$15_1 + 4 >> 2];
        $1_1 = $2_1 + 240 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$9_1 + 4 >> 2];
        $1_1 = $2_1 + 248 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $65($19_1, $19_1, $45_1, $46_1 + 120 | 0);
        HEAP32[$2_1 + 344 >> 2] = 0;
        $1_1 = HEAP32[$7_1 + 428 >> 2];
        HEAP32[$2_1 + 264 >> 2] = HEAP32[$7_1 + 424 >> 2];
        HEAP32[$2_1 + 268 >> 2] = $1_1;
        $4_1 = HEAP32[$20_1 + 4 >> 2];
        $1_1 = $2_1 + 272 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$18_1 + 4 >> 2];
        $1_1 = $2_1 + 280 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$14_1 + 4 >> 2];
        $1_1 = $2_1 + 288 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$16_1 + 4 >> 2];
        $1_1 = $2_1 + 296 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$7_1 + 468 >> 2];
        $1_1 = $2_1 + 304 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$11_1 + 4 >> 2];
        $1_1 = $2_1 + 312 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$12_1 + 4 >> 2];
        $1_1 = $2_1 + 320 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$15_1 + 4 >> 2];
        $1_1 = $2_1 + 328 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$9_1 + 4 >> 2];
        $1_1 = $2_1 + 336 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $65($19_1, $19_1, $45_1, $46_1 + 160 | 0);
        HEAP32[$2_1 + 432 >> 2] = 0;
        $1_1 = HEAP32[$7_1 + 428 >> 2];
        HEAP32[$2_1 + 352 >> 2] = HEAP32[$7_1 + 424 >> 2];
        HEAP32[$2_1 + 356 >> 2] = $1_1;
        $4_1 = HEAP32[$20_1 + 4 >> 2];
        $1_1 = $2_1 + 360 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$18_1 + 4 >> 2];
        $1_1 = $2_1 + 368 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$14_1 + 4 >> 2];
        $1_1 = $2_1 + 376 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$16_1 + 4 >> 2];
        $1_1 = $2_1 + 384 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$7_1 + 468 >> 2];
        $1_1 = $2_1 + 392 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$11_1 + 4 >> 2];
        $1_1 = $2_1 + 400 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$12_1 + 4 >> 2];
        $1_1 = $2_1 + 408 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$15_1 + 4 >> 2];
        $1_1 = $2_1 + 416 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$9_1 + 4 >> 2];
        $1_1 = $2_1 + 424 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $65($19_1, $19_1, $45_1, $46_1 + 200 | 0);
        HEAP32[$2_1 + 520 >> 2] = 0;
        $1_1 = HEAP32[$7_1 + 428 >> 2];
        HEAP32[$2_1 + 440 >> 2] = HEAP32[$7_1 + 424 >> 2];
        HEAP32[$2_1 + 444 >> 2] = $1_1;
        $4_1 = HEAP32[$20_1 + 4 >> 2];
        $1_1 = $2_1 + 448 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$18_1 + 4 >> 2];
        $1_1 = $2_1 + 456 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$14_1 + 4 >> 2];
        $1_1 = $2_1 + 464 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$16_1 + 4 >> 2];
        $1_1 = $2_1 + 472 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$7_1 + 468 >> 2];
        $1_1 = $2_1 + 480 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$11_1 + 4 >> 2];
        $1_1 = $2_1 + 488 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$12_1 + 4 >> 2];
        $1_1 = $2_1 + 496 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$15_1 + 4 >> 2];
        $1_1 = $2_1 + 504 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$9_1 + 4 >> 2];
        $1_1 = $2_1 + 512 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $23_1 = $46_1 + 240 | 0;
        $65($19_1, $19_1, $45_1, $23_1);
        HEAP32[$2_1 + 608 >> 2] = 0;
        $1_1 = HEAP32[$7_1 + 428 >> 2];
        HEAP32[$2_1 + 528 >> 2] = HEAP32[$7_1 + 424 >> 2];
        HEAP32[$2_1 + 532 >> 2] = $1_1;
        $4_1 = HEAP32[$20_1 + 4 >> 2];
        $1_1 = $2_1 + 536 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$18_1 + 4 >> 2];
        $1_1 = $2_1 + 544 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$14_1 + 4 >> 2];
        $1_1 = $2_1 + 552 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$16_1 + 4 >> 2];
        $1_1 = $2_1 + 560 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$7_1 + 468 >> 2];
        $1_1 = $2_1 + 568 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$11_1 + 4 >> 2];
        $1_1 = $2_1 + 576 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$12_1 + 4 >> 2];
        $1_1 = $2_1 + 584 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$15_1 + 4 >> 2];
        $1_1 = $2_1 + 592 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$9_1 + 4 >> 2];
        $1_1 = $2_1 + 600 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $6_1 = $46_1 + 280 | 0;
        $65($19_1, $19_1, $45_1, $6_1);
        HEAP32[$2_1 + 696 >> 2] = 0;
        $1_1 = HEAP32[$7_1 + 428 >> 2];
        HEAP32[$2_1 + 616 >> 2] = HEAP32[$7_1 + 424 >> 2];
        HEAP32[$2_1 + 620 >> 2] = $1_1;
        $4_1 = HEAP32[$20_1 + 4 >> 2];
        $1_1 = $2_1 + 624 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$18_1 + 4 >> 2];
        $1_1 = $2_1 + 632 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$14_1 + 4 >> 2];
        $1_1 = $2_1 + 640 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$16_1 + 4 >> 2];
        $1_1 = $2_1 + 648 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$7_1 + 468 >> 2];
        $1_1 = $2_1 + 656 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$11_1 + 4 >> 2];
        $1_1 = $2_1 + 664 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$12_1 + 4 >> 2];
        $1_1 = $2_1 + 672 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$15_1 + 4 >> 2];
        $1_1 = $2_1 + 680 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $4_1 = HEAP32[$9_1 + 4 >> 2];
        $1_1 = $2_1 + 688 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $34($51_1, $19_1 + 80 | 0, $13_1);
        global$0 = $7_1 + 720 | 0;
        $11_1 = global$0 - 928 | 0;
        global$0 = $11_1;
        $8_1 = $2_1 + 616 | 0;
        $7_1 = $8_1 + 72 | 0;
        $5_1 = HEAP32[$7_1 >> 2];
        $13_1 = HEAP32[$8_1 + 44 >> 2];
        $4_1 = HEAP32[$8_1 + 40 >> 2];
        $15_1 = HEAP32[$7_1 + 4 >> 2];
        $1_1 = __wasm_i64_mul($15_1 >>> 16 | 0, 0, 977, 1);
        $9_1 = $4_1 + $1_1 | 0;
        $4_1 = $13_1 + i64toi32_i32$HIGH_BITS | 0;
        HEAP32[$8_1 + 40 >> 2] = $9_1;
        $4_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$8_1 + 44 >> 2] = $4_1 & 1048575;
        $12_1 = $8_1 + 48 | 0;
        $9_1 = HEAP32[$12_1 >> 2];
        $1_1 = $4_1;
        $4_1 = HEAP32[$12_1 + 4 >> 2];
        $1_1 = $1_1 >>> 20 | 0;
        $13_1 = $1_1;
        $1_1 = $1_1 + $9_1 | 0;
        $4_1 = $13_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$12_1 >> 2] = $1_1;
        HEAP32[$12_1 + 4 >> 2] = $4_1 & 1048575;
        $12_1 = $8_1 + 56 | 0;
        $9_1 = HEAP32[$12_1 >> 2];
        $1_1 = $4_1;
        $4_1 = HEAP32[$12_1 + 4 >> 2];
        $1_1 = $1_1 >>> 20 | 0;
        $13_1 = $1_1;
        $1_1 = $1_1 + $9_1 | 0;
        $4_1 = $13_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$12_1 >> 2] = $1_1;
        HEAP32[$12_1 + 4 >> 2] = $4_1 & 1048575;
        $9_1 = $8_1 - -64 | 0;
        $13_1 = HEAP32[$9_1 >> 2];
        $1_1 = $4_1;
        $4_1 = HEAP32[$9_1 + 4 >> 2];
        $1_1 = $1_1 >>> 20 | 0;
        $8_1 = $1_1;
        $1_1 = $1_1 + $13_1 | 0;
        $4_1 = $8_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$9_1 >> 2] = $1_1;
        HEAP32[$9_1 + 4 >> 2] = $4_1 & 1048575;
        $8_1 = $7_1;
        $1_1 = $4_1;
        $4_1 = $15_1 & 65535;
        $1_1 = $1_1 >>> 20 | 0;
        $7_1 = $1_1;
        $1_1 = $1_1 + $5_1 | 0;
        $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$8_1 >> 2] = $1_1;
        HEAP32[$8_1 + 4 >> 2] = $4_1;
        $5_1 = $6_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $41_1 = $11_1 + 808 | 0;
        $1_1 = $41_1 + 8 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $6_1 + 16 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $41_1 + 16 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $6_1 + 24 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $41_1 + 24 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $6_1 + 32 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $41_1 + 32 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $1_1 = HEAP32[$6_1 + 4 >> 2];
        HEAP32[$11_1 + 808 >> 2] = HEAP32[$6_1 >> 2];
        HEAP32[$11_1 + 812 >> 2] = $1_1;
        $51_1 = 6;
        $34_1 = $2_1 + 528 | 0;
        $5_1 = $34_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $38_1 = $11_1 + 680 | 0;
        $1_1 = $38_1 + 8 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $34_1 + 16 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $38_1 + 16 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $34_1 + 24 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $38_1 + 24 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $34_1 + 32 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $38_1 + 32 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $34_1 + 48 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $38_1 + 48 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $34_1 + 56 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $38_1 + 56 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $34_1 - -64 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $38_1 - -64 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $34_1 + 72 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $38_1 + 72 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $1_1 = HEAP32[$34_1 + 4 >> 2];
        HEAP32[$11_1 + 680 >> 2] = HEAP32[$34_1 >> 2];
        HEAP32[$11_1 + 684 >> 2] = $1_1;
        $1_1 = HEAP32[$34_1 + 44 >> 2];
        HEAP32[$11_1 + 720 >> 2] = HEAP32[$34_1 + 40 >> 2];
        HEAP32[$11_1 + 724 >> 2] = $1_1;
        $16_1 = HEAP32[$11_1 + 840 >> 2];
        $7_1 = HEAP32[$11_1 + 844 >> 2];
        $5_1 = HEAP32[$11_1 + 824 >> 2];
        $13_1 = HEAP32[$11_1 + 828 >> 2];
        $31_1 = HEAP32[$11_1 + 816 >> 2];
        $17_1 = HEAP32[$11_1 + 820 >> 2];
        $8_1 = HEAP32[$11_1 + 832 >> 2];
        $6_1 = HEAP32[$11_1 + 836 >> 2];
        $12_1 = HEAP32[$11_1 + 808 >> 2];
        $15_1 = HEAP32[$11_1 + 812 >> 2];
        HEAP32[$11_1 + 800 >> 2] = 0;
        $25_1 = $11_1 + 440 | 0;
        $35_1 = $12_1 << 1;
        $43_1 = $15_1 << 1 | $12_1 >>> 31;
        $69($25_1, $8_1, $6_1, 0, 0, $35_1, $43_1, 0, 0);
        $24_1 = $11_1 + 504 | 0;
        $1_1 = $13_1;
        $13_1 = $31_1 << 1;
        $9_1 = $17_1 << 1 | $31_1 >>> 31;
        $69($24_1, $5_1, $1_1, 0, 0, $13_1, $9_1, 0, 0);
        $20_1 = $11_1 + 632 | 0;
        $4_1 = $7_1;
        $69($20_1, $16_1, $4_1, 0, 0, $16_1, $4_1, 0, 0);
        $18_1 = $11_1 + 616 | 0;
        $69($18_1, HEAP32[$11_1 + 632 >> 2], HEAP32[$11_1 + 636 >> 2], 0, 0, 15632, 16, 0, 0);
        $7_1 = $16_1;
        $4_1 = $4_1 << 1 | $7_1 >>> 31;
        $42_1 = $11_1 + 472 | 0;
        $28_1 = $7_1 << 1;
        $27_1 = $4_1;
        $69($42_1, $28_1, $4_1, 0, 0, $12_1, $15_1, 0, 0);
        $44_1 = $11_1 + 488 | 0;
        $69($44_1, $8_1, $6_1, 0, 0, $13_1, $9_1, 0, 0);
        $36_1 = $11_1 + 568 | 0;
        $69($36_1, $5_1, $1_1, 0, 0, $5_1, $1_1, 0, 0);
        $16_1 = $11_1 + 600 | 0;
        $4_1 = $20_1 + 8 | 0;
        $69($16_1, HEAP32[$4_1 >> 2], HEAP32[$4_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
        $47_1 = $11_1 + 456 | 0;
        $69($47_1, $12_1, $15_1, 0, 0, $12_1, $15_1, 0, 0);
        $48_1 = $11_1 + 536 | 0;
        $69($48_1, $28_1, $27_1, 0, 0, $31_1, $17_1, 0, 0);
        $21_1 = $1_1;
        $30_1 = $5_1;
        $4_1 = $1_1 << 1 | $5_1 >>> 31;
        $49_1 = $11_1 + 584 | 0;
        $26_1 = $8_1;
        $22_1 = $6_1;
        $69($49_1, $8_1, $6_1, 0, 0, $5_1 << 1, $4_1, 0, 0);
        $8_1 = HEAP32[$11_1 + 440 >> 2];
        $5_1 = HEAP32[$11_1 + 504 >> 2];
        $1_1 = $8_1 + $5_1 | 0;
        $15_1 = HEAP32[$11_1 + 444 >> 2];
        $4_1 = $15_1 + HEAP32[$11_1 + 508 >> 2] | 0;
        $4_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = HEAP32[$11_1 + 616 >> 2];
        $19_1 = $5_1 + $1_1 | 0;
        $6_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$11_1 + 620 >> 2] | 0;
        $5_1 = $5_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $9_1 = ($6_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $19_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
        $4_1 = $18_1 + 8 | 0;
        $13_1 = HEAP32[$4_1 >> 2];
        $7_1 = HEAP32[$4_1 + 4 >> 2];
        $8_1 = ($6_1 | 0) == ($15_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $6_1 >>> 0 < $15_1 >>> 0;
        $4_1 = $24_1 + 8 | 0;
        $6_1 = HEAP32[$4_1 >> 2];
        $1_1 = $25_1 + 8 | 0;
        $15_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $6_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = $8_1 + $15_1 | 0;
        $4_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $7_1 | 0;
        $6_1 = $1_1;
        $1_1 = $1_1 + $13_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $1_1;
        $1_1 = $1_1 + $9_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $20_1 = $5_1;
        $13_1 = $1_1 << 12 | $5_1 >>> 20;
        $8_1 = $4_1;
        $7_1 = $4_1 << 12 | $1_1 >>> 20;
        $40_1 = HEAP32[$11_1 + 488 >> 2];
        $1_1 = HEAP32[$11_1 + 568 >> 2];
        $12_1 = $40_1 + $1_1 | 0;
        $37_1 = HEAP32[$11_1 + 492 >> 2];
        $4_1 = $37_1 + HEAP32[$11_1 + 572 >> 2] | 0;
        $4_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = HEAP32[$11_1 + 472 >> 2];
        $15_1 = $1_1 + $12_1 | 0;
        $6_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$11_1 + 476 >> 2] | 0;
        $4_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = HEAP32[$11_1 + 600 >> 2];
        $9_1 = $1_1 + $15_1 | 0;
        $5_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$11_1 + 604 >> 2] | 0;
        $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $1_1 + $7_1 | 0;
        $33_1 = $11_1 + 376 | 0;
        $29_1 = $33_1;
        $13_1 = $9_1 + $13_1 | 0;
        $7_1 = $13_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $25_1 = ($1_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 > $13_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
        $24_1 = ($1_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $5_1 >>> 0;
        $1_1 = $16_1 + 8 | 0;
        $18_1 = HEAP32[$1_1 >> 2];
        $14_1 = HEAP32[$1_1 + 4 >> 2];
        $16_1 = ($5_1 | 0) == ($6_1 | 0) & $12_1 >>> 0 > $15_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
        $1_1 = $42_1 + 8 | 0;
        $15_1 = HEAP32[$1_1 >> 2];
        $9_1 = HEAP32[$1_1 + 4 >> 2];
        $6_1 = ($6_1 | 0) == ($37_1 | 0) & $12_1 >>> 0 < $40_1 >>> 0 | $6_1 >>> 0 < $37_1 >>> 0;
        $4_1 = $36_1 + 8 | 0;
        $5_1 = HEAP32[$4_1 >> 2];
        $1_1 = $44_1 + 8 | 0;
        $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = $6_1 + $12_1 | 0;
        $4_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $9_1 | 0;
        $5_1 = $1_1;
        $1_1 = $1_1 + $15_1 | 0;
        $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $1_1;
        $1_1 = $1_1 + $16_1 | 0;
        $4_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $14_1 | 0;
        $5_1 = $1_1;
        $1_1 = $1_1 + $18_1 | 0;
        $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $1_1 + $24_1 | 0;
        $4_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $8_1 >>> 20 | 0;
        $1_1 = $5_1 + $6_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $1_1;
        $1_1 = $1_1 + $25_1 | 0;
        $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $7_1;
        $7_1 = $1_1 << 12 | $5_1 >>> 20;
        $6_1 = $4_1;
        $9_1 = $4_1 << 12 | $1_1 >>> 20;
        $25_1 = HEAP32[$11_1 + 540 >> 2];
        $4_1 = $25_1 + HEAP32[$11_1 + 588 >> 2] | 0;
        $14_1 = HEAP32[$11_1 + 536 >> 2];
        $1_1 = HEAP32[$11_1 + 584 >> 2];
        $8_1 = $14_1 + $1_1 | 0;
        $12_1 = $8_1;
        $7_1 = $8_1 + $7_1 | 0;
        $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $1_1 + $9_1 | 0;
        $15_1 = $7_1 << 4 & -16;
        $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $9_1 = ($8_1 << 4 | $7_1 >>> 28) & 16777215;
        $18_1 = $5_1;
        $69($29_1, $15_1 | $5_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
        $9_1 = $11_1;
        $29_1 = HEAP32[$9_1 + 376 >> 2];
        $5_1 = HEAP32[$9_1 + 456 >> 2];
        $15_1 = $29_1 + $5_1 | 0;
        $50_1 = HEAP32[$9_1 + 380 >> 2];
        $4_1 = $50_1 + HEAP32[$9_1 + 460 >> 2] | 0;
        HEAP32[$9_1 + 888 >> 2] = $15_1;
        $5_1 = $5_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$9_1 + 892 >> 2] = $5_1 & 1048575;
        $37_1 = $9_1 + 360 | 0;
        $69($37_1, $31_1, $17_1, 0, 0, $35_1, $43_1, 0, 0);
        $42_1 = $9_1 + 552 | 0;
        $69($42_1, $28_1, $27_1, 0, 0, $30_1, $21_1, 0, 0);
        $44_1 = $9_1 + 664 | 0;
        $69($44_1, $26_1, $22_1, 0, 0, $26_1, $22_1, 0, 0);
        $36_1 = $9_1 + 424 | 0;
        $24_1 = $36_1;
        $16_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
        $12_1 = ($1_1 | 0) == ($25_1 | 0) & $14_1 >>> 0 > $12_1 >>> 0 | $1_1 >>> 0 < $25_1 >>> 0;
        $4_1 = $49_1 + 8 | 0;
        $7_1 = HEAP32[$4_1 >> 2];
        $1_1 = $48_1 + 8 | 0;
        $14_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $7_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $14_1 + $12_1 | 0;
        $4_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $6_1 >>> 20 | 0;
        $1_1 = $6_1 + $7_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $1_1;
        $1_1 = $1_1 + $16_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $12_1 = $1_1 << 12 | $8_1 >>> 20;
        $7_1 = $4_1;
        $6_1 = $4_1 << 12 | $1_1 >>> 20;
        $40_1 = HEAP32[$9_1 + 552 >> 2];
        $1_1 = HEAP32[$9_1 + 664 >> 2];
        $25_1 = $40_1 + $1_1 | 0;
        $48_1 = HEAP32[$9_1 + 556 >> 2];
        $4_1 = $48_1 + HEAP32[$9_1 + 668 >> 2] | 0;
        $8_1 = $1_1 >>> 0 > $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $8_1 + $6_1 | 0;
        $14_1 = $12_1 + $25_1 | 0;
        $4_1 = $14_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $12_1 = $4_1;
        $69($24_1, $14_1, $4_1 & 1048575, 0, 0, 15632, 16, 0, 0);
        $15_1 = ($5_1 | 0) == ($50_1 | 0) & $15_1 >>> 0 < $29_1 >>> 0 | $5_1 >>> 0 < $50_1 >>> 0;
        $4_1 = $47_1 + 8 | 0;
        $6_1 = HEAP32[$4_1 >> 2];
        $1_1 = $33_1 + 8 | 0;
        $16_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $6_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = $15_1 + $16_1 | 0;
        $4_1 = $1_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $16_1 = $1_1 << 12 | $5_1 >>> 20;
        $6_1 = $4_1;
        $15_1 = $4_1 << 12 | $1_1 >>> 20;
        $33_1 = HEAP32[$9_1 + 424 >> 2];
        $1_1 = HEAP32[$9_1 + 360 >> 2];
        $24_1 = $33_1 + $1_1 | 0;
        $49_1 = HEAP32[$9_1 + 428 >> 2];
        $4_1 = $49_1 + HEAP32[$9_1 + 364 >> 2] | 0;
        $5_1 = $1_1 >>> 0 > $24_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $5_1 + $15_1 | 0;
        $16_1 = $16_1 + $24_1 | 0;
        $4_1 = $16_1 >>> 0 < $24_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$9_1 + 896 >> 2] = $16_1;
        $15_1 = $4_1;
        HEAP32[$9_1 + 900 >> 2] = $4_1 & 1048575;
        $29_1 = $9_1 + 344 | 0;
        $69($29_1, $30_1, $21_1, 0, 0, $35_1, $43_1, 0, 0);
        $35_1 = $9_1 + 520 | 0;
        $69($35_1, $31_1, $17_1, 0, 0, $31_1, $17_1, 0, 0);
        $31_1 = $9_1 + 648 | 0;
        $69($31_1, $28_1, $27_1, 0, 0, $26_1, $22_1, 0, 0);
        $30_1 = $9_1 + 408 | 0;
        $26_1 = $30_1;
        $21_1 = ($8_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 < $25_1 >>> 0 | $8_1 >>> 0 > $12_1 >>> 0;
        $14_1 = ($8_1 | 0) == ($48_1 | 0) & $25_1 >>> 0 < $40_1 >>> 0 | $8_1 >>> 0 < $48_1 >>> 0;
        $4_1 = $44_1 + 8 | 0;
        $8_1 = HEAP32[$4_1 >> 2];
        $1_1 = $42_1 + 8 | 0;
        $22_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $8_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $14_1 + $22_1 | 0;
        $4_1 = $8_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $7_1 >>> 20 | 0;
        $1_1 = $7_1 + $8_1 | 0;
        $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $1_1;
        $1_1 = $1_1 + $21_1 | 0;
        $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $22_1 = $1_1 << 12 | $12_1 >>> 20;
        $7_1 = HEAP32[$9_1 + 648 >> 2];
        $12_1 = $22_1 + $7_1 | 0;
        $8_1 = $4_1;
        $25_1 = $4_1 << 12 | $1_1 >>> 20;
        $4_1 = $25_1 + HEAP32[$9_1 + 652 >> 2] | 0;
        $21_1 = $7_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $69($26_1, $12_1, $21_1, 0, 0, 15632, 16, 0, 0);
        $7_1 = $9_1;
        $16_1 = ($5_1 | 0) == ($15_1 | 0) & $16_1 >>> 0 < $24_1 >>> 0 | $5_1 >>> 0 > $15_1 >>> 0;
        $9_1 = ($5_1 | 0) == ($49_1 | 0) & $24_1 >>> 0 < $33_1 >>> 0 | $5_1 >>> 0 < $49_1 >>> 0;
        $4_1 = $37_1 + 8 | 0;
        $5_1 = HEAP32[$4_1 >> 2];
        $1_1 = $36_1 + 8 | 0;
        $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $9_1 + $14_1 | 0;
        $4_1 = $5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $6_1 >>> 20 | 0;
        $1_1 = $5_1 + $6_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $1_1;
        $1_1 = $1_1 + $16_1 | 0;
        $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $15_1 = $1_1 << 12 | $15_1 >>> 20;
        $6_1 = $4_1;
        $9_1 = $4_1 << 12 | $1_1 >>> 20;
        $17_1 = HEAP32[$7_1 + 344 >> 2];
        $1_1 = HEAP32[$7_1 + 520 >> 2];
        $14_1 = $17_1 + $1_1 | 0;
        $24_1 = HEAP32[$7_1 + 348 >> 2];
        $4_1 = $24_1 + HEAP32[$7_1 + 524 >> 2] | 0;
        $4_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = HEAP32[$7_1 + 408 >> 2];
        $16_1 = $1_1 + $14_1 | 0;
        $5_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$7_1 + 412 >> 2] | 0;
        $1_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $1_1 + $9_1 | 0;
        $15_1 = $15_1 + $16_1 | 0;
        $4_1 = $15_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$7_1 + 904 >> 2] = $15_1;
        $9_1 = $4_1;
        HEAP32[$7_1 + 908 >> 2] = $4_1 & 1048575;
        $26_1 = $7_1 + 392 | 0;
        $22_1 = ($21_1 | 0) == ($25_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $25_1 >>> 0;
        $4_1 = $31_1 + 8 | 0;
        $21_1 = HEAP32[$4_1 >> 2];
        $4_1 = HEAP32[$4_1 + 4 >> 2];
        $8_1 = $8_1 >>> 20 | 0;
        $12_1 = $8_1;
        $8_1 = $8_1 + $21_1 | 0;
        $4_1 = $12_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $12_1 = $8_1;
        $8_1 = $8_1 + $22_1 | 0;
        $4_1 = $12_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $69($26_1, $8_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
        $8_1 = $7_1;
        $21_1 = ($1_1 | 0) == ($9_1 | 0) & $15_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
        $16_1 = ($1_1 | 0) == ($5_1 | 0) & $14_1 >>> 0 > $16_1 >>> 0 | $1_1 >>> 0 < $5_1 >>> 0;
        $1_1 = $30_1 + 8 | 0;
        $12_1 = HEAP32[$1_1 >> 2];
        $15_1 = HEAP32[$1_1 + 4 >> 2];
        $7_1 = ($5_1 | 0) == ($24_1 | 0) & $14_1 >>> 0 < $17_1 >>> 0 | $5_1 >>> 0 < $24_1 >>> 0;
        $4_1 = $35_1 + 8 | 0;
        $5_1 = HEAP32[$4_1 >> 2];
        $1_1 = $29_1 + 8 | 0;
        $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = $7_1 + $14_1 | 0;
        $4_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $15_1 | 0;
        $5_1 = $1_1;
        $1_1 = $1_1 + $12_1 | 0;
        $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $1_1 + $16_1 | 0;
        $4_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $6_1 >>> 20 | 0;
        $1_1 = $5_1 + $6_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $1_1;
        $1_1 = $1_1 + $21_1 | 0;
        $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $1_1 << 12 | $9_1 >>> 20;
        $6_1 = $4_1;
        $15_1 = $4_1 << 12 | $1_1 >>> 20;
        $16_1 = HEAP32[$8_1 + 396 >> 2];
        $4_1 = $16_1 + ($20_1 & 1048575) | 0;
        $12_1 = HEAP32[$8_1 + 392 >> 2];
        $5_1 = $19_1 & -2;
        $1_1 = $12_1 + $5_1 | 0;
        $9_1 = $1_1;
        $7_1 = $1_1 + $7_1 | 0;
        $5_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $5_1 + $15_1 | 0;
        HEAP32[$8_1 + 912 >> 2] = $7_1;
        $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$8_1 + 916 >> 2] = $1_1 & 1048575;
        $15_1 = $18_1 & 65535;
        $7_1 = ($1_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 > $7_1 >>> 0 | $1_1 >>> 0 < $5_1 >>> 0;
        $5_1 = ($5_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $5_1 >>> 0 < $16_1 >>> 0;
        $4_1 = $26_1 + 8 | 0;
        $8_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2];
        $4_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $6_1 >>> 20 | 0;
        $5_1 = $6_1 + $8_1 | 0;
        $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $5_1;
        $5_1 = $5_1 + $7_1 | 0;
        $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = $5_1 << 12 | $1_1 >>> 20;
        $6_1 = $1_1 + $13_1 | 0;
        $4_1 = $15_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
        HEAP32[$11_1 + 920 >> 2] = $6_1;
        HEAP32[$11_1 + 924 >> 2] = $1_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $11_1 + 848 | 0;
        $1_1 = $11_1 + 888 | 0;
        $34($4_1, $1_1, $41_1);
        $34($34_1, $38_1, $1_1);
        $39_1 = $38_1 + 40 | 0;
        $34($34_1 + 40 | 0, $39_1, $4_1);
        HEAP32[$34_1 + 80 >> 2] = 0;
        $35_1 = $23_1;
        $32_1 = $2_1 + 440 | 0;
        while (1) {
          $50_1 = $11_1 + 808 | 0;
          $34($50_1, $50_1, $35_1);
          $5_1 = $32_1 + 32 | 0;
          $4_1 = HEAP32[$5_1 + 4 >> 2];
          $34_1 = $11_1 + 680 | 0;
          $1_1 = $34_1 + 32 | 0;
          HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
          HEAP32[$1_1 + 4 >> 2] = $4_1;
          $5_1 = $32_1 + 24 | 0;
          $4_1 = HEAP32[$5_1 + 4 >> 2];
          $1_1 = $34_1 + 24 | 0;
          HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
          HEAP32[$1_1 + 4 >> 2] = $4_1;
          $5_1 = $32_1 + 16 | 0;
          $4_1 = HEAP32[$5_1 + 4 >> 2];
          $1_1 = $34_1 + 16 | 0;
          HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
          HEAP32[$1_1 + 4 >> 2] = $4_1;
          $5_1 = $32_1 + 8 | 0;
          $4_1 = HEAP32[$5_1 + 4 >> 2];
          $1_1 = $34_1 + 8 | 0;
          HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
          HEAP32[$1_1 + 4 >> 2] = $4_1;
          $47_1 = $32_1 + 40 | 0;
          $1_1 = HEAP32[$47_1 + 4 >> 2];
          HEAP32[$39_1 >> 2] = HEAP32[$47_1 >> 2];
          HEAP32[$39_1 + 4 >> 2] = $1_1;
          $5_1 = $32_1 + 48 | 0;
          $4_1 = HEAP32[$5_1 + 4 >> 2];
          $1_1 = $39_1 + 8 | 0;
          HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
          HEAP32[$1_1 + 4 >> 2] = $4_1;
          $5_1 = $32_1 + 56 | 0;
          $4_1 = HEAP32[$5_1 + 4 >> 2];
          $1_1 = $39_1 + 16 | 0;
          HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
          HEAP32[$1_1 + 4 >> 2] = $4_1;
          $5_1 = $32_1 - -64 | 0;
          $4_1 = HEAP32[$5_1 + 4 >> 2];
          $1_1 = $39_1 + 24 | 0;
          HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
          HEAP32[$1_1 + 4 >> 2] = $4_1;
          $5_1 = $32_1 + 72 | 0;
          $4_1 = HEAP32[$5_1 + 4 >> 2];
          $1_1 = $39_1 + 32 | 0;
          HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
          HEAP32[$1_1 + 4 >> 2] = $4_1;
          $1_1 = HEAP32[$32_1 + 4 >> 2];
          HEAP32[$11_1 + 680 >> 2] = HEAP32[$32_1 >> 2];
          HEAP32[$11_1 + 684 >> 2] = $1_1;
          HEAP32[$11_1 + 800 >> 2] = 0;
          $1_1 = HEAP32[$11_1 + 812 >> 2];
          $18_1 = $1_1;
          $14_1 = HEAP32[$11_1 + 808 >> 2];
          $7_1 = $14_1;
          $4_1 = $1_1 << 1 | $7_1 >>> 31;
          $12_1 = $11_1 + 72 | 0;
          $26_1 = HEAP32[$11_1 + 832 >> 2];
          $22_1 = HEAP32[$11_1 + 836 >> 2];
          $25_1 = $7_1 << 1;
          $30_1 = $4_1;
          $69($12_1, $26_1, $22_1, 0, 0, $25_1, $4_1, 0, 0);
          $1_1 = HEAP32[$11_1 + 820 >> 2];
          $38_1 = $1_1;
          $41_1 = HEAP32[$11_1 + 816 >> 2];
          $5_1 = $41_1;
          $4_1 = $1_1 << 1 | $5_1 >>> 31;
          $15_1 = $11_1 + 280 | 0;
          $23_1 = HEAP32[$11_1 + 824 >> 2];
          $21_1 = HEAP32[$11_1 + 828 >> 2];
          $5_1 = $5_1 << 1;
          $6_1 = $4_1;
          $69($15_1, $23_1, $21_1, 0, 0, $5_1, $4_1, 0, 0);
          $9_1 = $11_1 + 232 | 0;
          $8_1 = HEAP32[$11_1 + 840 >> 2];
          $1_1 = HEAP32[$11_1 + 844 >> 2];
          $69($9_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
          $13_1 = $11_1 + 216 | 0;
          $69($13_1, HEAP32[$11_1 + 232 >> 2], HEAP32[$11_1 + 236 >> 2], 0, 0, 15632, 16, 0, 0);
          $4_1 = $1_1 << 1 | $8_1 >>> 31;
          $36_1 = $11_1 + 184 | 0;
          $31_1 = $8_1 << 1;
          $24_1 = $4_1;
          $69($36_1, $31_1, $4_1, 0, 0, $7_1, $18_1, 0, 0);
          $40_1 = $11_1 + 88 | 0;
          $69($40_1, $26_1, $22_1, 0, 0, $5_1, $6_1, 0, 0);
          $33_1 = $11_1 + 264 | 0;
          $69($33_1, $23_1, $21_1, 0, 0, $23_1, $21_1, 0, 0);
          $16_1 = $11_1 + 200 | 0;
          $1_1 = $9_1 + 8 | 0;
          $69($16_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
          $49_1 = $11_1 + 328 | 0;
          $69($49_1, $7_1, $18_1, 0, 0, $7_1, $18_1, 0, 0);
          $37_1 = $11_1 + 168 | 0;
          $69($37_1, $31_1, $4_1, 0, 0, $41_1, $38_1, 0, 0);
          $42_1 = $11_1 + 104 | 0;
          $69($42_1, $26_1, $22_1, 0, 0, $23_1 << 1, $21_1 << 1 | $23_1 >>> 31, 0, 0);
          $8_1 = HEAP32[$11_1 + 72 >> 2];
          $5_1 = HEAP32[$11_1 + 280 >> 2];
          $1_1 = $8_1 + $5_1 | 0;
          $14_1 = HEAP32[$11_1 + 76 >> 2];
          $4_1 = $14_1 + HEAP32[$11_1 + 284 >> 2] | 0;
          $4_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = HEAP32[$11_1 + 216 >> 2];
          $19_1 = $5_1 + $1_1 | 0;
          $6_1 = $4_1;
          $4_1 = $4_1 + HEAP32[$11_1 + 220 >> 2] | 0;
          $5_1 = $5_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $9_1 = ($6_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $19_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
          $4_1 = $13_1 + 8 | 0;
          $13_1 = HEAP32[$4_1 >> 2];
          $7_1 = HEAP32[$4_1 + 4 >> 2];
          $8_1 = ($6_1 | 0) == ($14_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $6_1 >>> 0 < $14_1 >>> 0;
          $4_1 = $15_1 + 8 | 0;
          $6_1 = HEAP32[$4_1 >> 2];
          $1_1 = $12_1 + 8 | 0;
          $15_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
          $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
          $4_1 = $6_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $1_1 = $8_1 + $15_1 | 0;
          $4_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $7_1 | 0;
          $6_1 = $1_1;
          $1_1 = $1_1 + $13_1 | 0;
          $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = $1_1;
          $1_1 = $1_1 + $9_1 | 0;
          $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $20_1 = $5_1;
          $13_1 = $1_1 << 12 | $5_1 >>> 20;
          $8_1 = $4_1;
          $7_1 = $4_1 << 12 | $1_1 >>> 20;
          $29_1 = HEAP32[$11_1 + 88 >> 2];
          $1_1 = HEAP32[$11_1 + 264 >> 2];
          $12_1 = $29_1 + $1_1 | 0;
          $44_1 = HEAP32[$11_1 + 92 >> 2];
          $4_1 = $44_1 + HEAP32[$11_1 + 268 >> 2] | 0;
          $4_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $1_1 = HEAP32[$11_1 + 184 >> 2];
          $15_1 = $1_1 + $12_1 | 0;
          $6_1 = $4_1;
          $4_1 = $4_1 + HEAP32[$11_1 + 188 >> 2] | 0;
          $4_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $1_1 = HEAP32[$11_1 + 200 >> 2];
          $9_1 = $1_1 + $15_1 | 0;
          $5_1 = $4_1;
          $4_1 = $4_1 + HEAP32[$11_1 + 204 >> 2] | 0;
          $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $1_1 + $7_1 | 0;
          $28_1 = $11_1 + 8 | 0;
          $13_1 = $9_1 + $13_1 | 0;
          $7_1 = $13_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $27_1 = ($1_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 > $13_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
          $17_1 = ($1_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $5_1 >>> 0;
          $1_1 = $16_1 + 8 | 0;
          $18_1 = HEAP32[$1_1 >> 2];
          $14_1 = HEAP32[$1_1 + 4 >> 2];
          $16_1 = ($5_1 | 0) == ($6_1 | 0) & $12_1 >>> 0 > $15_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
          $1_1 = $36_1 + 8 | 0;
          $15_1 = HEAP32[$1_1 >> 2];
          $9_1 = HEAP32[$1_1 + 4 >> 2];
          $6_1 = ($6_1 | 0) == ($44_1 | 0) & $12_1 >>> 0 < $29_1 >>> 0 | $6_1 >>> 0 < $44_1 >>> 0;
          $4_1 = $33_1 + 8 | 0;
          $5_1 = HEAP32[$4_1 >> 2];
          $1_1 = $40_1 + 8 | 0;
          $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
          $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
          $4_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $1_1 = $6_1 + $12_1 | 0;
          $4_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $9_1 | 0;
          $5_1 = $1_1;
          $1_1 = $1_1 + $15_1 | 0;
          $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = $1_1;
          $1_1 = $1_1 + $16_1 | 0;
          $4_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $14_1 | 0;
          $5_1 = $1_1;
          $1_1 = $1_1 + $18_1 | 0;
          $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = $1_1 + $17_1 | 0;
          $4_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = $8_1 >>> 20 | 0;
          $1_1 = $5_1 + $6_1 | 0;
          $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = $1_1;
          $1_1 = $1_1 + $27_1 | 0;
          $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = $7_1;
          $7_1 = $1_1 << 12 | $5_1 >>> 20;
          $6_1 = $4_1;
          $9_1 = $4_1 << 12 | $1_1 >>> 20;
          $27_1 = HEAP32[$11_1 + 172 >> 2];
          $4_1 = $27_1 + HEAP32[$11_1 + 108 >> 2] | 0;
          $14_1 = HEAP32[$11_1 + 168 >> 2];
          $1_1 = HEAP32[$11_1 + 104 >> 2];
          $8_1 = $14_1 + $1_1 | 0;
          $12_1 = $8_1;
          $7_1 = $8_1 + $7_1 | 0;
          $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $1_1 + $9_1 | 0;
          $15_1 = $7_1 << 4 & -16;
          $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $9_1 = ($8_1 << 4 | $7_1 >>> 28) & 16777215;
          $18_1 = $5_1;
          $69($28_1, $15_1 | $5_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
          $9_1 = $11_1;
          $43_1 = HEAP32[$9_1 + 8 >> 2];
          $5_1 = HEAP32[$9_1 + 328 >> 2];
          $15_1 = $43_1 + $5_1 | 0;
          $48_1 = HEAP32[$9_1 + 12 >> 2];
          $4_1 = $48_1 + HEAP32[$9_1 + 332 >> 2] | 0;
          HEAP32[$9_1 + 888 >> 2] = $15_1;
          $5_1 = $5_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$9_1 + 892 >> 2] = $5_1 & 1048575;
          $44_1 = $9_1 + 312 | 0;
          $69($44_1, $41_1, $38_1, 0, 0, $25_1, $30_1, 0, 0);
          $36_1 = $9_1 + 152 | 0;
          $69($36_1, $31_1, $24_1, 0, 0, $23_1, $21_1, 0, 0);
          $40_1 = $9_1 + 120 | 0;
          $69($40_1, $26_1, $22_1, 0, 0, $26_1, $22_1, 0, 0);
          $33_1 = $9_1 + 56 | 0;
          $17_1 = $33_1;
          $16_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
          $12_1 = ($1_1 | 0) == ($27_1 | 0) & $14_1 >>> 0 > $12_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
          $4_1 = $42_1 + 8 | 0;
          $7_1 = HEAP32[$4_1 >> 2];
          $1_1 = $37_1 + 8 | 0;
          $14_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
          $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
          $4_1 = $7_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $7_1 = $14_1 + $12_1 | 0;
          $4_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = $6_1 >>> 20 | 0;
          $1_1 = $6_1 + $7_1 | 0;
          $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = $1_1;
          $1_1 = $1_1 + $16_1 | 0;
          $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $16_1 = $1_1 << 12 | $8_1 >>> 20;
          $7_1 = $4_1;
          $12_1 = $4_1 << 12 | $1_1 >>> 20;
          $37_1 = HEAP32[$9_1 + 156 >> 2];
          $4_1 = $37_1 + HEAP32[$9_1 + 124 >> 2] | 0;
          $29_1 = HEAP32[$9_1 + 152 >> 2];
          $6_1 = HEAP32[$9_1 + 120 >> 2];
          $1_1 = $29_1 + $6_1 | 0;
          $27_1 = $1_1;
          $14_1 = $1_1 + $16_1 | 0;
          $8_1 = $1_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $8_1 + $12_1 | 0;
          $12_1 = $14_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $69($17_1, $14_1, $12_1 & 1048575, 0, 0, 15632, 16, 0, 0);
          $15_1 = ($5_1 | 0) == ($48_1 | 0) & $15_1 >>> 0 < $43_1 >>> 0 | $5_1 >>> 0 < $48_1 >>> 0;
          $4_1 = $49_1 + 8 | 0;
          $6_1 = HEAP32[$4_1 >> 2];
          $1_1 = $28_1 + 8 | 0;
          $16_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
          $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
          $4_1 = $6_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $1_1 = $15_1 + $16_1 | 0;
          $4_1 = $1_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $16_1 = $1_1 << 12 | $5_1 >>> 20;
          $6_1 = $4_1;
          $15_1 = $4_1 << 12 | $1_1 >>> 20;
          $28_1 = HEAP32[$9_1 + 56 >> 2];
          $1_1 = HEAP32[$9_1 + 312 >> 2];
          $17_1 = $28_1 + $1_1 | 0;
          $42_1 = HEAP32[$9_1 + 60 >> 2];
          $4_1 = $42_1 + HEAP32[$9_1 + 316 >> 2] | 0;
          $5_1 = $1_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $5_1 + $15_1 | 0;
          $16_1 = $16_1 + $17_1 | 0;
          $4_1 = $16_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$9_1 + 896 >> 2] = $16_1;
          $15_1 = $4_1;
          HEAP32[$9_1 + 900 >> 2] = $4_1 & 1048575;
          $43_1 = $9_1 + 248 | 0;
          $69($43_1, $23_1, $21_1, 0, 0, $25_1, $30_1, 0, 0);
          $30_1 = $9_1 + 296 | 0;
          $69($30_1, $41_1, $38_1, 0, 0, $41_1, $38_1, 0, 0);
          $25_1 = $9_1 + 136 | 0;
          $69($25_1, $31_1, $24_1, 0, 0, $26_1, $22_1, 0, 0);
          $23_1 = $9_1 + 40 | 0;
          $21_1 = ($8_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 < $27_1 >>> 0 | $8_1 >>> 0 > $12_1 >>> 0;
          $14_1 = ($8_1 | 0) == ($37_1 | 0) & $27_1 >>> 0 < $29_1 >>> 0 | $8_1 >>> 0 < $37_1 >>> 0;
          $4_1 = $40_1 + 8 | 0;
          $8_1 = HEAP32[$4_1 >> 2];
          $1_1 = $36_1 + 8 | 0;
          $22_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
          $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
          $4_1 = $8_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $8_1 = $14_1 + $22_1 | 0;
          $4_1 = $8_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $7_1 = $7_1 >>> 20 | 0;
          $1_1 = $7_1 + $8_1 | 0;
          $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $7_1 = $1_1;
          $1_1 = $1_1 + $21_1 | 0;
          $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $22_1 = $1_1 << 12 | $12_1 >>> 20;
          $7_1 = HEAP32[$9_1 + 136 >> 2];
          $12_1 = $22_1 + $7_1 | 0;
          $8_1 = $4_1;
          $27_1 = $4_1 << 12 | $1_1 >>> 20;
          $4_1 = $27_1 + HEAP32[$9_1 + 140 >> 2] | 0;
          $21_1 = $7_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $69($23_1, $12_1, $21_1, 0, 0, 15632, 16, 0, 0);
          $7_1 = $9_1;
          $16_1 = ($5_1 | 0) == ($15_1 | 0) & $16_1 >>> 0 < $17_1 >>> 0 | $5_1 >>> 0 > $15_1 >>> 0;
          $9_1 = ($5_1 | 0) == ($42_1 | 0) & $17_1 >>> 0 < $28_1 >>> 0 | $5_1 >>> 0 < $42_1 >>> 0;
          $4_1 = $44_1 + 8 | 0;
          $5_1 = HEAP32[$4_1 >> 2];
          $1_1 = $33_1 + 8 | 0;
          $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
          $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
          $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = $9_1 + $14_1 | 0;
          $4_1 = $5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = $6_1 >>> 20 | 0;
          $1_1 = $5_1 + $6_1 | 0;
          $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = $1_1;
          $1_1 = $1_1 + $16_1 | 0;
          $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $15_1 = $1_1 << 12 | $15_1 >>> 20;
          $6_1 = $4_1;
          $9_1 = $4_1 << 12 | $1_1 >>> 20;
          $17_1 = HEAP32[$7_1 + 248 >> 2];
          $1_1 = HEAP32[$7_1 + 296 >> 2];
          $14_1 = $17_1 + $1_1 | 0;
          $24_1 = HEAP32[$7_1 + 252 >> 2];
          $4_1 = $24_1 + HEAP32[$7_1 + 300 >> 2] | 0;
          $4_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $1_1 = HEAP32[$7_1 + 40 >> 2];
          $16_1 = $1_1 + $14_1 | 0;
          $5_1 = $4_1;
          $4_1 = $4_1 + HEAP32[$7_1 + 44 >> 2] | 0;
          $1_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $1_1 + $9_1 | 0;
          $15_1 = $15_1 + $16_1 | 0;
          $4_1 = $15_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$7_1 + 904 >> 2] = $15_1;
          $9_1 = $4_1;
          HEAP32[$7_1 + 908 >> 2] = $4_1 & 1048575;
          $26_1 = $7_1 + 24 | 0;
          $22_1 = ($21_1 | 0) == ($27_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
          $4_1 = $25_1 + 8 | 0;
          $21_1 = HEAP32[$4_1 >> 2];
          $4_1 = HEAP32[$4_1 + 4 >> 2];
          $8_1 = $8_1 >>> 20 | 0;
          $12_1 = $8_1;
          $8_1 = $8_1 + $21_1 | 0;
          $4_1 = $12_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $12_1 = $8_1;
          $8_1 = $8_1 + $22_1 | 0;
          $4_1 = $12_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $69($26_1, $8_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
          $8_1 = $7_1;
          $21_1 = ($1_1 | 0) == ($9_1 | 0) & $15_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
          $16_1 = ($1_1 | 0) == ($5_1 | 0) & $14_1 >>> 0 > $16_1 >>> 0 | $1_1 >>> 0 < $5_1 >>> 0;
          $1_1 = $23_1 + 8 | 0;
          $12_1 = HEAP32[$1_1 >> 2];
          $15_1 = HEAP32[$1_1 + 4 >> 2];
          $7_1 = ($5_1 | 0) == ($24_1 | 0) & $14_1 >>> 0 < $17_1 >>> 0 | $5_1 >>> 0 < $24_1 >>> 0;
          $4_1 = $30_1 + 8 | 0;
          $5_1 = HEAP32[$4_1 >> 2];
          $1_1 = $43_1 + 8 | 0;
          $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
          $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
          $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $1_1 = $7_1 + $14_1 | 0;
          $4_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $15_1 | 0;
          $5_1 = $1_1;
          $1_1 = $1_1 + $12_1 | 0;
          $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = $1_1 + $16_1 | 0;
          $4_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = $6_1 >>> 20 | 0;
          $1_1 = $5_1 + $6_1 | 0;
          $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = $1_1;
          $1_1 = $1_1 + $21_1 | 0;
          $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $15_1 = $1_1 << 12 | $9_1 >>> 20;
          $6_1 = $4_1;
          $7_1 = $4_1 << 12 | $1_1 >>> 20;
          $12_1 = HEAP32[$8_1 + 24 >> 2];
          $1_1 = $19_1 & -2;
          $9_1 = $12_1 + $1_1 | 0;
          $16_1 = HEAP32[$8_1 + 28 >> 2];
          $4_1 = $16_1 + ($20_1 & 1048575) | 0;
          $5_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $5_1 + $7_1 | 0;
          $7_1 = $9_1 + $15_1 | 0;
          $4_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$8_1 + 912 >> 2] = $7_1;
          $1_1 = $4_1;
          HEAP32[$8_1 + 916 >> 2] = $4_1 & 1048575;
          $15_1 = $18_1 & 65535;
          $7_1 = ($4_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 > $7_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
          $5_1 = ($5_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $5_1 >>> 0 < $16_1 >>> 0;
          $4_1 = $26_1 + 8 | 0;
          $8_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
          $4_1 = HEAP32[$4_1 + 4 >> 2];
          $4_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = $6_1 >>> 20 | 0;
          $5_1 = $6_1 + $8_1 | 0;
          $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = $5_1;
          $5_1 = $5_1 + $7_1 | 0;
          $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $1_1 = $5_1 << 12 | $1_1 >>> 20;
          $6_1 = $1_1 + $13_1 | 0;
          $4_1 = $15_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
          HEAP32[$11_1 + 920 >> 2] = $6_1;
          HEAP32[$11_1 + 924 >> 2] = $1_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $11_1 + 848 | 0;
          $1_1 = $11_1 + 888 | 0;
          $34($4_1, $1_1, $50_1);
          $34($32_1, $34_1, $1_1);
          $34($47_1, $39_1, $4_1);
          HEAP32[$32_1 + 80 >> 2] = 0;
          $32_1 = $32_1 - 88 | 0;
          $35_1 = $35_1 - 40 | 0;
          $51_1 = $51_1 - 1 | 0;
          if ($51_1) {
            continue;
          }
          break;
        }
        ;
        global$0 = $11_1 + 928 | 0;
        $1_1 = 0;
        $32_1 = ($52_1 | 0) > 0 ? $52_1 : 0;
        while (1) {
          $40_1 = $10_1 - -64 | 0;
          $53_1 = HEAP32[$2_1 >> 2];
          $54_1 = HEAP32[$2_1 + 4 >> 2];
          $69($40_1, $53_1, $54_1, 0, 0, -431719958, 28934, 0, 0);
          $33_1 = $10_1 + 416 | 0;
          $4_1 = $2_1 + 8 | 0;
          $55_1 = HEAP32[$4_1 >> 2];
          $56_1 = HEAP32[$4_1 + 4 >> 2];
          $69($33_1, $55_1, $56_1, 0, 0, -375590839, 799796, 0, 0);
          $29_1 = $10_1 + 336 | 0;
          $4_1 = $2_1 + 16 | 0;
          $57_1 = HEAP32[$4_1 >> 2];
          $58_1 = HEAP32[$4_1 + 4 >> 2];
          $69($29_1, $57_1, $58_1, 0, 0, 1486445587, 479535, 0, 0);
          $26_1 = $10_1 + 256 | 0;
          $4_1 = $2_1 + 24 | 0;
          $59_1 = HEAP32[$4_1 >> 2];
          $60_1 = HEAP32[$4_1 + 4 >> 2];
          $69($26_1, $59_1, $60_1, 0, 0, 1905590766, 617512, 0, 0);
          $5_1 = $10_1 + 176 | 0;
          $4_1 = $2_1 + 32 | 0;
          $61_1 = HEAP32[$4_1 >> 2];
          $45_1 = HEAP32[$4_1 + 4 >> 2];
          $69($5_1, $61_1, $45_1, 0, 0, 1781228924, 31465, 0, 0);
          $19_1 = $10_1 + 160 | 0;
          $69($19_1, HEAP32[$10_1 + 176 >> 2] & -4, HEAP32[$10_1 + 180 >> 2], 0, 0, 15632, 16, 0, 0);
          $34_1 = $10_1 + 80 | 0;
          $69($34_1, $53_1, $54_1, 0, 0, 1781228924, 31465, 0, 0);
          $51_1 = $10_1 + 432 | 0;
          $69($51_1, $55_1, $56_1, 0, 0, -431719958, 28934, 0, 0);
          $50_1 = $10_1 + 352 | 0;
          $69($50_1, $57_1, $58_1, 0, 0, -375590839, 799796, 0, 0);
          $47_1 = $10_1 + 272 | 0;
          $69($47_1, $59_1, $60_1, 0, 0, 1486445587, 479535, 0, 0);
          $48_1 = $10_1 + 192 | 0;
          $69($48_1, $61_1, $45_1, 0, 0, 1905590766, 617512, 0, 0);
          $28_1 = $10_1 + 144 | 0;
          $4_1 = $5_1 + 8 | 0;
          $69($28_1, HEAP32[$4_1 >> 2], HEAP32[$4_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
          $38_1 = $10_1 + 96 | 0;
          $69($38_1, $53_1, $54_1, 0, 0, 1905590766, 617512, 0, 0);
          $41_1 = $10_1 + 448 | 0;
          $69($41_1, $55_1, $56_1, 0, 0, 1781228924, 31465, 0, 0);
          $49_1 = $10_1 + 368 | 0;
          $69($49_1, $57_1, $58_1, 0, 0, -431719958, 28934, 0, 0);
          $37_1 = $10_1 + 288 | 0;
          $69($37_1, $59_1, $60_1, 0, 0, -375590839, 799796, 0, 0);
          $42_1 = $10_1 + 208 | 0;
          $69($42_1, $61_1, $45_1, 0, 0, 1486445587, 479535, 0, 0);
          $44_1 = HEAP32[$10_1 + 432 >> 2];
          $5_1 = HEAP32[$10_1 + 80 >> 2];
          $23_1 = $44_1 + $5_1 | 0;
          $52_1 = HEAP32[$10_1 + 436 >> 2];
          $4_1 = $52_1 + HEAP32[$10_1 + 84 >> 2] | 0;
          $4_1 = $5_1 >>> 0 > $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = HEAP32[$10_1 + 352 >> 2];
          $22_1 = $5_1 + $23_1 | 0;
          $24_1 = $4_1;
          $4_1 = $4_1 + HEAP32[$10_1 + 356 >> 2] | 0;
          $4_1 = $5_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = HEAP32[$10_1 + 272 >> 2];
          $21_1 = $5_1 + $22_1 | 0;
          $12_1 = $4_1;
          $4_1 = $4_1 + HEAP32[$10_1 + 276 >> 2] | 0;
          $4_1 = $5_1 >>> 0 > $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = HEAP32[$10_1 + 192 >> 2];
          $20_1 = $5_1 + $21_1 | 0;
          $15_1 = $4_1;
          $4_1 = $4_1 + HEAP32[$10_1 + 196 >> 2] | 0;
          $4_1 = $5_1 >>> 0 > $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = HEAP32[$10_1 + 144 >> 2];
          $18_1 = $5_1 + $20_1 | 0;
          $9_1 = $4_1;
          $4_1 = $4_1 + HEAP32[$10_1 + 148 >> 2] | 0;
          $6_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $43_1 = HEAP32[$10_1 + 416 >> 2];
          $5_1 = HEAP32[$10_1 + 64 >> 2];
          $14_1 = $43_1 + $5_1 | 0;
          $36_1 = HEAP32[$10_1 + 420 >> 2];
          $4_1 = $36_1 + HEAP32[$10_1 + 68 >> 2] | 0;
          $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = HEAP32[$10_1 + 336 >> 2];
          $16_1 = $5_1 + $14_1 | 0;
          $7_1 = $4_1;
          $4_1 = $4_1 + HEAP32[$10_1 + 340 >> 2] | 0;
          $8_1 = $5_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $8_1 + HEAP32[$10_1 + 260 >> 2] | 0;
          $5_1 = HEAP32[$10_1 + 256 >> 2];
          $11_1 = $5_1 + $16_1 | 0;
          $13_1 = HEAP32[$10_1 + 160 >> 2];
          $30_1 = $11_1 + $13_1 | 0;
          $5_1 = $5_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $5_1 + HEAP32[$10_1 + 164 >> 2] | 0;
          $13_1 = $13_1 >>> 0 > $30_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $35_1 = ($5_1 | 0) == ($13_1 | 0) & $11_1 >>> 0 > $30_1 >>> 0 | $5_1 >>> 0 > $13_1 >>> 0;
          $4_1 = $19_1 + 8 | 0;
          $31_1 = HEAP32[$4_1 >> 2];
          $27_1 = HEAP32[$4_1 + 4 >> 2];
          $25_1 = ($5_1 | 0) == ($8_1 | 0) & $11_1 >>> 0 < $16_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
          $4_1 = $26_1 + 8 | 0;
          $17_1 = HEAP32[$4_1 >> 2];
          $26_1 = HEAP32[$4_1 + 4 >> 2];
          $19_1 = ($7_1 | 0) == ($8_1 | 0) & $14_1 >>> 0 > $16_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
          $4_1 = $29_1 + 8 | 0;
          $16_1 = HEAP32[$4_1 >> 2];
          $11_1 = HEAP32[$4_1 + 4 >> 2];
          $7_1 = ($7_1 | 0) == ($36_1 | 0) & $14_1 >>> 0 < $43_1 >>> 0 | $7_1 >>> 0 < $36_1 >>> 0;
          $8_1 = $40_1 + 8 | 0;
          $5_1 = HEAP32[$8_1 >> 2];
          $4_1 = $33_1 + 8 | 0;
          $14_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
          $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
          $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = $7_1 + $14_1 | 0;
          $4_1 = ($5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $11_1 | 0;
          $7_1 = $5_1;
          $5_1 = $5_1 + $16_1 | 0;
          $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $7_1 = $5_1;
          $5_1 = $5_1 + $19_1 | 0;
          $4_1 = ($7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $26_1 | 0;
          $7_1 = $5_1;
          $5_1 = $5_1 + $17_1 | 0;
          $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $7_1 = $5_1;
          $5_1 = $5_1 + $25_1 | 0;
          $4_1 = ($7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $27_1 | 0;
          $7_1 = $5_1;
          $5_1 = $5_1 + $31_1 | 0;
          $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $7_1 = $5_1;
          $5_1 = $5_1 + $35_1 | 0;
          $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $19_1 = $13_1;
          $7_1 = $5_1 << 12 | $13_1 >>> 20;
          $11_1 = $7_1 + $18_1 | 0;
          $8_1 = $4_1;
          $4_1 = $6_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
          $16_1 = $7_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $36_1 = HEAP32[$10_1 + 368 >> 2];
          $5_1 = HEAP32[$10_1 + 448 >> 2];
          $17_1 = $36_1 + $5_1 | 0;
          $39_1 = HEAP32[$10_1 + 372 >> 2];
          $4_1 = $39_1 + HEAP32[$10_1 + 452 >> 2] | 0;
          $4_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = HEAP32[$10_1 + 288 >> 2];
          $26_1 = $5_1 + $17_1 | 0;
          $13_1 = $4_1;
          $4_1 = $4_1 + HEAP32[$10_1 + 292 >> 2] | 0;
          $4_1 = $5_1 >>> 0 > $26_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = HEAP32[$10_1 + 208 >> 2];
          $14_1 = $5_1 + $26_1 | 0;
          $7_1 = $4_1;
          $4_1 = $4_1 + HEAP32[$10_1 + 212 >> 2] | 0;
          $5_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $40_1 = ($6_1 | 0) == ($16_1 | 0) & $11_1 >>> 0 < $18_1 >>> 0 | $6_1 >>> 0 > $16_1 >>> 0;
          $33_1 = ($6_1 | 0) == ($9_1 | 0) & $18_1 >>> 0 < $20_1 >>> 0 | $6_1 >>> 0 < $9_1 >>> 0;
          $4_1 = $28_1 + 8 | 0;
          $29_1 = HEAP32[$4_1 >> 2];
          $28_1 = HEAP32[$4_1 + 4 >> 2];
          $43_1 = ($9_1 | 0) == ($15_1 | 0) & $20_1 >>> 0 < $21_1 >>> 0 | $9_1 >>> 0 < $15_1 >>> 0;
          $4_1 = $48_1 + 8 | 0;
          $35_1 = HEAP32[$4_1 >> 2];
          $31_1 = HEAP32[$4_1 + 4 >> 2];
          $27_1 = ($12_1 | 0) == ($15_1 | 0) & $21_1 >>> 0 < $22_1 >>> 0 | $12_1 >>> 0 > $15_1 >>> 0;
          $4_1 = $47_1 + 8 | 0;
          $25_1 = HEAP32[$4_1 >> 2];
          $21_1 = HEAP32[$4_1 + 4 >> 2];
          $20_1 = ($12_1 | 0) == ($24_1 | 0) & $22_1 >>> 0 < $23_1 >>> 0 | $12_1 >>> 0 < $24_1 >>> 0;
          $4_1 = $50_1 + 8 | 0;
          $18_1 = HEAP32[$4_1 >> 2];
          $12_1 = HEAP32[$4_1 + 4 >> 2];
          $15_1 = ($24_1 | 0) == ($52_1 | 0) & $23_1 >>> 0 < $44_1 >>> 0 | $24_1 >>> 0 < $52_1 >>> 0;
          $9_1 = $34_1 + 8 | 0;
          $6_1 = HEAP32[$9_1 >> 2];
          $4_1 = $51_1 + 8 | 0;
          $22_1 = $6_1 + HEAP32[$4_1 >> 2] | 0;
          $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
          $4_1 = $6_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = $15_1 + $22_1 | 0;
          $4_1 = ($6_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $12_1 | 0;
          $9_1 = $6_1;
          $6_1 = $6_1 + $18_1 | 0;
          $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $9_1 = $6_1;
          $6_1 = $6_1 + $20_1 | 0;
          $4_1 = ($9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $21_1 | 0;
          $9_1 = $6_1;
          $6_1 = $6_1 + $25_1 | 0;
          $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $9_1 = $6_1;
          $6_1 = $6_1 + $27_1 | 0;
          $4_1 = ($9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $31_1 | 0;
          $9_1 = $6_1;
          $6_1 = $6_1 + $35_1 | 0;
          $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $9_1 = $6_1;
          $6_1 = $6_1 + $43_1 | 0;
          $4_1 = ($9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $28_1 | 0;
          $9_1 = $6_1;
          $6_1 = $6_1 + $29_1 | 0;
          $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $9_1 = $6_1 + $33_1 | 0;
          $4_1 = $9_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $8_1 = $8_1 >>> 20 | 0;
          $6_1 = $9_1 + $8_1 | 0;
          $4_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $8_1 = $6_1;
          $6_1 = $6_1 + $40_1 | 0;
          $8_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $9_1 = $8_1 << 12 | $6_1 >>> 20;
          $4_1 = $6_1 << 12;
          $6_1 = $16_1;
          $15_1 = $4_1 | $6_1 >>> 20;
          $16_1 = $15_1 + $14_1 | 0;
          $4_1 = $5_1 + $9_1 | 0;
          $12_1 = $15_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $9_1 = $16_1;
          $4_1 = $12_1 << 4 | $9_1 >>> 28;
          $15_1 = $9_1 << 4 & -16;
          $9_1 = $4_1 & 16777215;
          $20_1 = $6_1;
          $69($10_1, $15_1 | $6_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
          $33_1 = HEAP32[$10_1 + 4 >> 2];
          $4_1 = $33_1 + HEAP32[$10_1 + 100 >> 2] | 0;
          $46_1 = ($10_1 + 2240 | 0) + $1_1 | 0;
          $9_1 = $46_1;
          $29_1 = HEAP32[$10_1 >> 2];
          $6_1 = HEAP32[$10_1 + 96 >> 2];
          $18_1 = $29_1 + $6_1 | 0;
          HEAP32[$9_1 >> 2] = $18_1;
          $15_1 = $6_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$9_1 + 4 >> 2] = $15_1 & 1048575;
          $51_1 = $10_1 + 112 | 0;
          $69($51_1, $53_1, $54_1, 0, 0, 1486445587, 479535, 0, 0);
          $50_1 = $10_1 + 464 | 0;
          $69($50_1, $55_1, $56_1, 0, 0, 1905590766, 617512, 0, 0);
          $47_1 = $10_1 + 384 | 0;
          $69($47_1, $57_1, $58_1, 0, 0, 1781228924, 31465, 0, 0);
          $28_1 = $10_1 + 304 | 0;
          $69($28_1, $59_1, $60_1, 0, 0, -431719958, 28934, 0, 0);
          $43_1 = $10_1 + 224 | 0;
          $69($43_1, $61_1, $45_1, 0, 0, -375590839, 799796, 0, 0);
          $48_1 = $10_1 + 48 | 0;
          $31_1 = $48_1;
          $35_1 = HEAP32[$10_1 + 304 >> 2];
          $6_1 = HEAP32[$10_1 + 384 >> 2];
          $22_1 = $35_1 + $6_1 | 0;
          $52_1 = HEAP32[$10_1 + 308 >> 2];
          $4_1 = $52_1 + HEAP32[$10_1 + 388 >> 2] | 0;
          $4_1 = $6_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = HEAP32[$10_1 + 224 >> 2];
          $21_1 = $6_1 + $22_1 | 0;
          $9_1 = $4_1;
          $4_1 = $4_1 + HEAP32[$10_1 + 228 >> 2] | 0;
          $6_1 = $6_1 >>> 0 > $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $27_1 = ($5_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 > $16_1 >>> 0 | $5_1 >>> 0 > $12_1 >>> 0;
          $25_1 = ($5_1 | 0) == ($7_1 | 0) & $14_1 >>> 0 < $26_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
          $4_1 = $42_1 + 8 | 0;
          $24_1 = HEAP32[$4_1 >> 2];
          $23_1 = HEAP32[$4_1 + 4 >> 2];
          $26_1 = ($7_1 | 0) == ($13_1 | 0) & $17_1 >>> 0 > $26_1 >>> 0 | $7_1 >>> 0 < $13_1 >>> 0;
          $4_1 = $37_1 + 8 | 0;
          $14_1 = HEAP32[$4_1 >> 2];
          $16_1 = HEAP32[$4_1 + 4 >> 2];
          $13_1 = ($13_1 | 0) == ($39_1 | 0) & $17_1 >>> 0 < $36_1 >>> 0 | $13_1 >>> 0 < $39_1 >>> 0;
          $7_1 = $41_1 + 8 | 0;
          $5_1 = HEAP32[$7_1 >> 2];
          $4_1 = $49_1 + 8 | 0;
          $17_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
          $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
          $4_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = $13_1 + $17_1 | 0;
          $4_1 = ($5_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $16_1 | 0;
          $7_1 = $5_1;
          $5_1 = $5_1 + $14_1 | 0;
          $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $7_1 = $5_1;
          $5_1 = $5_1 + $26_1 | 0;
          $4_1 = ($7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $23_1 | 0;
          $7_1 = $5_1;
          $5_1 = $5_1 + $24_1 | 0;
          $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $7_1 = $5_1 + $25_1 | 0;
          $4_1 = $7_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $8_1 = $8_1 >>> 20 | 0;
          $5_1 = $7_1 + $8_1 | 0;
          $4_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $7_1 = $5_1;
          $5_1 = $5_1 + $27_1 | 0;
          $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $8_1 = $5_1 << 12 | $12_1 >>> 20;
          $14_1 = $8_1 + $21_1 | 0;
          $13_1 = $4_1;
          $4_1 = $6_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
          $16_1 = $8_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $69($31_1, $14_1, $16_1 & 1048575, 0, 0, 15632, 16, 0, 0);
          $17_1 = $46_1 + 8 | 0;
          $49_1 = HEAP32[$10_1 + 464 >> 2];
          $5_1 = HEAP32[$10_1 + 112 >> 2];
          $25_1 = $49_1 + $5_1 | 0;
          $34_1 = HEAP32[$10_1 + 468 >> 2];
          $4_1 = $34_1 + HEAP32[$10_1 + 116 >> 2] | 0;
          $4_1 = $5_1 >>> 0 > $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = HEAP32[$10_1 + 48 >> 2];
          $24_1 = $5_1 + $25_1 | 0;
          $27_1 = $4_1;
          $4_1 = $4_1 + HEAP32[$10_1 + 52 >> 2] | 0;
          $8_1 = $5_1 >>> 0 > $24_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $12_1 = ($15_1 | 0) == ($33_1 | 0) & $18_1 >>> 0 < $29_1 >>> 0 | $15_1 >>> 0 < $33_1 >>> 0;
          $7_1 = $38_1 + 8 | 0;
          $5_1 = HEAP32[$7_1 >> 2];
          $4_1 = $10_1 + 8 | 0;
          $18_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
          $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
          $4_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = $12_1 + $18_1 | 0;
          $4_1 = $5_1 >>> 0 < $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $15_1 = $5_1 << 12 | $15_1 >>> 20;
          $18_1 = $15_1 + $24_1 | 0;
          $7_1 = $4_1;
          $4_1 = $8_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
          HEAP32[$17_1 >> 2] = $18_1;
          $12_1 = $15_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$17_1 + 4 >> 2] = $12_1 & 1048575;
          $37_1 = $10_1 + 128 | 0;
          $69($37_1, $53_1, $54_1, 0, 0, -375590839, 799796, 0, 0);
          $42_1 = $10_1 + 480 | 0;
          $69($42_1, $55_1, $56_1, 0, 0, 1486445587, 479535, 0, 0);
          $44_1 = $10_1 + 400 | 0;
          $69($44_1, $57_1, $58_1, 0, 0, 1905590766, 617512, 0, 0);
          $36_1 = $10_1 + 320 | 0;
          $69($36_1, $59_1, $60_1, 0, 0, 1781228924, 31465, 0, 0);
          $40_1 = $10_1 + 240 | 0;
          $69($40_1, $61_1, $45_1, 0, 0, -431719958, 28934, 0, 0);
          $33_1 = $10_1 + 32 | 0;
          $31_1 = $33_1;
          $29_1 = HEAP32[$10_1 + 240 >> 2];
          $5_1 = HEAP32[$10_1 + 320 >> 2];
          $23_1 = $29_1 + $5_1 | 0;
          $38_1 = HEAP32[$10_1 + 244 >> 2];
          $4_1 = $38_1 + HEAP32[$10_1 + 324 >> 2] | 0;
          $5_1 = $5_1 >>> 0 > $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $17_1 = ($6_1 | 0) == ($16_1 | 0) & $14_1 >>> 0 < $21_1 >>> 0 | $6_1 >>> 0 > $16_1 >>> 0;
          $26_1 = ($6_1 | 0) == ($9_1 | 0) & $21_1 >>> 0 < $22_1 >>> 0 | $6_1 >>> 0 < $9_1 >>> 0;
          $4_1 = $43_1 + 8 | 0;
          $21_1 = HEAP32[$4_1 >> 2];
          $14_1 = HEAP32[$4_1 + 4 >> 2];
          $15_1 = ($9_1 | 0) == ($52_1 | 0) & $22_1 >>> 0 < $35_1 >>> 0 | $9_1 >>> 0 < $52_1 >>> 0;
          $9_1 = $47_1 + 8 | 0;
          $6_1 = HEAP32[$9_1 >> 2];
          $4_1 = $28_1 + 8 | 0;
          $22_1 = $6_1 + HEAP32[$4_1 >> 2] | 0;
          $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
          $4_1 = $6_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = $15_1 + $22_1 | 0;
          $4_1 = ($6_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $14_1 | 0;
          $9_1 = $6_1;
          $6_1 = $6_1 + $21_1 | 0;
          $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $9_1 = $6_1 + $26_1 | 0;
          $4_1 = $9_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $13_1 = $13_1 >>> 20 | 0;
          $6_1 = $9_1 + $13_1 | 0;
          $4_1 = $13_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $9_1 = $6_1;
          $6_1 = $6_1 + $17_1 | 0;
          $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $13_1 = $6_1 << 12 | $16_1 >>> 20;
          $14_1 = $13_1 + $23_1 | 0;
          $15_1 = $4_1;
          $4_1 = $5_1 + ($4_1 << 12 | $6_1 >>> 20) | 0;
          $17_1 = $14_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $69($31_1, $14_1, $17_1, 0, 0, 15632, 16, 0, 0);
          $41_1 = $46_1 + 16 | 0;
          $28_1 = HEAP32[$10_1 + 480 >> 2];
          $6_1 = HEAP32[$10_1 + 128 >> 2];
          $26_1 = $28_1 + $6_1 | 0;
          $47_1 = HEAP32[$10_1 + 484 >> 2];
          $4_1 = $47_1 + HEAP32[$10_1 + 132 >> 2] | 0;
          $4_1 = $6_1 >>> 0 > $26_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = HEAP32[$10_1 + 400 >> 2];
          $22_1 = $6_1 + $26_1 | 0;
          $9_1 = $4_1;
          $4_1 = $4_1 + HEAP32[$10_1 + 404 >> 2] | 0;
          $4_1 = $6_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = HEAP32[$10_1 + 32 >> 2];
          $21_1 = $6_1 + $22_1 | 0;
          $13_1 = $4_1;
          $4_1 = $4_1 + HEAP32[$10_1 + 36 >> 2] | 0;
          $6_1 = $6_1 >>> 0 > $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $43_1 = ($8_1 | 0) == ($12_1 | 0) & $18_1 >>> 0 < $24_1 >>> 0 | $8_1 >>> 0 > $12_1 >>> 0;
          $35_1 = ($8_1 | 0) == ($27_1 | 0) & $25_1 >>> 0 > $24_1 >>> 0 | $8_1 >>> 0 < $27_1 >>> 0;
          $4_1 = $48_1 + 8 | 0;
          $31_1 = HEAP32[$4_1 >> 2];
          $24_1 = HEAP32[$4_1 + 4 >> 2];
          $18_1 = ($27_1 | 0) == ($34_1 | 0) & $25_1 >>> 0 < $49_1 >>> 0 | $27_1 >>> 0 < $34_1 >>> 0;
          $16_1 = $51_1 + 8 | 0;
          $8_1 = HEAP32[$16_1 >> 2];
          $4_1 = $50_1 + 8 | 0;
          $25_1 = $8_1 + HEAP32[$4_1 >> 2] | 0;
          $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$16_1 + 4 >> 2] | 0;
          $4_1 = $8_1 >>> 0 > $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $8_1 = $18_1 + $25_1 | 0;
          $4_1 = ($8_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $24_1 | 0;
          $16_1 = $8_1;
          $8_1 = $8_1 + $31_1 | 0;
          $4_1 = $16_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $16_1 = $8_1 + $35_1 | 0;
          $4_1 = $16_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $7_1 = $7_1 >>> 20 | 0;
          $8_1 = $7_1 + $16_1 | 0;
          $4_1 = $7_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $7_1 = $8_1;
          $8_1 = $8_1 + $43_1 | 0;
          $4_1 = $7_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $12_1 = $8_1 << 12 | $12_1 >>> 20;
          $16_1 = $12_1 + $21_1 | 0;
          $7_1 = $4_1;
          $4_1 = $6_1 + ($4_1 << 12 | $8_1 >>> 20) | 0;
          HEAP32[$41_1 >> 2] = $16_1;
          $12_1 = $12_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$41_1 + 4 >> 2] = $12_1 & 1048575;
          $25_1 = $10_1 + 16 | 0;
          $24_1 = $25_1;
          $18_1 = ($5_1 | 0) == ($17_1 | 0) & $14_1 >>> 0 < $23_1 >>> 0 | $5_1 >>> 0 > $17_1 >>> 0;
          $14_1 = ($5_1 | 0) == ($38_1 | 0) & $23_1 >>> 0 < $29_1 >>> 0 | $5_1 >>> 0 < $38_1 >>> 0;
          $8_1 = $36_1 + 8 | 0;
          $5_1 = HEAP32[$8_1 >> 2];
          $4_1 = $40_1 + 8 | 0;
          $17_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
          $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
          $4_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $8_1 = $14_1 + $17_1 | 0;
          $4_1 = $8_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $15_1 = $15_1 >>> 20 | 0;
          $5_1 = $8_1 + $15_1 | 0;
          $4_1 = $15_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $8_1 = $5_1;
          $5_1 = $5_1 + $18_1 | 0;
          $4_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $69($24_1, $5_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
          $31_1 = $46_1 + 24 | 0;
          $27_1 = HEAP32[$10_1 + 20 >> 2];
          $4_1 = $27_1 + ($19_1 & 1048575) | 0;
          $24_1 = HEAP32[$10_1 + 16 >> 2];
          $8_1 = $30_1 + $24_1 | 0;
          $5_1 = $8_1 >>> 0 < $30_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $15_1 = $8_1;
          $23_1 = ($6_1 | 0) == ($12_1 | 0) & $16_1 >>> 0 < $21_1 >>> 0 | $6_1 >>> 0 > $12_1 >>> 0;
          $17_1 = ($6_1 | 0) == ($13_1 | 0) & $21_1 >>> 0 < $22_1 >>> 0 | $6_1 >>> 0 < $13_1 >>> 0;
          $4_1 = $33_1 + 8 | 0;
          $21_1 = HEAP32[$4_1 >> 2];
          $19_1 = HEAP32[$4_1 + 4 >> 2];
          $18_1 = ($9_1 | 0) == ($13_1 | 0) & $22_1 >>> 0 < $26_1 >>> 0 | $9_1 >>> 0 > $13_1 >>> 0;
          $4_1 = $44_1 + 8 | 0;
          $14_1 = HEAP32[$4_1 >> 2];
          $16_1 = HEAP32[$4_1 + 4 >> 2];
          $13_1 = ($9_1 | 0) == ($47_1 | 0) & $26_1 >>> 0 < $28_1 >>> 0 | $9_1 >>> 0 < $47_1 >>> 0;
          $8_1 = $37_1 + 8 | 0;
          $6_1 = HEAP32[$8_1 >> 2];
          $4_1 = $42_1 + 8 | 0;
          $9_1 = $6_1 + HEAP32[$4_1 >> 2] | 0;
          $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
          $4_1 = $6_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = $9_1 + $13_1 | 0;
          $4_1 = ($6_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $16_1 | 0;
          $8_1 = $6_1;
          $6_1 = $6_1 + $14_1 | 0;
          $4_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $8_1 = $6_1;
          $6_1 = $6_1 + $18_1 | 0;
          $4_1 = ($8_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $19_1 | 0;
          $8_1 = $6_1;
          $6_1 = $6_1 + $21_1 | 0;
          $4_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $8_1 = $6_1 + $17_1 | 0;
          $4_1 = $8_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $7_1 = $7_1 >>> 20 | 0;
          $6_1 = $7_1 + $8_1 | 0;
          $4_1 = $7_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $7_1 = $6_1;
          $6_1 = $6_1 + $23_1 | 0;
          $4_1 = $7_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $13_1 = $6_1 << 12 | $12_1 >>> 20;
          $7_1 = $13_1 + $15_1 | 0;
          $8_1 = $4_1;
          $4_1 = $5_1 + ($4_1 << 12 | $6_1 >>> 20) | 0;
          HEAP32[$31_1 >> 2] = $7_1;
          $6_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$31_1 + 4 >> 2] = $6_1 & 1048575;
          $12_1 = $46_1 + 32 | 0;
          $9_1 = $20_1 & 65535;
          $13_1 = ($5_1 | 0) == ($6_1 | 0) & $7_1 >>> 0 < $15_1 >>> 0 | $5_1 >>> 0 > $6_1 >>> 0;
          $5_1 = ($5_1 | 0) == ($27_1 | 0) & $15_1 >>> 0 < $24_1 >>> 0 | $5_1 >>> 0 < $27_1 >>> 0;
          $4_1 = $25_1 + 8 | 0;
          $7_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
          $4_1 = HEAP32[$4_1 + 4 >> 2];
          $4_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $8_1 = $8_1 >>> 20 | 0;
          $5_1 = $7_1 + $8_1 | 0;
          $4_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $7_1 = $5_1;
          $5_1 = $5_1 + $13_1 | 0;
          $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = $5_1 << 12 | $6_1 >>> 20;
          $8_1 = $6_1 + $11_1 | 0;
          $4_1 = $9_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
          HEAP32[$12_1 >> 2] = $8_1;
          HEAP32[$12_1 + 4 >> 2] = $6_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $2_1 = $2_1 + 88 | 0;
          $1_1 = $1_1 + 40 | 0;
          if (($1_1 | 0) != 320) {
            continue;
          }
          break;
        }
        ;
        $2_1 = ($32_1 | 0) < ($62_1 | 0) ? $62_1 : $32_1;
        $1_1 = 1;
      }
      label$8: {
        if (!$3_1) {
          $12_1 = 0;
          $13_1 = 0;
          break label$8;
        }
        $6_1 = $10_1 + 3648 | 0;
        $4_1 = $6_1 + 24 | 0;
        HEAP32[$4_1 >> 2] = 0;
        HEAP32[$4_1 + 4 >> 2] = 0;
        $5_1 = $10_1 + 3616 | 0;
        $4_1 = $5_1 + 24 | 0;
        HEAP32[$4_1 >> 2] = 0;
        HEAP32[$4_1 + 4 >> 2] = 0;
        HEAP32[$10_1 + 3664 >> 2] = 0;
        HEAP32[$10_1 + 3668 >> 2] = 0;
        HEAP32[$10_1 + 3632 >> 2] = 0;
        HEAP32[$10_1 + 3636 >> 2] = 0;
        $4_1 = HEAP32[$3_1 + 4 >> 2];
        HEAP32[$10_1 + 3648 >> 2] = HEAP32[$3_1 >> 2];
        HEAP32[$10_1 + 3652 >> 2] = $4_1;
        $4_1 = HEAP32[$3_1 + 12 >> 2];
        HEAP32[$10_1 + 3656 >> 2] = HEAP32[$3_1 + 8 >> 2];
        HEAP32[$10_1 + 3660 >> 2] = $4_1;
        $4_1 = HEAP32[$3_1 + 20 >> 2];
        HEAP32[$10_1 + 3616 >> 2] = HEAP32[$3_1 + 16 >> 2];
        HEAP32[$10_1 + 3620 >> 2] = $4_1;
        $4_1 = HEAP32[$3_1 + 28 >> 2];
        HEAP32[$10_1 + 3624 >> 2] = HEAP32[$3_1 + 24 >> 2];
        HEAP32[$10_1 + 3628 >> 2] = $4_1;
        $12_1 = $62($10_1 + 3088 | 0, $6_1, 4);
        $13_1 = $62($10_1 + 2560 | 0, $5_1, 4);
        $2_1 = ($2_1 | 0) < ($12_1 | 0) ? $12_1 : $2_1;
        $2_1 = ($2_1 | 0) < ($13_1 | 0) ? $13_1 : $2_1;
      }
      HEAP32[$0_1 + 120 >> 2] = 1;
      $14_1 = $68($0_1, 120);
      label$10: {
        if (($2_1 | 0) <= 0) {
          break label$10;
        }
        $0_1 = $2_1 - 1 | 0;
        label$11: {
          if (!$1_1) {
            $0_1 = $0_1 << 2;
            $3_1 = $0_1 + ($10_1 + 3088 | 0) | 0;
            $0_1 = ($10_1 + 2560 | 0) + $0_1 | 0;
            $11_1 = 1;
            while (1) {
              label$14: {
                if ($11_1) {
                  HEAP32[$14_1 + 120 >> 2] = 1;
                  $68($14_1, 120);
                  break label$14;
                }
                $55($14_1, $14_1);
              }
              label$16: {
                if (($2_1 | 0) > ($12_1 | 0)) {
                  break label$16;
                }
                $4_1 = HEAP32[$3_1 >> 2];
                if (!$4_1) {
                  break label$16;
                }
                $1_1 = $10_1 + 3720 | 0;
                $63($1_1, 655920, $4_1);
                $64($14_1, $14_1, $1_1, $10_1 + 3680 | 0);
              }
              $1_1 = $2_1 - 1 | 0;
              label$17: {
                if (($2_1 | 0) > ($13_1 | 0)) {
                  break label$17;
                }
                $4_1 = HEAP32[$0_1 >> 2];
                if (!$4_1) {
                  break label$17;
                }
                $2_1 = $10_1 + 3720 | 0;
                $63($2_1, 656176, $4_1);
                $64($14_1, $14_1, $2_1, $10_1 + 3680 | 0);
              }
              if (($1_1 | 0) <= 0) {
                break label$11;
              }
              $3_1 = $3_1 - 4 | 0;
              $0_1 = $0_1 - 4 | 0;
              $11_1 = HEAP32[$14_1 + 120 >> 2];
              $2_1 = $1_1;
              continue;
            }
            ;
          }
          $16_1 = $10_1 + 3760 | 0;
          $3_1 = (($2_1 << 2) + $10_1 | 0) + 1008 | 0;
          $1_1 = $0_1 << 2;
          $0_1 = $1_1 + ($10_1 + 3088 | 0) | 0;
          $11_1 = ($10_1 + 2560 | 0) + $1_1 | 0;
          $7_1 = HEAP32[$10_1 + 1532 >> 2];
          $8_1 = HEAP32[$10_1 + 1528 >> 2];
          $4_1 = 1;
          while (1) {
            label$19: {
              if ($4_1) {
                HEAP32[$14_1 + 120 >> 2] = 1;
                $68($14_1, 120);
                break label$19;
              }
              $55($14_1, $14_1);
            }
            label$21: {
              if (($2_1 | 0) > ($8_1 | 0)) {
                break label$21;
              }
              $1_1 = HEAP32[$3_1 - 516 >> 2];
              if (!$1_1) {
                break label$21;
              }
              label$22: {
                if (($1_1 | 0) <= 0) {
                  $70($10_1 + 3720 | 0, ($10_1 + 1536 | 0) + Math_imul(($1_1 ^ -1) / 2 | 0, 88) | 0, 88);
                  $1_1 = HEAP32[$10_1 + 3760 >> 2];
                  $4_1 = -3908 - $1_1 | 0;
                  $1_1 = 4194299 - (HEAP32[$10_1 + 3764 >> 2] + ($1_1 >>> 0 > 4294963388) | 0) | 0;
                  HEAP32[$10_1 + 3760 >> 2] = $4_1;
                  HEAP32[$10_1 + 3764 >> 2] = $1_1;
                  $1_1 = HEAP32[$10_1 + 3768 >> 2];
                  $4_1 = -4 - $1_1 | 0;
                  $1_1 = 4194303 - (HEAP32[$10_1 + 3772 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
                  HEAP32[$10_1 + 3768 >> 2] = $4_1;
                  HEAP32[$10_1 + 3772 >> 2] = $1_1;
                  $1_1 = HEAP32[$10_1 + 3776 >> 2];
                  $4_1 = -4 - $1_1 | 0;
                  $1_1 = 4194303 - (HEAP32[$10_1 + 3780 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
                  HEAP32[$10_1 + 3776 >> 2] = $4_1;
                  HEAP32[$10_1 + 3780 >> 2] = $1_1;
                  $1_1 = HEAP32[$10_1 + 3784 >> 2];
                  $4_1 = -4 - $1_1 | 0;
                  $1_1 = 4194303 - (HEAP32[$10_1 + 3788 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
                  HEAP32[$10_1 + 3784 >> 2] = $4_1;
                  HEAP32[$10_1 + 3788 >> 2] = $1_1;
                  $1_1 = HEAP32[$10_1 + 3792 >> 2];
                  $4_1 = -4 - $1_1 | 0;
                  $1_1 = 262143 - (HEAP32[$10_1 + 3796 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
                  HEAP32[$10_1 + 3792 >> 2] = $4_1;
                  HEAP32[$10_1 + 3796 >> 2] = $1_1;
                  break label$22;
                }
                $70($10_1 + 3720 | 0, ($10_1 + 1536 | 0) + Math_imul($1_1 - 1 >>> 1 | 0, 88) | 0, 88);
              }
              $65($14_1, $14_1, $10_1 + 3720 | 0, 0);
            }
            label$24: {
              if (($2_1 | 0) > ($7_1 | 0)) {
                break label$24;
              }
              $1_1 = HEAP32[$3_1 >> 2];
              if (!$1_1) {
                break label$24;
              }
              label$25: {
                if (($1_1 | 0) <= 0) {
                  $6_1 = ($1_1 ^ -1) / 2 | 0;
                  $9_1 = ($10_1 + 1536 | 0) + Math_imul($6_1, 88) | 0;
                  $1_1 = HEAP32[$9_1 + 44 >> 2];
                  HEAP32[$16_1 >> 2] = HEAP32[$9_1 + 40 >> 2];
                  HEAP32[$16_1 + 4 >> 2] = $1_1;
                  $5_1 = $9_1 + 48 | 0;
                  $4_1 = HEAP32[$5_1 + 4 >> 2];
                  $1_1 = $16_1 + 8 | 0;
                  HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                  HEAP32[$1_1 + 4 >> 2] = $4_1;
                  $5_1 = $9_1 + 56 | 0;
                  $4_1 = HEAP32[$5_1 + 4 >> 2];
                  $1_1 = $16_1 + 16 | 0;
                  HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                  HEAP32[$1_1 + 4 >> 2] = $4_1;
                  $5_1 = $9_1 - -64 | 0;
                  $4_1 = HEAP32[$5_1 + 4 >> 2];
                  $1_1 = $16_1 + 24 | 0;
                  HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                  HEAP32[$1_1 + 4 >> 2] = $4_1;
                  $5_1 = $9_1 + 72 | 0;
                  $4_1 = HEAP32[$5_1 + 4 >> 2];
                  $1_1 = $16_1 + 32 | 0;
                  HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                  HEAP32[$1_1 + 4 >> 2] = $4_1;
                  $9_1 = ($10_1 + 2240 | 0) + Math_imul($6_1, 40) | 0;
                  $5_1 = $9_1 + 8 | 0;
                  $4_1 = HEAP32[$5_1 + 4 >> 2];
                  $6_1 = $10_1 + 3720 | 0;
                  $1_1 = $6_1 + 8 | 0;
                  HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                  HEAP32[$1_1 + 4 >> 2] = $4_1;
                  $5_1 = $9_1 + 16 | 0;
                  $4_1 = HEAP32[$5_1 + 4 >> 2];
                  $1_1 = $6_1 + 16 | 0;
                  HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                  HEAP32[$1_1 + 4 >> 2] = $4_1;
                  $5_1 = $9_1 + 24 | 0;
                  $4_1 = HEAP32[$5_1 + 4 >> 2];
                  $1_1 = $6_1 + 24 | 0;
                  HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                  HEAP32[$1_1 + 4 >> 2] = $4_1;
                  $5_1 = $9_1 + 32 | 0;
                  $4_1 = HEAP32[$5_1 + 4 >> 2];
                  $1_1 = $6_1 + 32 | 0;
                  HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                  HEAP32[$1_1 + 4 >> 2] = $4_1;
                  HEAP32[$10_1 + 3800 >> 2] = 0;
                  $1_1 = HEAP32[$9_1 + 4 >> 2];
                  HEAP32[$10_1 + 3720 >> 2] = HEAP32[$9_1 >> 2];
                  HEAP32[$10_1 + 3724 >> 2] = $1_1;
                  $1_1 = HEAP32[$10_1 + 3760 >> 2];
                  $4_1 = -3908 - $1_1 | 0;
                  $1_1 = 4194299 - (HEAP32[$10_1 + 3764 >> 2] + ($1_1 >>> 0 > 4294963388) | 0) | 0;
                  HEAP32[$10_1 + 3760 >> 2] = $4_1;
                  HEAP32[$10_1 + 3764 >> 2] = $1_1;
                  $1_1 = HEAP32[$10_1 + 3768 >> 2];
                  $4_1 = -4 - $1_1 | 0;
                  $1_1 = 4194303 - (HEAP32[$10_1 + 3772 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
                  HEAP32[$10_1 + 3768 >> 2] = $4_1;
                  HEAP32[$10_1 + 3772 >> 2] = $1_1;
                  $1_1 = HEAP32[$10_1 + 3776 >> 2];
                  $4_1 = -4 - $1_1 | 0;
                  $1_1 = 4194303 - (HEAP32[$10_1 + 3780 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
                  HEAP32[$10_1 + 3776 >> 2] = $4_1;
                  HEAP32[$10_1 + 3780 >> 2] = $1_1;
                  $1_1 = HEAP32[$10_1 + 3784 >> 2];
                  $4_1 = -4 - $1_1 | 0;
                  $1_1 = 4194303 - (HEAP32[$10_1 + 3788 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
                  HEAP32[$10_1 + 3784 >> 2] = $4_1;
                  HEAP32[$10_1 + 3788 >> 2] = $1_1;
                  $1_1 = HEAP32[$10_1 + 3792 >> 2];
                  $4_1 = -4 - $1_1 | 0;
                  $1_1 = 262143 - (HEAP32[$10_1 + 3796 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
                  HEAP32[$10_1 + 3792 >> 2] = $4_1;
                  HEAP32[$10_1 + 3796 >> 2] = $1_1;
                  break label$25;
                }
                $4_1 = $1_1 - 1 >>> 1 | 0;
                $15_1 = ($10_1 + 1536 | 0) + Math_imul($4_1, 88) | 0;
                $1_1 = HEAP32[$15_1 + 44 >> 2];
                HEAP32[$16_1 >> 2] = HEAP32[$15_1 + 40 >> 2];
                HEAP32[$16_1 + 4 >> 2] = $1_1;
                $9_1 = ($10_1 + 2240 | 0) + Math_imul($4_1, 40) | 0;
                $5_1 = $9_1 + 8 | 0;
                $4_1 = HEAP32[$5_1 + 4 >> 2];
                $6_1 = $10_1 + 3720 | 0;
                $1_1 = $6_1 + 8 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $4_1;
                $5_1 = $9_1 + 16 | 0;
                $4_1 = HEAP32[$5_1 + 4 >> 2];
                $1_1 = $6_1 + 16 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $4_1;
                $5_1 = $9_1 + 24 | 0;
                $4_1 = HEAP32[$5_1 + 4 >> 2];
                $1_1 = $6_1 + 24 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $4_1;
                $5_1 = $9_1 + 32 | 0;
                $4_1 = HEAP32[$5_1 + 4 >> 2];
                $1_1 = $6_1 + 32 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $4_1;
                $5_1 = $15_1 + 48 | 0;
                $4_1 = HEAP32[$5_1 + 4 >> 2];
                $1_1 = $16_1 + 8 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $4_1;
                $5_1 = $15_1 + 56 | 0;
                $4_1 = HEAP32[$5_1 + 4 >> 2];
                $1_1 = $16_1 + 16 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $4_1;
                $5_1 = $15_1 - -64 | 0;
                $4_1 = HEAP32[$5_1 + 4 >> 2];
                $1_1 = $16_1 + 24 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $4_1;
                $5_1 = $15_1 + 72 | 0;
                $4_1 = HEAP32[$5_1 + 4 >> 2];
                $1_1 = $16_1 + 32 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $4_1;
                HEAP32[$10_1 + 3800 >> 2] = 0;
                $1_1 = HEAP32[$9_1 + 4 >> 2];
                HEAP32[$10_1 + 3720 >> 2] = HEAP32[$9_1 >> 2];
                HEAP32[$10_1 + 3724 >> 2] = $1_1;
              }
              $65($14_1, $14_1, $10_1 + 3720 | 0, 0);
            }
            label$27: {
              if (($2_1 | 0) > ($12_1 | 0)) {
                break label$27;
              }
              $4_1 = HEAP32[$0_1 >> 2];
              if (!$4_1) {
                break label$27;
              }
              $1_1 = $10_1 + 3720 | 0;
              $63($1_1, 655920, $4_1);
              $64($14_1, $14_1, $1_1, $10_1 + 3680 | 0);
            }
            $1_1 = $2_1 - 1 | 0;
            label$28: {
              if (($2_1 | 0) > ($13_1 | 0)) {
                break label$28;
              }
              $4_1 = HEAP32[$11_1 >> 2];
              if (!$4_1) {
                break label$28;
              }
              $2_1 = $10_1 + 3720 | 0;
              $63($2_1, 656176, $4_1);
              $64($14_1, $14_1, $2_1, $10_1 + 3680 | 0);
            }
            if (($1_1 | 0) <= 0) {
              break label$11;
            }
            $0_1 = $0_1 - 4 | 0;
            $11_1 = $11_1 - 4 | 0;
            $3_1 = $3_1 - 4 | 0;
            $4_1 = HEAP32[$14_1 + 120 >> 2];
            $2_1 = $1_1;
            continue;
          }
          ;
        }
        if (HEAP32[$14_1 + 120 >> 2]) {
          break label$10;
        }
        $0_1 = $14_1 + 80 | 0;
        $34($0_1, $0_1, $10_1 + 3680 | 0);
      }
      global$0 = $10_1 + 3808 | 0;
    }
    function $43($0_1, $1_1) {
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0;
      $8_1 = global$0 - 48 | 0;
      global$0 = $8_1;
      $3_1 = $8_1 + 8 | 0;
      $54($3_1, $1_1 + 80 | 0);
      $34($3_1, $3_1, $0_1);
      $5_1 = HEAP32[$1_1 + 24 >> 2];
      $4_1 = HEAP32[$1_1 + 28 >> 2];
      $9_1 = HEAP32[$1_1 + 16 >> 2];
      $6_1 = HEAP32[$1_1 + 20 >> 2];
      $3_1 = HEAP32[$1_1 + 8 >> 2];
      $11_1 = HEAP32[$1_1 + 12 >> 2];
      $2_1 = HEAP32[$1_1 >> 2];
      $7_1 = HEAP32[$1_1 + 4 >> 2];
      $12_1 = HEAP32[$1_1 + 32 >> 2];
      $1_1 = HEAP32[$1_1 + 36 >> 2];
      $13_1 = $1_1;
      $0_1 = $2_1;
      $2_1 = __wasm_i64_mul($1_1 >>> 16 | 0, 0, 977, 1);
      $1_1 = $0_1 + $2_1 | 0;
      $0_1 = $7_1 + i64toi32_i32$HIGH_BITS | 0;
      $0_1 = $1_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $2_1 = $1_1;
      $7_1 = $0_1;
      $0_1 = $11_1;
      $1_1 = $7_1 >>> 20 | 0;
      $10_1 = $1_1;
      $1_1 = $1_1 + $3_1 | 0;
      $11_1 = $10_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $6_1;
      $3_1 = $11_1 >>> 20 | 0;
      $9_1 = $3_1 + $9_1 | 0;
      $6_1 = $3_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $4_1;
      $3_1 = $6_1 >>> 20 | 0;
      $5_1 = $3_1 + $5_1 | 0;
      $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = HEAP32[$8_1 + 8 >> 2];
      $4_1 = $2_1 - $0_1 | 0;
      $14_1 = ($7_1 & 1048575) - (HEAP32[$8_1 + 12 >> 2] + ($0_1 >>> 0 > $2_1 >>> 0) | 0) | 0;
      $0_1 = HEAP32[$8_1 + 40 >> 2];
      $7_1 = $12_1 - $0_1 | 0;
      $0_1 = ($13_1 & 65535) - (HEAP32[$8_1 + 44 >> 2] + ($0_1 >>> 0 > $12_1 >>> 0) | 0) | 0;
      $2_1 = $3_1 >>> 20 | 0;
      $10_1 = $2_1;
      $2_1 = $2_1 + $7_1 | 0;
      $0_1 = ($10_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 262143 | 0;
      $10_1 = $4_1;
      $2_1 = $2_1 - 4 | 0;
      $12_1 = $2_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
      $4_1 = __wasm_i64_mul($12_1 >>> 16 | 0, 0, 977, 1);
      $7_1 = $10_1 + $4_1 | 0;
      $0_1 = $14_1 + i64toi32_i32$HIGH_BITS | 0;
      $0_1 = ($7_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194299 | 0;
      $7_1 = $7_1 - 3908 | 0;
      $0_1 = $7_1 >>> 0 < 4294963388 ? $0_1 + 1 | 0 : $0_1;
      $4_1 = $0_1 & 1048575;
      $15_1 = $4_1;
      $13_1 = $7_1 ^ 976;
      $14_1 = $4_1 ^ 1;
      global$0 = $8_1 + 48 | 0;
      label$1: {
        if ($7_1 | $4_1) {
          $4_1 = 0;
          if (($13_1 | 0) != -1 | ($14_1 | 0) != 1048575) {
            break label$1;
          }
        }
        $4_1 = $2_1;
        $12_1 = $12_1 & 65535;
        $2_1 = HEAP32[$8_1 + 32 >> 2];
        $16_1 = $5_1 - $2_1 | 0;
        $10_1 = ($3_1 & 1048575) - (HEAP32[$8_1 + 36 >> 2] + ($2_1 >>> 0 > $5_1 >>> 0) | 0) | 0;
        $3_1 = HEAP32[$8_1 + 24 >> 2];
        $5_1 = $9_1 - $3_1 | 0;
        $9_1 = ($6_1 & 1048575) - (HEAP32[$8_1 + 28 >> 2] + ($3_1 >>> 0 > $9_1 >>> 0) | 0) | 0;
        $3_1 = $0_1;
        $0_1 = $11_1 & 1048575;
        $3_1 = $3_1 >>> 20 | 0;
        $2_1 = $3_1;
        $3_1 = $1_1 + $3_1 | 0;
        $0_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $2_1 = HEAP32[$8_1 + 16 >> 2];
        $1_1 = ($3_1 - $2_1 | 0) - 4 | 0;
        $0_1 = ($0_1 - (HEAP32[$8_1 + 20 >> 2] + ($3_1 >>> 0 < $2_1 >>> 0) | 0) | 0) + 4194303 | 0;
        $3_1 = $1_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $9_1;
        $2_1 = $3_1 >>> 20 | 0;
        $6_1 = $2_1;
        $2_1 = $2_1 + $5_1 | 0;
        $0_1 = ($6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194303 | 0;
        $2_1 = $2_1 - 4 | 0;
        $9_1 = $2_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $10_1;
        $5_1 = $9_1 >>> 20 | 0;
        $6_1 = $5_1;
        $5_1 = $5_1 + $16_1 | 0;
        $0_1 = ($6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194303 | 0;
        $5_1 = $5_1 - 4 | 0;
        $11_1 = $5_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $12_1;
        $6_1 = $11_1 >>> 20 | 0;
        $10_1 = $6_1;
        $6_1 = $4_1 + $6_1 | 0;
        $0_1 = $10_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        if (($1_1 & $13_1 & $2_1 & $5_1 & $6_1) == -1) {
          $4_1 = ($3_1 & $14_1 & $9_1 & $11_1 & ($0_1 ^ 983040)) == 1048575;
        } else {
          $4_1 = 0;
        }
        if ($4_1) {
          $1_1 = 0;
          $0_1 = 0;
        } else {
          $1_1 = $5_1 | ($2_1 | ($1_1 | $7_1)) | $6_1;
          $0_1 = $11_1 & 1048575 | ($9_1 & 1048575 | ($3_1 & 1048575 | $15_1)) | $0_1;
        }
        $4_1 = !($0_1 | $1_1);
      }
      return $4_1;
    }
    function $44($0_1, $1_1, $2_1, $3_1, $4_1, $5_1) {
      $0_1 = $0_1 | 0;
      $1_1 = $1_1 | 0;
      $2_1 = $2_1 | 0;
      $3_1 = $3_1 | 0;
      $4_1 = $4_1 | 0;
      $5_1 = $5_1 | 0;
      var $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0;
      $6_1 = global$0 - 224 | 0;
      global$0 = $6_1;
      $38($6_1 + 8 | 0, $1_1, 0);
      $1_1 = $2_1 + 16 | 0;
      $7_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
      $8_1 = $6_1 + 112 | 0;
      $9_1 = $8_1 + 16 | 0;
      HEAP32[$9_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
      HEAP32[$9_1 + 4 >> 2] = $7_1;
      $1_1 = $2_1 + 24 | 0;
      $7_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
      $8_1 = $8_1 + 24 | 0;
      HEAP32[$8_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
      HEAP32[$8_1 + 4 >> 2] = $7_1;
      $1_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
      HEAP32[$6_1 + 112 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
      HEAP32[$6_1 + 116 >> 2] = $1_1;
      $1_1 = $2_1 + 8 | 0;
      $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
      HEAP32[$6_1 + 120 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
      HEAP32[$6_1 + 124 >> 2] = $2_1;
      $1_1 = HEAP32[$6_1 + 12 >> 2];
      $9_1 = HEAP32[$6_1 + 8 >> 2];
      HEAP8[$6_1 + 175 | 0] = $9_1;
      $2_1 = HEAP32[$6_1 + 20 >> 2];
      $10_1 = HEAP32[$6_1 + 16 >> 2];
      HEAP8[$6_1 + 167 | 0] = $10_1;
      $7_1 = HEAP32[$6_1 + 28 >> 2];
      $11_1 = HEAP32[$6_1 + 24 >> 2];
      HEAP8[$6_1 + 159 | 0] = $11_1;
      $8_1 = HEAP32[$6_1 + 36 >> 2];
      $12_1 = HEAP32[$6_1 + 32 >> 2];
      HEAP8[$6_1 + 151 | 0] = $12_1;
      HEAP8[$6_1 + 174 | 0] = ($1_1 & 255) << 24 | $9_1 >>> 8;
      HEAP8[$6_1 + 173 | 0] = ($1_1 & 65535) << 16 | $9_1 >>> 16;
      HEAP8[$6_1 + 172 | 0] = ($1_1 & 16777215) << 8 | $9_1 >>> 24;
      HEAP8[$6_1 + 171 | 0] = $1_1;
      HEAP8[$6_1 + 170 | 0] = $1_1 >>> 8;
      HEAP8[$6_1 + 169 | 0] = $1_1 >>> 16;
      HEAP8[$6_1 + 168 | 0] = $1_1 >>> 24;
      HEAP8[$6_1 + 166 | 0] = ($2_1 & 255) << 24 | $10_1 >>> 8;
      HEAP8[$6_1 + 165 | 0] = ($2_1 & 65535) << 16 | $10_1 >>> 16;
      HEAP8[$6_1 + 164 | 0] = ($2_1 & 16777215) << 8 | $10_1 >>> 24;
      HEAP8[$6_1 + 163 | 0] = $2_1;
      HEAP8[$6_1 + 162 | 0] = $2_1 >>> 8;
      HEAP8[$6_1 + 161 | 0] = $2_1 >>> 16;
      HEAP8[$6_1 + 160 | 0] = $2_1 >>> 24;
      HEAP8[$6_1 + 158 | 0] = ($7_1 & 255) << 24 | $11_1 >>> 8;
      HEAP8[$6_1 + 157 | 0] = ($7_1 & 65535) << 16 | $11_1 >>> 16;
      HEAP8[$6_1 + 156 | 0] = ($7_1 & 16777215) << 8 | $11_1 >>> 24;
      HEAP8[$6_1 + 155 | 0] = $7_1;
      HEAP8[$6_1 + 154 | 0] = $7_1 >>> 8;
      HEAP8[$6_1 + 153 | 0] = $7_1 >>> 16;
      HEAP8[$6_1 + 152 | 0] = $7_1 >>> 24;
      HEAP8[$6_1 + 150 | 0] = ($8_1 & 255) << 24 | $12_1 >>> 8;
      HEAP8[$6_1 + 149 | 0] = ($8_1 & 65535) << 16 | $12_1 >>> 16;
      HEAP8[$6_1 + 148 | 0] = ($8_1 & 16777215) << 8 | $12_1 >>> 24;
      HEAP8[$6_1 + 147 | 0] = $8_1;
      HEAP8[$6_1 + 146 | 0] = $8_1 >>> 8;
      HEAP8[$6_1 + 145 | 0] = $8_1 >>> 16;
      HEAP8[$6_1 + 144 | 0] = $8_1 >>> 24;
      if ($4_1) {
        $1_1 = $4_1 + 24 | 0;
        $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
        $7_1 = $6_1 + 200 | 0;
        HEAP32[$7_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
        HEAP32[$7_1 + 4 >> 2] = $2_1;
        $1_1 = $4_1 + 16 | 0;
        $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
        $7_1 = $6_1 + 192 | 0;
        HEAP32[$7_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
        HEAP32[$7_1 + 4 >> 2] = $2_1;
        $1_1 = $4_1 + 8 | 0;
        $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
        $7_1 = $6_1 + 184 | 0;
        HEAP32[$7_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
        HEAP32[$7_1 + 4 >> 2] = $2_1;
        $1_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
        HEAP32[$6_1 + 176 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
        HEAP32[$6_1 + 180 >> 2] = $1_1;
        $2_1 = 96;
      } else {
        $2_1 = 64;
      }
      if ($3_1) {
        $4_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
        $1_1 = ($6_1 + 112 | 0) + $2_1 | 0;
        $7_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
        HEAP8[$1_1 | 0] = $7_1;
        HEAP8[$1_1 + 1 | 0] = $7_1 >>> 8;
        HEAP8[$1_1 + 2 | 0] = $7_1 >>> 16;
        HEAP8[$1_1 + 3 | 0] = $7_1 >>> 24;
        HEAP8[$1_1 + 4 | 0] = $4_1;
        HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
        $3_1 = $3_1 + 8 | 0;
        $4_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
        $1_1 = $1_1 + 8 | 0;
        $3_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
        HEAP8[$1_1 | 0] = $3_1;
        HEAP8[$1_1 + 1 | 0] = $3_1 >>> 8;
        HEAP8[$1_1 + 2 | 0] = $3_1 >>> 16;
        HEAP8[$1_1 + 3 | 0] = $3_1 >>> 24;
        HEAP8[$1_1 + 4 | 0] = $4_1;
        HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
        $2_1 = $2_1 | 16;
      }
      $1_1 = $6_1 + 112 | 0;
      $45($6_1 + 40 | 0, $1_1, $2_1);
      $2_1 = 0;
      $68($1_1, 112);
      while (1) {
        $46($6_1 + 40 | 0, $0_1);
        $2_1 = $2_1 + 1 | 0;
        if ($5_1 >>> 0 >= $2_1 >>> 0) {
          continue;
        }
        break;
      }
      ;
      global$0 = $6_1 + 224 | 0;
      return 1;
    }
    function $45($0_1, $1_1, $2_1) {
      var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0;
      $3_1 = global$0 - 272 | 0;
      global$0 = $3_1;
      HEAP32[$0_1 >> 2] = 16843009;
      HEAP32[$0_1 + 4 >> 2] = 16843009;
      HEAP32[$0_1 + 32 >> 2] = 0;
      HEAP32[$0_1 + 36 >> 2] = 0;
      $6_1 = $0_1 + 24 | 0;
      HEAP32[$6_1 >> 2] = 16843009;
      HEAP32[$6_1 + 4 >> 2] = 16843009;
      $6_1 = $0_1 + 16 | 0;
      HEAP32[$6_1 >> 2] = 16843009;
      HEAP32[$6_1 + 4 >> 2] = 16843009;
      $6_1 = $0_1 + 8 | 0;
      HEAP32[$6_1 >> 2] = 16843009;
      HEAP32[$6_1 + 4 >> 2] = 16843009;
      $6_1 = $0_1 + 40 | 0;
      HEAP32[$6_1 >> 2] = 0;
      HEAP32[$6_1 + 4 >> 2] = 0;
      $6_1 = $0_1 + 48 | 0;
      HEAP32[$6_1 >> 2] = 0;
      HEAP32[$6_1 + 4 >> 2] = 0;
      $6_1 = $0_1 + 56 | 0;
      HEAP32[$6_1 >> 2] = 0;
      HEAP32[$6_1 + 4 >> 2] = 0;
      $6_1 = $3_1 + 128 | 0;
      HEAP32[$6_1 >> 2] = 528734635;
      HEAP32[$6_1 + 4 >> 2] = 1541459225;
      $6_1 = $3_1 + 120 | 0;
      HEAP32[$6_1 >> 2] = 1359893119;
      HEAP32[$6_1 + 4 >> 2] = -1694144372;
      $6_1 = $3_1 + 112 | 0;
      HEAP32[$6_1 >> 2] = 1013904242;
      HEAP32[$6_1 + 4 >> 2] = -1521486534;
      $6_1 = $3_1 + 200 | 0;
      HEAP32[$6_1 >> 2] = 0;
      HEAP32[$6_1 + 4 >> 2] = 0;
      $6_1 = $3_1 + 208 | 0;
      $4_1 = $6_1 + 56 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $6_1 + 48 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $6_1 + 40 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $6_1 + 32 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $6_1 + 24 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $6_1 = $6_1 + 16 | 0;
      HEAP32[$6_1 >> 2] = 0;
      HEAP32[$6_1 + 4 >> 2] = 0;
      HEAP32[$3_1 + 104 >> 2] = 1779033703;
      HEAP32[$3_1 + 108 >> 2] = -1150833019;
      HEAP32[$3_1 + 216 >> 2] = 0;
      HEAP32[$3_1 + 220 >> 2] = 0;
      HEAP32[$3_1 + 208 >> 2] = 0;
      HEAP32[$3_1 + 212 >> 2] = 0;
      $6_1 = $0_1 + 32 | 0;
      $8_1 = $3_1 + 104 | 0;
      $4_1 = 0;
      while (1) {
        $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
        $7_1 = $5_1 + 1 | 0;
        HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
        $7_1 = $5_1 + 2 | 0;
        HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
        $5_1 = $5_1 + 3 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
        $4_1 = $4_1 + 4 | 0;
        if (($4_1 | 0) != 64) {
          continue;
        }
        break;
      }
      ;
      $29($8_1, $3_1 + 208 | 0, 64);
      HEAP32[$3_1 + 96 >> 2] = 0;
      HEAP32[$3_1 + 100 >> 2] = 0;
      HEAP32[$3_1 + 24 >> 2] = 528734635;
      HEAP32[$3_1 + 28 >> 2] = 1541459225;
      HEAP32[$3_1 + 16 >> 2] = 1359893119;
      HEAP32[$3_1 + 20 >> 2] = -1694144372;
      HEAP32[$3_1 + 8 >> 2] = 1013904242;
      HEAP32[$3_1 + 12 >> 2] = -1521486534;
      HEAP32[$3_1 >> 2] = 1779033703;
      HEAP32[$3_1 + 4 >> 2] = -1150833019;
      $4_1 = 0;
      while (1) {
        $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
        $7_1 = $5_1 + 1 | 0;
        HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
        $7_1 = $5_1 + 2 | 0;
        HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
        $5_1 = $5_1 + 3 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
        $4_1 = $4_1 + 4 | 0;
        if (($4_1 | 0) != 64) {
          continue;
        }
        break;
      }
      ;
      $5_1 = $3_1 + 208 | 0;
      $29($3_1, $5_1, 64);
      $29($3_1, $0_1, 32);
      $29($3_1, 690368, 1);
      $29($3_1, $1_1, $2_1);
      $30($3_1, $5_1);
      $29($8_1, $5_1, 32);
      $30($8_1, $6_1);
      $4_1 = $3_1 + 248 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $3_1 + 256 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $3_1 + 264 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $6_1 + 24 | 0;
      $7_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
      $9_1 = $5_1 + 24 | 0;
      HEAP32[$9_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
      HEAP32[$9_1 + 4 >> 2] = $7_1;
      $4_1 = $6_1 + 16 | 0;
      $7_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
      $5_1 = $5_1 + 16 | 0;
      HEAP32[$5_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
      HEAP32[$5_1 + 4 >> 2] = $7_1;
      HEAP32[$3_1 + 200 >> 2] = 0;
      HEAP32[$3_1 + 204 >> 2] = 0;
      HEAP32[$3_1 + 128 >> 2] = 528734635;
      HEAP32[$3_1 + 132 >> 2] = 1541459225;
      HEAP32[$3_1 + 120 >> 2] = 1359893119;
      HEAP32[$3_1 + 124 >> 2] = -1694144372;
      HEAP32[$3_1 + 112 >> 2] = 1013904242;
      HEAP32[$3_1 + 116 >> 2] = -1521486534;
      HEAP32[$3_1 + 104 >> 2] = 1779033703;
      HEAP32[$3_1 + 108 >> 2] = -1150833019;
      HEAP32[$3_1 + 240 >> 2] = 0;
      HEAP32[$3_1 + 244 >> 2] = 0;
      $4_1 = $6_1 + 8 | 0;
      $5_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
      HEAP32[$3_1 + 216 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
      HEAP32[$3_1 + 220 >> 2] = $5_1;
      $4_1 = HEAPU8[$6_1 + 4 | 0] | HEAPU8[$6_1 + 5 | 0] << 8 | (HEAPU8[$6_1 + 6 | 0] << 16 | HEAPU8[$6_1 + 7 | 0] << 24);
      HEAP32[$3_1 + 208 >> 2] = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8 | (HEAPU8[$6_1 + 2 | 0] << 16 | HEAPU8[$6_1 + 3 | 0] << 24);
      HEAP32[$3_1 + 212 >> 2] = $4_1;
      $4_1 = 0;
      while (1) {
        $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
        $7_1 = $5_1 + 1 | 0;
        HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
        $7_1 = $5_1 + 2 | 0;
        HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
        $5_1 = $5_1 + 3 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
        $4_1 = $4_1 + 4 | 0;
        if (($4_1 | 0) != 64) {
          continue;
        }
        break;
      }
      ;
      $29($8_1, $3_1 + 208 | 0, 64);
      HEAP32[$3_1 + 96 >> 2] = 0;
      HEAP32[$3_1 + 100 >> 2] = 0;
      HEAP32[$3_1 + 24 >> 2] = 528734635;
      HEAP32[$3_1 + 28 >> 2] = 1541459225;
      HEAP32[$3_1 + 16 >> 2] = 1359893119;
      HEAP32[$3_1 + 20 >> 2] = -1694144372;
      HEAP32[$3_1 + 8 >> 2] = 1013904242;
      HEAP32[$3_1 + 12 >> 2] = -1521486534;
      HEAP32[$3_1 >> 2] = 1779033703;
      HEAP32[$3_1 + 4 >> 2] = -1150833019;
      $4_1 = 0;
      while (1) {
        $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
        $7_1 = $5_1 + 1 | 0;
        HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
        $7_1 = $5_1 + 2 | 0;
        HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
        $5_1 = $5_1 + 3 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
        $4_1 = $4_1 + 4 | 0;
        if (($4_1 | 0) != 64) {
          continue;
        }
        break;
      }
      ;
      $5_1 = $3_1 + 208 | 0;
      $29($3_1, $5_1, 64);
      $29($3_1, $0_1, 32);
      $30($3_1, $5_1);
      $29($8_1, $5_1, 32);
      $30($8_1, $0_1);
      $4_1 = $3_1 + 248 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $3_1 + 256 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $3_1 + 264 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $4_1 = $6_1 + 24 | 0;
      $7_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
      $9_1 = $5_1 + 24 | 0;
      HEAP32[$9_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
      HEAP32[$9_1 + 4 >> 2] = $7_1;
      $4_1 = $6_1 + 16 | 0;
      $7_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
      $5_1 = $5_1 + 16 | 0;
      HEAP32[$5_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
      HEAP32[$5_1 + 4 >> 2] = $7_1;
      HEAP32[$3_1 + 200 >> 2] = 0;
      HEAP32[$3_1 + 204 >> 2] = 0;
      HEAP32[$3_1 + 128 >> 2] = 528734635;
      HEAP32[$3_1 + 132 >> 2] = 1541459225;
      HEAP32[$3_1 + 120 >> 2] = 1359893119;
      HEAP32[$3_1 + 124 >> 2] = -1694144372;
      HEAP32[$3_1 + 112 >> 2] = 1013904242;
      HEAP32[$3_1 + 116 >> 2] = -1521486534;
      HEAP32[$3_1 + 104 >> 2] = 1779033703;
      HEAP32[$3_1 + 108 >> 2] = -1150833019;
      HEAP32[$3_1 + 240 >> 2] = 0;
      HEAP32[$3_1 + 244 >> 2] = 0;
      $4_1 = $6_1 + 8 | 0;
      $5_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
      HEAP32[$3_1 + 216 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
      HEAP32[$3_1 + 220 >> 2] = $5_1;
      $4_1 = HEAPU8[$6_1 + 4 | 0] | HEAPU8[$6_1 + 5 | 0] << 8 | (HEAPU8[$6_1 + 6 | 0] << 16 | HEAPU8[$6_1 + 7 | 0] << 24);
      HEAP32[$3_1 + 208 >> 2] = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8 | (HEAPU8[$6_1 + 2 | 0] << 16 | HEAPU8[$6_1 + 3 | 0] << 24);
      HEAP32[$3_1 + 212 >> 2] = $4_1;
      $4_1 = 0;
      while (1) {
        $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
        $7_1 = $5_1 + 1 | 0;
        HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
        $7_1 = $5_1 + 2 | 0;
        HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
        $5_1 = $5_1 + 3 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
        $4_1 = $4_1 + 4 | 0;
        if (($4_1 | 0) != 64) {
          continue;
        }
        break;
      }
      ;
      $29($8_1, $3_1 + 208 | 0, 64);
      HEAP32[$3_1 + 96 >> 2] = 0;
      HEAP32[$3_1 + 100 >> 2] = 0;
      HEAP32[$3_1 + 24 >> 2] = 528734635;
      HEAP32[$3_1 + 28 >> 2] = 1541459225;
      HEAP32[$3_1 + 16 >> 2] = 1359893119;
      HEAP32[$3_1 + 20 >> 2] = -1694144372;
      HEAP32[$3_1 + 8 >> 2] = 1013904242;
      HEAP32[$3_1 + 12 >> 2] = -1521486534;
      HEAP32[$3_1 >> 2] = 1779033703;
      HEAP32[$3_1 + 4 >> 2] = -1150833019;
      $4_1 = 0;
      while (1) {
        $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
        $7_1 = $5_1 + 1 | 0;
        HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
        $7_1 = $5_1 + 2 | 0;
        HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
        $5_1 = $5_1 + 3 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
        $4_1 = $4_1 + 4 | 0;
        if (($4_1 | 0) != 64) {
          continue;
        }
        break;
      }
      ;
      $4_1 = $3_1 + 208 | 0;
      $29($3_1, $4_1, 64);
      $29($3_1, $0_1, 32);
      $29($3_1, 690369, 1);
      $29($3_1, $1_1, $2_1);
      $30($3_1, $4_1);
      $29($8_1, $4_1, 32);
      $30($8_1, $6_1);
      $1_1 = $3_1 + 248 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $3_1 + 256 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $3_1 + 264 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $6_1 + 24 | 0;
      $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
      $5_1 = $4_1 + 24 | 0;
      HEAP32[$5_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
      HEAP32[$5_1 + 4 >> 2] = $2_1;
      $1_1 = $6_1 + 16 | 0;
      $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
      $4_1 = $4_1 + 16 | 0;
      HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
      HEAP32[$4_1 + 4 >> 2] = $2_1;
      HEAP32[$3_1 + 200 >> 2] = 0;
      HEAP32[$3_1 + 204 >> 2] = 0;
      HEAP32[$3_1 + 128 >> 2] = 528734635;
      HEAP32[$3_1 + 132 >> 2] = 1541459225;
      HEAP32[$3_1 + 120 >> 2] = 1359893119;
      HEAP32[$3_1 + 124 >> 2] = -1694144372;
      HEAP32[$3_1 + 112 >> 2] = 1013904242;
      HEAP32[$3_1 + 116 >> 2] = -1521486534;
      HEAP32[$3_1 + 104 >> 2] = 1779033703;
      HEAP32[$3_1 + 108 >> 2] = -1150833019;
      HEAP32[$3_1 + 240 >> 2] = 0;
      HEAP32[$3_1 + 244 >> 2] = 0;
      $1_1 = $6_1 + 8 | 0;
      $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
      HEAP32[$3_1 + 216 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
      HEAP32[$3_1 + 220 >> 2] = $2_1;
      $1_1 = HEAPU8[$6_1 + 4 | 0] | HEAPU8[$6_1 + 5 | 0] << 8 | (HEAPU8[$6_1 + 6 | 0] << 16 | HEAPU8[$6_1 + 7 | 0] << 24);
      HEAP32[$3_1 + 208 >> 2] = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8 | (HEAPU8[$6_1 + 2 | 0] << 16 | HEAPU8[$6_1 + 3 | 0] << 24);
      HEAP32[$3_1 + 212 >> 2] = $1_1;
      $4_1 = 0;
      while (1) {
        $1_1 = ($3_1 + 208 | 0) + $4_1 | 0;
        HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] ^ 92;
        $2_1 = $1_1 + 1 | 0;
        HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
        $2_1 = $1_1 + 2 | 0;
        HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
        $1_1 = $1_1 + 3 | 0;
        HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] ^ 92;
        $4_1 = $4_1 + 4 | 0;
        if (($4_1 | 0) != 64) {
          continue;
        }
        break;
      }
      ;
      $29($8_1, $3_1 + 208 | 0, 64);
      HEAP32[$3_1 + 96 >> 2] = 0;
      HEAP32[$3_1 + 100 >> 2] = 0;
      HEAP32[$3_1 + 24 >> 2] = 528734635;
      HEAP32[$3_1 + 28 >> 2] = 1541459225;
      HEAP32[$3_1 + 16 >> 2] = 1359893119;
      HEAP32[$3_1 + 20 >> 2] = -1694144372;
      HEAP32[$3_1 + 8 >> 2] = 1013904242;
      HEAP32[$3_1 + 12 >> 2] = -1521486534;
      HEAP32[$3_1 >> 2] = 1779033703;
      HEAP32[$3_1 + 4 >> 2] = -1150833019;
      $4_1 = 0;
      while (1) {
        $1_1 = ($3_1 + 208 | 0) + $4_1 | 0;
        HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] ^ 106;
        $2_1 = $1_1 + 1 | 0;
        HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
        $2_1 = $1_1 + 2 | 0;
        HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
        $1_1 = $1_1 + 3 | 0;
        HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] ^ 106;
        $4_1 = $4_1 + 4 | 0;
        if (($4_1 | 0) != 64) {
          continue;
        }
        break;
      }
      ;
      $1_1 = $3_1 + 208 | 0;
      $29($3_1, $1_1, 64);
      $29($3_1, $0_1, 32);
      $30($3_1, $1_1);
      $29($8_1, $1_1, 32);
      $30($8_1, $0_1);
      HEAP32[$0_1 + 64 >> 2] = 0;
      global$0 = $3_1 + 272 | 0;
    }
    function $46($0_1, $1_1) {
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0;
      $4_1 = global$0 - 272 | 0;
      global$0 = $4_1;
      if (HEAP32[$0_1 + 64 >> 2]) {
        $2_1 = $4_1 + 208 | 0;
        $3_1 = $2_1 + 40 | 0;
        HEAP32[$3_1 >> 2] = 0;
        HEAP32[$3_1 + 4 >> 2] = 0;
        $3_1 = $2_1 + 48 | 0;
        HEAP32[$3_1 >> 2] = 0;
        HEAP32[$3_1 + 4 >> 2] = 0;
        $2_1 = $2_1 + 56 | 0;
        HEAP32[$2_1 >> 2] = 0;
        HEAP32[$2_1 + 4 >> 2] = 0;
        $2_1 = $4_1 + 200 | 0;
        HEAP32[$2_1 >> 2] = 0;
        HEAP32[$2_1 + 4 >> 2] = 0;
        $2_1 = $4_1 + 128 | 0;
        HEAP32[$2_1 >> 2] = 528734635;
        HEAP32[$2_1 + 4 >> 2] = 1541459225;
        $2_1 = $4_1 + 120 | 0;
        HEAP32[$2_1 >> 2] = 1359893119;
        HEAP32[$2_1 + 4 >> 2] = -1694144372;
        $2_1 = $4_1 + 112 | 0;
        HEAP32[$2_1 >> 2] = 1013904242;
        HEAP32[$2_1 + 4 >> 2] = -1521486534;
        $2_1 = $0_1 + 56 | 0;
        $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $6_1 = $4_1 + 232 | 0;
        HEAP32[$6_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        HEAP32[$6_1 + 4 >> 2] = $3_1;
        $2_1 = $0_1 + 48 | 0;
        $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $6_1 = $4_1 + 224 | 0;
        HEAP32[$6_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        HEAP32[$6_1 + 4 >> 2] = $3_1;
        HEAP32[$4_1 + 104 >> 2] = 1779033703;
        HEAP32[$4_1 + 108 >> 2] = -1150833019;
        HEAP32[$4_1 + 240 >> 2] = 0;
        HEAP32[$4_1 + 244 >> 2] = 0;
        $2_1 = $0_1 + 40 | 0;
        $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        HEAP32[$4_1 + 216 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        HEAP32[$4_1 + 220 >> 2] = $3_1;
        $2_1 = HEAPU8[$0_1 + 36 | 0] | HEAPU8[$0_1 + 37 | 0] << 8 | (HEAPU8[$0_1 + 38 | 0] << 16 | HEAPU8[$0_1 + 39 | 0] << 24);
        HEAP32[$4_1 + 208 >> 2] = HEAPU8[$0_1 + 32 | 0] | HEAPU8[$0_1 + 33 | 0] << 8 | (HEAPU8[$0_1 + 34 | 0] << 16 | HEAPU8[$0_1 + 35 | 0] << 24);
        HEAP32[$4_1 + 212 >> 2] = $2_1;
        $2_1 = $0_1 + 32 | 0;
        $6_1 = $4_1 + 104 | 0;
        $3_1 = 0;
        while (1) {
          $5_1 = ($4_1 + 208 | 0) + $3_1 | 0;
          HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
          $7_1 = $5_1 + 1 | 0;
          HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
          $7_1 = $5_1 + 2 | 0;
          HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
          $5_1 = $5_1 + 3 | 0;
          HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
          $3_1 = $3_1 + 4 | 0;
          if (($3_1 | 0) != 64) {
            continue;
          }
          break;
        }
        ;
        $29($6_1, $4_1 + 208 | 0, 64);
        HEAP32[$4_1 + 96 >> 2] = 0;
        HEAP32[$4_1 + 100 >> 2] = 0;
        HEAP32[$4_1 + 24 >> 2] = 528734635;
        HEAP32[$4_1 + 28 >> 2] = 1541459225;
        HEAP32[$4_1 + 16 >> 2] = 1359893119;
        HEAP32[$4_1 + 20 >> 2] = -1694144372;
        HEAP32[$4_1 + 8 >> 2] = 1013904242;
        HEAP32[$4_1 + 12 >> 2] = -1521486534;
        HEAP32[$4_1 >> 2] = 1779033703;
        HEAP32[$4_1 + 4 >> 2] = -1150833019;
        $3_1 = 0;
        while (1) {
          $5_1 = ($4_1 + 208 | 0) + $3_1 | 0;
          HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
          $7_1 = $5_1 + 1 | 0;
          HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
          $7_1 = $5_1 + 2 | 0;
          HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
          $5_1 = $5_1 + 3 | 0;
          HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
          $3_1 = $3_1 + 4 | 0;
          if (($3_1 | 0) != 64) {
            continue;
          }
          break;
        }
        ;
        $5_1 = $4_1 + 208 | 0;
        $29($4_1, $5_1, 64);
        $29($4_1, $0_1, 32);
        $29($4_1, 690370, 1);
        $30($4_1, $5_1);
        $29($6_1, $5_1, 32);
        $30($6_1, $2_1);
        $3_1 = $4_1 + 248 | 0;
        HEAP32[$3_1 >> 2] = 0;
        HEAP32[$3_1 + 4 >> 2] = 0;
        $3_1 = $4_1 + 256 | 0;
        HEAP32[$3_1 >> 2] = 0;
        HEAP32[$3_1 + 4 >> 2] = 0;
        $3_1 = $4_1 + 264 | 0;
        HEAP32[$3_1 >> 2] = 0;
        HEAP32[$3_1 + 4 >> 2] = 0;
        $3_1 = $2_1 + 24 | 0;
        $7_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
        $8_1 = $5_1 + 24 | 0;
        HEAP32[$8_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
        HEAP32[$8_1 + 4 >> 2] = $7_1;
        $3_1 = $2_1 + 16 | 0;
        $7_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
        $5_1 = $5_1 + 16 | 0;
        HEAP32[$5_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
        HEAP32[$5_1 + 4 >> 2] = $7_1;
        HEAP32[$4_1 + 200 >> 2] = 0;
        HEAP32[$4_1 + 204 >> 2] = 0;
        HEAP32[$4_1 + 128 >> 2] = 528734635;
        HEAP32[$4_1 + 132 >> 2] = 1541459225;
        HEAP32[$4_1 + 120 >> 2] = 1359893119;
        HEAP32[$4_1 + 124 >> 2] = -1694144372;
        HEAP32[$4_1 + 112 >> 2] = 1013904242;
        HEAP32[$4_1 + 116 >> 2] = -1521486534;
        HEAP32[$4_1 + 104 >> 2] = 1779033703;
        HEAP32[$4_1 + 108 >> 2] = -1150833019;
        HEAP32[$4_1 + 240 >> 2] = 0;
        HEAP32[$4_1 + 244 >> 2] = 0;
        $3_1 = $2_1 + 8 | 0;
        $5_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
        HEAP32[$4_1 + 216 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
        HEAP32[$4_1 + 220 >> 2] = $5_1;
        $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        HEAP32[$4_1 + 208 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        HEAP32[$4_1 + 212 >> 2] = $3_1;
        $3_1 = 0;
        while (1) {
          $2_1 = ($4_1 + 208 | 0) + $3_1 | 0;
          HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
          $5_1 = $2_1 + 1 | 0;
          HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
          $5_1 = $2_1 + 2 | 0;
          HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
          $2_1 = $2_1 + 3 | 0;
          HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
          $3_1 = $3_1 + 4 | 0;
          if (($3_1 | 0) != 64) {
            continue;
          }
          break;
        }
        ;
        $29($6_1, $4_1 + 208 | 0, 64);
        HEAP32[$4_1 + 96 >> 2] = 0;
        HEAP32[$4_1 + 100 >> 2] = 0;
        HEAP32[$4_1 + 24 >> 2] = 528734635;
        HEAP32[$4_1 + 28 >> 2] = 1541459225;
        HEAP32[$4_1 + 16 >> 2] = 1359893119;
        HEAP32[$4_1 + 20 >> 2] = -1694144372;
        HEAP32[$4_1 + 8 >> 2] = 1013904242;
        HEAP32[$4_1 + 12 >> 2] = -1521486534;
        HEAP32[$4_1 >> 2] = 1779033703;
        HEAP32[$4_1 + 4 >> 2] = -1150833019;
        $3_1 = 0;
        while (1) {
          $2_1 = ($4_1 + 208 | 0) + $3_1 | 0;
          HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
          $5_1 = $2_1 + 1 | 0;
          HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
          $5_1 = $2_1 + 2 | 0;
          HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
          $2_1 = $2_1 + 3 | 0;
          HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
          $3_1 = $3_1 + 4 | 0;
          if (($3_1 | 0) != 64) {
            continue;
          }
          break;
        }
        ;
        $2_1 = $4_1 + 208 | 0;
        $29($4_1, $2_1, 64);
        $29($4_1, $0_1, 32);
        $30($4_1, $2_1);
        $29($6_1, $2_1, 32);
        $30($6_1, $0_1);
      }
      $2_1 = $4_1 + 208 | 0;
      $3_1 = $2_1 + 40 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $3_1 = $2_1 + 48 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $2_1 = $2_1 + 56 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $4_1 + 200 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $4_1 + 128 | 0;
      HEAP32[$2_1 >> 2] = 528734635;
      HEAP32[$2_1 + 4 >> 2] = 1541459225;
      $2_1 = $4_1 + 120 | 0;
      HEAP32[$2_1 >> 2] = 1359893119;
      HEAP32[$2_1 + 4 >> 2] = -1694144372;
      $2_1 = $4_1 + 112 | 0;
      HEAP32[$2_1 >> 2] = 1013904242;
      HEAP32[$2_1 + 4 >> 2] = -1521486534;
      $2_1 = $0_1 + 56 | 0;
      $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
      $6_1 = $4_1 + 232 | 0;
      HEAP32[$6_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
      HEAP32[$6_1 + 4 >> 2] = $3_1;
      $2_1 = $0_1 + 48 | 0;
      $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
      $6_1 = $4_1 + 224 | 0;
      HEAP32[$6_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
      HEAP32[$6_1 + 4 >> 2] = $3_1;
      HEAP32[$4_1 + 104 >> 2] = 1779033703;
      HEAP32[$4_1 + 108 >> 2] = -1150833019;
      HEAP32[$4_1 + 240 >> 2] = 0;
      HEAP32[$4_1 + 244 >> 2] = 0;
      $2_1 = $0_1 + 40 | 0;
      $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
      HEAP32[$4_1 + 216 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
      HEAP32[$4_1 + 220 >> 2] = $3_1;
      $2_1 = HEAPU8[$0_1 + 36 | 0] | HEAPU8[$0_1 + 37 | 0] << 8 | (HEAPU8[$0_1 + 38 | 0] << 16 | HEAPU8[$0_1 + 39 | 0] << 24);
      HEAP32[$4_1 + 208 >> 2] = HEAPU8[$0_1 + 32 | 0] | HEAPU8[$0_1 + 33 | 0] << 8 | (HEAPU8[$0_1 + 34 | 0] << 16 | HEAPU8[$0_1 + 35 | 0] << 24);
      HEAP32[$4_1 + 212 >> 2] = $2_1;
      $6_1 = $4_1 + 104 | 0;
      $3_1 = 0;
      while (1) {
        $2_1 = ($4_1 + 208 | 0) + $3_1 | 0;
        HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
        $5_1 = $2_1 + 1 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
        $5_1 = $2_1 + 2 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
        $2_1 = $2_1 + 3 | 0;
        HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
        $3_1 = $3_1 + 4 | 0;
        if (($3_1 | 0) != 64) {
          continue;
        }
        break;
      }
      ;
      $29($6_1, $4_1 + 208 | 0, 64);
      HEAP32[$4_1 + 96 >> 2] = 0;
      HEAP32[$4_1 + 100 >> 2] = 0;
      HEAP32[$4_1 + 24 >> 2] = 528734635;
      HEAP32[$4_1 + 28 >> 2] = 1541459225;
      HEAP32[$4_1 + 16 >> 2] = 1359893119;
      HEAP32[$4_1 + 20 >> 2] = -1694144372;
      HEAP32[$4_1 + 8 >> 2] = 1013904242;
      HEAP32[$4_1 + 12 >> 2] = -1521486534;
      HEAP32[$4_1 >> 2] = 1779033703;
      HEAP32[$4_1 + 4 >> 2] = -1150833019;
      $3_1 = 0;
      while (1) {
        $2_1 = ($4_1 + 208 | 0) + $3_1 | 0;
        HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
        $5_1 = $2_1 + 1 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
        $5_1 = $2_1 + 2 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
        $2_1 = $2_1 + 3 | 0;
        HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
        $3_1 = $3_1 + 4 | 0;
        if (($3_1 | 0) != 64) {
          continue;
        }
        break;
      }
      ;
      $2_1 = $4_1 + 208 | 0;
      $29($4_1, $2_1, 64);
      $29($4_1, $0_1, 32);
      $30($4_1, $2_1);
      $29($6_1, $2_1, 32);
      $30($6_1, $0_1);
      $2_1 = $0_1 + 24 | 0;
      $6_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
      $3_1 = $1_1 + 24 | 0;
      $2_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
      HEAP8[$3_1 | 0] = $2_1;
      HEAP8[$3_1 + 1 | 0] = $2_1 >>> 8;
      HEAP8[$3_1 + 2 | 0] = $2_1 >>> 16;
      HEAP8[$3_1 + 3 | 0] = $2_1 >>> 24;
      HEAP8[$3_1 + 4 | 0] = $6_1;
      HEAP8[$3_1 + 5 | 0] = $6_1 >>> 8;
      HEAP8[$3_1 + 6 | 0] = $6_1 >>> 16;
      HEAP8[$3_1 + 7 | 0] = $6_1 >>> 24;
      $2_1 = $0_1 + 16 | 0;
      $6_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
      $3_1 = $1_1 + 16 | 0;
      $2_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
      HEAP8[$3_1 | 0] = $2_1;
      HEAP8[$3_1 + 1 | 0] = $2_1 >>> 8;
      HEAP8[$3_1 + 2 | 0] = $2_1 >>> 16;
      HEAP8[$3_1 + 3 | 0] = $2_1 >>> 24;
      HEAP8[$3_1 + 4 | 0] = $6_1;
      HEAP8[$3_1 + 5 | 0] = $6_1 >>> 8;
      HEAP8[$3_1 + 6 | 0] = $6_1 >>> 16;
      HEAP8[$3_1 + 7 | 0] = $6_1 >>> 24;
      $2_1 = $0_1 + 8 | 0;
      $6_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
      $3_1 = $1_1 + 8 | 0;
      $2_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
      HEAP8[$3_1 | 0] = $2_1;
      HEAP8[$3_1 + 1 | 0] = $2_1 >>> 8;
      HEAP8[$3_1 + 2 | 0] = $2_1 >>> 16;
      HEAP8[$3_1 + 3 | 0] = $2_1 >>> 24;
      HEAP8[$3_1 + 4 | 0] = $6_1;
      HEAP8[$3_1 + 5 | 0] = $6_1 >>> 8;
      HEAP8[$3_1 + 6 | 0] = $6_1 >>> 16;
      HEAP8[$3_1 + 7 | 0] = $6_1 >>> 24;
      $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
      $3_1 = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
      HEAP8[$1_1 | 0] = $3_1;
      HEAP8[$1_1 + 1 | 0] = $3_1 >>> 8;
      HEAP8[$1_1 + 2 | 0] = $3_1 >>> 16;
      HEAP8[$1_1 + 3 | 0] = $3_1 >>> 24;
      HEAP8[$1_1 + 4 | 0] = $2_1;
      HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
      HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
      HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
      HEAP32[$0_1 + 64 >> 2] = 1;
      global$0 = $4_1 + 272 | 0;
    }
    function $47($0_1, $1_1, $2_1, $3_1, $4_1, $5_1) {
      var $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0;
      $11_1 = global$0 - 464 | 0;
      global$0 = $11_1;
      $6_1 = $1_1 + 24 | 0;
      HEAP32[$6_1 >> 2] = 0;
      HEAP32[$6_1 + 4 >> 2] = 0;
      $6_1 = $1_1 + 16 | 0;
      HEAP32[$6_1 >> 2] = 0;
      HEAP32[$6_1 + 4 >> 2] = 0;
      $6_1 = $1_1 + 8 | 0;
      HEAP32[$6_1 >> 2] = 0;
      HEAP32[$6_1 + 4 >> 2] = 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $6_1 = $2_1 + 24 | 0;
      HEAP32[$6_1 >> 2] = 0;
      HEAP32[$6_1 + 4 >> 2] = 0;
      $6_1 = $2_1 + 16 | 0;
      HEAP32[$6_1 >> 2] = 0;
      HEAP32[$6_1 + 4 >> 2] = 0;
      $6_1 = $2_1 + 8 | 0;
      HEAP32[$6_1 >> 2] = 0;
      HEAP32[$6_1 + 4 >> 2] = 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      if ($3_1) {
        HEAP32[$3_1 >> 2] = 0;
      }
      $38($11_1 + 96 | 0, 690788, $11_1 + 256 | 0);
      $14_1 = HEAP32[$11_1 + 120 >> 2];
      $13_1 = HEAP32[$11_1 + 112 >> 2];
      $10_1 = HEAP32[$11_1 + 104 >> 2];
      $12_1 = HEAP32[$11_1 + 96 >> 2];
      $18_1 = HEAP32[$11_1 + 124 >> 2];
      $16_1 = HEAP32[$11_1 + 116 >> 2];
      $8_1 = HEAP32[$11_1 + 108 >> 2];
      $15_1 = HEAP32[$11_1 + 100 >> 2];
      $7_1 = HEAP32[$11_1 + 256 >> 2] | !($14_1 | ($13_1 | ($10_1 | $12_1)) | ($18_1 | ($16_1 | ($8_1 | $15_1))));
      $6_1 = $7_1 ? 0 : -1;
      HEAP32[$11_1 + 120 >> 2] = $6_1 & $14_1;
      HEAP32[$11_1 + 124 >> 2] = $6_1 & $18_1;
      HEAP32[$11_1 + 112 >> 2] = $6_1 & $13_1;
      HEAP32[$11_1 + 116 >> 2] = $6_1 & $16_1;
      HEAP32[$11_1 + 104 >> 2] = $6_1 & $10_1;
      HEAP32[$11_1 + 108 >> 2] = $6_1 & $8_1;
      HEAP32[$11_1 + 96 >> 2] = $6_1 & $12_1 | ($7_1 | 0) != 0;
      HEAP32[$11_1 + 100 >> 2] = $6_1 & $15_1;
      $38($11_1 + 32 | 0, 655649, 0);
      $31_1 = !$7_1;
      $28_1 = $4_1 ? $4_1 : 4;
      label$2: {
        if (!(FUNCTION_TABLE[$28_1 | 0]($11_1, 655649, 690788, 0, $5_1, 0) | 0)) {
          break label$2;
        }
        $4_1 = 1;
        while (1) {
          $29_1 = $4_1;
          $38($11_1 - -64 | 0, $11_1, $11_1 + 256 | 0);
          label$4: {
            if (HEAP32[$11_1 + 256 >> 2] | !(HEAP32[$11_1 + 88 >> 2] | (HEAP32[$11_1 + 80 >> 2] | (HEAP32[$11_1 + 72 >> 2] | HEAP32[$11_1 + 64 >> 2])) | (HEAP32[$11_1 + 92 >> 2] | (HEAP32[$11_1 + 84 >> 2] | (HEAP32[$11_1 + 76 >> 2] | HEAP32[$11_1 + 68 >> 2]))))) {
              break label$4;
            }
            HEAP32[$11_1 + 132 >> 2] = 0;
            $4_1 = $11_1 + 256 | 0;
            $48($0_1, $4_1, $11_1 - -64 | 0);
            $49($11_1 + 168 | 0, $4_1);
            $6_1 = $11_1;
            $16_1 = HEAP32[$6_1 + 232 >> 2];
            $18_1 = HEAP32[$6_1 + 236 >> 2];
            $14_1 = HEAP32[$6_1 + 224 >> 2];
            $15_1 = HEAP32[$6_1 + 228 >> 2];
            $10_1 = HEAP32[$6_1 + 216 >> 2];
            $8_1 = HEAP32[$6_1 + 220 >> 2];
            $9_1 = HEAP32[$6_1 + 212 >> 2];
            $12_1 = HEAP32[$6_1 + 240 >> 2];
            $13_1 = HEAP32[$6_1 + 244 >> 2];
            $20_1 = $13_1;
            $4_1 = HEAP32[$6_1 + 208 >> 2];
            $13_1 = __wasm_i64_mul($13_1 >>> 16 | 0, 0, 977, 1);
            $7_1 = $4_1 + $13_1 | 0;
            $4_1 = $9_1 + i64toi32_i32$HIGH_BITS | 0;
            $13_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $4_1 = $8_1;
            $9_1 = $13_1 >>> 20 | 0;
            $17_1 = $9_1;
            $9_1 = $10_1 + $9_1 | 0;
            $8_1 = $17_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $4_1 = $15_1;
            $10_1 = $8_1 >>> 20 | 0;
            $15_1 = $10_1;
            $10_1 = $10_1 + $14_1 | 0;
            $14_1 = $15_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $4_1 = $18_1;
            $15_1 = $14_1 >>> 20 | 0;
            $17_1 = $15_1;
            $15_1 = $16_1 + $15_1 | 0;
            $4_1 = $17_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $21_1 = $10_1;
            $16_1 = $4_1;
            $30_1 = $14_1 & 1048575;
            $14_1 = ($15_1 & ($10_1 & $9_1)) == -1 & ($4_1 & ($30_1 & $8_1)) == 1048575;
            $4_1 = $20_1 & 65535;
            $10_1 = $16_1 >>> 20 | 0;
            $17_1 = $10_1;
            $10_1 = $10_1 + $12_1 | 0;
            $18_1 = $17_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $4_1 = $13_1 & 1048575;
            $22_1 = $10_1;
            $10_1 = __wasm_i64_mul($14_1 & (($10_1 | 0) == -1 & ($18_1 | 0) == 65535) & (($4_1 | 0) == 1048574 & $7_1 >>> 0 > 4294966318 | $4_1 >>> 0 > 1048574) | $18_1 >>> 16, 0, 977, 1) + $7_1 | 0;
            $4_1 = i64toi32_i32$HIGH_BITS + $4_1 | 0;
            $27_1 = $10_1;
            HEAP32[$6_1 + 208 >> 2] = $10_1;
            $14_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            HEAP32[$6_1 + 212 >> 2] = $14_1 & 1048575;
            $20_1 = HEAP32[$6_1 + 192 >> 2];
            $17_1 = HEAP32[$6_1 + 196 >> 2];
            $13_1 = HEAP32[$6_1 + 184 >> 2];
            $23_1 = HEAP32[$6_1 + 188 >> 2];
            $12_1 = HEAP32[$6_1 + 176 >> 2];
            $19_1 = HEAP32[$6_1 + 180 >> 2];
            $25_1 = HEAP32[$6_1 + 172 >> 2];
            $26_1 = HEAP32[$6_1 + 200 >> 2];
            $10_1 = HEAP32[$6_1 + 204 >> 2];
            $32_1 = $10_1;
            $4_1 = HEAP32[$6_1 + 168 >> 2];
            $7_1 = __wasm_i64_mul($10_1 >>> 16 | 0, 0, 977, 1);
            $10_1 = $4_1 + $7_1 | 0;
            $4_1 = $25_1 + i64toi32_i32$HIGH_BITS | 0;
            $25_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $4_1 = $19_1;
            $7_1 = $25_1 >>> 20 | 0;
            $19_1 = $7_1;
            $7_1 = $7_1 + $12_1 | 0;
            $19_1 = $19_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $4_1 = $23_1;
            $12_1 = $19_1 >>> 20 | 0;
            $23_1 = $12_1;
            $12_1 = $12_1 + $13_1 | 0;
            $24_1 = $23_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $4_1 = $17_1;
            $13_1 = $24_1 >>> 20 | 0;
            $20_1 = $13_1 + $20_1 | 0;
            $4_1 = $13_1 >>> 0 > $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $13_1 = $19_1 & 1048575;
            $23_1 = $12_1;
            $17_1 = $4_1;
            $24_1 = $24_1 & 1048575;
            $12_1 = ($7_1 & $12_1 & $20_1) == -1 & ($4_1 & ($19_1 & $24_1)) == 1048575;
            $4_1 = $32_1 & 65535;
            $6_1 = $17_1 >>> 20 | 0;
            $19_1 = $6_1;
            $6_1 = $6_1 + $26_1 | 0;
            $19_1 = $19_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $4_1 = $25_1 & 1048575;
            $26_1 = $6_1;
            $6_1 = __wasm_i64_mul($12_1 & (($6_1 | 0) == -1 & ($19_1 | 0) == 65535) & (($4_1 | 0) == 1048574 & $10_1 >>> 0 > 4294966318 | $4_1 >>> 0 > 1048574) | $19_1 >>> 16, 0, 977, 1) + $10_1 | 0;
            $4_1 = i64toi32_i32$HIGH_BITS + $4_1 | 0;
            $4_1 = $6_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $10_1 = $6_1;
            $6_1 = $4_1;
            $4_1 = $13_1;
            $12_1 = $6_1 >>> 20 | 0;
            $13_1 = $12_1;
            $12_1 = $7_1 + $12_1 | 0;
            $4_1 = $13_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            HEAP32[$11_1 + 176 >> 2] = $12_1;
            $7_1 = $4_1;
            HEAP32[$11_1 + 180 >> 2] = $4_1 & 1048575;
            $4_1 = $8_1 & 1048575;
            $14_1 = $14_1 >>> 20 | 0;
            $9_1 = $9_1 + $14_1 | 0;
            $4_1 = $14_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            HEAP32[$11_1 + 216 >> 2] = $9_1;
            HEAP32[$11_1 + 220 >> 2] = $4_1 & 1048575;
            $9_1 = $4_1;
            $4_1 = $30_1;
            $9_1 = ($9_1 >>> 20 | 0) + $21_1 | 0;
            $4_1 = $9_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            HEAP32[$11_1 + 224 >> 2] = $9_1;
            $21_1 = $4_1;
            HEAP32[$11_1 + 228 >> 2] = $4_1 & 1048575;
            $8_1 = $11_1;
            $9_1 = $20_1;
            $17_1 = $17_1 & 1048575;
            $4_1 = $24_1;
            $20_1 = $7_1;
            $13_1 = ($7_1 >>> 20 | 0) + $23_1 | 0;
            $7_1 = $13_1 >>> 0 < $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $4_1 = $17_1;
            $14_1 = $7_1 >>> 20 | 0;
            $17_1 = $14_1;
            $14_1 = $9_1 + $14_1 | 0;
            $4_1 = $17_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            HEAP32[$8_1 + 192 >> 2] = $14_1;
            $9_1 = $4_1;
            HEAP32[$8_1 + 196 >> 2] = $4_1 & 1048575;
            $4_1 = $16_1 & 1048575;
            $16_1 = $21_1 >>> 20 | 0;
            $15_1 = $16_1 + $15_1 | 0;
            $4_1 = $16_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            HEAP32[$8_1 + 232 >> 2] = $15_1;
            $15_1 = $4_1;
            HEAP32[$8_1 + 236 >> 2] = $4_1 & 1048575;
            $4_1 = $19_1;
            $16_1 = $9_1;
            $17_1 = ($9_1 >>> 20 | 0) + $26_1 | 0;
            $4_1 = $17_1 >>> 0 < $26_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            HEAP32[$8_1 + 200 >> 2] = $17_1;
            $9_1 = $4_1;
            HEAP32[$8_1 + 204 >> 2] = $4_1 & 65535;
            $4_1 = $18_1;
            $15_1 = ($15_1 >>> 20 | 0) + $22_1 | 0;
            $4_1 = $15_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            HEAP32[$8_1 + 240 >> 2] = $15_1;
            HEAP32[$8_1 + 244 >> 2] = $4_1 & 65535;
            $15_1 = $13_1;
            HEAP32[$8_1 + 184 >> 2] = $13_1;
            $4_1 = $7_1 & 1048575;
            HEAP32[$8_1 + 188 >> 2] = $4_1;
            HEAP32[$8_1 + 168 >> 2] = $10_1;
            $13_1 = $6_1 & 1048575;
            HEAP32[$8_1 + 172 >> 2] = $13_1;
            HEAP8[$8_1 + 415 | 0] = $10_1;
            HEAP8[$8_1 + 414 | 0] = ($6_1 & 255) << 24 | $10_1 >>> 8;
            HEAP8[$8_1 + 413 | 0] = ($6_1 & 65535) << 16 | $10_1 >>> 16;
            HEAP8[$8_1 + 412 | 0] = ($6_1 & 16777215) << 8 | $10_1 >>> 24;
            HEAP8[$8_1 + 411 | 0] = $6_1;
            HEAP8[$8_1 + 410 | 0] = $6_1 >>> 8;
            $6_1 = $12_1 >>> 28 | 0;
            HEAP8[$8_1 + 409 | 0] = $12_1 << 4 | $13_1 >>> 16;
            HEAP8[$8_1 + 408 | 0] = ($20_1 & 15) << 28 | $12_1 >>> 4;
            HEAP8[$8_1 + 407 | 0] = ($20_1 & 4095) << 20 | $12_1 >>> 12;
            HEAP8[$8_1 + 406 | 0] = ($20_1 & 1048575) << 12 | $12_1 >>> 20;
            HEAP8[$8_1 + 405 | 0] = $6_1 | ($20_1 & 268435455) << 4;
            HEAP8[$8_1 + 404 | 0] = $20_1 >>> 4;
            HEAP8[$8_1 + 403 | 0] = $20_1 >>> 12;
            HEAP8[$8_1 + 402 | 0] = $15_1;
            HEAP8[$8_1 + 401 | 0] = ($7_1 & 255) << 24 | $15_1 >>> 8;
            HEAP8[$8_1 + 400 | 0] = ($7_1 & 65535) << 16 | $15_1 >>> 16;
            HEAP8[$8_1 + 399 | 0] = ($7_1 & 16777215) << 8 | $15_1 >>> 24;
            HEAP8[$8_1 + 398 | 0] = $7_1;
            HEAP8[$8_1 + 397 | 0] = $7_1 >>> 8;
            $6_1 = $14_1 >>> 28 | 0;
            HEAP8[$8_1 + 396 | 0] = $14_1 << 4 | $4_1 >>> 16;
            HEAP8[$8_1 + 395 | 0] = ($16_1 & 15) << 28 | $14_1 >>> 4;
            HEAP8[$8_1 + 394 | 0] = ($16_1 & 4095) << 20 | $14_1 >>> 12;
            HEAP8[$8_1 + 393 | 0] = ($16_1 & 1048575) << 12 | $14_1 >>> 20;
            HEAP8[$8_1 + 392 | 0] = $6_1 | ($16_1 & 268435455) << 4;
            HEAP8[$8_1 + 391 | 0] = $16_1 >>> 4;
            HEAP8[$8_1 + 390 | 0] = $16_1 >>> 12;
            HEAP8[$8_1 + 389 | 0] = $17_1;
            HEAP8[$8_1 + 388 | 0] = ($9_1 & 255) << 24 | $17_1 >>> 8;
            HEAP8[$8_1 + 387 | 0] = ($9_1 & 65535) << 16 | $17_1 >>> 16;
            HEAP8[$8_1 + 386 | 0] = ($9_1 & 16777215) << 8 | $17_1 >>> 24;
            HEAP8[$8_1 + 385 | 0] = $9_1;
            HEAP8[$8_1 + 384 | 0] = $9_1 >>> 8;
            $38($1_1, $8_1 + 384 | 0, $8_1 + 132 | 0);
            if ($3_1) {
              HEAP32[$3_1 >> 2] = $27_1 & 1 | HEAP32[$8_1 + 132 >> 2] << 1;
            }
            $21_1 = $8_1 + 136 | 0;
            $41($21_1, $1_1, $8_1 + 96 | 0);
            $7_1 = HEAP32[$8_1 + 32 >> 2];
            $9_1 = HEAP32[$8_1 + 136 >> 2];
            $15_1 = $7_1 + $9_1 | 0;
            $6_1 = HEAP32[$8_1 + 36 >> 2];
            $4_1 = $6_1 + HEAP32[$8_1 + 140 >> 2] | 0;
            $10_1 = $9_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $18_1 = ($6_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 > $15_1 >>> 0 | $6_1 >>> 0 > $10_1 >>> 0;
            $7_1 = HEAP32[$8_1 + 144 >> 2];
            $6_1 = $18_1 + $7_1 | 0;
            $4_1 = HEAP32[$8_1 + 148 >> 2];
            $4_1 = $6_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $9_1 = $6_1;
            $6_1 = HEAP32[$8_1 + 40 >> 2];
            $13_1 = $9_1 + $6_1 | 0;
            $7_1 = $4_1;
            $4_1 = $4_1 + HEAP32[$8_1 + 44 >> 2] | 0;
            $12_1 = $6_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $19_1 = HEAP32[$8_1 + 48 >> 2];
            $6_1 = HEAP32[$8_1 + 152 >> 2];
            $14_1 = $19_1 + $6_1 | 0;
            $20_1 = HEAP32[$8_1 + 52 >> 2];
            $4_1 = $20_1 + HEAP32[$8_1 + 156 >> 2] | 0;
            $6_1 = $6_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $16_1 = $14_1;
            $4_1 = !$7_1 & $9_1 >>> 0 < $18_1 >>> 0;
            $9_1 = ($7_1 | 0) == ($12_1 | 0) & $9_1 >>> 0 > $13_1 >>> 0 | $7_1 >>> 0 > $12_1 >>> 0;
            $7_1 = $4_1 + $9_1 | 0;
            $4_1 = ($7_1 >>> 0 < $9_1 >>> 0) + $6_1 | 0;
            $14_1 = $7_1 + $14_1 | 0;
            $9_1 = $14_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $22_1 = HEAP32[$8_1 + 56 >> 2];
            $7_1 = HEAP32[$8_1 + 160 >> 2];
            $18_1 = $22_1 + $7_1 | 0;
            $17_1 = HEAP32[$8_1 + 60 >> 2];
            $4_1 = $17_1 + HEAP32[$8_1 + 164 >> 2] | 0;
            $7_1 = $7_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $4_1 = ($6_1 | 0) == ($20_1 | 0) & $16_1 >>> 0 < $19_1 >>> 0 | $6_1 >>> 0 < $20_1 >>> 0;
            $16_1 = ($6_1 | 0) == ($9_1 | 0) & $14_1 >>> 0 < $16_1 >>> 0 | $6_1 >>> 0 > $9_1 >>> 0;
            $6_1 = $4_1 + $16_1 | 0;
            $4_1 = ($6_1 >>> 0 < $16_1 >>> 0) + $7_1 | 0;
            $16_1 = $6_1;
            $6_1 = $6_1 + $18_1 | 0;
            $4_1 = $16_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $16_1 = $6_1;
            $6_1 = $8_1;
            $20_1 = $4_1;
            $17_1 = (($7_1 | 0) == ($17_1 | 0) & $18_1 >>> 0 < $22_1 >>> 0 | $7_1 >>> 0 < $17_1 >>> 0) + (($7_1 | 0) == ($4_1 | 0) & $16_1 >>> 0 < $18_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0) | 0;
            $7_1 = ($9_1 | 0) == -1;
            $8_1 = $7_1 & $14_1 >>> 0 < 4294967294 | ($9_1 | 0) != -1 | ($16_1 & $4_1) != -1;
            $4_1 = ($12_1 | 0) == -1162945306;
            $18_1 = ($8_1 | ($4_1 & $13_1 >>> 0 < 2940772411 | $12_1 >>> 0 < 3132021990)) ^ -1;
            $19_1 = $17_1 + ($18_1 & (($10_1 | 0) == -1076732276 & $15_1 >>> 0 > 3493216576 | $10_1 >>> 0 > 3218235020) | ($18_1 & ($4_1 & $13_1 >>> 0 > 2940772411 | $12_1 >>> 0 > 3132021990) | ($14_1 | 0) == -1 & $7_1 & ($8_1 ^ -1))) | 0;
            $8_1 = __wasm_i64_mul($19_1, 0, 801750719, 1076732275);
            $7_1 = $8_1 + $15_1 | 0;
            $4_1 = $10_1 + i64toi32_i32$HIGH_BITS | 0;
            $17_1 = $7_1;
            HEAP32[$6_1 + 136 >> 2] = $7_1;
            $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            HEAP32[$6_1 + 140 >> 2] = $8_1;
            $7_1 = $6_1;
            $6_1 = __wasm_i64_mul($19_1, 0, 1354194884, 1162945305);
            $18_1 = $6_1 + $13_1 | 0;
            $4_1 = $12_1 + i64toi32_i32$HIGH_BITS | 0;
            $8_1 = ($8_1 | 0) == ($10_1 | 0) & $15_1 >>> 0 > $17_1 >>> 0 | $8_1 >>> 0 < $10_1 >>> 0;
            $10_1 = $18_1 + $8_1 | 0;
            $4_1 = $6_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $6_1 = $4_1;
            $17_1 = $10_1;
            HEAP32[$7_1 + 144 >> 2] = $10_1;
            $8_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            HEAP32[$7_1 + 148 >> 2] = $8_1;
            $10_1 = $7_1;
            $4_1 = $9_1;
            $15_1 = $14_1 + $19_1 | 0;
            $7_1 = $15_1 >>> 0 < $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $4_1 = ($6_1 | 0) == ($12_1 | 0) & $13_1 >>> 0 > $18_1 >>> 0 | $6_1 >>> 0 < $12_1 >>> 0;
            $12_1 = ($6_1 | 0) == ($8_1 | 0) & $18_1 >>> 0 > $17_1 >>> 0 | $6_1 >>> 0 > $8_1 >>> 0;
            $6_1 = $4_1 + $12_1 | 0;
            $4_1 = ($6_1 >>> 0 < $12_1 >>> 0) + $7_1 | 0;
            $17_1 = $6_1;
            $6_1 = $6_1 + $15_1 | 0;
            $4_1 = $17_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            HEAP32[$10_1 + 152 >> 2] = $6_1;
            HEAP32[$10_1 + 156 >> 2] = $4_1;
            $9_1 = ($7_1 | 0) == ($9_1 | 0) & $14_1 >>> 0 > $15_1 >>> 0 | $7_1 >>> 0 < $9_1 >>> 0;
            $7_1 = ($4_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
            $6_1 = $9_1 + $7_1 | 0;
            $4_1 = $20_1 + ($6_1 >>> 0 < $7_1 >>> 0) | 0;
            $6_1 = $6_1 + $16_1 | 0;
            $4_1 = $6_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            HEAP32[$10_1 + 160 >> 2] = $6_1;
            HEAP32[$10_1 + 164 >> 2] = $4_1;
            $6_1 = HEAP32[$10_1 + 88 >> 2];
            $7_1 = HEAP32[$10_1 + 92 >> 2];
            HEAP32[$10_1 + 456 >> 2] = $7_1 >>> 24;
            HEAP32[$10_1 + 460 >> 2] = 0;
            $7_1 = $7_1 << 6 | $6_1 >>> 26;
            $9_1 = HEAP32[$10_1 + 80 >> 2];
            $12_1 = HEAP32[$10_1 + 84 >> 2];
            HEAP32[$10_1 + 448 >> 2] = $6_1 << 6 | $12_1 >>> 26;
            HEAP32[$10_1 + 452 >> 2] = $7_1 & 1073741823;
            $6_1 = $9_1;
            $7_1 = $12_1 << 4 | $6_1 >>> 28;
            $9_1 = HEAP32[$10_1 + 72 >> 2];
            $12_1 = HEAP32[$10_1 + 76 >> 2];
            HEAP32[$10_1 + 440 >> 2] = $6_1 << 4 | $12_1 >>> 28;
            HEAP32[$10_1 + 444 >> 2] = $7_1 & 1073741823;
            $6_1 = $9_1;
            $7_1 = $12_1 << 2 | $6_1 >>> 30;
            $9_1 = HEAP32[$11_1 + 64 >> 2];
            $10_1 = HEAP32[$11_1 + 68 >> 2];
            HEAP32[$11_1 + 432 >> 2] = $6_1 << 2 | $10_1 >>> 30;
            HEAP32[$11_1 + 436 >> 2] = $7_1 & 1073741823;
            HEAP32[$11_1 + 424 >> 2] = $9_1;
            HEAP32[$11_1 + 428 >> 2] = $10_1 & 1073741823;
            $50($11_1 + 424 | 0, 690320);
            $7_1 = HEAP32[$11_1 + 456 >> 2] << 24;
            $10_1 = HEAP32[$11_1 + 452 >> 2];
            $4_1 = $10_1 >>> 6 | 0;
            $9_1 = HEAP32[$11_1 + 448 >> 2];
            HEAP32[$2_1 + 24 >> 2] = ($10_1 & 63) << 26 | $9_1 >>> 6;
            HEAP32[$2_1 + 28 >> 2] = $4_1 | $7_1;
            $7_1 = $9_1 << 26;
            $10_1 = HEAP32[$11_1 + 444 >> 2];
            $4_1 = $10_1 >>> 4 | 0;
            $9_1 = HEAP32[$11_1 + 440 >> 2];
            HEAP32[$2_1 + 16 >> 2] = ($10_1 & 15) << 28 | $9_1 >>> 4;
            HEAP32[$2_1 + 20 >> 2] = $4_1 | $7_1;
            $7_1 = $9_1 << 28;
            $10_1 = HEAP32[$11_1 + 436 >> 2];
            $4_1 = $10_1 >>> 2 | 0;
            $9_1 = HEAP32[$11_1 + 432 >> 2];
            HEAP32[$2_1 + 8 >> 2] = ($10_1 & 3) << 30 | $9_1 >>> 2;
            HEAP32[$2_1 + 12 >> 2] = $4_1 | $7_1;
            $7_1 = HEAP32[$11_1 + 428 >> 2];
            $4_1 = $9_1 << 30;
            HEAP32[$2_1 >> 2] = HEAP32[$11_1 + 424 >> 2];
            HEAP32[$2_1 + 4 >> 2] = $4_1 | $7_1;
            $41($2_1, $2_1, $21_1);
            $4_1 = HEAP32[$2_1 + 28 >> 2];
            $18_1 = $4_1;
            $4_1 = $4_1 >>> 31 | 0;
            $6_1 = $4_1 ^ -1;
            $8_1 = HEAP32[$2_1 + 12 >> 2];
            $9_1 = ($8_1 | 0) == 1566010995;
            $13_1 = HEAP32[$2_1 + 8 >> 2];
            $17_1 = HEAP32[$2_1 + 16 >> 2];
            $19_1 = HEAP32[$2_1 + 20 >> 2];
            $20_1 = HEAP32[$2_1 + 24 >> 2];
            $6_1 = ($6_1 & ($9_1 & $13_1 >>> 0 < 1470386205 | $8_1 >>> 0 < 1566010995) | (($17_1 & $19_1) != -1 & $6_1 | (($18_1 | 0) == 2147483647 & ($20_1 | 0) != -1 | $18_1 >>> 0 < 2147483647))) ^ -1;
            $7_1 = HEAP32[$2_1 + 4 >> 2];
            $12_1 = HEAP32[$2_1 >> 2];
            $16_1 = $6_1 & (($7_1 | 0) == -538366138 & $12_1 >>> 0 > 1746608288 | $7_1 >>> 0 > 3756601158) | ($6_1 & ($9_1 & $13_1 >>> 0 > 1470386205 | $8_1 >>> 0 > 1566010995) | $4_1);
            $15_1 = $16_1 ? -801750718 : 0;
            $10_1 = $16_1 ? -1 : 0;
            $9_1 = $10_1 ^ $12_1;
            $6_1 = $15_1 + $9_1 | 0;
            $21_1 = $16_1 ? -1076732276 : 0;
            $4_1 = $21_1 + ($7_1 ^ $10_1) | 0;
            $12_1 = $17_1 | $20_1 | $13_1 | $12_1 | ($18_1 | $19_1 | $8_1 | $7_1) ? -1 : 0;
            $23_1 = $6_1 & $12_1;
            HEAP32[$2_1 >> 2] = $23_1;
            $9_1 = $6_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $26_1 = $12_1 & $9_1;
            HEAP32[$2_1 + 4 >> 2] = $26_1;
            $7_1 = $2_1;
            $22_1 = $16_1 ? -1162945306 : 0;
            $4_1 = $22_1 + ($8_1 ^ $10_1) | 0;
            $14_1 = ($9_1 | 0) == ($21_1 | 0) & $6_1 >>> 0 < $15_1 >>> 0 | $9_1 >>> 0 < $21_1 >>> 0;
            $27_1 = $16_1 ? -1354194885 : 0;
            $6_1 = $10_1 ^ $13_1;
            $13_1 = $27_1 + $6_1 | 0;
            $9_1 = $14_1 + $13_1 | 0;
            $4_1 = $6_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $6_1 = $4_1;
            $15_1 = $9_1;
            $21_1 = $9_1 & $12_1;
            HEAP32[$7_1 + 8 >> 2] = $21_1;
            $14_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $25_1 = $12_1 & $14_1;
            HEAP32[$7_1 + 12 >> 2] = $25_1;
            $9_1 = $7_1;
            $24_1 = $16_1 ? -2 : 0;
            $7_1 = $10_1 ^ $17_1;
            $8_1 = $24_1 + $7_1 | 0;
            $17_1 = $16_1 ? -1 : 0;
            $4_1 = $17_1 + ($10_1 ^ $19_1) | 0;
            $7_1 = $7_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $4_1 = ($6_1 | 0) == ($22_1 | 0) & $13_1 >>> 0 < $27_1 >>> 0 | $6_1 >>> 0 < $22_1 >>> 0;
            $13_1 = ($6_1 | 0) == ($14_1 | 0) & $13_1 >>> 0 > $15_1 >>> 0 | $6_1 >>> 0 > $14_1 >>> 0;
            $6_1 = $4_1 + $13_1 | 0;
            $4_1 = ($6_1 >>> 0 < $13_1 >>> 0) + $7_1 | 0;
            $15_1 = $6_1;
            $6_1 = $6_1 + $8_1 | 0;
            $4_1 = $15_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $13_1 = $6_1 & $12_1;
            HEAP32[$9_1 + 16 >> 2] = $13_1;
            $14_1 = $4_1 & $12_1;
            HEAP32[$9_1 + 20 >> 2] = $14_1;
            $9_1 = ($7_1 | 0) == ($17_1 | 0) & $8_1 >>> 0 < $24_1 >>> 0 | $7_1 >>> 0 < $17_1 >>> 0;
            $7_1 = ($4_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
            $6_1 = $9_1 + $7_1 | 0;
            $4_1 = $6_1 >>> 0 < $7_1 >>> 0;
            $7_1 = $10_1 ^ $20_1;
            $9_1 = $7_1 - $16_1 | 0;
            $6_1 = $9_1 + $6_1 | 0;
            $4_1 = $4_1 + (($10_1 ^ $18_1) - ($7_1 >>> 0 < $16_1 >>> 0) | 0) | 0;
            $4_1 = $6_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $6_1 = $6_1 & $12_1;
            HEAP32[$2_1 + 24 >> 2] = $6_1;
            $4_1 = $4_1 & $12_1;
            HEAP32[$2_1 + 28 >> 2] = $4_1;
            if ($3_1) {
              HEAP32[$3_1 >> 2] = HEAP32[$3_1 >> 2] ^ $16_1;
            }
            if (!($21_1 | $23_1 | $13_1 | $6_1 | ($25_1 | $26_1 | $14_1 | $4_1))) {
              break label$4;
            }
            if (!(HEAP32[$1_1 + 24 >> 2] | (HEAP32[$1_1 + 16 >> 2] | (HEAP32[$1_1 + 8 >> 2] | HEAP32[$1_1 >> 2])) | (HEAP32[$1_1 + 28 >> 2] | (HEAP32[$1_1 + 20 >> 2] | (HEAP32[$1_1 + 12 >> 2] | HEAP32[$1_1 + 4 >> 2]))))) {
              break label$4;
            }
            $9_1 = 1;
            break label$2;
          }
          $4_1 = $29_1 + 1 | 0;
          $9_1 = 0;
          if (FUNCTION_TABLE[$28_1 | 0]($11_1, 655649, 690788, 0, $5_1, $29_1) | 0) {
            continue;
          }
          break;
        }
        ;
      }
      $6_1 = $9_1 & $31_1;
      $5_1 = !$6_1;
      $0_1 = $5_1 - 1 | 0;
      $4_1 = 0 - !$5_1 | 0;
      $7_1 = $4_1 & HEAP32[$1_1 + 4 >> 2];
      HEAP32[$1_1 >> 2] = $0_1 & HEAP32[$1_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $7_1;
      $7_1 = HEAP32[$1_1 + 12 >> 2] & $4_1;
      HEAP32[$1_1 + 8 >> 2] = HEAP32[$1_1 + 8 >> 2] & $0_1;
      HEAP32[$1_1 + 12 >> 2] = $7_1;
      $7_1 = HEAP32[$1_1 + 20 >> 2] & $4_1;
      HEAP32[$1_1 + 16 >> 2] = HEAP32[$1_1 + 16 >> 2] & $0_1;
      HEAP32[$1_1 + 20 >> 2] = $7_1;
      $7_1 = HEAP32[$1_1 + 28 >> 2] & $4_1;
      HEAP32[$1_1 + 24 >> 2] = HEAP32[$1_1 + 24 >> 2] & $0_1;
      HEAP32[$1_1 + 28 >> 2] = $7_1;
      $1_1 = HEAP32[$2_1 + 4 >> 2] & $4_1;
      HEAP32[$2_1 >> 2] = HEAP32[$2_1 >> 2] & $0_1;
      HEAP32[$2_1 + 4 >> 2] = $1_1;
      $1_1 = HEAP32[$2_1 + 12 >> 2] & $4_1;
      HEAP32[$2_1 + 8 >> 2] = HEAP32[$2_1 + 8 >> 2] & $0_1;
      HEAP32[$2_1 + 12 >> 2] = $1_1;
      $1_1 = HEAP32[$2_1 + 20 >> 2] & $4_1;
      HEAP32[$2_1 + 16 >> 2] = HEAP32[$2_1 + 16 >> 2] & $0_1;
      HEAP32[$2_1 + 20 >> 2] = $1_1;
      $1_1 = HEAP32[$2_1 + 28 >> 2] & $4_1;
      HEAP32[$2_1 + 24 >> 2] = HEAP32[$2_1 + 24 >> 2] & $0_1;
      HEAP32[$2_1 + 28 >> 2] = $1_1;
      if ($3_1) {
        HEAP32[$11_1 + 256 >> 2] = $5_1;
        HEAP32[$3_1 >> 2] = HEAP32[$3_1 >> 2] & HEAP32[$11_1 + 256 >> 2] - 1;
      }
      global$0 = $11_1 + 464 | 0;
      return $6_1;
    }
    function $48($0_1, $1_1, $2_1) {
      var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0;
      $5_1 = global$0 - 128 | 0;
      global$0 = $5_1;
      $26_1 = $70($1_1, $0_1 + 40 | 0, 128);
      $6_1 = HEAP32[$0_1 + 8 >> 2];
      $9_1 = HEAP32[$2_1 >> 2];
      $20_1 = $6_1 + $9_1 | 0;
      $1_1 = HEAP32[$0_1 + 12 >> 2];
      $3_1 = $1_1 + HEAP32[$2_1 + 4 >> 2] | 0;
      $7_1 = $9_1 >>> 0 > $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = ($1_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 > $20_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
      $6_1 = HEAP32[$2_1 + 8 >> 2];
      $3_1 = $8_1 + $6_1 | 0;
      $1_1 = HEAP32[$2_1 + 12 >> 2];
      $1_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $6_1 = $3_1;
      $3_1 = $0_1 + 16 | 0;
      $9_1 = HEAP32[$3_1 >> 2];
      $19_1 = $6_1 + $9_1 | 0;
      $3_1 = $1_1 + HEAP32[$3_1 + 4 >> 2] | 0;
      $8_1 = !$1_1 & $6_1 >>> 0 < $8_1 >>> 0;
      $9_1 = $9_1 >>> 0 > $19_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = ($1_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 > $19_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
      $3_1 = $8_1 + $6_1 | 0;
      $1_1 = $3_1 >>> 0 < $6_1 >>> 0;
      $13_1 = $3_1;
      $3_1 = HEAP32[$2_1 + 16 >> 2];
      $8_1 = $13_1 + $3_1 | 0;
      $6_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$2_1 + 20 >> 2] | 0;
      $3_1 = $3_1 >>> 0 > $8_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $0_1 + 24 | 0;
      $17_1 = HEAP32[$1_1 >> 2];
      $11_1 = $17_1 + $8_1 | 0;
      $1_1 = $3_1 + HEAP32[$1_1 + 4 >> 2] | 0;
      $13_1 = ($3_1 | 0) == ($6_1 | 0) & $8_1 >>> 0 < $13_1 >>> 0 | $3_1 >>> 0 < $6_1 >>> 0;
      $6_1 = $11_1 >>> 0 < $17_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $8_1;
      $8_1 = $11_1;
      $11_1 = ($3_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 > $8_1 >>> 0 | $3_1 >>> 0 > $6_1 >>> 0;
      $3_1 = $13_1 + $11_1 | 0;
      $1_1 = $3_1 >>> 0 < $11_1 >>> 0;
      $17_1 = $3_1;
      $13_1 = HEAP32[$2_1 + 24 >> 2];
      $11_1 = $3_1 + $13_1 | 0;
      $3_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$2_1 + 28 >> 2] | 0;
      $1_1 = $11_1 >>> 0 < $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $0_1 = $0_1 + 32 | 0;
      $13_1 = HEAP32[$0_1 >> 2];
      $2_1 = $13_1 + $11_1 | 0;
      $0_1 = $1_1 + HEAP32[$0_1 + 4 >> 2] | 0;
      $21_1 = $2_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $13_1 = $2_1;
      $17_1 = (($1_1 | 0) == ($3_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $1_1 >>> 0 < $3_1 >>> 0) + (($1_1 | 0) == ($21_1 | 0) & $2_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $21_1 >>> 0) | 0;
      $1_1 = ($6_1 | 0) == -1;
      $2_1 = $1_1 & $8_1 >>> 0 < 4294967294 | ($6_1 | 0) != -1 | ($2_1 & $21_1) != -1;
      $0_1 = ($9_1 | 0) == -1162945306;
      $3_1 = ($2_1 | ($0_1 & $19_1 >>> 0 < 2940772411 | $9_1 >>> 0 < 3132021990)) ^ -1;
      $11_1 = $17_1 + ($3_1 & (($7_1 | 0) == -1076732276 & $20_1 >>> 0 > 3493216576 | $7_1 >>> 0 > 3218235020) | ($3_1 & ($0_1 & $19_1 >>> 0 > 2940772411 | $9_1 >>> 0 > 3132021990) | ($8_1 | 0) == -1 & $1_1 & ($2_1 ^ -1))) | 0;
      $0_1 = __wasm_i64_mul($11_1, 0, 801750719, 1076732275);
      $2_1 = $0_1 + $20_1 | 0;
      $1_1 = $7_1 + i64toi32_i32$HIGH_BITS | 0;
      HEAP32[$5_1 + 8 >> 2] = $2_1;
      $1_1 = $0_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      HEAP32[$5_1 + 12 >> 2] = $1_1;
      $0_1 = $5_1;
      $7_1 = ($1_1 | 0) == ($7_1 | 0) & $2_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $7_1 >>> 0;
      $3_1 = __wasm_i64_mul($11_1, 0, 1354194884, 1162945305);
      $2_1 = $3_1 + $19_1 | 0;
      $1_1 = $9_1 + i64toi32_i32$HIGH_BITS | 0;
      $1_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $7_1 = $2_1 + $7_1 | 0;
      $3_1 = $7_1 >>> 0 < $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      HEAP32[$0_1 + 16 >> 2] = $7_1;
      HEAP32[$0_1 + 20 >> 2] = $3_1;
      $3_1 = ($1_1 | 0) == ($3_1 | 0) & $2_1 >>> 0 > $7_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $2_1 = $3_1 + (($1_1 | 0) == ($9_1 | 0) & $2_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $9_1 >>> 0) | 0;
      $1_1 = $2_1 >>> 0 < $3_1 >>> 0;
      $3_1 = $2_1;
      $9_1 = $1_1;
      $1_1 = $6_1;
      $7_1 = $8_1 + $11_1 | 0;
      $2_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $1_1 = $2_1 + $9_1 | 0;
      $17_1 = $3_1;
      $3_1 = $7_1;
      $7_1 = $17_1 + $3_1 | 0;
      HEAP32[$0_1 + 24 >> 2] = $7_1;
      $1_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      HEAP32[$0_1 + 28 >> 2] = $1_1;
      $0_1 = ($2_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 < $8_1 >>> 0 | $2_1 >>> 0 < $6_1 >>> 0;
      $2_1 = ($1_1 | 0) == ($2_1 | 0) & $3_1 >>> 0 > $7_1 >>> 0 | $1_1 >>> 0 < $2_1 >>> 0;
      $1_1 = $0_1 + $2_1 | 0;
      $3_1 = $21_1 + ($1_1 >>> 0 < $2_1 >>> 0) | 0;
      $0_1 = $1_1 + $13_1 | 0;
      $3_1 = $0_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$5_1 + 32 >> 2] = $0_1;
      HEAP32[$5_1 + 36 >> 2] = $3_1;
      $2_1 = 0;
      $19_1 = 0;
      $6_1 = 0;
      $20_1 = 0;
      $11_1 = 0;
      $13_1 = 0;
      $9_1 = 0;
      $7_1 = 0;
      $17_1 = 0;
      $8_1 = 0;
      $21_1 = 0;
      while (1) {
        HEAP32[$5_1 + 120 >> 2] = 0;
        $1_1 = ($5_1 + 8 | 0) + ($27_1 >>> 2 & 1073741816) | 0;
        $0_1 = HEAP32[$1_1 >> 2];
        $3_1 = HEAP32[$1_1 + 4 >> 2];
        $4_1 = $28_1 & 62;
        $1_1 = $4_1 & 31;
        if ($4_1 >>> 0 >= 32) {
          $0_1 = $3_1 >>> $1_1 | 0;
        } else {
          $0_1 = ((1 << $1_1) - 1 & $3_1) << 32 - $1_1 | $0_1 >>> $1_1;
        }
        $12_1 = $0_1 & 3;
        $14_1 = ($12_1 | 0) == 1;
        $4_1 = $22_1 + 656432 | 0;
        $0_1 = $4_1 + 248 | 0;
        $1_1 = $4_1 + 184 | 0;
        $3_1 = $4_1 + 120 | 0;
        $10_1 = $4_1 + 56 | 0;
        $15_1 = ($12_1 | 0) == 2;
        $16_1 = ($12_1 | 0) == 3;
        $2_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$3_1 >> 2] : $12_1 ? $2_1 : HEAP32[$10_1 >> 2];
        $1_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$3_1 + 4 >> 2] : $12_1 ? $19_1 : HEAP32[$10_1 + 4 >> 2];
        $19_1 = $1_1;
        $0_1 = $1_1 >>> 16 | 0;
        HEAP32[$5_1 + 112 >> 2] = ($1_1 & 65535) << 16 | $2_1 >>> 16;
        HEAP32[$5_1 + 116 >> 2] = $0_1;
        $0_1 = $4_1 + 224 | 0;
        $1_1 = $4_1 + 160 | 0;
        $3_1 = $4_1 + 96 | 0;
        $10_1 = $4_1 + 32 | 0;
        $29_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$3_1 >> 2] : $12_1 ? $29_1 : HEAP32[$10_1 >> 2];
        $9_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$3_1 + 4 >> 2] : $12_1 ? $9_1 : HEAP32[$10_1 + 4 >> 2];
        HEAP32[$5_1 + 80 >> 2] = $29_1;
        HEAP32[$5_1 + 84 >> 2] = $9_1 & 1048575;
        $0_1 = $4_1 + 216 | 0;
        $1_1 = $4_1 + 152 | 0;
        $3_1 = $4_1 + 88 | 0;
        $10_1 = $4_1 + 24 | 0;
        $7_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$3_1 >> 2] : $12_1 ? $7_1 : HEAP32[$10_1 >> 2];
        $0_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$3_1 + 4 >> 2] : $12_1 ? $17_1 : HEAP32[$10_1 + 4 >> 2];
        $17_1 = $0_1;
        $3_1 = $0_1 >>> 16 | 0;
        HEAP32[$5_1 + 72 >> 2] = ($0_1 & 65535) << 16 | $7_1 >>> 16;
        HEAP32[$5_1 + 76 >> 2] = $3_1;
        $0_1 = $4_1 + 192 | 0;
        $1_1 = $4_1 + 128 | 0;
        $3_1 = $4_1 - -64 | 0;
        $30_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$3_1 >> 2] : $12_1 ? $30_1 : HEAP32[$4_1 >> 2];
        $23_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$3_1 + 4 >> 2] : $12_1 ? $23_1 : HEAP32[$4_1 + 4 >> 2];
        HEAP32[$5_1 + 40 >> 2] = $30_1;
        HEAP32[$5_1 + 44 >> 2] = $23_1 & 1048575;
        $3_1 = $2_1 << 4 & 1048560;
        $0_1 = $4_1 + 240 | 0;
        $1_1 = $4_1 + 176 | 0;
        $10_1 = $4_1 + 112 | 0;
        $18_1 = $4_1 + 48 | 0;
        $6_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$10_1 >> 2] : $12_1 ? $6_1 : HEAP32[$18_1 >> 2];
        $1_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$10_1 + 4 >> 2] : $12_1 ? $20_1 : HEAP32[$18_1 + 4 >> 2];
        $20_1 = $1_1;
        $0_1 = $1_1 >>> 28 | 0;
        HEAP32[$5_1 + 104 >> 2] = ($1_1 & 268435455) << 4 | $6_1 >>> 28;
        HEAP32[$5_1 + 108 >> 2] = $0_1 | $3_1;
        $3_1 = $4_1 + 232 | 0;
        $10_1 = $4_1 + 168 | 0;
        $18_1 = $4_1 + 104 | 0;
        $0_1 = $4_1 + 40 | 0;
        $11_1 = $16_1 ? HEAP32[$3_1 >> 2] : $15_1 ? HEAP32[$10_1 >> 2] : $14_1 ? HEAP32[$18_1 >> 2] : $12_1 ? $11_1 : HEAP32[$0_1 >> 2];
        $13_1 = $16_1 ? HEAP32[$3_1 + 4 >> 2] : $15_1 ? HEAP32[$10_1 + 4 >> 2] : $14_1 ? HEAP32[$18_1 + 4 >> 2] : $12_1 ? $13_1 : HEAP32[$0_1 + 4 >> 2];
        HEAP32[$5_1 + 96 >> 2] = $6_1 << 24 & -16777216 | $13_1 >>> 8;
        HEAP32[$5_1 + 100 >> 2] = ($1_1 << 24 | $6_1 >>> 8) & 1048575;
        HEAP32[$5_1 + 88 >> 2] = $11_1 << 12 & -4096 | $9_1 >>> 20;
        HEAP32[$5_1 + 92 >> 2] = ($13_1 << 12 | $11_1 >>> 20) & 1048575;
        $0_1 = $4_1 + 208 | 0;
        $1_1 = $4_1 + 144 | 0;
        $10_1 = $4_1 + 80 | 0;
        $18_1 = $4_1 + 16 | 0;
        $8_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$10_1 >> 2] : $12_1 ? $8_1 : HEAP32[$18_1 >> 2];
        $0_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$10_1 + 4 >> 2] : $12_1 ? $21_1 : HEAP32[$18_1 + 4 >> 2];
        $21_1 = $0_1;
        $1_1 = $0_1 >>> 28 | 0;
        HEAP32[$5_1 + 64 >> 2] = ($0_1 & 268435455) << 4 | $8_1 >>> 28;
        HEAP32[$5_1 + 68 >> 2] = $1_1 | $7_1 << 4 & 1048560;
        $1_1 = $8_1 << 24 & -16777216;
        $0_1 = $4_1 + 200 | 0;
        $10_1 = $4_1 + 136 | 0;
        $18_1 = $4_1 + 72 | 0;
        $4_1 = $4_1 + 8 | 0;
        $24_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$10_1 >> 2] : $14_1 ? HEAP32[$18_1 >> 2] : $12_1 ? $24_1 : HEAP32[$4_1 >> 2];
        $25_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$10_1 + 4 >> 2] : $14_1 ? HEAP32[$18_1 + 4 >> 2] : $12_1 ? $25_1 : HEAP32[$4_1 + 4 >> 2];
        HEAP32[$5_1 + 56 >> 2] = $25_1 >>> 8 | $1_1;
        HEAP32[$5_1 + 60 >> 2] = ($21_1 << 24 | $8_1 >>> 8) & 1048575;
        HEAP32[$5_1 + 48 >> 2] = $24_1 << 12 & -4096 | $23_1 >>> 20;
        HEAP32[$5_1 + 52 >> 2] = ($25_1 << 12 | $24_1 >>> 20) & 1048575;
        $53($26_1, $26_1, $5_1 + 40 | 0);
        $28_1 = $28_1 + 2 | 0;
        $27_1 = $27_1 + 1 | 0;
        $22_1 = $22_1 + 256 | 0;
        if (($22_1 | 0) != 32768) {
          continue;
        }
        break;
      }
      ;
      global$0 = $5_1 + 128 | 0;
    }
    function $49($0_1, $1_1) {
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0;
      $6_1 = global$0 - 80 | 0;
      global$0 = $6_1;
      HEAP32[$0_1 + 80 >> 2] = HEAP32[$1_1 + 120 >> 2];
      $13_1 = $1_1 + 104 | 0;
      $11_1 = HEAP32[$13_1 >> 2];
      $12_1 = HEAP32[$13_1 + 4 >> 2];
      $14_1 = $1_1 + 96 | 0;
      $7_1 = HEAP32[$14_1 >> 2];
      $10_1 = HEAP32[$14_1 + 4 >> 2];
      $15_1 = $1_1 + 88 | 0;
      $5_1 = HEAP32[$15_1 >> 2];
      $8_1 = HEAP32[$15_1 + 4 >> 2];
      $9_1 = HEAP32[$1_1 + 84 >> 2];
      $16_1 = $1_1 + 112 | 0;
      $17_1 = HEAP32[$16_1 >> 2];
      $4_1 = HEAP32[$16_1 + 4 >> 2];
      $21_1 = $4_1;
      $2_1 = HEAP32[$1_1 + 80 >> 2];
      $3_1 = __wasm_i64_mul($4_1 >>> 16 | 0, 0, 977, 1);
      $4_1 = $2_1 + $3_1 | 0;
      $2_1 = $9_1 + i64toi32_i32$HIGH_BITS | 0;
      $9_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $8_1;
      $3_1 = $9_1 >>> 20 | 0;
      $8_1 = $3_1;
      $3_1 = $3_1 + $5_1 | 0;
      $8_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $10_1;
      $5_1 = $8_1 >>> 20 | 0;
      $10_1 = $5_1;
      $5_1 = $5_1 + $7_1 | 0;
      $10_1 = $10_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $12_1;
      $7_1 = $10_1 >>> 20 | 0;
      $12_1 = $7_1;
      $7_1 = $7_1 + $11_1 | 0;
      $11_1 = $12_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $22_1 = $8_1 & 1048575;
      $2_1 = $9_1 & 1048575;
      $19_1 = $4_1;
      $18_1 = $2_1;
      $12_1 = $3_1;
      $9_1 = $5_1;
      $20_1 = $10_1 & 1048575;
      $5_1 = ($3_1 & $5_1 & $7_1) == -1 & ($20_1 & $8_1 & $11_1) == 1048575;
      $2_1 = $21_1 & 65535;
      $3_1 = $11_1 >>> 20 | 0;
      $4_1 = $3_1;
      $3_1 = $3_1 + $17_1 | 0;
      $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $8_1 = $3_1;
      $4_1 = $2_1;
      $5_1 = __wasm_i64_mul($5_1 & (($3_1 | 0) == -1 & ($2_1 | 0) == 65535) & (($18_1 | 0) == 1048574 & $19_1 >>> 0 > 4294966318 | $18_1 >>> 0 > 1048574) | $2_1 >>> 16, 0, 977, 1);
      $3_1 = $5_1 + $19_1 | 0;
      $2_1 = $18_1 + i64toi32_i32$HIGH_BITS | 0;
      $2_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $5_1 = $3_1;
      $17_1 = $2_1;
      $2_1 = $22_1;
      $3_1 = $17_1 >>> 20 | 0;
      $10_1 = $3_1 + $12_1 | 0;
      $3_1 = $3_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$6_1 + 40 >> 2] = $5_1;
      HEAP32[$6_1 + 44 >> 2] = $10_1 << 20 & 1072693248 | $17_1 & 1048575;
      $2_1 = $20_1;
      $12_1 = $9_1;
      $5_1 = $3_1;
      $9_1 = ($3_1 >>> 20 | 0) + $9_1 | 0;
      $3_1 = $12_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $17_1 = $9_1 << 10 & 1073740800;
      $2_1 = $5_1 >>> 10 | 0;
      HEAP32[$6_1 + 48 >> 2] = ($5_1 & 1023) << 22 | $10_1 >>> 10;
      HEAP32[$6_1 + 52 >> 2] = $17_1 | $2_1 & 1023;
      $2_1 = $11_1 & 1048575;
      $5_1 = $3_1;
      $3_1 = $3_1 >>> 20 | 0;
      $7_1 = $3_1 + $7_1 | 0;
      $3_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$6_1 + 56 >> 2] = ($5_1 & 1048575) << 12 | $9_1 >>> 20;
      HEAP32[$6_1 + 60 >> 2] = $7_1 & 1073741823;
      $2_1 = $4_1;
      $4_1 = ($3_1 >>> 20 | 0) + $8_1 | 0;
      $2_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$6_1 + 72 >> 2] = $2_1 >>> 8 & 255;
      HEAP32[$6_1 + 76 >> 2] = 0;
      $2_1 = $2_1 << 22 | $4_1 >>> 10;
      HEAP32[$6_1 + 64 >> 2] = (($3_1 & 1073741823) << 2 | $7_1 >>> 30) & 4194303 | $4_1 << 22 & -4194304;
      HEAP32[$6_1 + 68 >> 2] = $2_1 & 1073741823;
      $8_1 = $6_1 + 40 | 0;
      $50($8_1, 690464);
      $3_1 = HEAP32[$6_1 + 44 >> 2];
      $4_1 = $3_1;
      HEAP32[$1_1 + 80 >> 2] = HEAP32[$6_1 + 40 >> 2];
      HEAP32[$1_1 + 84 >> 2] = $3_1 & 1048575;
      $5_1 = HEAP32[$6_1 + 72 >> 2] << 8;
      $11_1 = HEAP32[$6_1 + 68 >> 2];
      $2_1 = $11_1 >>> 22 | 0;
      $7_1 = HEAP32[$6_1 + 64 >> 2];
      HEAP32[$16_1 >> 2] = ($11_1 & 4194303) << 10 | $7_1 >>> 22;
      HEAP32[$16_1 + 4 >> 2] = $2_1 | $5_1;
      $3_1 = $7_1;
      $2_1 = $11_1 << 30 | $3_1 >>> 2;
      $7_1 = $3_1 << 30 & -1073741824;
      $3_1 = HEAP32[$6_1 + 56 >> 2];
      $5_1 = HEAP32[$6_1 + 60 >> 2];
      HEAP32[$13_1 >> 2] = $5_1 | $7_1;
      HEAP32[$13_1 + 4 >> 2] = $2_1 & 1048575;
      $2_1 = $5_1 << 20 | $3_1 >>> 12;
      $7_1 = $3_1 << 20 & -1048576;
      $3_1 = HEAP32[$6_1 + 48 >> 2];
      $5_1 = HEAP32[$6_1 + 52 >> 2];
      HEAP32[$14_1 >> 2] = $5_1 >>> 10 | $7_1;
      HEAP32[$14_1 + 4 >> 2] = $2_1 & 1048575;
      $5_1 = ($5_1 << 10 | $3_1 >>> 22) & 1048575;
      HEAP32[$15_1 >> 2] = $3_1 << 10 & -1024 | $4_1 >>> 20;
      HEAP32[$15_1 + 4 >> 2] = $5_1;
      $2_1 = $1_1 + 80 | 0;
      $54($8_1, $2_1);
      $34($6_1, $2_1, $8_1);
      $34($1_1, $1_1, $8_1);
      $2_1 = $1_1 + 40 | 0;
      $34($2_1, $2_1, $6_1);
      HEAP32[$16_1 >> 2] = 0;
      HEAP32[$16_1 + 4 >> 2] = 0;
      HEAP32[$13_1 >> 2] = 0;
      HEAP32[$13_1 + 4 >> 2] = 0;
      HEAP32[$14_1 >> 2] = 0;
      HEAP32[$14_1 + 4 >> 2] = 0;
      HEAP32[$15_1 >> 2] = 0;
      HEAP32[$15_1 + 4 >> 2] = 0;
      HEAP32[$1_1 + 80 >> 2] = 1;
      HEAP32[$1_1 + 84 >> 2] = 0;
      $2_1 = HEAP32[$1_1 + 4 >> 2];
      HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$0_1 + 4 >> 2] = $2_1;
      $2_1 = $1_1 + 8 | 0;
      $3_1 = HEAP32[$2_1 + 4 >> 2];
      $4_1 = $0_1 + 8 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $3_1;
      $2_1 = $1_1 + 16 | 0;
      $3_1 = HEAP32[$2_1 + 4 >> 2];
      $4_1 = $0_1 + 16 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $3_1;
      $2_1 = $1_1 + 24 | 0;
      $3_1 = HEAP32[$2_1 + 4 >> 2];
      $4_1 = $0_1 + 24 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $3_1;
      $2_1 = $1_1 + 32 | 0;
      $3_1 = HEAP32[$2_1 + 4 >> 2];
      $4_1 = $0_1 + 32 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $3_1;
      $2_1 = HEAP32[$1_1 + 44 >> 2];
      HEAP32[$0_1 + 40 >> 2] = HEAP32[$1_1 + 40 >> 2];
      HEAP32[$0_1 + 44 >> 2] = $2_1;
      $2_1 = $1_1 + 48 | 0;
      $3_1 = HEAP32[$2_1 + 4 >> 2];
      $4_1 = $0_1 + 48 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $3_1;
      $2_1 = $1_1 + 56 | 0;
      $3_1 = HEAP32[$2_1 + 4 >> 2];
      $4_1 = $0_1 + 56 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $3_1;
      $2_1 = $1_1 - -64 | 0;
      $3_1 = HEAP32[$2_1 + 4 >> 2];
      $4_1 = $0_1 - -64 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $3_1;
      $1_1 = $1_1 + 72 | 0;
      $2_1 = HEAP32[$1_1 + 4 >> 2];
      $0_1 = $0_1 + 72 | 0;
      HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$0_1 + 4 >> 2] = $2_1;
      global$0 = $6_1 + 80 | 0;
    }
    function $50($0_1, $1_1) {
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0;
      $7_1 = global$0 - 432 | 0;
      global$0 = $7_1;
      $3_1 = $7_1 + 392 | 0;
      $2_1 = $3_1 + 32 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $3_1 + 24 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $3_1 + 16 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $3_1 = $3_1 + 8 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      HEAP32[$7_1 + 392 >> 2] = 0;
      HEAP32[$7_1 + 396 >> 2] = 0;
      $3_1 = $7_1 + 352 | 0;
      $2_1 = $3_1 + 32 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $3_1 + 24 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $3_1 = $3_1 + 16 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      HEAP32[$7_1 + 360 >> 2] = 0;
      HEAP32[$7_1 + 364 >> 2] = 0;
      HEAP32[$7_1 + 352 >> 2] = 1;
      HEAP32[$7_1 + 356 >> 2] = 0;
      $34_1 = $0_1;
      $41_1 = HEAP32[$0_1 + 32 >> 2];
      $43_1 = HEAP32[$0_1 + 36 >> 2];
      $20_1 = HEAP32[$0_1 + 24 >> 2];
      $39_1 = HEAP32[$0_1 + 28 >> 2];
      $26_1 = HEAP32[$0_1 + 16 >> 2];
      $29_1 = HEAP32[$0_1 + 20 >> 2];
      $22_1 = HEAP32[$0_1 + 8 >> 2];
      $35_1 = HEAP32[$0_1 + 12 >> 2];
      $3_1 = HEAP32[$0_1 >> 2];
      $9_1 = HEAP32[$0_1 + 4 >> 2];
      $42_1 = HEAP32[$1_1 + 32 >> 2];
      $23_1 = HEAP32[$1_1 + 36 >> 2];
      $30_1 = HEAP32[$1_1 + 24 >> 2];
      $31_1 = HEAP32[$1_1 + 28 >> 2];
      $27_1 = HEAP32[$1_1 + 16 >> 2];
      $32_1 = HEAP32[$1_1 + 20 >> 2];
      $24_1 = HEAP32[$1_1 + 8 >> 2];
      $33_1 = HEAP32[$1_1 + 12 >> 2];
      $2_1 = HEAP32[$1_1 >> 2];
      $11_1 = HEAP32[$1_1 + 4 >> 2];
      $44_1 = -1;
      $21_1 = -1;
      while (1) {
        $5_1 = 8;
        $4_1 = 0;
        $36_1 = 59;
        $6_1 = 0;
        $14_1 = 0;
        $8_1 = $3_1;
        $0_1 = $9_1;
        $12_1 = $2_1;
        $19_1 = $11_1;
        $10_1 = 0;
        $15_1 = 0;
        $16_1 = 8;
        $13_1 = 0;
        while (1) {
          $18_1 = $0_1;
          $0_1 = $8_1 & 1;
          $28_1 = 0 - $0_1 | 0;
          $37_1 = 0 - $0_1 | 0;
          $25_1 = $37_1;
          $38_1 = $21_1;
          $0_1 = $21_1 >> 31;
          $17_1 = $0_1;
          $0_1 = $0_1 ^ $12_1;
          $21_1 = $0_1 - $17_1 & $28_1;
          $8_1 = $21_1 + $8_1 | 0;
          $0_1 = $18_1 + ($25_1 & ($17_1 ^ $19_1) - (($0_1 >>> 0 < $17_1 >>> 0) + $17_1 | 0)) | 0;
          $40_1 = $8_1;
          $8_1 = $8_1 >>> 0 < $21_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $18_1 = $17_1 & $25_1;
          $0_1 = ($8_1 & $18_1) + $19_1 | 0;
          $19_1 = $12_1;
          $21_1 = $17_1 & $28_1;
          $12_1 = ($21_1 & $40_1) + $12_1 | 0;
          $19_1 = $19_1 >>> 0 > $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $0_1 = $6_1 ^ $17_1;
          $25_1 = $0_1 - $17_1 & $28_1;
          $16_1 = $25_1 + $16_1 | 0;
          $0_1 = $13_1 + (($14_1 ^ $17_1) - (($0_1 >>> 0 < $17_1 >>> 0) + $17_1 | 0) & $37_1) | 0;
          $13_1 = $16_1 >>> 0 < $25_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $0_1 = ($13_1 & $18_1) + $14_1 | 0;
          $14_1 = $6_1;
          $6_1 = ($16_1 & $21_1) + $6_1 | 0;
          $0_1 = ($14_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) << 1 | $6_1 >>> 31;
          $6_1 = $6_1 << 1;
          $14_1 = $0_1;
          $25_1 = $21_1;
          $0_1 = $5_1 ^ $17_1;
          $21_1 = ($0_1 - $17_1 & $28_1) + $10_1 | 0;
          $0_1 = (($4_1 ^ $17_1) - (($0_1 >>> 0 < $17_1 >>> 0) + $17_1 | 0) & $37_1) + $15_1 | 0;
          $15_1 = $10_1 >>> 0 > $21_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $0_1 = ($15_1 & $18_1) + $4_1 | 0;
          $4_1 = $5_1;
          $10_1 = $21_1;
          $5_1 = ($25_1 & $10_1) + $5_1 | 0;
          $0_1 = ($4_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) << 1 | $5_1 >>> 31;
          $5_1 = $5_1 << 1;
          $4_1 = $0_1;
          $0_1 = $25_1 ^ $44_1;
          $44_1 = $0_1 - 1 | 0;
          $21_1 = ($18_1 ^ $38_1) - !$0_1 | 0;
          $0_1 = $8_1 >>> 1 | 0;
          $8_1 = ($8_1 & 1) << 31 | $40_1 >>> 1;
          $36_1 = $36_1 - 1 | 0;
          if ($36_1) {
            continue;
          }
          break;
        }
        ;
        HEAP32[$7_1 + 344 >> 2] = $16_1;
        HEAP32[$7_1 + 348 >> 2] = $13_1;
        HEAP32[$7_1 + 336 >> 2] = $10_1;
        HEAP32[$7_1 + 340 >> 2] = $15_1;
        HEAP32[$7_1 + 328 >> 2] = $6_1;
        HEAP32[$7_1 + 332 >> 2] = $14_1;
        HEAP32[$7_1 + 320 >> 2] = $5_1;
        HEAP32[$7_1 + 324 >> 2] = $4_1;
        $67($7_1 + 392 | 0, $7_1 + 352 | 0, $7_1 + 320 | 0, $1_1);
        $0_1 = $11_1 >> 31;
        $40_1 = $7_1 + 304 | 0;
        $8_1 = $4_1 >> 31;
        $12_1 = $2_1;
        $19_1 = $0_1;
        $69($40_1, $5_1, $4_1, $8_1, $8_1, $2_1, $11_1, $0_1, $0_1);
        $0_1 = $9_1 >> 31;
        $25_1 = $7_1 + 272 | 0;
        $2_1 = $14_1 >> 31;
        $18_1 = $3_1;
        $17_1 = $0_1;
        $69($25_1, $6_1, $14_1, $2_1, $2_1, $3_1, $9_1, $0_1, $0_1);
        $0_1 = $15_1 >> 31;
        $28_1 = $7_1 + 288 | 0;
        $38_1 = $10_1;
        $3_1 = $0_1;
        $69($28_1, $10_1, $15_1, $0_1, $0_1, $12_1, $11_1, $19_1, $19_1);
        $0_1 = $13_1 >> 31;
        $11_1 = $7_1 + 256 | 0;
        $10_1 = $0_1;
        $69($11_1, $16_1, $13_1, $0_1, $0_1, $18_1, $9_1, $17_1, $17_1);
        $0_1 = $33_1 >> 31;
        $12_1 = $7_1 + 240 | 0;
        $9_1 = $0_1;
        $69($12_1, $5_1, $4_1, $8_1, $8_1, $24_1, $33_1, $0_1, $0_1);
        $19_1 = $7_1 + 208 | 0;
        $18_1 = $35_1;
        $0_1 = $18_1 >> 31;
        $69($19_1, $6_1, $14_1, $2_1, $2_1, $22_1, $18_1, $0_1, $0_1);
        $18_1 = $7_1 + 224 | 0;
        $69($18_1, $38_1, $15_1, $3_1, $3_1, $24_1, $33_1, $9_1, $9_1);
        $17_1 = $7_1 + 192 | 0;
        $69($17_1, $16_1, $13_1, $10_1, $10_1, $22_1, $35_1, $0_1, $0_1);
        $0_1 = $32_1 >> 31;
        $22_1 = $7_1 + 176 | 0;
        $9_1 = $0_1;
        $69($22_1, $5_1, $4_1, $8_1, $8_1, $27_1, $32_1, $0_1, $0_1);
        $35_1 = $7_1 + 144 | 0;
        $0_1 = $29_1 >> 31;
        $69($35_1, $6_1, $14_1, $2_1, $2_1, $26_1, $29_1, $0_1, $0_1);
        $33_1 = $7_1 + 160 | 0;
        $69($33_1, $38_1, $15_1, $3_1, $3_1, $27_1, $32_1, $9_1, $9_1);
        $32_1 = $7_1 + 128 | 0;
        $69($32_1, $16_1, $13_1, $10_1, $10_1, $26_1, $29_1, $0_1, $0_1);
        $0_1 = $31_1 >> 31;
        $26_1 = $7_1 + 112 | 0;
        $9_1 = $0_1;
        $69($26_1, $5_1, $4_1, $8_1, $8_1, $30_1, $31_1, $0_1, $0_1);
        $29_1 = $7_1 + 80 | 0;
        $24_1 = $39_1;
        $0_1 = $24_1 >> 31;
        $69($29_1, $6_1, $14_1, $2_1, $2_1, $20_1, $24_1, $0_1, $0_1);
        $37_1 = $7_1 + 96 | 0;
        $69($37_1, $38_1, $15_1, $3_1, $3_1, $30_1, $31_1, $9_1, $9_1);
        $31_1 = $7_1 - -64 | 0;
        $69($31_1, $16_1, $13_1, $10_1, $10_1, $20_1, $24_1, $0_1, $0_1);
        $0_1 = $23_1 >> 31;
        $20_1 = $7_1 + 48 | 0;
        $9_1 = $8_1;
        $8_1 = $0_1;
        $69($20_1, $5_1, $4_1, $9_1, $9_1, $42_1, $23_1, $0_1, $0_1);
        $39_1 = $7_1 + 16 | 0;
        $4_1 = $43_1;
        $0_1 = $4_1 >> 31;
        $69($39_1, $6_1, $14_1, $2_1, $2_1, $41_1, $4_1, $0_1, $0_1);
        $36_1 = $7_1 + 32 | 0;
        $69($36_1, $38_1, $15_1, $3_1, $3_1, $42_1, $23_1, $8_1, $8_1);
        $69($7_1, $16_1, $13_1, $10_1, $10_1, $41_1, $4_1, $0_1, $0_1);
        $5_1 = HEAP32[$7_1 + 272 >> 2];
        $2_1 = HEAP32[$7_1 + 304 >> 2];
        $3_1 = $5_1 + $2_1 | 0;
        $8_1 = HEAP32[$7_1 + 276 >> 2];
        $0_1 = $8_1 + HEAP32[$7_1 + 308 >> 2] | 0;
        $0_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $2_1 = $3_1;
        $3_1 = $0_1;
        $8_1 = ($8_1 | 0) == ($0_1 | 0) & $2_1 >>> 0 < $5_1 >>> 0 | $0_1 >>> 0 < $8_1 >>> 0;
        $0_1 = $40_1 + 8 | 0;
        $5_1 = HEAP32[$0_1 >> 2];
        $4_1 = $25_1 + 8 | 0;
        $2_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
        $0_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
        $0_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $8_1 = $2_1 + $8_1 | 0;
        $2_1 = $8_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $5_1 = $2_1 << 2 | $8_1 >>> 30;
        $4_1 = $8_1 << 2 | $3_1 >>> 30;
        $10_1 = HEAP32[$7_1 + 208 >> 2];
        $8_1 = HEAP32[$7_1 + 240 >> 2];
        $3_1 = $10_1 + $8_1 | 0;
        $6_1 = HEAP32[$7_1 + 212 >> 2];
        $0_1 = $6_1 + HEAP32[$7_1 + 244 >> 2] | 0;
        $8_1 = $3_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $8_1 + $5_1 | 0;
        $5_1 = $3_1;
        $4_1 = $3_1 + $4_1 | 0;
        $3_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $8_1;
        $8_1 = $4_1;
        $14_1 = ($3_1 | 0) == ($0_1 | 0) & $4_1 >>> 0 < $5_1 >>> 0 | $0_1 >>> 0 > $3_1 >>> 0;
        $4_1 = ($0_1 | 0) == ($6_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 < $6_1 >>> 0;
        $0_1 = $12_1 + 8 | 0;
        $6_1 = HEAP32[$0_1 >> 2];
        $10_1 = $19_1 + 8 | 0;
        $5_1 = $6_1 + HEAP32[$10_1 >> 2] | 0;
        $0_1 = HEAP32[$10_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
        $0_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $6_1 = $5_1;
        $5_1 = $4_1 + $5_1 | 0;
        $0_1 = ($2_1 >> 31) + ($6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
        $2_1 = $2_1 >> 30;
        $4_1 = $2_1;
        $2_1 = $2_1 + $5_1 | 0;
        $0_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $5_1 = $2_1 + $14_1 | 0;
        $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $2_1 << 2 | $5_1 >>> 30;
        $14_1 = $3_1;
        $10_1 = $5_1 << 2 | $3_1 >>> 30;
        $13_1 = HEAP32[$7_1 + 144 >> 2];
        $5_1 = HEAP32[$7_1 + 176 >> 2];
        $3_1 = $13_1 + $5_1 | 0;
        $6_1 = HEAP32[$7_1 + 148 >> 2];
        $0_1 = $6_1 + HEAP32[$7_1 + 180 >> 2] | 0;
        $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $5_1 + $4_1 | 0;
        $4_1 = $3_1;
        $24_1 = $3_1 + $10_1 | 0;
        $3_1 = $3_1 >>> 0 > $24_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $10_1 = ($5_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 > $24_1 >>> 0 | $3_1 >>> 0 < $5_1 >>> 0;
        $4_1 = ($5_1 | 0) == ($6_1 | 0) & $4_1 >>> 0 < $13_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
        $0_1 = $22_1 + 8 | 0;
        $6_1 = HEAP32[$0_1 >> 2];
        $15_1 = $35_1 + 8 | 0;
        $5_1 = $6_1 + HEAP32[$15_1 >> 2] | 0;
        $0_1 = HEAP32[$15_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
        $0_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $6_1 = $5_1;
        $5_1 = $4_1 + $5_1 | 0;
        $0_1 = ($2_1 >> 31) + ($6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
        $2_1 = $2_1 >> 30;
        $4_1 = $2_1;
        $2_1 = $2_1 + $5_1 | 0;
        $0_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $5_1 = $2_1 + $10_1 | 0;
        $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $2_1 << 2 | $5_1 >>> 30;
        $10_1 = $3_1;
        $15_1 = $5_1 << 2 | $3_1 >>> 30;
        $16_1 = HEAP32[$7_1 + 80 >> 2];
        $5_1 = HEAP32[$7_1 + 112 >> 2];
        $3_1 = $16_1 + $5_1 | 0;
        $6_1 = HEAP32[$7_1 + 84 >> 2];
        $0_1 = $6_1 + HEAP32[$7_1 + 116 >> 2] | 0;
        $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $5_1 + $4_1 | 0;
        $4_1 = $3_1;
        $27_1 = $3_1 + $15_1 | 0;
        $3_1 = $3_1 >>> 0 > $27_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $15_1 = ($5_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 > $27_1 >>> 0 | $3_1 >>> 0 < $5_1 >>> 0;
        $4_1 = ($5_1 | 0) == ($6_1 | 0) & $4_1 >>> 0 < $16_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
        $0_1 = $26_1 + 8 | 0;
        $6_1 = HEAP32[$0_1 >> 2];
        $13_1 = $29_1 + 8 | 0;
        $5_1 = $6_1 + HEAP32[$13_1 >> 2] | 0;
        $0_1 = HEAP32[$13_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
        $0_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $6_1 = $5_1;
        $5_1 = $4_1 + $5_1 | 0;
        $0_1 = ($2_1 >> 31) + ($6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
        $2_1 = $2_1 >> 30;
        $4_1 = $2_1;
        $2_1 = $2_1 + $5_1 | 0;
        $0_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $5_1 = $2_1 + $15_1 | 0;
        $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $2_1 << 2 | $5_1 >>> 30;
        $15_1 = $3_1;
        $13_1 = $5_1 << 2 | $3_1 >>> 30;
        $9_1 = HEAP32[$7_1 + 16 >> 2];
        $5_1 = HEAP32[$7_1 + 48 >> 2];
        $3_1 = $9_1 + $5_1 | 0;
        $6_1 = HEAP32[$7_1 + 20 >> 2];
        $0_1 = $6_1 + HEAP32[$7_1 + 52 >> 2] | 0;
        $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $5_1 + $4_1 | 0;
        $4_1 = $3_1;
        $30_1 = $3_1 + $13_1 | 0;
        $3_1 = $3_1 >>> 0 > $30_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $13_1 = ($5_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 > $30_1 >>> 0 | $3_1 >>> 0 < $5_1 >>> 0;
        $4_1 = ($5_1 | 0) == ($6_1 | 0) & $4_1 >>> 0 < $9_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
        $0_1 = $20_1 + 8 | 0;
        $6_1 = HEAP32[$0_1 >> 2];
        $16_1 = $39_1 + 8 | 0;
        $5_1 = $6_1 + HEAP32[$16_1 >> 2] | 0;
        $0_1 = HEAP32[$16_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
        $0_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $6_1 = $5_1;
        $5_1 = $4_1 + $5_1 | 0;
        $0_1 = ($2_1 >> 31) + ($6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
        $2_1 = $2_1 >> 30;
        $4_1 = $2_1;
        $2_1 = $2_1 + $5_1 | 0;
        $0_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $2_1;
        $2_1 = $2_1 + $13_1 | 0;
        $5_1 = ($4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) << 2 | $2_1 >>> 30;
        $13_1 = $3_1;
        $42_1 = $2_1 << 2 | $3_1 >>> 30;
        $23_1 = $5_1;
        $4_1 = HEAP32[$7_1 + 256 >> 2];
        $2_1 = HEAP32[$7_1 + 288 >> 2];
        $3_1 = $4_1 + $2_1 | 0;
        $5_1 = HEAP32[$7_1 + 260 >> 2];
        $0_1 = $5_1 + HEAP32[$7_1 + 292 >> 2] | 0;
        $0_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $2_1 = $3_1;
        $3_1 = $0_1;
        $5_1 = ($5_1 | 0) == ($0_1 | 0) & $2_1 >>> 0 < $4_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
        $0_1 = $28_1 + 8 | 0;
        $4_1 = HEAP32[$0_1 >> 2];
        $6_1 = $11_1 + 8 | 0;
        $2_1 = $4_1 + HEAP32[$6_1 >> 2] | 0;
        $0_1 = HEAP32[$6_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
        $0_1 = $2_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $5_1 = $2_1 + $5_1 | 0;
        $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $2_1 << 2 | $5_1 >>> 30;
        $6_1 = $5_1 << 2 | $3_1 >>> 30;
        $11_1 = HEAP32[$7_1 + 192 >> 2];
        $5_1 = HEAP32[$7_1 + 224 >> 2];
        $3_1 = $11_1 + $5_1 | 0;
        $16_1 = HEAP32[$7_1 + 196 >> 2];
        $0_1 = $16_1 + HEAP32[$7_1 + 228 >> 2] | 0;
        $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $5_1 + $4_1 | 0;
        $4_1 = $3_1;
        $6_1 = $3_1 + $6_1 | 0;
        $3_1 = $3_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $5_1;
        $5_1 = $6_1;
        $9_1 = ($3_1 | 0) == ($0_1 | 0) & $4_1 >>> 0 > $5_1 >>> 0 | $0_1 >>> 0 > $3_1 >>> 0;
        $6_1 = ($0_1 | 0) == ($16_1 | 0) & $4_1 >>> 0 < $11_1 >>> 0 | $0_1 >>> 0 < $16_1 >>> 0;
        $0_1 = $18_1 + 8 | 0;
        $16_1 = HEAP32[$0_1 >> 2];
        $11_1 = $17_1 + 8 | 0;
        $4_1 = $16_1 + HEAP32[$11_1 >> 2] | 0;
        $0_1 = HEAP32[$11_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
        $0_1 = $4_1 >>> 0 < $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $19_1 = $4_1;
        $4_1 = $4_1 + $6_1 | 0;
        $0_1 = ($2_1 >> 31) + ($19_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
        $2_1 = $2_1 >> 30;
        $6_1 = $2_1;
        $2_1 = $2_1 + $4_1 | 0;
        $0_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $2_1 + $9_1 | 0;
        $2_1 = $4_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $6_1 = $2_1 << 2 | $4_1 >>> 30;
        $16_1 = $3_1;
        $11_1 = $4_1 << 2 | $3_1 >>> 30;
        $20_1 = HEAP32[$7_1 + 128 >> 2];
        $4_1 = HEAP32[$7_1 + 160 >> 2];
        $3_1 = $20_1 + $4_1 | 0;
        $9_1 = HEAP32[$7_1 + 132 >> 2];
        $0_1 = $9_1 + HEAP32[$7_1 + 164 >> 2] | 0;
        $4_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $4_1 + $6_1 | 0;
        $6_1 = $3_1;
        $22_1 = $3_1 + $11_1 | 0;
        $3_1 = $3_1 >>> 0 > $22_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $11_1 = ($4_1 | 0) == ($3_1 | 0) & $6_1 >>> 0 > $22_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
        $6_1 = ($4_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 < $20_1 >>> 0 | $4_1 >>> 0 < $9_1 >>> 0;
        $0_1 = $33_1 + 8 | 0;
        $9_1 = HEAP32[$0_1 >> 2];
        $12_1 = $32_1 + 8 | 0;
        $4_1 = $9_1 + HEAP32[$12_1 >> 2] | 0;
        $0_1 = HEAP32[$12_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
        $0_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $9_1 = $4_1;
        $4_1 = $4_1 + $6_1 | 0;
        $0_1 = ($2_1 >> 31) + ($9_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
        $2_1 = $2_1 >> 30;
        $6_1 = $2_1;
        $2_1 = $2_1 + $4_1 | 0;
        $0_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $2_1 + $11_1 | 0;
        $2_1 = $4_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $6_1 = $2_1 << 2 | $4_1 >>> 30;
        $9_1 = $3_1;
        $12_1 = $4_1 << 2 | $3_1 >>> 30;
        $19_1 = HEAP32[$7_1 + 64 >> 2];
        $4_1 = HEAP32[$7_1 + 96 >> 2];
        $3_1 = $19_1 + $4_1 | 0;
        $11_1 = HEAP32[$7_1 + 68 >> 2];
        $0_1 = $11_1 + HEAP32[$7_1 + 100 >> 2] | 0;
        $4_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $4_1 + $6_1 | 0;
        $6_1 = $3_1;
        $26_1 = $3_1 + $12_1 | 0;
        $3_1 = $3_1 >>> 0 > $26_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $12_1 = ($4_1 | 0) == ($3_1 | 0) & $6_1 >>> 0 > $26_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
        $6_1 = ($4_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 < $19_1 >>> 0 | $4_1 >>> 0 < $11_1 >>> 0;
        $0_1 = $37_1 + 8 | 0;
        $11_1 = HEAP32[$0_1 >> 2];
        $20_1 = $31_1 + 8 | 0;
        $4_1 = $11_1 + HEAP32[$20_1 >> 2] | 0;
        $0_1 = HEAP32[$20_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
        $0_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $19_1 = $4_1;
        $4_1 = $4_1 + $6_1 | 0;
        $0_1 = ($2_1 >> 31) + ($19_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
        $2_1 = $2_1 >> 30;
        $6_1 = $2_1;
        $2_1 = $2_1 + $4_1 | 0;
        $0_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $2_1 + $12_1 | 0;
        $2_1 = $4_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $6_1 = $2_1 << 2 | $4_1 >>> 30;
        $11_1 = $3_1;
        $20_1 = $4_1 << 2 | $3_1 >>> 30;
        $18_1 = HEAP32[$7_1 >> 2];
        $4_1 = HEAP32[$7_1 + 32 >> 2];
        $3_1 = $18_1 + $4_1 | 0;
        $12_1 = HEAP32[$7_1 + 4 >> 2];
        $0_1 = $12_1 + HEAP32[$7_1 + 36 >> 2] | 0;
        $4_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $4_1 + $6_1 | 0;
        $6_1 = $3_1;
        $20_1 = $3_1 + $20_1 | 0;
        $3_1 = $3_1 >>> 0 > $20_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $19_1 = ($4_1 | 0) == ($3_1 | 0) & $6_1 >>> 0 > $20_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
        $6_1 = ($4_1 | 0) == ($12_1 | 0) & $6_1 >>> 0 < $18_1 >>> 0 | $4_1 >>> 0 < $12_1 >>> 0;
        $0_1 = $36_1 + 8 | 0;
        $12_1 = HEAP32[$0_1 >> 2];
        $18_1 = $7_1 + 8 | 0;
        $4_1 = $12_1 + HEAP32[$18_1 >> 2] | 0;
        $0_1 = HEAP32[$18_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
        $0_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $12_1 = $4_1;
        $4_1 = $4_1 + $6_1 | 0;
        $0_1 = ($2_1 >> 31) + ($12_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
        $2_1 = $2_1 >> 30;
        $6_1 = $2_1;
        $2_1 = $2_1 + $4_1 | 0;
        $0_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $2_1;
        $2_1 = $2_1 + $19_1 | 0;
        $4_1 = ($4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) << 2 | $2_1 >>> 30;
        $41_1 = $2_1 << 2 | $3_1 >>> 30;
        $43_1 = $4_1;
        $39_1 = $3_1 & 1073741823;
        $31_1 = $13_1 & 1073741823;
        $29_1 = $11_1 & 1073741823;
        $32_1 = $15_1 & 1073741823;
        $35_1 = $9_1 & 1073741823;
        $33_1 = $10_1 & 1073741823;
        $3_1 = $5_1;
        $9_1 = $16_1 & 1073741823;
        $2_1 = $8_1;
        $11_1 = $14_1 & 1073741823;
        $45_1 = $45_1 + 1 | 0;
        if (($45_1 | 0) != 10) {
          continue;
        }
        break;
      }
      ;
      $0_1 = $23_1 >> 31;
      $3_1 = $0_1;
      $14_1 = $7_1 + 392 | 0;
      $8_1 = $14_1 + 32 | 0;
      $15_1 = HEAP32[$8_1 >> 2];
      $0_1 = HEAP32[$8_1 + 4 >> 2];
      $9_1 = $0_1;
      $0_1 = $0_1 >> 31;
      $2_1 = $0_1;
      $4_1 = HEAP32[$1_1 >> 2];
      $13_1 = $0_1 & $4_1;
      $5_1 = $13_1 + HEAP32[$7_1 + 392 >> 2] | 0;
      $6_1 = HEAP32[$1_1 + 4 >> 2];
      $0_1 = HEAP32[$7_1 + 396 >> 2] + ($6_1 & $0_1) | 0;
      $0_1 = $5_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $5_1 = $3_1 ^ $5_1;
      $20_1 = $5_1 - $3_1 | 0;
      $5_1 = ($0_1 ^ $3_1) - (($3_1 >>> 0 > $5_1 >>> 0) + $3_1 | 0) | 0;
      $13_1 = $4_1;
      $16_1 = $6_1;
      $0_1 = HEAP32[$1_1 + 32 >> 2];
      $26_1 = $0_1;
      $6_1 = $0_1 & $2_1;
      $4_1 = $6_1 + $15_1 | 0;
      $22_1 = HEAP32[$1_1 + 36 >> 2];
      $0_1 = $9_1 + ($22_1 & $2_1) | 0;
      $0_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $4_1 = $3_1 ^ $4_1;
      $15_1 = $4_1 - $3_1 | 0;
      $12_1 = ($0_1 ^ $3_1) - (($3_1 >>> 0 > $4_1 >>> 0) + $3_1 | 0) | 0;
      $0_1 = HEAP32[$1_1 + 24 >> 2];
      $30_1 = $0_1;
      $10_1 = $0_1 & $2_1;
      $4_1 = $14_1 + 24 | 0;
      $6_1 = $10_1 + HEAP32[$4_1 >> 2] | 0;
      $27_1 = HEAP32[$1_1 + 28 >> 2];
      $0_1 = HEAP32[$4_1 + 4 >> 2] + ($27_1 & $2_1) | 0;
      $0_1 = $6_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $6_1 = $3_1 ^ $6_1;
      $11_1 = $6_1 - $3_1 | 0;
      $24_1 = ($0_1 ^ $3_1) - (($3_1 >>> 0 > $6_1 >>> 0) + $3_1 | 0) | 0;
      $0_1 = HEAP32[$1_1 + 16 >> 2];
      $19_1 = $0_1;
      $9_1 = $0_1 & $2_1;
      $6_1 = $14_1 + 16 | 0;
      $10_1 = $9_1 + HEAP32[$6_1 >> 2] | 0;
      $21_1 = HEAP32[$1_1 + 20 >> 2];
      $0_1 = HEAP32[$6_1 + 4 >> 2] + ($21_1 & $2_1) | 0;
      $0_1 = $9_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $10_1 = $3_1 ^ $10_1;
      $23_1 = $10_1 - $3_1 | 0;
      $10_1 = ($0_1 ^ $3_1) - (($3_1 >>> 0 > $10_1 >>> 0) + $3_1 | 0) | 0;
      $18_1 = HEAP32[$1_1 + 8 >> 2];
      $9_1 = $18_1 & $2_1;
      $0_1 = $14_1 + 8 | 0;
      $14_1 = $9_1 + HEAP32[$0_1 >> 2] | 0;
      $17_1 = HEAP32[$1_1 + 12 >> 2];
      $0_1 = HEAP32[$0_1 + 4 >> 2] + ($17_1 & $2_1) | 0;
      $1_1 = $3_1 ^ $14_1;
      $2_1 = $1_1 - $3_1 | 0;
      $0_1 = (($3_1 ^ ($9_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1)) - (($1_1 >>> 0 < $3_1 >>> 0) + $3_1 | 0) | 0) + ($5_1 >> 31) | 0;
      $1_1 = $5_1 >> 30;
      $2_1 = $1_1 + $2_1 | 0;
      $9_1 = $1_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = ($9_1 >> 31) + $10_1 | 0;
      $1_1 = $9_1 >> 30;
      $14_1 = $1_1 + $23_1 | 0;
      $23_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = ($23_1 >> 31) + $24_1 | 0;
      $1_1 = $23_1 >> 30;
      $10_1 = $1_1 + $11_1 | 0;
      $11_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = ($11_1 >> 31) + $12_1 | 0;
      $1_1 = $11_1 >> 30;
      $15_1 = $1_1 + $15_1 | 0;
      $12_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $1_1 = $12_1 >> 31;
      $0_1 = ($1_1 & $16_1) + ($5_1 & 1073741823) | 0;
      $3_1 = $1_1;
      $1_1 = ($3_1 & $13_1) + $20_1 | 0;
      $0_1 = $1_1 >>> 0 < $20_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      HEAP32[$34_1 >> 2] = $1_1;
      $1_1 = $0_1;
      HEAP32[$34_1 + 4 >> 2] = $0_1 & 1073741823;
      $13_1 = $34_1 + 8 | 0;
      $0_1 = ($3_1 & $17_1) + ($9_1 & 1073741823) | 0;
      $5_1 = $2_1;
      $2_1 = ($3_1 & $18_1) + $2_1 | 0;
      $0_1 = ($1_1 >> 31) + ($5_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
      $1_1 = $1_1 >> 30;
      $5_1 = $1_1;
      $1_1 = $1_1 + $2_1 | 0;
      $0_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      HEAP32[$13_1 >> 2] = $1_1;
      $1_1 = $0_1;
      HEAP32[$13_1 + 4 >> 2] = $0_1 & 1073741823;
      $0_1 = ($3_1 & $21_1) + ($23_1 & 1073741823) | 0;
      $2_1 = ($3_1 & $19_1) + $14_1 | 0;
      $0_1 = ($1_1 >> 31) + ($2_1 >>> 0 < $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
      $1_1 = $1_1 >> 30;
      $5_1 = $1_1;
      $1_1 = $1_1 + $2_1 | 0;
      $0_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $2_1 = $1_1;
      HEAP32[$6_1 >> 2] = $2_1;
      $1_1 = $0_1;
      $0_1 = $0_1 & 1073741823;
      HEAP32[$6_1 + 4 >> 2] = $0_1;
      $5_1 = $34_1 + 16 | 0;
      HEAP32[$5_1 >> 2] = $2_1;
      HEAP32[$5_1 + 4 >> 2] = $0_1;
      $0_1 = ($3_1 & $27_1) + ($11_1 & 1073741823) | 0;
      $2_1 = ($3_1 & $30_1) + $10_1 | 0;
      $0_1 = ($1_1 >> 31) + ($2_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
      $1_1 = $1_1 >> 30;
      $5_1 = $1_1;
      $1_1 = $1_1 + $2_1 | 0;
      $0_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $2_1 = $1_1;
      HEAP32[$4_1 >> 2] = $2_1;
      $1_1 = $0_1;
      $0_1 = $0_1 & 1073741823;
      HEAP32[$4_1 + 4 >> 2] = $0_1;
      $5_1 = $34_1 + 24 | 0;
      HEAP32[$5_1 >> 2] = $2_1;
      HEAP32[$5_1 + 4 >> 2] = $0_1;
      $0_1 = ($3_1 & $22_1) + $12_1 | 0;
      $3_1 = ($3_1 & $26_1) + $15_1 | 0;
      $0_1 = ($1_1 >> 31) + ($3_1 >>> 0 < $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
      $1_1 = $1_1 >> 30;
      $2_1 = $1_1;
      $1_1 = $1_1 + $3_1 | 0;
      $0_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      HEAP32[$8_1 >> 2] = $1_1;
      HEAP32[$8_1 + 4 >> 2] = $0_1;
      $3_1 = $34_1 + 32 | 0;
      HEAP32[$3_1 >> 2] = $1_1;
      HEAP32[$3_1 + 4 >> 2] = $0_1;
      global$0 = $7_1 + 432 | 0;
    }
    function $51($0_1, $1_1) {
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0;
      $4_1 = global$0 - 48 | 0;
      global$0 = $4_1;
      label$1: {
        if (!$1_1) {
          FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689571, HEAP32[$0_1 + 172 >> 2]);
          $0_1 = 0;
          break label$1;
        }
        $14_1 = $4_1 + 8 | 0;
        $38($14_1, $1_1, $4_1 + 44 | 0);
        $8_1 = HEAP32[$4_1 + 32 >> 2];
        $2_1 = HEAP32[$4_1 + 24 >> 2];
        $7_1 = HEAP32[$4_1 + 16 >> 2];
        $3_1 = HEAP32[$4_1 + 8 >> 2];
        $11_1 = HEAP32[$4_1 + 36 >> 2];
        $9_1 = HEAP32[$4_1 + 28 >> 2];
        $5_1 = HEAP32[$4_1 + 20 >> 2];
        $6_1 = HEAP32[$4_1 + 12 >> 2];
        $15_1 = HEAP32[$4_1 + 44 >> 2] | !($8_1 | ($2_1 | ($7_1 | $3_1)) | ($11_1 | ($9_1 | ($5_1 | $6_1))));
        $0_1 = $15_1 ? 0 : -1;
        $8_1 = $0_1 & $8_1;
        $12_1 = $0_1 & $2_1;
        $10_1 = $0_1 & $7_1;
        $3_1 = $0_1 & $3_1;
        $11_1 = $0_1 & $11_1;
        $16_1 = $0_1 & $9_1;
        $13_1 = $0_1 & $5_1;
        $2_1 = $0_1 & $6_1;
        $7_1 = $8_1 | ($12_1 | ($10_1 | $3_1)) | ($11_1 | ($16_1 | ($13_1 | $2_1))) ? -1 : 0;
        $3_1 = $3_1 ^ -1;
        $6_1 = $3_1 - 801750718 | 0;
        HEAP32[$4_1 + 8 >> 2] = $7_1 & $6_1;
        $2_1 = $2_1 ^ -1;
        $5_1 = $2_1 - (($3_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
        HEAP32[$4_1 + 12 >> 2] = $5_1 & $7_1;
        $0_1 = ($2_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 > $6_1 >>> 0 | $2_1 >>> 0 > $5_1 >>> 0;
        $5_1 = $10_1 ^ -1;
        $3_1 = $0_1 + $5_1 | 0;
        $6_1 = $13_1 ^ -1;
        $2_1 = $6_1;
        $13_1 = $3_1 - 1354194885 | 0;
        HEAP32[$4_1 + 16 >> 2] = $13_1 & $7_1;
        $2_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $9_1 = $2_1 - (($3_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
        HEAP32[$4_1 + 20 >> 2] = $9_1 & $7_1;
        $12_1 = $12_1 ^ -1;
        $0_1 = ($2_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 < $5_1 >>> 0 | $2_1 >>> 0 < $6_1 >>> 0;
        $5_1 = ($2_1 | 0) == ($9_1 | 0) & $3_1 >>> 0 > $13_1 >>> 0 | $2_1 >>> 0 > $9_1 >>> 0;
        $2_1 = $0_1 + $5_1 | 0;
        $10_1 = $16_1 ^ -1;
        $3_1 = $10_1 + ($2_1 >>> 0 < $5_1 >>> 0) | 0;
        $0_1 = $2_1;
        $2_1 = $2_1 + $12_1 | 0;
        $3_1 = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $6_1 = $2_1 - 2 | 0;
        HEAP32[$4_1 + 24 >> 2] = $6_1 & $7_1;
        $5_1 = $3_1 - ($2_1 >>> 0 < 2) | 0;
        HEAP32[$4_1 + 28 >> 2] = $5_1 & $7_1;
        $0_1 = ($3_1 | 0) == ($10_1 | 0) & $2_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 < $10_1 >>> 0;
        $2_1 = ($3_1 | 0) == ($5_1 | 0) & $2_1 >>> 0 > $6_1 >>> 0 | $3_1 >>> 0 > $5_1 >>> 0;
        $0_1 = $0_1 + $2_1 | 0;
        $3_1 = $0_1 >>> 0 < $2_1 >>> 0;
        $2_1 = $0_1 - $8_1 | 0;
        HEAP32[$4_1 + 32 >> 2] = $2_1 - 2 & $7_1;
        HEAP32[$4_1 + 36 >> 2] = ($3_1 - (($0_1 >>> 0 < $8_1 >>> 0) + $11_1 | 0) | 0) - ($2_1 >>> 0 < 2) & $7_1;
        $39($1_1, $14_1);
        $0_1 = !$15_1;
      }
      global$0 = $4_1 + 48 | 0;
      return $0_1;
    }
    function $52() {
      var $0_1 = 0, $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0;
      $4_1 = global$0 - 80 | 0;
      global$0 = $4_1;
      $24_1 = $4_1 + 8 | 0;
      $0_1 = $4_1 + 48 | 0;
      $38($24_1, 690788, $0_1);
      $29_1 = HEAP32[$4_1 + 48 >> 2];
      $20_1 = HEAP32[$4_1 + 32 >> 2];
      $25_1 = HEAP32[$4_1 + 36 >> 2];
      $21_1 = HEAP32[$4_1 + 24 >> 2];
      $26_1 = HEAP32[$4_1 + 28 >> 2];
      $22_1 = HEAP32[$4_1 + 8 >> 2];
      $27_1 = HEAP32[$4_1 + 12 >> 2];
      $23_1 = HEAP32[$4_1 + 16 >> 2];
      $28_1 = HEAP32[$4_1 + 20 >> 2];
      HEAP32[$4_1 + 44 >> 2] = 0;
      $38($0_1, 690949, $4_1 + 44 | 0);
      $3_1 = HEAP32[$4_1 + 52 >> 2];
      $0_1 = $3_1 + $27_1 | 0;
      $2_1 = HEAP32[$4_1 + 48 >> 2];
      $18_1 = $2_1 + $22_1 | 0;
      $15_1 = $18_1 >>> 0 < $22_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $5_1 = HEAP32[$4_1 + 60 >> 2];
      $0_1 = $5_1 + $28_1 | 0;
      $9_1 = $0_1 + 1 | 0;
      $10_1 = $0_1;
      $0_1 = HEAP32[$4_1 + 56 >> 2];
      $1_1 = $0_1 + $23_1 | 0;
      $6_1 = $1_1 >>> 0 < $23_1 >>> 0 ? $9_1 : $10_1;
      $5_1 = ($6_1 | 0) == ($5_1 | 0) & $0_1 >>> 0 > $1_1 >>> 0 | $6_1 >>> 0 < $5_1 >>> 0;
      $0_1 = ($3_1 | 0) == ($15_1 | 0) & $2_1 >>> 0 > $18_1 >>> 0 | $3_1 >>> 0 > $15_1 >>> 0;
      $17_1 = $0_1 + $1_1 | 0;
      $13_1 = $17_1 >>> 0 < $0_1 >>> 0 ? $6_1 + 1 | 0 : $6_1;
      $2_1 = ($13_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 > $17_1 >>> 0 | $6_1 >>> 0 > $13_1 >>> 0;
      $5_1 = $5_1 + $2_1 | 0;
      $1_1 = HEAP32[$4_1 + 68 >> 2];
      $0_1 = $1_1 + $26_1 | 0;
      $9_1 = $0_1 + 1 | 0;
      $10_1 = $0_1;
      $0_1 = HEAP32[$4_1 + 64 >> 2];
      $6_1 = $0_1 + $21_1 | 0;
      $7_1 = $6_1 >>> 0 < $21_1 >>> 0 ? $9_1 : $10_1;
      $2_1 = $7_1 + ($2_1 >>> 0 > $5_1 >>> 0) | 0;
      $16_1 = $6_1 + $5_1 | 0;
      $5_1 = $16_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $3_1 = ($5_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 > $16_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
      $8_1 = $3_1 + (($1_1 | 0) == ($7_1 | 0) & $0_1 >>> 0 > $6_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0) | 0;
      $0_1 = $5_1;
      $6_1 = ($0_1 | 0) == -1;
      $14_1 = HEAP32[$4_1 + 76 >> 2];
      $2_1 = $14_1 + $25_1 | 0;
      $1_1 = HEAP32[$4_1 + 72 >> 2];
      $12_1 = $1_1 + $20_1 | 0;
      $11_1 = $12_1 >>> 0 < $20_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $11_1 + ($3_1 >>> 0 > $8_1 >>> 0) | 0;
      $9_1 = $2_1 + 1 | 0;
      $10_1 = $2_1;
      $2_1 = $8_1 + $12_1 | 0;
      $19_1 = $2_1 >>> 0 < $8_1 >>> 0 ? $9_1 : $10_1;
      $3_1 = $6_1 & $16_1 >>> 0 < 4294967294 | ($0_1 | 0) != -1 | ($19_1 & $2_1) != -1;
      $7_1 = ($13_1 | 0) == -1162945306;
      $8_1 = ($3_1 | ($7_1 & $17_1 >>> 0 < 2940772411 | $13_1 >>> 0 < 3132021990)) ^ -1;
      $3_1 = ((($11_1 | 0) == ($14_1 | 0) & $1_1 >>> 0 > $12_1 >>> 0 | $11_1 >>> 0 < $14_1 >>> 0) + (($11_1 | 0) == ($19_1 | 0) & $2_1 >>> 0 < $12_1 >>> 0 | $11_1 >>> 0 > $19_1 >>> 0) | 0) + ($8_1 & (($15_1 | 0) == -1076732276 & $18_1 >>> 0 > 3493216576 | $15_1 >>> 0 > 3218235020) | ($8_1 & ($7_1 & $17_1 >>> 0 > 2940772411 | $13_1 >>> 0 > 3132021990) | ($16_1 | 0) == -1 & $6_1 & ($3_1 ^ -1))) | 0;
      $12_1 = $3_1 + $16_1 | 0;
      if ($12_1 >>> 0 < $16_1 >>> 0) {
        $0_1 = $0_1 + 1 | 0;
      }
      $7_1 = __wasm_i64_mul($3_1, 0, 1354194884, 1162945305);
      $6_1 = $13_1 + i64toi32_i32$HIGH_BITS | 0;
      $1_1 = __wasm_i64_mul($3_1, 0, 801750719, 1076732275);
      $9_1 = $1_1 + $18_1 | 0;
      $14_1 = $7_1 + $17_1 | 0;
      $3_1 = $15_1 + i64toi32_i32$HIGH_BITS | 0;
      $8_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = ($8_1 | 0) == ($15_1 | 0) & $18_1 >>> 0 > $9_1 >>> 0 | $8_1 >>> 0 < $15_1 >>> 0;
      $11_1 = $14_1 + $3_1 | 0;
      $1_1 = $7_1 >>> 0 > $14_1 >>> 0 ? $6_1 + 1 | 0 : $6_1;
      $7_1 = $3_1 >>> 0 > $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
      $3_1 = ($1_1 | 0) == ($7_1 | 0) & $11_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
      $1_1 = $3_1 + (($1_1 | 0) == ($13_1 | 0) & $14_1 >>> 0 < $17_1 >>> 0 | $1_1 >>> 0 < $13_1 >>> 0) | 0;
      $10_1 = ($0_1 | 0) == ($5_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
      $3_1 = ($1_1 >>> 0 < $3_1 >>> 0) + $0_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $12_1 | 0;
      $6_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $0_1 = ($6_1 | 0) == ($0_1 | 0) & $1_1 >>> 0 < $12_1 >>> 0 | $0_1 >>> 0 > $6_1 >>> 0;
      $5_1 = $10_1 + $0_1 | 0;
      $0_1 = $19_1 + ($0_1 >>> 0 > $5_1 >>> 0) | 0;
      $5_1 = $2_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $4_1;
      if ($5_1 | ($11_1 | $9_1 | $1_1) | ($3_1 | ($7_1 | $8_1 | $6_1))) {
        $10_1 = HEAP32[$0_1 + 44 >> 2] | ($29_1 | !($20_1 | ($21_1 | ($22_1 | $23_1)) | ($25_1 | ($26_1 | ($27_1 | $28_1)))));
      } else {
        $10_1 = 1;
      }
      $4_1 = !$10_1;
      $2_1 = 0 - $4_1 | 0;
      HEAP32[$0_1 + 32 >> 2] = $5_1 & $2_1;
      HEAP32[$0_1 + 36 >> 2] = $2_1 & $3_1;
      HEAP32[$0_1 + 24 >> 2] = $1_1 & $2_1;
      HEAP32[$0_1 + 28 >> 2] = $2_1 & $6_1;
      HEAP32[$0_1 + 16 >> 2] = $2_1 & $11_1;
      HEAP32[$0_1 + 20 >> 2] = $2_1 & $7_1;
      HEAP32[$0_1 + 8 >> 2] = $2_1 & $9_1;
      HEAP32[$0_1 + 12 >> 2] = $2_1 & $8_1;
      $39(690788, $24_1);
      global$0 = $0_1 + 80 | 0;
      return $4_1;
    }
    function $53($0_1, $1_1, $2_1) {
      var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0, $51_1 = 0, $52_1 = 0, $53_1 = 0, $54_1 = 0, $55_1 = 0, $56_1 = 0, $57_1 = 0, $58_1 = 0, $59_1 = 0, $60_1 = 0, $61_1 = 0, $62_1 = 0, $63_1 = 0, $64_1 = 0, $65_1 = 0, $66_1 = 0, $67_1 = 0, $68_1 = 0, $69_1 = 0, $70_1 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0;
      $5_1 = global$0 - 1744 | 0;
      global$0 = $5_1;
      $15_1 = $5_1 + 1704 | 0;
      $69_1 = $1_1 + 80 | 0;
      $54($15_1, $69_1);
      $35_1 = $5_1 + 1664 | 0;
      $20_1 = $35_1 + 8 | 0;
      $6_1 = $20_1;
      $3_1 = $1_1 + 8 | 0;
      $27_1 = HEAP32[$3_1 >> 2];
      $19_1 = HEAP32[$3_1 + 4 >> 2];
      $7_1 = HEAP32[$1_1 + 4 >> 2];
      $3_1 = $1_1 + 32 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $9_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = $9_1;
      $4_1 = HEAP32[$1_1 >> 2];
      $9_1 = __wasm_i64_mul($8_1 >>> 16 | 0, 0, 977, 1);
      $4_1 = $4_1 + $9_1 | 0;
      $3_1 = $7_1 + i64toi32_i32$HIGH_BITS | 0;
      $7_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $19_1;
      $9_1 = $7_1 >>> 20 | 0;
      $24_1 = $9_1 + $27_1 | 0;
      $3_1 = $9_1 >>> 0 > $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 >> 2] = $24_1;
      $71 = $3_1 & 1048575;
      HEAP32[$6_1 + 4 >> 2] = $71;
      $27_1 = $35_1 + 16 | 0;
      $9_1 = $27_1;
      $6_1 = $1_1 + 16 | 0;
      $19_1 = HEAP32[$6_1 >> 2];
      $13_1 = HEAP32[$6_1 + 4 >> 2];
      $6_1 = $3_1;
      $3_1 = $13_1;
      $6_1 = $6_1 >>> 20 | 0;
      $25_1 = $6_1 + $19_1 | 0;
      $3_1 = $6_1 >>> 0 > $25_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$9_1 >> 2] = $25_1;
      $72 = $3_1 & 1048575;
      HEAP32[$9_1 + 4 >> 2] = $72;
      $19_1 = $35_1 + 24 | 0;
      $9_1 = $19_1;
      $6_1 = $1_1 + 24 | 0;
      $13_1 = HEAP32[$6_1 >> 2];
      $47_1 = HEAP32[$6_1 + 4 >> 2];
      $6_1 = $3_1;
      $3_1 = $47_1;
      $6_1 = $6_1 >>> 20 | 0;
      $28_1 = $6_1 + $13_1 | 0;
      $3_1 = $6_1 >>> 0 > $28_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$9_1 >> 2] = $28_1;
      $73 = $3_1 & 1048575;
      HEAP32[$9_1 + 4 >> 2] = $73;
      $13_1 = $35_1 + 32 | 0;
      $9_1 = $13_1;
      $6_1 = $3_1;
      $3_1 = $8_1 & 65535;
      $6_1 = $6_1 >>> 20 | 0;
      $45_1 = $6_1 + $11_1 | 0;
      $3_1 = $6_1 >>> 0 > $45_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$9_1 >> 2] = $45_1;
      $57_1 = $3_1;
      HEAP32[$9_1 + 4 >> 2] = $3_1;
      $54_1 = $4_1;
      HEAP32[$5_1 + 1664 >> 2] = $4_1;
      $74 = $7_1 & 1048575;
      HEAP32[$5_1 + 1668 >> 2] = $74;
      $34($5_1 + 1624 | 0, $2_1, $15_1);
      $3_1 = $1_1 - -64 | 0;
      $22_1 = HEAP32[$3_1 >> 2];
      $16_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $1_1 + 56 | 0;
      $21_1 = HEAP32[$3_1 >> 2];
      $33_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $1_1 + 48 | 0;
      $38_1 = HEAP32[$3_1 >> 2];
      $42_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $1_1 + 72 | 0;
      $44_1 = HEAP32[$3_1 >> 2];
      $47_1 = HEAP32[$3_1 + 4 >> 2];
      $36_1 = HEAP32[$1_1 + 40 >> 2];
      $26_1 = HEAP32[$1_1 + 44 >> 2];
      $3_1 = $5_1 + 1584 | 0;
      $34($3_1, $2_1 + 40 | 0, $15_1);
      $34($3_1, $3_1, $69_1);
      $34_1 = HEAP32[$5_1 + 1636 >> 2];
      $3_1 = $34_1 + HEAP32[$20_1 + 4 >> 2] | 0;
      $63_1 = $5_1 + 1544 | 0;
      $65_1 = $63_1 + 8 | 0;
      $4_1 = $65_1;
      $58_1 = HEAP32[$5_1 + 1632 >> 2];
      $11_1 = HEAP32[$20_1 >> 2];
      $9_1 = $58_1 + $11_1 | 0;
      HEAP32[$4_1 >> 2] = $9_1;
      $15_1 = $9_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$4_1 + 4 >> 2] = $15_1;
      $31_1 = HEAP32[$5_1 + 1644 >> 2];
      $3_1 = $31_1 + HEAP32[$27_1 + 4 >> 2] | 0;
      $66_1 = $63_1 + 16 | 0;
      $7_1 = $66_1;
      $59_1 = HEAP32[$5_1 + 1640 >> 2];
      $4_1 = HEAP32[$27_1 >> 2];
      $11_1 = $59_1 + $4_1 | 0;
      HEAP32[$7_1 >> 2] = $11_1;
      $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$7_1 + 4 >> 2] = $4_1;
      $32_1 = HEAP32[$5_1 + 1652 >> 2];
      $3_1 = $32_1 + HEAP32[$19_1 + 4 >> 2] | 0;
      $67_1 = $63_1 + 24 | 0;
      $20_1 = $67_1;
      $39_1 = HEAP32[$5_1 + 1648 >> 2];
      $7_1 = HEAP32[$19_1 >> 2];
      $6_1 = $39_1 + $7_1 | 0;
      HEAP32[$20_1 >> 2] = $6_1;
      $7_1 = $6_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$20_1 + 4 >> 2] = $7_1;
      $48_1 = HEAP32[$5_1 + 1660 >> 2];
      $3_1 = $48_1 + HEAP32[$13_1 + 4 >> 2] | 0;
      $61_1 = $63_1 + 32 | 0;
      $27_1 = $61_1;
      $37_1 = HEAP32[$5_1 + 1656 >> 2];
      $19_1 = HEAP32[$13_1 >> 2];
      $20_1 = $37_1 + $19_1 | 0;
      HEAP32[$27_1 >> 2] = $20_1;
      $13_1 = $19_1 >>> 0 > $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$27_1 + 4 >> 2] = $13_1;
      $51_1 = HEAP32[$5_1 + 1628 >> 2];
      $3_1 = $51_1 + HEAP32[$5_1 + 1668 >> 2] | 0;
      $30_1 = HEAP32[$5_1 + 1624 >> 2];
      $19_1 = HEAP32[$5_1 + 1664 >> 2];
      $27_1 = $30_1 + $19_1 | 0;
      HEAP32[$5_1 + 1544 >> 2] = $27_1;
      $19_1 = $19_1 >>> 0 > $27_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$5_1 + 1548 >> 2] = $19_1;
      $56_1 = $5_1 + 1232 | 0;
      $12_1 = $27_1 << 1;
      $10_1 = $19_1 << 1 | $27_1 >>> 31;
      $69($56_1, $6_1, $7_1, 0, 0, $12_1, $10_1, 0, 0);
      $40_1 = $5_1 + 1312 | 0;
      $23_1 = $9_1 << 1;
      $17_1 = $15_1;
      $14_1 = $9_1;
      $15_1 = $15_1 << 1 | $9_1 >>> 31;
      $69($40_1, $11_1, $4_1, 0, 0, $23_1, $15_1, 0, 0);
      $18_1 = $5_1 + 1168 | 0;
      $3_1 = $13_1;
      $69($18_1, $20_1, $3_1, 0, 0, $20_1, $3_1, 0, 0);
      $52_1 = $5_1 + 1152 | 0;
      $69($52_1, HEAP32[$5_1 + 1168 >> 2], HEAP32[$5_1 + 1172 >> 2], 0, 0, 15632, 16, 0, 0);
      $43_1 = $5_1 + 1120 | 0;
      $9_1 = $20_1 << 1;
      $13_1 = $3_1 << 1 | $20_1 >>> 31;
      $69($43_1, $9_1, $13_1, 0, 0, $27_1, $19_1, 0, 0);
      $46_1 = $5_1 + 1216 | 0;
      $69($46_1, $6_1, $7_1, 0, 0, $23_1, $15_1, 0, 0);
      $53_1 = $5_1 + 1328 | 0;
      $69($53_1, $11_1, $4_1, 0, 0, $11_1, $4_1, 0, 0);
      $49_1 = $5_1 + 1136 | 0;
      $3_1 = $18_1 + 8 | 0;
      $69($49_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $60_1 = $5_1 + 1248 | 0;
      $69($60_1, $27_1, $19_1, 0, 0, $27_1, $19_1, 0, 0);
      $50_1 = $5_1 + 1104 | 0;
      $69($50_1, $9_1, $13_1, 0, 0, $14_1, $17_1, 0, 0);
      $41_1 = $4_1;
      $27_1 = $11_1;
      $3_1 = $4_1 << 1 | $11_1 >>> 31;
      $55_1 = $5_1 + 1200 | 0;
      $23_1 = $6_1;
      $18_1 = $7_1;
      $69($55_1, $6_1, $7_1, 0, 0, $11_1 << 1, $3_1, 0, 0);
      $15_1 = HEAP32[$5_1 + 1232 >> 2];
      $4_1 = HEAP32[$5_1 + 1312 >> 2];
      $11_1 = $15_1 + $4_1 | 0;
      $6_1 = HEAP32[$5_1 + 1236 >> 2];
      $3_1 = $6_1 + HEAP32[$5_1 + 1316 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + HEAP32[$5_1 + 1156 >> 2] | 0;
      $7_1 = $11_1;
      $20_1 = HEAP32[$5_1 + 1152 >> 2];
      $11_1 = $7_1 + $20_1 | 0;
      $29_1 = $11_1;
      $11_1 = $11_1 >>> 0 < $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 > $29_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
      $3_1 = $52_1 + 8 | 0;
      $19_1 = HEAP32[$3_1 >> 2];
      $8_1 = HEAP32[$3_1 + 4 >> 2];
      $6_1 = ($4_1 | 0) == ($6_1 | 0) & $7_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $6_1 >>> 0;
      $3_1 = $40_1 + 8 | 0;
      $15_1 = HEAP32[$3_1 >> 2];
      $4_1 = $56_1 + 8 | 0;
      $7_1 = $15_1 + HEAP32[$4_1 >> 2] | 0;
      $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $6_1 + $7_1 | 0;
      $3_1 = ($4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $8_1 | 0;
      $6_1 = $4_1;
      $4_1 = $4_1 + $19_1 | 0;
      $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $4_1;
      $4_1 = $4_1 + $20_1 | 0;
      $7_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $7_1 << 12 | $4_1 >>> 20;
      $40_1 = $11_1;
      $11_1 = $4_1 << 12 | $11_1 >>> 20;
      $56_1 = $6_1;
      $62_1 = HEAP32[$5_1 + 1216 >> 2];
      $6_1 = HEAP32[$5_1 + 1328 >> 2];
      $4_1 = $62_1 + $6_1 | 0;
      $52_1 = HEAP32[$5_1 + 1220 >> 2];
      $3_1 = $52_1 + HEAP32[$5_1 + 1332 >> 2] | 0;
      $6_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = $4_1;
      $15_1 = HEAP32[$5_1 + 1120 >> 2];
      $3_1 = $4_1 + $15_1 | 0;
      $4_1 = $6_1 + HEAP32[$5_1 + 1124 >> 2] | 0;
      $15_1 = $3_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $19_1 = $3_1;
      $8_1 = HEAP32[$5_1 + 1136 >> 2];
      $4_1 = $3_1 + $8_1 | 0;
      $3_1 = $15_1 + HEAP32[$5_1 + 1140 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $4_1 = $3_1;
      $3_1 = $3_1 + $56_1 | 0;
      $68_1 = $5_1 + 1088 | 0;
      $56_1 = $8_1 + $11_1 | 0;
      $11_1 = $56_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $64_1 = ($4_1 | 0) == ($11_1 | 0) & $8_1 >>> 0 > $56_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
      $8_1 = ($4_1 | 0) == ($15_1 | 0) & $8_1 >>> 0 < $19_1 >>> 0 | $4_1 >>> 0 < $15_1 >>> 0;
      $3_1 = $49_1 + 8 | 0;
      $49_1 = HEAP32[$3_1 >> 2];
      $70_1 = HEAP32[$3_1 + 4 >> 2];
      $15_1 = ($6_1 | 0) == ($15_1 | 0) & $19_1 >>> 0 < $20_1 >>> 0 | $6_1 >>> 0 > $15_1 >>> 0;
      $3_1 = $43_1 + 8 | 0;
      $19_1 = HEAP32[$3_1 >> 2];
      $43_1 = HEAP32[$3_1 + 4 >> 2];
      $20_1 = ($6_1 | 0) == ($52_1 | 0) & $20_1 >>> 0 < $62_1 >>> 0 | $6_1 >>> 0 < $52_1 >>> 0;
      $3_1 = $53_1 + 8 | 0;
      $52_1 = HEAP32[$3_1 >> 2];
      $4_1 = $46_1 + 8 | 0;
      $6_1 = $52_1 + HEAP32[$4_1 >> 2] | 0;
      $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $6_1 >>> 0 < $52_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $6_1 + $20_1 | 0;
      $3_1 = ($4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $43_1 | 0;
      $6_1 = $4_1;
      $4_1 = $4_1 + $19_1 | 0;
      $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $4_1;
      $4_1 = $4_1 + $15_1 | 0;
      $3_1 = ($6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $70_1 | 0;
      $6_1 = $4_1 + $49_1 | 0;
      $4_1 = $6_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $6_1 + $8_1 | 0;
      $4_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $3_1;
      $3_1 = $4_1;
      $7_1 = $7_1 >>> 20 | 0;
      $4_1 = $6_1 + $7_1 | 0;
      $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $4_1;
      $4_1 = $4_1 + $64_1 | 0;
      $7_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $7_1 << 12 | $4_1 >>> 20;
      $6_1 = $11_1;
      $4_1 = $4_1 << 12 | $6_1 >>> 20;
      $11_1 = $15_1;
      $8_1 = HEAP32[$5_1 + 1104 >> 2];
      $15_1 = HEAP32[$5_1 + 1200 >> 2];
      $20_1 = $8_1 + $15_1 | 0;
      $19_1 = HEAP32[$5_1 + 1108 >> 2];
      $3_1 = $19_1 + HEAP32[$5_1 + 1204 >> 2] | 0;
      $15_1 = $15_1 >>> 0 > $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $20_1 | 0;
      $4_1 = $11_1 + $15_1 | 0;
      $11_1 = $3_1 >>> 0 < $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $3_1;
      $3_1 = $11_1 << 4 | $3_1 >>> 28;
      $43_1 = $4_1 << 4 & -16;
      $52_1 = $6_1;
      $69($68_1, $43_1 | $6_1 >>> 16 & 15, $3_1 & 16777215, 0, 0, 977, 1, 0, 0);
      $43_1 = $5_1 + 1280 | 0;
      $69($43_1, $14_1, $17_1, 0, 0, $12_1, $10_1, 0, 0);
      $46_1 = $5_1 + 1072 | 0;
      $69($46_1, $9_1, $13_1, 0, 0, $27_1, $41_1, 0, 0);
      $53_1 = $5_1 + 1184 | 0;
      $69($53_1, $23_1, $18_1, 0, 0, $23_1, $18_1, 0, 0);
      $64_1 = $5_1 + 1056 | 0;
      $49_1 = $64_1;
      $62_1 = ($11_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $20_1 >>> 0 | $11_1 >>> 0 < $15_1 >>> 0;
      $6_1 = ($15_1 | 0) == ($19_1 | 0) & $8_1 >>> 0 > $20_1 >>> 0 | $15_1 >>> 0 < $19_1 >>> 0;
      $3_1 = $55_1 + 8 | 0;
      $15_1 = HEAP32[$3_1 >> 2];
      $20_1 = $50_1 + 8 | 0;
      $4_1 = $15_1 + HEAP32[$20_1 >> 2] | 0;
      $3_1 = HEAP32[$20_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $4_1 = $4_1 + $6_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $7_1 >>> 20 | 0;
      $6_1 = $7_1;
      $7_1 = $4_1 + $7_1 | 0;
      $4_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $7_1 + $62_1 | 0;
      $4_1 = $3_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $4_1 << 12 | $3_1 >>> 20;
      $7_1 = $3_1 << 12 | $11_1 >>> 20;
      $15_1 = $6_1;
      $19_1 = HEAP32[$5_1 + 1072 >> 2];
      $6_1 = HEAP32[$5_1 + 1184 >> 2];
      $11_1 = $19_1 + $6_1 | 0;
      $20_1 = HEAP32[$5_1 + 1076 >> 2];
      $3_1 = $20_1 + HEAP32[$5_1 + 1188 >> 2] | 0;
      $3_1 = $6_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $11_1;
      $11_1 = $3_1;
      $3_1 = $3_1 + $15_1 | 0;
      $7_1 = $6_1 + $7_1 | 0;
      $3_1 = $7_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $7_1;
      $7_1 = $3_1;
      $69($49_1, $15_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $8_1 = $5_1 + 1264 | 0;
      $69($8_1, $27_1, $41_1, 0, 0, $12_1, $10_1, 0, 0);
      $10_1 = $5_1 + 1296 | 0;
      $69($10_1, $14_1, $17_1, 0, 0, $14_1, $17_1, 0, 0);
      $27_1 = $5_1 + 1040 | 0;
      $69($27_1, $9_1, $13_1, 0, 0, $23_1, $18_1, 0, 0);
      $12_1 = $5_1 + 1024 | 0;
      $9_1 = $12_1;
      $15_1 = ($3_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 > $15_1 >>> 0 | $3_1 >>> 0 < $11_1 >>> 0;
      $6_1 = ($11_1 | 0) == ($20_1 | 0) & $6_1 >>> 0 < $19_1 >>> 0 | $11_1 >>> 0 < $20_1 >>> 0;
      $3_1 = $53_1 + 8 | 0;
      $20_1 = HEAP32[$3_1 >> 2];
      $19_1 = $46_1 + 8 | 0;
      $11_1 = $20_1 + HEAP32[$19_1 >> 2] | 0;
      $3_1 = HEAP32[$19_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $11_1 >>> 0 < $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $11_1;
      $11_1 = $6_1 + $11_1 | 0;
      $3_1 = $13_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $6_1 = $4_1;
      $4_1 = $4_1 + $11_1 | 0;
      $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $11_1 = $4_1 + $15_1 | 0;
      $4_1 = $11_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $4_1 << 12 | $11_1 >>> 20;
      $15_1 = $11_1 << 12 | $7_1 >>> 20;
      $20_1 = HEAP32[$5_1 + 1040 >> 2];
      $11_1 = $15_1 + $20_1 | 0;
      $7_1 = $6_1;
      $3_1 = $6_1 + HEAP32[$5_1 + 1044 >> 2] | 0;
      $3_1 = $11_1 >>> 0 < $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($9_1, $11_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $14_1 = $5_1 + 1008 | 0;
      $6_1 = $14_1;
      $11_1 = ($3_1 | 0) == ($7_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $3_1 >>> 0 < $7_1 >>> 0;
      $3_1 = $27_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $4_1 = $4_1 >>> 20 | 0;
      $9_1 = $4_1;
      $4_1 = $4_1 + $7_1 | 0;
      $3_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $4_1;
      $4_1 = $4_1 + $11_1 | 0;
      $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($6_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $49_1 = HEAP32[$5_1 + 1608 >> 2];
      $53_1 = HEAP32[$5_1 + 1612 >> 2];
      $50_1 = HEAP32[$5_1 + 1600 >> 2];
      $70_1 = HEAP32[$5_1 + 1604 >> 2];
      $62_1 = HEAP32[$5_1 + 1584 >> 2];
      $75 = HEAP32[$5_1 + 1588 >> 2];
      $27_1 = HEAP32[$5_1 + 1616 >> 2];
      $19_1 = HEAP32[$5_1 + 1620 >> 2];
      $55_1 = HEAP32[$5_1 + 1592 >> 2];
      $76 = HEAP32[$5_1 + 1596 >> 2];
      HEAP32[$5_1 + 1416 >> 2] = -4 - $37_1;
      HEAP32[$5_1 + 1420 >> 2] = 262143 - (($37_1 >>> 0 > 4294967292) + $48_1 | 0);
      HEAP32[$5_1 + 1408 >> 2] = -4 - $39_1;
      HEAP32[$5_1 + 1412 >> 2] = 4194303 - (($39_1 >>> 0 > 4294967292) + $32_1 | 0);
      HEAP32[$5_1 + 1400 >> 2] = -4 - $59_1;
      HEAP32[$5_1 + 1404 >> 2] = 4194303 - (($59_1 >>> 0 > 4294967292) + $31_1 | 0);
      HEAP32[$5_1 + 1392 >> 2] = -4 - $58_1;
      HEAP32[$5_1 + 1396 >> 2] = 4194303 - (($58_1 >>> 0 > 4294967292) + $34_1 | 0);
      HEAP32[$5_1 + 1384 >> 2] = -3908 - $30_1;
      HEAP32[$5_1 + 1388 >> 2] = 4194299 - (($30_1 >>> 0 > 4294963388) + $51_1 | 0);
      $3_1 = $60_1 + 8 | 0;
      $17_1 = HEAP32[$3_1 >> 2];
      $23_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $68_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $39_1 = HEAP32[$3_1 + 4 >> 2];
      $11_1 = HEAP32[$5_1 + 1248 >> 2];
      $3_1 = HEAP32[$5_1 + 1252 >> 2];
      $6_1 = HEAP32[$5_1 + 1088 >> 2];
      $4_1 = HEAP32[$5_1 + 1092 >> 2];
      $15_1 = $43_1 + 8 | 0;
      $37_1 = HEAP32[$15_1 >> 2];
      $30_1 = HEAP32[$15_1 + 4 >> 2];
      $15_1 = $64_1 + 8 | 0;
      $9_1 = HEAP32[$15_1 >> 2];
      $34_1 = HEAP32[$15_1 + 4 >> 2];
      $20_1 = HEAP32[$5_1 + 1280 >> 2];
      $31_1 = HEAP32[$5_1 + 1284 >> 2];
      $13_1 = HEAP32[$5_1 + 1056 >> 2];
      $15_1 = HEAP32[$5_1 + 1060 >> 2];
      $10_1 = $10_1 + 8 | 0;
      $60_1 = HEAP32[$10_1 >> 2];
      $68_1 = HEAP32[$10_1 + 4 >> 2];
      $8_1 = $8_1 + 8 | 0;
      $51_1 = HEAP32[$8_1 >> 2];
      $64_1 = HEAP32[$8_1 + 4 >> 2];
      $8_1 = HEAP32[$5_1 + 1296 >> 2];
      $77 = HEAP32[$5_1 + 1300 >> 2];
      $43_1 = HEAP32[$5_1 + 1264 >> 2];
      $32_1 = HEAP32[$5_1 + 1268 >> 2];
      $10_1 = $12_1 + 8 | 0;
      $41_1 = HEAP32[$10_1 >> 2];
      $58_1 = HEAP32[$10_1 + 4 >> 2];
      $10_1 = HEAP32[$5_1 + 1024 >> 2];
      $12_1 = HEAP32[$5_1 + 1028 >> 2];
      $46_1 = HEAP32[$5_1 + 1008 >> 2];
      $48_1 = HEAP32[$5_1 + 1012 >> 2];
      $14_1 = $14_1 + 8 | 0;
      $78 = HEAP32[$14_1 >> 2];
      $59_1 = HEAP32[$14_1 + 4 >> 2];
      $79 = $5_1 + 1384 | 0;
      $34($5_1 + 1504 | 0, $35_1, $79);
      $3_1 = $3_1 + $4_1 | 0;
      $18_1 = $6_1 + $11_1 | 0;
      $11_1 = $18_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = ($4_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
      $4_1 = $23_1 + $39_1 | 0;
      $3_1 = $7_1;
      $7_1 = $7_1 + $17_1 | 0;
      $3_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $6_1 + $7_1 | 0;
      $7_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $7_1 << 12 | $4_1 >>> 20;
      $35_1 = $11_1;
      $11_1 = $4_1 << 12 | $11_1 >>> 20;
      $14_1 = $3_1;
      $3_1 = $15_1 + $31_1 | 0;
      $6_1 = $13_1 + $20_1 | 0;
      $4_1 = $6_1 >>> 0 < $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $14_1 | 0;
      $23_1 = $6_1 + $11_1 | 0;
      $11_1 = $23_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = ($4_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 > $23_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
      $15_1 = ($4_1 | 0) == ($15_1 | 0) & $6_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $15_1 >>> 0;
      $3_1 = $30_1 + $34_1 | 0;
      $6_1 = $9_1 + $37_1 | 0;
      $4_1 = $6_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $6_1 + $15_1 | 0;
      $4_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $3_1;
      $3_1 = $4_1;
      $7_1 = $7_1 >>> 20 | 0;
      $4_1 = $6_1 + $7_1 | 0;
      $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $4_1;
      $4_1 = $4_1 + $20_1 | 0;
      $15_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $15_1 << 12 | $4_1 >>> 20;
      $39_1 = $11_1;
      $11_1 = $4_1 << 12 | $11_1 >>> 20;
      $3_1 = $32_1 + $77 | 0;
      $14_1 = $8_1 + $43_1 | 0;
      $9_1 = $14_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $9_1 + $12_1 | 0;
      $12_1 = $10_1 + $14_1 | 0;
      $20_1 = $12_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $3_1 = $20_1 + $7_1 | 0;
      $17_1 = $11_1 + $12_1 | 0;
      $11_1 = $17_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $27_1;
      $6_1 = $19_1;
      $10_1 = $44_1;
      $44_1 = $47_1 & 65535;
      $4_1 = __wasm_i64_mul($47_1 >>> 16 | 0, 0, 977, 1);
      $19_1 = $4_1 + $36_1 | 0;
      $3_1 = $26_1 + i64toi32_i32$HIGH_BITS | 0;
      $37_1 = $4_1 >>> 0 > $19_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $42_1;
      $4_1 = $37_1 >>> 20 | 0;
      $27_1 = $4_1 + $38_1 | 0;
      $30_1 = $4_1 >>> 0 > $27_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $33_1;
      $4_1 = $30_1 >>> 20 | 0;
      $13_1 = $4_1 + $21_1 | 0;
      $34_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $16_1;
      $3_1 = $44_1;
      $8_1 = $34_1 >>> 20 | 0;
      $16_1 = $8_1;
      $8_1 = $8_1 + $22_1 | 0;
      $31_1 = $16_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $31_1 >>> 20 | 0;
      $47_1 = $4_1 + $10_1 | 0;
      $10_1 = $4_1 >>> 0 > $47_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $10_1 + $6_1 | 0;
      $6_1 = $7_1 + $47_1 | 0;
      $7_1 = $6_1 >>> 0 < $47_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $16_1 = HEAP32[$5_1 + 1528 >> 2];
      $21_1 = HEAP32[$5_1 + 1532 >> 2];
      $22_1 = ($11_1 | 0) == ($20_1 | 0) & $12_1 >>> 0 > $17_1 >>> 0 | $11_1 >>> 0 < $20_1 >>> 0;
      $20_1 = ($9_1 | 0) == ($20_1 | 0) & $12_1 >>> 0 < $14_1 >>> 0 | $9_1 >>> 0 > $20_1 >>> 0;
      $12_1 = ($9_1 | 0) == ($32_1 | 0) & $14_1 >>> 0 < $43_1 >>> 0 | $9_1 >>> 0 < $32_1 >>> 0;
      $3_1 = $64_1 + $68_1 | 0;
      $9_1 = $51_1 + $60_1 | 0;
      $4_1 = $9_1 >>> 0 < $51_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $9_1;
      $9_1 = $9_1 + $12_1 | 0;
      $3_1 = ($3_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $58_1 | 0;
      $4_1 = $9_1 + $41_1 | 0;
      $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $4_1;
      $4_1 = $4_1 + $20_1 | 0;
      $3_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $15_1 >>> 20 | 0;
      $4_1 = $4_1 + $15_1 | 0;
      $3_1 = $15_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $4_1;
      $4_1 = $4_1 + $22_1 | 0;
      $15_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1;
      $4_1 = $15_1 << 12 | $3_1 >>> 20;
      $22_1 = $11_1;
      $11_1 = $3_1 << 12 | $11_1 >>> 20;
      $12_1 = $4_1;
      $9_1 = $29_1 & -2;
      $4_1 = $9_1 + $46_1 | 0;
      $3_1 = $48_1 + ($40_1 & 1048575) | 0;
      $9_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $9_1 + $12_1 | 0;
      $20_1 = $4_1;
      $33_1 = $4_1 + $11_1 | 0;
      $11_1 = $4_1 >>> 0 > $33_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $21_1 + ($11_1 & 1048575) | 0;
      $12_1 = $16_1 + $33_1 | 0;
      $14_1 = $12_1 >>> 0 < $33_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = HEAP32[$5_1 + 1524 >> 2] + ($22_1 & 1048575) | 0;
      $4_1 = $17_1;
      $17_1 = HEAP32[$5_1 + 1520 >> 2] + $17_1 | 0;
      $22_1 = $4_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = HEAP32[$5_1 + 1516 >> 2] + ($39_1 & 1048575) | 0;
      $4_1 = $23_1;
      $23_1 = HEAP32[$5_1 + 1512 >> 2] + $23_1 | 0;
      $16_1 = $4_1 >>> 0 > $23_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$5_1 + 1508 >> 2] + ($35_1 & 1048575) | 0;
      $3_1 = $18_1;
      $18_1 = HEAP32[$5_1 + 1504 >> 2] + $18_1 | 0;
      $21_1 = $3_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $3_1 = HEAP32[$5_1 + 1540 >> 2] + ($52_1 & 65535) | 0;
      $4_1 = HEAP32[$5_1 + 1536 >> 2] + $56_1 | 0;
      $3_1 = $4_1 >>> 0 < $56_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $56_1 = $4_1;
      $38_1 = $3_1;
      $33_1 = ($9_1 | 0) == ($11_1 | 0) & $20_1 >>> 0 > $33_1 >>> 0 | $9_1 >>> 0 > $11_1 >>> 0;
      $9_1 = ($9_1 | 0) == ($48_1 | 0) & $20_1 >>> 0 < $46_1 >>> 0 | $9_1 >>> 0 < $48_1 >>> 0;
      $4_1 = $9_1 + $78 | 0;
      $3_1 = $59_1;
      $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $15_1 >>> 20 | 0;
      $9_1 = $15_1;
      $15_1 = $4_1 + $15_1 | 0;
      $4_1 = $9_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $15_1;
      $15_1 = $15_1 + $33_1 | 0;
      $3_1 = ($3_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 12 | $15_1 >>> 20;
      $4_1 = $15_1 << 12 | $11_1 >>> 20;
      $11_1 = $4_1 + $56_1 | 0;
      $3_1 = $3_1 + $38_1 | 0;
      $15_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = __wasm_i64_mul($15_1 >>> 16 | 0, 0, 977, 1);
      $4_1 = $9_1 + $18_1 | 0;
      $3_1 = $21_1 + i64toi32_i32$HIGH_BITS | 0;
      $33_1 = $4_1;
      $38_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $16_1;
      $4_1 = $38_1 >>> 20 | 0;
      $42_1 = $4_1 + $23_1 | 0;
      $44_1 = $4_1 >>> 0 > $42_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $22_1;
      $3_1 = $14_1;
      $9_1 = $44_1 >>> 20 | 0;
      $36_1 = $9_1 + $17_1 | 0;
      $26_1 = $9_1 >>> 0 > $36_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $26_1 >>> 20 | 0;
      $41_1 = $4_1 + $12_1 | 0;
      $9_1 = $4_1 >>> 0 > $41_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $15_1 & 65535;
      $4_1 = $9_1 >>> 20 | 0;
      $29_1 = $4_1 + $11_1 | 0;
      $40_1 = $4_1 >>> 0 > $29_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $48_1 = $47_1 << 1;
      $51_1 = $10_1 << 1 | $47_1 >>> 31;
      $43_1 = $11_1;
      $46_1 = $15_1;
      $47_1 = $6_1;
      $60_1 = $7_1 & 65535;
      $4_1 = $53_1;
      $53_1 = $31_1 & 1048575;
      $3_1 = $4_1 + $53_1 | 0;
      $52_1 = $8_1 + $49_1 | 0;
      $15_1 = $52_1 >>> 0 < $49_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $49_1 = $34_1 & 1048575;
      $3_1 = $49_1 + $70_1 | 0;
      $58_1 = $13_1 + $50_1 | 0;
      $20_1 = $58_1 >>> 0 < $50_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $50_1 = $30_1 & 1048575;
      $4_1 = $50_1 + $76 | 0;
      $6_1 = $27_1;
      $59_1 = $6_1 + $55_1 | 0;
      $27_1 = $59_1 >>> 0 < $55_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $55_1 = $37_1 & 1048575;
      $3_1 = $55_1 + $75 | 0;
      $10_1 = $19_1;
      $19_1 = $10_1 + $62_1 | 0;
      $11_1 = $19_1 >>> 0 < $62_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $56_1 = $7_1;
      $7_1 = __wasm_i64_mul($7_1 >>> 16 | 0, 0, 977, 1);
      $4_1 = $7_1 + $19_1 | 0;
      $3_1 = $11_1 + i64toi32_i32$HIGH_BITS | 0;
      $3_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $4_1;
      $35_1 = $3_1;
      $3_1 = $27_1;
      $4_1 = $35_1 >>> 20 | 0;
      $39_1 = $4_1 + $59_1 | 0;
      $37_1 = $4_1 >>> 0 > $39_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $20_1;
      $4_1 = $37_1 >>> 20 | 0;
      $30_1 = $4_1 + $58_1 | 0;
      $34_1 = $4_1 >>> 0 > $30_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $15_1;
      $3_1 = $60_1;
      $31_1 = $34_1 >>> 20 | 0;
      $32_1 = $31_1;
      $31_1 = $31_1 + $52_1 | 0;
      $4_1 = $32_1 >>> 0 > $31_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $32_1 = $4_1 >>> 20 | 0;
      $60_1 = $32_1;
      $32_1 = $32_1 + $47_1 | 0;
      $3_1 = $60_1 >>> 0 > $32_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      if ($32_1 | ($31_1 | ($7_1 | $39_1 | $30_1)) | ($3_1 | ($35_1 | $37_1 | $34_1 | $4_1) & 1048575)) {
        if (($39_1 & ($7_1 ^ 976) & $30_1 & $31_1 & $32_1) == -1) {
          $4_1 = ($37_1 & ($35_1 ^ 1) & $34_1 & $4_1 & ($3_1 ^ 983040)) == 1048575;
        } else {
          $4_1 = 0;
        }
      } else {
        $4_1 = 1;
      }
      $3_1 = $4_1;
      if ($41_1 | ($33_1 | $42_1 | $36_1) | $29_1 | (($44_1 | $38_1 | $26_1 | $9_1) & 1048575 | $40_1)) {
        if (($42_1 & ($33_1 ^ 976) & $36_1 & $41_1 & $29_1) == -1) {
          $4_1 = ($44_1 & ($38_1 ^ 1) & $26_1 & $9_1 & ($40_1 ^ 983040)) == 1048575;
        } else {
          $4_1 = 0;
        }
      } else {
        $4_1 = 1;
      }
      $29_1 = $3_1 & $4_1;
      HEAP32[$5_1 + 1376 >> 2] = $29_1 ? $48_1 : $43_1;
      HEAP32[$5_1 + 1380 >> 2] = $29_1 ? $51_1 : $46_1;
      HEAP32[$5_1 + 1368 >> 2] = $29_1 ? $8_1 << 1 : $12_1;
      HEAP32[$5_1 + 1372 >> 2] = $29_1 ? $53_1 << 1 | $8_1 >>> 31 : $14_1;
      HEAP32[$5_1 + 1360 >> 2] = $29_1 ? $13_1 << 1 : $17_1;
      HEAP32[$5_1 + 1364 >> 2] = $29_1 ? $49_1 << 1 | $13_1 >>> 31 : $22_1;
      HEAP32[$5_1 + 1352 >> 2] = $29_1 ? $6_1 << 1 : $23_1;
      HEAP32[$5_1 + 1356 >> 2] = $29_1 ? $50_1 << 1 | $6_1 >>> 31 : $16_1;
      HEAP32[$5_1 + 1344 >> 2] = $29_1 ? $10_1 << 1 : $18_1;
      HEAP32[$5_1 + 1348 >> 2] = $29_1 ? $55_1 << 1 | $10_1 >>> 31 : $21_1;
      $3_1 = HEAP32[$5_1 + 1420 >> 2] + $57_1 | 0;
      $4_1 = HEAP32[$5_1 + 1416 >> 2] + $45_1 | 0;
      $3_1 = $4_1 >>> 0 < $45_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $29_1 ? $4_1 : $47_1;
      HEAP32[$5_1 + 1416 >> 2] = $8_1;
      $10_1 = $29_1 ? $3_1 : $56_1;
      HEAP32[$5_1 + 1420 >> 2] = $10_1;
      $3_1 = HEAP32[$5_1 + 1412 >> 2] + $73 | 0;
      $4_1 = HEAP32[$5_1 + 1408 >> 2] + $28_1 | 0;
      $3_1 = $4_1 >>> 0 < $28_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $41_1 = $29_1 ? $4_1 : $52_1;
      HEAP32[$5_1 + 1408 >> 2] = $41_1;
      $40_1 = $29_1 ? $3_1 : $15_1;
      HEAP32[$5_1 + 1412 >> 2] = $40_1;
      $3_1 = HEAP32[$5_1 + 1404 >> 2] + $72 | 0;
      $4_1 = HEAP32[$5_1 + 1400 >> 2] + $25_1 | 0;
      $3_1 = $4_1 >>> 0 < $25_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $29_1 ? $4_1 : $58_1;
      HEAP32[$5_1 + 1400 >> 2] = $7_1;
      $6_1 = $29_1 ? $3_1 : $20_1;
      HEAP32[$5_1 + 1404 >> 2] = $6_1;
      $3_1 = HEAP32[$5_1 + 1396 >> 2] + $71 | 0;
      $4_1 = HEAP32[$5_1 + 1392 >> 2] + $24_1 | 0;
      $3_1 = $4_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $29_1 ? $4_1 : $59_1;
      HEAP32[$5_1 + 1392 >> 2] = $4_1;
      $9_1 = $29_1 ? $3_1 : $27_1;
      HEAP32[$5_1 + 1396 >> 2] = $9_1;
      $3_1 = HEAP32[$5_1 + 1388 >> 2] + $74 | 0;
      $13_1 = HEAP32[$5_1 + 1384 >> 2] + $54_1 | 0;
      $3_1 = $13_1 >>> 0 < $54_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $29_1 ? $13_1 : $19_1;
      HEAP32[$5_1 + 1384 >> 2] = $13_1;
      $3_1 = $29_1 ? $3_1 : $11_1;
      $12_1 = $3_1;
      HEAP32[$5_1 + 1388 >> 2] = $3_1;
      $14_1 = $5_1 + 896 | 0;
      $25_1 = $13_1 << 1;
      $24_1 = $3_1 << 1 | $13_1 >>> 31;
      $69($14_1, $25_1, $24_1, 0, 0, $41_1, $40_1, 0, 0);
      $33_1 = $9_1;
      $28_1 = $4_1;
      $4_1 = $9_1 << 1 | $4_1 >>> 31;
      $17_1 = $5_1 + 944 | 0;
      $9_1 = $28_1 << 1;
      $69($17_1, $9_1, $4_1, 0, 0, $7_1, $6_1, 0, 0);
      $22_1 = $5_1 + 832 | 0;
      $69($22_1, $8_1, $10_1, 0, 0, $8_1, $10_1, 0, 0);
      $23_1 = $5_1 + 816 | 0;
      $69($23_1, HEAP32[$5_1 + 832 >> 2], HEAP32[$5_1 + 836 >> 2], 0, 0, 15632, 16, 0, 0);
      $18_1 = $5_1 + 784 | 0;
      $16_1 = $8_1 << 1;
      $45_1 = $10_1 << 1 | $8_1 >>> 31;
      $69($18_1, $16_1, $45_1, 0, 0, $13_1, $3_1, 0, 0);
      $21_1 = $5_1 + 880 | 0;
      $69($21_1, $9_1, $4_1, 0, 0, $41_1, $40_1, 0, 0);
      $36_1 = $5_1 + 928 | 0;
      $69($36_1, $7_1, $6_1, 0, 0, $7_1, $6_1, 0, 0);
      $26_1 = $5_1 + 800 | 0;
      $3_1 = $22_1 + 8 | 0;
      $69($26_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $39_1 = $5_1 + 992 | 0;
      $69($39_1, $13_1, $12_1, 0, 0, $13_1, $12_1, 0, 0);
      $35_1 = $5_1 + 768 | 0;
      $69($35_1, $16_1, $45_1, 0, 0, $28_1, $33_1, 0, 0);
      $38_1 = $6_1;
      $54_1 = $7_1;
      $4_1 = $6_1 << 1 | $7_1 >>> 31;
      $37_1 = $5_1 + 864 | 0;
      $69($37_1, $7_1 << 1, $4_1, 0, 0, $41_1, $40_1, 0, 0);
      $13_1 = HEAP32[$5_1 + 896 >> 2];
      $7_1 = HEAP32[$5_1 + 944 >> 2];
      $4_1 = $13_1 + $7_1 | 0;
      $9_1 = HEAP32[$5_1 + 900 >> 2];
      $3_1 = $9_1 + HEAP32[$5_1 + 948 >> 2] | 0;
      $7_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $7_1 + HEAP32[$5_1 + 820 >> 2] | 0;
      $6_1 = $4_1;
      $8_1 = HEAP32[$5_1 + 816 >> 2];
      $4_1 = $4_1 + $8_1 | 0;
      $42_1 = $4_1;
      $4_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = ($7_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 > $42_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
      $3_1 = $23_1 + 8 | 0;
      $10_1 = HEAP32[$3_1 >> 2];
      $12_1 = HEAP32[$3_1 + 4 >> 2];
      $6_1 = ($7_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 < $13_1 >>> 0 | $7_1 >>> 0 < $9_1 >>> 0;
      $3_1 = $17_1 + 8 | 0;
      $9_1 = HEAP32[$3_1 >> 2];
      $13_1 = $14_1 + 8 | 0;
      $7_1 = $9_1 + HEAP32[$13_1 >> 2] | 0;
      $3_1 = HEAP32[$13_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $7_1;
      $7_1 = $6_1 + $7_1 | 0;
      $3_1 = ($9_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $12_1 | 0;
      $6_1 = $7_1;
      $7_1 = $7_1 + $10_1 | 0;
      $3_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $7_1;
      $7_1 = $7_1 + $8_1 | 0;
      $6_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $6_1 << 12 | $7_1 >>> 20;
      $44_1 = $4_1;
      $7_1 = $7_1 << 12 | $4_1 >>> 20;
      $13_1 = $9_1;
      $22_1 = HEAP32[$5_1 + 880 >> 2];
      $9_1 = HEAP32[$5_1 + 928 >> 2];
      $3_1 = $22_1 + $9_1 | 0;
      $17_1 = HEAP32[$5_1 + 884 >> 2];
      $4_1 = $17_1 + HEAP32[$5_1 + 932 >> 2] | 0;
      $8_1 = $3_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $10_1 = $3_1;
      $9_1 = HEAP32[$5_1 + 784 >> 2];
      $4_1 = $3_1 + $9_1 | 0;
      $3_1 = $8_1 + HEAP32[$5_1 + 788 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $4_1;
      $14_1 = HEAP32[$5_1 + 800 >> 2];
      $4_1 = $4_1 + $14_1 | 0;
      $9_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$5_1 + 804 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $4_1;
      $4_1 = $3_1 + $13_1 | 0;
      $30_1 = $5_1 + 752 | 0;
      $23_1 = $30_1;
      $13_1 = $7_1 + $14_1 | 0;
      $7_1 = $13_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $34_1 = ($3_1 | 0) == ($7_1 | 0) & $13_1 >>> 0 < $14_1 >>> 0 | $3_1 >>> 0 > $7_1 >>> 0;
      $14_1 = ($3_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 > $14_1 >>> 0 | $3_1 >>> 0 < $9_1 >>> 0;
      $3_1 = $26_1 + 8 | 0;
      $26_1 = HEAP32[$3_1 >> 2];
      $31_1 = HEAP32[$3_1 + 4 >> 2];
      $9_1 = ($8_1 | 0) == ($9_1 | 0) & $10_1 >>> 0 > $12_1 >>> 0 | $8_1 >>> 0 > $9_1 >>> 0;
      $3_1 = $18_1 + 8 | 0;
      $12_1 = HEAP32[$3_1 >> 2];
      $18_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = ($8_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $22_1 >>> 0 | $8_1 >>> 0 < $17_1 >>> 0;
      $3_1 = $36_1 + 8 | 0;
      $10_1 = HEAP32[$3_1 >> 2];
      $17_1 = $21_1 + 8 | 0;
      $4_1 = $10_1 + HEAP32[$17_1 >> 2] | 0;
      $3_1 = HEAP32[$17_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $4_1;
      $4_1 = $4_1 + $8_1 | 0;
      $3_1 = ($10_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $12_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $4_1 + $9_1 | 0;
      $4_1 = ($9_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $31_1 | 0;
      $3_1 = $9_1;
      $9_1 = $9_1 + $26_1 | 0;
      $3_1 = $3_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $9_1 + $14_1 | 0;
      $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $6_1 >>> 20 | 0;
      $4_1 = $4_1 + $6_1 | 0;
      $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $4_1;
      $4_1 = $4_1 + $34_1 | 0;
      $6_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $6_1 << 12 | $4_1 >>> 20;
      $10_1 = $4_1 << 12 | $7_1 >>> 20;
      $3_1 = $9_1;
      $18_1 = HEAP32[$5_1 + 768 >> 2];
      $9_1 = HEAP32[$5_1 + 864 >> 2];
      $8_1 = $18_1 + $9_1 | 0;
      $14_1 = HEAP32[$5_1 + 772 >> 2];
      $4_1 = $14_1 + HEAP32[$5_1 + 868 >> 2] | 0;
      $9_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $3_1 = $9_1 + $3_1 | 0;
      $10_1 = $8_1 + $10_1 | 0;
      $4_1 = $10_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $10_1;
      $3_1 = $4_1 << 4 | $10_1 >>> 28;
      $36_1 = $7_1;
      $69($23_1, $7_1 >>> 16 & 15 | $10_1 << 4 & -16, $3_1 & 16777215, 0, 0, 977, 1, 0, 0);
      $17_1 = HEAP32[$5_1 + 756 >> 2];
      $3_1 = $17_1 + HEAP32[$5_1 + 996 >> 2] | 0;
      $21_1 = HEAP32[$5_1 + 752 >> 2];
      $7_1 = HEAP32[$5_1 + 992 >> 2];
      $10_1 = $21_1 + $7_1 | 0;
      $22_1 = $10_1;
      HEAP32[$5_1 + 1464 >> 2] = $10_1;
      $7_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $23_1 = $7_1 & 1048575;
      HEAP32[$5_1 + 1468 >> 2] = $23_1;
      $34_1 = $5_1 + 976 | 0;
      $69($34_1, $25_1, $24_1, 0, 0, $28_1, $33_1, 0, 0);
      $31_1 = $5_1 + 720 | 0;
      $69($31_1, $16_1, $45_1, 0, 0, $54_1, $38_1, 0, 0);
      $32_1 = $5_1 + 848 | 0;
      $69($32_1, $41_1, $40_1, 0, 0, $41_1, $40_1, 0, 0);
      $57_1 = $5_1 + 704 | 0;
      $12_1 = ($4_1 | 0) == ($9_1 | 0) & $8_1 >>> 0 > $12_1 >>> 0 | $4_1 >>> 0 < $9_1 >>> 0;
      $8_1 = ($9_1 | 0) == ($14_1 | 0) & $8_1 >>> 0 < $18_1 >>> 0 | $9_1 >>> 0 < $14_1 >>> 0;
      $3_1 = $37_1 + 8 | 0;
      $14_1 = HEAP32[$3_1 >> 2];
      $18_1 = $35_1 + 8 | 0;
      $9_1 = $14_1 + HEAP32[$18_1 >> 2] | 0;
      $3_1 = HEAP32[$18_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $9_1;
      $9_1 = $8_1 + $9_1 | 0;
      $3_1 = $14_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $6_1 >>> 20 | 0;
      $8_1 = $6_1;
      $6_1 = $6_1 + $9_1 | 0;
      $3_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $6_1;
      $6_1 = $6_1 + $12_1 | 0;
      $9_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $9_1 << 12 | $6_1 >>> 20;
      $4_1 = $6_1 << 12 | $4_1 >>> 20;
      $6_1 = $8_1;
      $37_1 = HEAP32[$5_1 + 720 >> 2];
      $8_1 = HEAP32[$5_1 + 848 >> 2];
      $18_1 = $37_1 + $8_1 | 0;
      $35_1 = HEAP32[$5_1 + 724 >> 2];
      $3_1 = $35_1 + HEAP32[$5_1 + 852 >> 2] | 0;
      $8_1 = $8_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $8_1 + $6_1 | 0;
      $4_1 = $4_1 + $18_1 | 0;
      $3_1 = $4_1 >>> 0 < $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $26_1 = $4_1;
      $6_1 = $3_1;
      $69($57_1, $4_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $10_1 = ($7_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $21_1 >>> 0 | $7_1 >>> 0 < $17_1 >>> 0;
      $3_1 = $39_1 + 8 | 0;
      $12_1 = HEAP32[$3_1 >> 2];
      $14_1 = $30_1 + 8 | 0;
      $4_1 = $12_1 + HEAP32[$14_1 >> 2] | 0;
      $3_1 = HEAP32[$14_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $4_1;
      $4_1 = $4_1 + $10_1 | 0;
      $10_1 = $12_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $10_1 << 12 | $4_1 >>> 20;
      $7_1 = $4_1 << 12 | $7_1 >>> 20;
      $3_1 = $12_1;
      $30_1 = HEAP32[$5_1 + 704 >> 2];
      $12_1 = HEAP32[$5_1 + 976 >> 2];
      $21_1 = $30_1 + $12_1 | 0;
      $39_1 = HEAP32[$5_1 + 708 >> 2];
      $4_1 = $39_1 + HEAP32[$5_1 + 980 >> 2] | 0;
      $12_1 = $12_1 >>> 0 > $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $3_1 = $12_1 + $3_1 | 0;
      $4_1 = $7_1 + $21_1 | 0;
      $3_1 = $4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $4_1;
      HEAP32[$5_1 + 1472 >> 2] = $4_1;
      $7_1 = $3_1;
      $17_1 = $3_1 & 1048575;
      HEAP32[$5_1 + 1476 >> 2] = $17_1;
      $48_1 = $5_1 + 912 | 0;
      $69($48_1, $25_1, $24_1, 0, 0, $54_1, $38_1, 0, 0);
      $54_1 = $5_1 + 960 | 0;
      $69($54_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
      $33_1 = $5_1 + 656 | 0;
      $69($33_1, $16_1, $45_1, 0, 0, $41_1, $40_1, 0, 0);
      $45_1 = $5_1 + 640 | 0;
      $16_1 = $45_1;
      $24_1 = ($6_1 | 0) == ($8_1 | 0) & $18_1 >>> 0 > $26_1 >>> 0 | $6_1 >>> 0 < $8_1 >>> 0;
      $8_1 = ($8_1 | 0) == ($35_1 | 0) & $18_1 >>> 0 < $37_1 >>> 0 | $8_1 >>> 0 < $35_1 >>> 0;
      $3_1 = $32_1 + 8 | 0;
      $18_1 = HEAP32[$3_1 >> 2];
      $25_1 = $31_1 + 8 | 0;
      $4_1 = $18_1 + HEAP32[$25_1 >> 2] | 0;
      $3_1 = HEAP32[$25_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $18_1 = $4_1;
      $4_1 = $4_1 + $8_1 | 0;
      $3_1 = $18_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $9_1 = $9_1 >>> 20 | 0;
      $4_1 = $9_1;
      $9_1 = $8_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $9_1 + $24_1 | 0;
      $9_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $9_1 << 12 | $4_1 >>> 20;
      $38_1 = $4_1 << 12 | $6_1 >>> 20;
      $8_1 = HEAP32[$5_1 + 656 >> 2];
      $6_1 = $38_1 + $8_1 | 0;
      $25_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$5_1 + 660 >> 2] | 0;
      $24_1 = $6_1;
      $18_1 = $6_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($16_1, $6_1, $18_1, 0, 0, 15632, 16, 0, 0);
      $16_1 = ($7_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 < $21_1 >>> 0 | $7_1 >>> 0 < $12_1 >>> 0;
      $6_1 = ($12_1 | 0) == ($39_1 | 0) & $21_1 >>> 0 < $30_1 >>> 0 | $12_1 >>> 0 < $39_1 >>> 0;
      $3_1 = $34_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $12_1 = $57_1 + 8 | 0;
      $4_1 = $8_1 + HEAP32[$12_1 >> 2] | 0;
      $3_1 = HEAP32[$12_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $4_1 = $4_1 + $6_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $4_1;
      $8_1 = $10_1 >>> 20 | 0;
      $6_1 = $6_1 + $8_1 | 0;
      $3_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $6_1 + $16_1 | 0;
      $6_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $6_1 << 12 | $4_1 >>> 20;
      $7_1 = $4_1 << 12 | $7_1 >>> 20;
      $10_1 = $3_1;
      $26_1 = HEAP32[$5_1 + 912 >> 2];
      $8_1 = HEAP32[$5_1 + 960 >> 2];
      $4_1 = $26_1 + $8_1 | 0;
      $28_1 = HEAP32[$5_1 + 916 >> 2];
      $3_1 = $28_1 + HEAP32[$5_1 + 964 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $21_1 = $4_1;
      $4_1 = HEAP32[$5_1 + 640 >> 2];
      $16_1 = $21_1 + $4_1 | 0;
      $12_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$5_1 + 644 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $10_1 | 0;
      $8_1 = $7_1 + $16_1 | 0;
      $3_1 = $8_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$5_1 + 1480 >> 2] = $8_1;
      $7_1 = $3_1;
      $10_1 = $3_1 & 1048575;
      HEAP32[$5_1 + 1484 >> 2] = $10_1;
      $41_1 = $5_1 + 576 | 0;
      $18_1 = ($18_1 | 0) == ($25_1 | 0) & $24_1 >>> 0 < $38_1 >>> 0 | $18_1 >>> 0 < $25_1 >>> 0;
      $3_1 = $33_1 + 8 | 0;
      $24_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $9_1 = $9_1 >>> 20 | 0;
      $25_1 = $9_1;
      $9_1 = $9_1 + $24_1 | 0;
      $3_1 = $25_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $24_1 = $9_1;
      $9_1 = $9_1 + $18_1 | 0;
      $3_1 = $24_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($41_1, $9_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $18_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $16_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $16_1 = ($4_1 | 0) == ($12_1 | 0) & $16_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 < $12_1 >>> 0;
      $3_1 = $45_1 + 8 | 0;
      $24_1 = HEAP32[$3_1 >> 2];
      $25_1 = HEAP32[$3_1 + 4 >> 2];
      $12_1 = ($12_1 | 0) == ($28_1 | 0) & $21_1 >>> 0 < $26_1 >>> 0 | $12_1 >>> 0 < $28_1 >>> 0;
      $3_1 = $54_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $21_1 = $48_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$21_1 >> 2] | 0;
      $3_1 = HEAP32[$21_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $9_1;
      $9_1 = $9_1 + $12_1 | 0;
      $3_1 = ($3_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $25_1 | 0;
      $4_1 = $9_1 + $24_1 | 0;
      $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $4_1;
      $4_1 = $4_1 + $16_1 | 0;
      $3_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $6_1 >>> 20 | 0;
      $4_1 = $6_1 + $4_1 | 0;
      $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $4_1;
      $4_1 = $4_1 + $18_1 | 0;
      $6_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1;
      $4_1 = $6_1 << 12 | $3_1 >>> 20;
      $7_1 = $3_1 << 12 | $7_1 >>> 20;
      $9_1 = $4_1;
      $18_1 = HEAP32[$5_1 + 576 >> 2];
      $16_1 = $18_1 + ($42_1 & -2) | 0;
      $21_1 = HEAP32[$5_1 + 580 >> 2];
      $3_1 = $21_1 + ($44_1 & 1048575) | 0;
      $4_1 = $16_1 >>> 0 < $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $9_1 | 0;
      $7_1 = $7_1 + $16_1 | 0;
      $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$5_1 + 1488 >> 2] = $7_1;
      $9_1 = $3_1;
      $12_1 = $3_1 & 1048575;
      HEAP32[$5_1 + 1492 >> 2] = $12_1;
      $24_1 = $36_1 & 65535;
      $25_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $16_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $16_1 = ($4_1 | 0) == ($21_1 | 0) & $16_1 >>> 0 < $18_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
      $4_1 = $41_1 + 8 | 0;
      $3_1 = $16_1 + HEAP32[$4_1 >> 2] | 0;
      $4_1 = HEAP32[$4_1 + 4 >> 2];
      $4_1 = $3_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $16_1 = $3_1;
      $3_1 = $4_1;
      $6_1 = $6_1 >>> 20 | 0;
      $4_1 = $6_1 + $16_1 | 0;
      $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $4_1;
      $4_1 = $4_1 + $25_1 | 0;
      $3_1 = $24_1 + (($6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) << 12 | $4_1 >>> 20) | 0;
      $4_1 = $4_1 << 12 | $9_1 >>> 20;
      $6_1 = $4_1 + $13_1 | 0;
      HEAP32[$5_1 + 1496 >> 2] = $6_1;
      $4_1 = $4_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$5_1 + 1500 >> 2] = $4_1;
      $3_1 = HEAP32[$5_1 + 1544 >> 2];
      $9_1 = -5862 - $3_1 | 0;
      $3_1 = 6291449 - (HEAP32[$5_1 + 1548 >> 2] + ($3_1 >>> 0 > 4294961434) | 0) | 0;
      HEAP32[$5_1 + 1424 >> 2] = $9_1;
      HEAP32[$5_1 + 1428 >> 2] = $3_1;
      $3_1 = HEAP32[$65_1 >> 2];
      $9_1 = -6 - $3_1 | 0;
      $3_1 = 6291455 - (HEAP32[$65_1 + 4 >> 2] + ($3_1 >>> 0 > 4294967290) | 0) | 0;
      HEAP32[$5_1 + 1432 >> 2] = $9_1;
      HEAP32[$5_1 + 1436 >> 2] = $3_1;
      $3_1 = HEAP32[$66_1 >> 2];
      $9_1 = -6 - $3_1 | 0;
      $3_1 = 6291455 - (HEAP32[$66_1 + 4 >> 2] + ($3_1 >>> 0 > 4294967290) | 0) | 0;
      HEAP32[$5_1 + 1440 >> 2] = $9_1;
      HEAP32[$5_1 + 1444 >> 2] = $3_1;
      $3_1 = HEAP32[$67_1 >> 2];
      $9_1 = -6 - $3_1 | 0;
      $3_1 = 6291455 - (HEAP32[$67_1 + 4 >> 2] + ($3_1 >>> 0 > 4294967290) | 0) | 0;
      HEAP32[$5_1 + 1448 >> 2] = $9_1;
      HEAP32[$5_1 + 1452 >> 2] = $3_1;
      $3_1 = HEAP32[$61_1 >> 2];
      $9_1 = -6 - $3_1 | 0;
      $3_1 = 393215 - (HEAP32[$61_1 + 4 >> 2] + ($3_1 >>> 0 > 4294967290) | 0) | 0;
      HEAP32[$5_1 + 1456 >> 2] = $9_1;
      HEAP32[$5_1 + 1460 >> 2] = $3_1;
      $16_1 = $23_1;
      $3_1 = $16_1 << 1 | $22_1 >>> 31;
      $54_1 = $5_1 + 528 | 0;
      $9_1 = $12_1;
      $23_1 = $22_1 << 1;
      $12_1 = $3_1;
      $69($54_1, $7_1, $9_1, 0, 0, $23_1, $3_1, 0, 0);
      $33_1 = $5_1 + 592 | 0;
      $13_1 = $8_1;
      $8_1 = $10_1;
      $24_1 = $14_1 << 1;
      $21_1 = $17_1;
      $18_1 = $17_1 << 1 | $14_1 >>> 31;
      $69($33_1, $13_1, $8_1, 0, 0, $24_1, $18_1, 0, 0);
      $25_1 = $5_1 + 496 | 0;
      $69($25_1, $6_1, $4_1, 0, 0, $6_1, $4_1, 0, 0);
      $38_1 = $5_1 + 480 | 0;
      $69($38_1, HEAP32[$5_1 + 496 >> 2], HEAP32[$5_1 + 500 >> 2], 0, 0, 15632, 16, 0, 0);
      $42_1 = $5_1 + 448 | 0;
      $10_1 = $6_1 << 1;
      $17_1 = $4_1 << 1 | $6_1 >>> 31;
      $69($42_1, $10_1, $17_1, 0, 0, $22_1, $16_1, 0, 0);
      $44_1 = $5_1 + 544 | 0;
      $69($44_1, $7_1, $9_1, 0, 0, $24_1, $18_1, 0, 0);
      $36_1 = $5_1 + 608 | 0;
      $69($36_1, $13_1, $8_1, 0, 0, $13_1, $8_1, 0, 0);
      $26_1 = $5_1 + 464 | 0;
      $3_1 = $25_1 + 8 | 0;
      $69($26_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $41_1 = $5_1 + 736 | 0;
      $69($41_1, $22_1, $16_1, 0, 0, $22_1, $16_1, 0, 0);
      $40_1 = $5_1 + 432 | 0;
      $69($40_1, $10_1, $17_1, 0, 0, $14_1, $21_1, 0, 0);
      $35_1 = $5_1 + 512 | 0;
      $24_1 = $7_1;
      $25_1 = $9_1;
      $28_1 = $8_1;
      $22_1 = $13_1;
      $69($35_1, $7_1, $9_1, 0, 0, $13_1 << 1, $8_1 << 1 | $13_1 >>> 31, 0, 0);
      $13_1 = HEAP32[$5_1 + 528 >> 2];
      $7_1 = HEAP32[$5_1 + 592 >> 2];
      $4_1 = $13_1 + $7_1 | 0;
      $9_1 = HEAP32[$5_1 + 532 >> 2];
      $3_1 = $9_1 + HEAP32[$5_1 + 596 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $4_1;
      $8_1 = HEAP32[$5_1 + 480 >> 2];
      $7_1 = $4_1 + $8_1 | 0;
      $4_1 = $3_1 + HEAP32[$5_1 + 484 >> 2] | 0;
      $45_1 = $7_1;
      $7_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $8_1 = ($3_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 > $45_1 >>> 0 | $3_1 >>> 0 > $7_1 >>> 0;
      $4_1 = $38_1 + 8 | 0;
      $16_1 = HEAP32[$4_1 >> 2];
      $18_1 = HEAP32[$4_1 + 4 >> 2];
      $6_1 = ($3_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 < $13_1 >>> 0 | $3_1 >>> 0 < $9_1 >>> 0;
      $3_1 = $33_1 + 8 | 0;
      $9_1 = HEAP32[$3_1 >> 2];
      $13_1 = $54_1 + 8 | 0;
      $4_1 = $9_1 + HEAP32[$13_1 >> 2] | 0;
      $3_1 = HEAP32[$13_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $4_1 + $6_1 | 0;
      $4_1 = ($6_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
      $3_1 = $6_1;
      $6_1 = $6_1 + $16_1 | 0;
      $3_1 = $3_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $6_1 + $8_1 | 0;
      $6_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $6_1 << 12 | $4_1 >>> 20;
      $54_1 = $7_1;
      $33_1 = $4_1 << 12 | $7_1 >>> 20;
      $39_1 = $3_1;
      $37_1 = HEAP32[$5_1 + 544 >> 2];
      $7_1 = HEAP32[$5_1 + 608 >> 2];
      $4_1 = $37_1 + $7_1 | 0;
      $38_1 = HEAP32[$5_1 + 548 >> 2];
      $3_1 = $38_1 + HEAP32[$5_1 + 612 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $4_1 = HEAP32[$5_1 + 448 >> 2];
      $7_1 = $8_1 + $4_1 | 0;
      $13_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$5_1 + 452 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $16_1 = $7_1;
      $9_1 = HEAP32[$5_1 + 464 >> 2];
      $7_1 = $7_1 + $9_1 | 0;
      $4_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$5_1 + 468 >> 2] | 0;
      $9_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $9_1 + $39_1 | 0;
      $39_1 = $5_1 + 416 | 0;
      $18_1 = $7_1;
      $33_1 = $7_1 + $33_1 | 0;
      $7_1 = $7_1 >>> 0 > $33_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $9_1;
      $9_1 = $33_1;
      $33_1 = ($7_1 | 0) == ($3_1 | 0) & $18_1 >>> 0 > $9_1 >>> 0 | $3_1 >>> 0 > $7_1 >>> 0;
      $18_1 = ($3_1 | 0) == ($4_1 | 0) & $16_1 >>> 0 > $18_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $3_1 = $26_1 + 8 | 0;
      $26_1 = HEAP32[$3_1 >> 2];
      $30_1 = HEAP32[$3_1 + 4 >> 2];
      $16_1 = ($4_1 | 0) == ($13_1 | 0) & $8_1 >>> 0 > $16_1 >>> 0 | $4_1 >>> 0 < $13_1 >>> 0;
      $3_1 = $42_1 + 8 | 0;
      $42_1 = HEAP32[$3_1 >> 2];
      $34_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = ($13_1 | 0) == ($38_1 | 0) & $8_1 >>> 0 < $37_1 >>> 0 | $13_1 >>> 0 < $38_1 >>> 0;
      $3_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $38_1 = $44_1 + 8 | 0;
      $13_1 = $4_1 + HEAP32[$38_1 >> 2] | 0;
      $3_1 = HEAP32[$38_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $13_1;
      $13_1 = $8_1 + $13_1 | 0;
      $3_1 = ($3_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $34_1 | 0;
      $4_1 = $13_1 + $42_1 | 0;
      $3_1 = $4_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $4_1 = $4_1 + $16_1 | 0;
      $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $30_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $26_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $4_1 = $4_1 + $18_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $4_1;
      $6_1 = $6_1 >>> 20 | 0;
      $4_1 = $6_1;
      $6_1 = $6_1 + $13_1 | 0;
      $3_1 = $4_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $6_1 + $33_1 | 0;
      $6_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $6_1 << 12 | $4_1 >>> 20;
      $13_1 = $7_1;
      $7_1 = $4_1 << 12 | $7_1 >>> 20;
      $33_1 = $3_1;
      $38_1 = HEAP32[$5_1 + 432 >> 2];
      $4_1 = HEAP32[$5_1 + 512 >> 2];
      $8_1 = $38_1 + $4_1 | 0;
      $18_1 = HEAP32[$5_1 + 436 >> 2];
      $3_1 = $18_1 + HEAP32[$5_1 + 516 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $33_1 | 0;
      $16_1 = $7_1 + $8_1 | 0;
      $3_1 = $16_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $42_1 = $16_1 << 4 & -16;
      $33_1 = $13_1;
      $7_1 = $3_1;
      $69($39_1, $42_1 | $13_1 >>> 16 & 15, ($3_1 << 4 | $16_1 >>> 28) & 16777215, 0, 0, 977, 1, 0, 0);
      $37_1 = $5_1 + 672 | 0;
      $69($37_1, $14_1, $21_1, 0, 0, $23_1, $12_1, 0, 0);
      $42_1 = $5_1 + 400 | 0;
      $69($42_1, $10_1, $17_1, 0, 0, $22_1, $28_1, 0, 0);
      $44_1 = $5_1 + 560 | 0;
      $69($44_1, $24_1, $25_1, 0, 0, $24_1, $25_1, 0, 0);
      $57_1 = $5_1 + 384 | 0;
      $36_1 = $57_1;
      $16_1 = ($4_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $16_1 >>> 0 | $4_1 >>> 0 > $3_1 >>> 0;
      $8_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $38_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
      $3_1 = $35_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $18_1 = $40_1 + 8 | 0;
      $13_1 = $4_1 + HEAP32[$18_1 >> 2] | 0;
      $3_1 = HEAP32[$18_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $8_1 + $13_1 | 0;
      $4_1 = $3_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $13_1 = $3_1;
      $3_1 = $4_1;
      $6_1 = $6_1 >>> 20 | 0;
      $4_1 = $6_1 + $13_1 | 0;
      $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $4_1;
      $4_1 = $4_1 + $16_1 | 0;
      $6_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $6_1 << 12 | $4_1 >>> 20;
      $7_1 = $4_1 << 12 | $7_1 >>> 20;
      $8_1 = $13_1;
      $18_1 = HEAP32[$5_1 + 400 >> 2];
      $13_1 = HEAP32[$5_1 + 560 >> 2];
      $4_1 = $18_1 + $13_1 | 0;
      $16_1 = HEAP32[$5_1 + 404 >> 2];
      $3_1 = $16_1 + HEAP32[$5_1 + 564 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $4_1;
      $4_1 = $3_1 + $8_1 | 0;
      $7_1 = $7_1 + $13_1 | 0;
      $4_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $8_1 = $7_1;
      $7_1 = $4_1;
      $69($36_1, $8_1, $4_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $40_1 = $5_1 + 624 | 0;
      $69($40_1, $22_1, $28_1, 0, 0, $23_1, $12_1, 0, 0);
      $35_1 = $5_1 + 688 | 0;
      $69($35_1, $14_1, $21_1, 0, 0, $14_1, $21_1, 0, 0);
      $12_1 = $5_1 + 368 | 0;
      $69($12_1, $10_1, $17_1, 0, 0, $24_1, $25_1, 0, 0);
      $48_1 = $5_1 + 352 | 0;
      $10_1 = $48_1;
      $8_1 = ($3_1 | 0) == ($4_1 | 0) & $8_1 >>> 0 < $13_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
      $13_1 = ($3_1 | 0) == ($16_1 | 0) & $13_1 >>> 0 < $18_1 >>> 0 | $3_1 >>> 0 < $16_1 >>> 0;
      $3_1 = $44_1 + 8 | 0;
      $14_1 = HEAP32[$3_1 >> 2];
      $17_1 = $42_1 + 8 | 0;
      $4_1 = $14_1 + HEAP32[$17_1 >> 2] | 0;
      $3_1 = HEAP32[$17_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $4_1;
      $4_1 = $4_1 + $13_1 | 0;
      $3_1 = $14_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $4_1;
      $6_1 = $6_1 >>> 20 | 0;
      $4_1 = $6_1;
      $6_1 = $6_1 + $13_1 | 0;
      $3_1 = $4_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $6_1 + $8_1 | 0;
      $6_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $6_1 << 12 | $4_1 >>> 20;
      $13_1 = $4_1 << 12 | $7_1 >>> 20;
      $8_1 = HEAP32[$5_1 + 368 >> 2];
      $7_1 = $13_1 + $8_1 | 0;
      $4_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$5_1 + 372 >> 2] | 0;
      $3_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($10_1, $7_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $50_1 = $5_1 + 336 | 0;
      $8_1 = $50_1;
      $13_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $3_1 = $12_1 + 8 | 0;
      $10_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $7_1 = $6_1 >>> 20 | 0;
      $4_1 = $7_1 + $10_1 | 0;
      $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $4_1;
      $4_1 = $4_1 + $13_1 | 0;
      $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($8_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $3_1 = $5_1 + 1424 | 0;
      $34($3_1, $3_1, $5_1 + 1464 | 0);
      $3_1 = HEAP32[$5_1 + 1348 >> 2];
      $16_1 = $3_1;
      $18_1 = HEAP32[$5_1 + 1344 >> 2];
      $6_1 = $18_1;
      $3_1 = $3_1 << 1 | $6_1 >>> 31;
      $21_1 = $5_1 - -64 | 0;
      $4_1 = HEAP32[$5_1 + 1368 >> 2];
      $7_1 = HEAP32[$5_1 + 1372 >> 2];
      $17_1 = $6_1 << 1;
      $14_1 = $3_1;
      $69($21_1, $4_1, $7_1, 0, 0, $17_1, $3_1, 0, 0);
      $3_1 = HEAP32[$5_1 + 1356 >> 2];
      $44_1 = $3_1;
      $36_1 = HEAP32[$5_1 + 1352 >> 2];
      $8_1 = $36_1;
      $3_1 = $3_1 << 1 | $8_1 >>> 31;
      $42_1 = $5_1 + 272 | 0;
      $6_1 = HEAP32[$5_1 + 1360 >> 2];
      $13_1 = HEAP32[$5_1 + 1364 >> 2];
      $23_1 = $8_1 << 1;
      $10_1 = $3_1;
      $69($42_1, $6_1, $13_1, 0, 0, $23_1, $3_1, 0, 0);
      $24_1 = $5_1 + 224 | 0;
      $3_1 = HEAP32[$5_1 + 1376 >> 2];
      $8_1 = HEAP32[$5_1 + 1380 >> 2];
      $69($24_1, $3_1, $8_1, 0, 0, $3_1, $8_1, 0, 0);
      $26_1 = $5_1 + 208 | 0;
      $69($26_1, HEAP32[$5_1 + 224 >> 2], HEAP32[$5_1 + 228 >> 2], 0, 0, 15632, 16, 0, 0);
      $12_1 = $8_1 << 1;
      $8_1 = $3_1;
      $3_1 = $12_1 | $3_1 >>> 31;
      $30_1 = $5_1 + 176 | 0;
      $12_1 = $8_1 << 1;
      $22_1 = $3_1;
      $69($30_1, $12_1, $3_1, 0, 0, $18_1, $16_1, 0, 0);
      $34_1 = $5_1 + 80 | 0;
      $69($34_1, $4_1, $7_1, 0, 0, $23_1, $10_1, 0, 0);
      $31_1 = $5_1 + 256 | 0;
      $69($31_1, $6_1, $13_1, 0, 0, $6_1, $13_1, 0, 0);
      $32_1 = $5_1 + 192 | 0;
      $3_1 = $24_1 + 8 | 0;
      $69($32_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $51_1 = $5_1 + 320 | 0;
      $69($51_1, $18_1, $16_1, 0, 0, $18_1, $16_1, 0, 0);
      $43_1 = $5_1 + 160 | 0;
      $69($43_1, $12_1, $22_1, 0, 0, $36_1, $44_1, 0, 0);
      $46_1 = $5_1 + 96 | 0;
      $24_1 = $4_1;
      $25_1 = $7_1;
      $28_1 = $13_1;
      $23_1 = $6_1;
      $69($46_1, $4_1, $7_1, 0, 0, $6_1 << 1, $13_1 << 1 | $6_1 >>> 31, 0, 0);
      $10_1 = HEAP32[$5_1 + 64 >> 2];
      $7_1 = HEAP32[$5_1 + 272 >> 2];
      $4_1 = $10_1 + $7_1 | 0;
      $8_1 = HEAP32[$5_1 + 68 >> 2];
      $3_1 = $8_1 + HEAP32[$5_1 + 276 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $4_1;
      $4_1 = HEAP32[$5_1 + 208 >> 2];
      $13_1 = $6_1 + $4_1 | 0;
      $7_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$5_1 + 212 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $38_1 = $13_1;
      $13_1 = ($7_1 | 0) == ($4_1 | 0) & $13_1 >>> 0 < $6_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
      $3_1 = $26_1 + 8 | 0;
      $16_1 = HEAP32[$3_1 >> 2];
      $18_1 = HEAP32[$3_1 + 4 >> 2];
      $6_1 = ($7_1 | 0) == ($8_1 | 0) & $6_1 >>> 0 < $10_1 >>> 0 | $7_1 >>> 0 < $8_1 >>> 0;
      $3_1 = $42_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $10_1 = $21_1 + 8 | 0;
      $7_1 = $8_1 + HEAP32[$10_1 >> 2] | 0;
      $3_1 = HEAP32[$10_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $7_1;
      $7_1 = $6_1 + $7_1 | 0;
      $3_1 = ($8_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
      $6_1 = $7_1;
      $7_1 = $7_1 + $16_1 | 0;
      $3_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $7_1;
      $7_1 = $7_1 + $13_1 | 0;
      $6_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $6_1 << 12 | $7_1 >>> 20;
      $42_1 = $4_1;
      $7_1 = $7_1 << 12 | $4_1 >>> 20;
      $53_1 = HEAP32[$5_1 + 80 >> 2];
      $8_1 = HEAP32[$5_1 + 256 >> 2];
      $4_1 = $53_1 + $8_1 | 0;
      $26_1 = HEAP32[$5_1 + 84 >> 2];
      $3_1 = $26_1 + HEAP32[$5_1 + 260 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $16_1 = $4_1;
      $10_1 = HEAP32[$5_1 + 176 >> 2];
      $4_1 = $4_1 + $10_1 | 0;
      $8_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$5_1 + 180 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $18_1 = $4_1;
      $21_1 = HEAP32[$5_1 + 192 >> 2];
      $4_1 = $4_1 + $21_1 | 0;
      $10_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$5_1 + 196 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $21_1 = $4_1;
      $4_1 = $3_1;
      $3_1 = $3_1 + $13_1 | 0;
      $13_1 = $7_1 + $21_1 | 0;
      $7_1 = $13_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $49_1 = ($4_1 | 0) == ($7_1 | 0) & $13_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $21_1 = ($4_1 | 0) == ($10_1 | 0) & $18_1 >>> 0 > $21_1 >>> 0 | $4_1 >>> 0 < $10_1 >>> 0;
      $3_1 = $32_1 + 8 | 0;
      $32_1 = HEAP32[$3_1 >> 2];
      $55_1 = HEAP32[$3_1 + 4 >> 2];
      $10_1 = ($8_1 | 0) == ($10_1 | 0) & $16_1 >>> 0 > $18_1 >>> 0 | $8_1 >>> 0 > $10_1 >>> 0;
      $3_1 = $30_1 + 8 | 0;
      $18_1 = HEAP32[$3_1 >> 2];
      $30_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = ($8_1 | 0) == ($26_1 | 0) & $16_1 >>> 0 < $53_1 >>> 0 | $8_1 >>> 0 < $26_1 >>> 0;
      $3_1 = $31_1 + 8 | 0;
      $16_1 = HEAP32[$3_1 >> 2];
      $26_1 = $34_1 + 8 | 0;
      $4_1 = $16_1 + HEAP32[$26_1 >> 2] | 0;
      $3_1 = HEAP32[$26_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $16_1 = $4_1;
      $4_1 = $4_1 + $8_1 | 0;
      $3_1 = ($16_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $30_1 | 0;
      $8_1 = $4_1 + $18_1 | 0;
      $4_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $8_1;
      $8_1 = $8_1 + $10_1 | 0;
      $3_1 = ($3_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $55_1 | 0;
      $4_1 = $8_1 + $32_1 | 0;
      $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $4_1 = $4_1 + $21_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $6_1 >>> 20 | 0;
      $4_1 = $6_1 + $4_1 | 0;
      $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $4_1;
      $4_1 = $4_1 + $49_1 | 0;
      $6_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1;
      $10_1 = $6_1 << 12 | $3_1 >>> 20;
      $4_1 = $7_1;
      $16_1 = $3_1 << 12 | $4_1 >>> 20;
      $26_1 = HEAP32[$5_1 + 160 >> 2];
      $8_1 = HEAP32[$5_1 + 96 >> 2];
      $7_1 = $26_1 + $8_1 | 0;
      $21_1 = HEAP32[$5_1 + 164 >> 2];
      $3_1 = $21_1 + HEAP32[$5_1 + 100 >> 2] | 0;
      $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $8_1 + $10_1 | 0;
      $10_1 = $7_1;
      $16_1 = $7_1 + $16_1 | 0;
      $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $30_1 = $16_1 << 4 & -16;
      $18_1 = $4_1;
      $7_1 = $3_1;
      $69($5_1, $30_1 | $4_1 >>> 16 & 15, ($3_1 << 4 | $16_1 >>> 28) & 16777215, 0, 0, 977, 1, 0, 0);
      $31_1 = $5_1 + 304 | 0;
      $69($31_1, $36_1, $44_1, 0, 0, $17_1, $14_1, 0, 0);
      $30_1 = $5_1 + 144 | 0;
      $69($30_1, $12_1, $22_1, 0, 0, $23_1, $28_1, 0, 0);
      $34_1 = $5_1 + 112 | 0;
      $69($34_1, $24_1, $25_1, 0, 0, $24_1, $25_1, 0, 0);
      $32_1 = $5_1 + 48 | 0;
      $16_1 = ($3_1 | 0) == ($8_1 | 0) & $10_1 >>> 0 > $16_1 >>> 0 | $3_1 >>> 0 < $8_1 >>> 0;
      $10_1 = ($8_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $26_1 >>> 0 | $8_1 >>> 0 < $21_1 >>> 0;
      $3_1 = $46_1 + 8 | 0;
      $21_1 = HEAP32[$3_1 >> 2];
      $4_1 = $43_1 + 8 | 0;
      $8_1 = $21_1 + HEAP32[$4_1 >> 2] | 0;
      $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $8_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $8_1 + $10_1 | 0;
      $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $6_1 >>> 20 | 0;
      $4_1 = $4_1 + $6_1 | 0;
      $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $4_1;
      $4_1 = $4_1 + $16_1 | 0;
      $6_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $6_1 << 12 | $4_1 >>> 20;
      $7_1 = $4_1 << 12 | $7_1 >>> 20;
      $3_1 = $8_1;
      $21_1 = HEAP32[$5_1 + 144 >> 2];
      $10_1 = HEAP32[$5_1 + 112 >> 2];
      $8_1 = $21_1 + $10_1 | 0;
      $16_1 = HEAP32[$5_1 + 148 >> 2];
      $4_1 = $16_1 + HEAP32[$5_1 + 116 >> 2] | 0;
      $4_1 = $8_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $3_1 = $4_1 + $3_1 | 0;
      $7_1 = $7_1 + $8_1 | 0;
      $3_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $7_1;
      $7_1 = $3_1;
      $69($32_1, $10_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $26_1 = $5_1 + 240 | 0;
      $69($26_1, $23_1, $28_1, 0, 0, $17_1, $14_1, 0, 0);
      $43_1 = $5_1 + 288 | 0;
      $69($43_1, $36_1, $44_1, 0, 0, $36_1, $44_1, 0, 0);
      $14_1 = $5_1 + 128 | 0;
      $69($14_1, $12_1, $22_1, 0, 0, $24_1, $25_1, 0, 0);
      $36_1 = $5_1 + 32 | 0;
      $12_1 = $36_1;
      $10_1 = ($3_1 | 0) == ($4_1 | 0) & $8_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $8_1 = ($4_1 | 0) == ($16_1 | 0) & $8_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
      $3_1 = $34_1 + 8 | 0;
      $17_1 = HEAP32[$3_1 >> 2];
      $22_1 = $30_1 + 8 | 0;
      $4_1 = $17_1 + HEAP32[$22_1 >> 2] | 0;
      $3_1 = HEAP32[$22_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $16_1 = $4_1;
      $4_1 = $4_1 + $8_1 | 0;
      $3_1 = $16_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $6_1 >>> 20 | 0;
      $8_1 = $6_1;
      $6_1 = $4_1 + $6_1 | 0;
      $4_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $6_1 + $10_1 | 0;
      $4_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $8_1 = $4_1 << 12 | $3_1 >>> 20;
      $10_1 = $3_1 << 12 | $7_1 >>> 20;
      $17_1 = HEAP32[$5_1 + 128 >> 2];
      $7_1 = $10_1 + $17_1 | 0;
      $6_1 = $8_1;
      $3_1 = $6_1 + HEAP32[$5_1 + 132 >> 2] | 0;
      $3_1 = $7_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($12_1, $7_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $46_1 = $5_1 + 16 | 0;
      $8_1 = $46_1;
      $6_1 = ($3_1 | 0) == ($6_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $3_1 >>> 0 < $6_1 >>> 0;
      $3_1 = $14_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $4_1 = $4_1 >>> 20 | 0;
      $7_1 = $4_1 + $7_1 | 0;
      $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $6_1 + $7_1 | 0;
      $4_1 = $3_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $69($8_1, $3_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
      $34($0_1 + 80 | 0, $69_1, $79);
      $69_1 = HEAP32[$1_1 + 120 >> 2];
      $7_1 = $0_1;
      $0_1 = HEAP32[$5_1 + 1424 >> 2];
      $16_1 = $0_1;
      $3_1 = HEAP32[$5_1 + 1428 >> 2];
      $21_1 = $3_1;
      $6_1 = $0_1;
      $8_1 = $3_1;
      $14_1 = HEAP32[$5_1 >> 2];
      $0_1 = HEAP32[$5_1 + 320 >> 2];
      $4_1 = $14_1 + $0_1 | 0;
      $12_1 = HEAP32[$5_1 + 4 >> 2];
      $3_1 = $12_1 + HEAP32[$5_1 + 324 >> 2] | 0;
      $0_1 = $0_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $8_1 + ($0_1 & 1048575) | 0;
      $6_1 = $4_1 + $6_1 | 0;
      $3_1 = $6_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$7_1 >> 2] = $6_1;
      $8_1 = $3_1;
      HEAP32[$7_1 + 4 >> 2] = $3_1;
      $30_1 = $7_1 + 8 | 0;
      $24_1 = $30_1;
      $3_1 = HEAP32[$5_1 + 1432 >> 2];
      $22_1 = $3_1;
      $10_1 = HEAP32[$5_1 + 1436 >> 2];
      $23_1 = $10_1;
      $10_1 = ($0_1 | 0) == ($12_1 | 0) & $4_1 >>> 0 < $14_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
      $3_1 = $51_1 + 8 | 0;
      $12_1 = HEAP32[$3_1 >> 2];
      $14_1 = $5_1 + 8 | 0;
      $4_1 = $12_1 + HEAP32[$14_1 >> 2] | 0;
      $3_1 = HEAP32[$14_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $4_1;
      $4_1 = $4_1 + $10_1 | 0;
      $10_1 = $12_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $10_1 << 12 | $4_1 >>> 20;
      $0_1 = $4_1 << 12 | $0_1 >>> 20;
      $4_1 = $12_1;
      $51_1 = HEAP32[$5_1 + 48 >> 2];
      $12_1 = HEAP32[$5_1 + 304 >> 2];
      $14_1 = $51_1 + $12_1 | 0;
      $28_1 = HEAP32[$5_1 + 52 >> 2];
      $3_1 = $28_1 + HEAP32[$5_1 + 308 >> 2] | 0;
      $12_1 = $12_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $12_1 + $4_1 | 0;
      $3_1 = $0_1 + $14_1 | 0;
      $0_1 = $3_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $17_1 = $3_1;
      $4_1 = $22_1 + $3_1 | 0;
      $3_1 = $23_1 + ($0_1 & 1048575) | 0;
      HEAP32[$24_1 >> 2] = $4_1;
      $3_1 = $4_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$24_1 + 4 >> 2] = $3_1;
      $24_1 = $3_1 << 1;
      $3_1 = $4_1;
      $4_1 = $24_1 | $3_1 >>> 31;
      $24_1 = $3_1 << 1;
      $3_1 = $4_1 + $23_1 | 0;
      $4_1 = $22_1 + $24_1 | 0;
      $3_1 = $4_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$65_1 >> 2] = $4_1;
      HEAP32[$65_1 + 4 >> 2] = $3_1;
      $34_1 = $7_1 + 16 | 0;
      $3_1 = HEAP32[$5_1 + 1440 >> 2];
      $24_1 = $3_1;
      $4_1 = HEAP32[$5_1 + 1444 >> 2];
      $25_1 = $4_1;
      $17_1 = ($0_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 > $17_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
      $12_1 = ($12_1 | 0) == ($28_1 | 0) & $14_1 >>> 0 < $51_1 >>> 0 | $12_1 >>> 0 < $28_1 >>> 0;
      $3_1 = $31_1 + 8 | 0;
      $14_1 = HEAP32[$3_1 >> 2];
      $22_1 = $32_1 + 8 | 0;
      $4_1 = $14_1 + HEAP32[$22_1 >> 2] | 0;
      $3_1 = HEAP32[$22_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $4_1;
      $4_1 = $4_1 + $12_1 | 0;
      $3_1 = $14_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $4_1;
      $10_1 = $10_1 >>> 20 | 0;
      $4_1 = $10_1;
      $10_1 = $10_1 + $12_1 | 0;
      $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $10_1 + $17_1 | 0;
      $10_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $10_1 << 12 | $4_1 >>> 20;
      $14_1 = $4_1 << 12 | $0_1 >>> 20;
      $31_1 = $3_1;
      $32_1 = HEAP32[$5_1 + 240 >> 2];
      $4_1 = HEAP32[$5_1 + 288 >> 2];
      $0_1 = $32_1 + $4_1 | 0;
      $28_1 = HEAP32[$5_1 + 244 >> 2];
      $3_1 = $28_1 + HEAP32[$5_1 + 292 >> 2] | 0;
      $3_1 = $0_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $17_1 = $0_1;
      $4_1 = HEAP32[$5_1 + 32 >> 2];
      $0_1 = $0_1 + $4_1 | 0;
      $12_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$5_1 + 36 >> 2] | 0;
      $4_1 = $0_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $31_1 | 0;
      $22_1 = $0_1;
      $14_1 = $0_1 + $14_1 | 0;
      $0_1 = $0_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $25_1 + ($0_1 & 1048575) | 0;
      $23_1 = $14_1;
      $14_1 = $24_1 + $14_1 | 0;
      HEAP32[$34_1 >> 2] = $14_1;
      $3_1 = $14_1 >>> 0 < $23_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$34_1 + 4 >> 2] = $3_1;
      $3_1 = ($3_1 << 1 | $14_1 >>> 31) + $25_1 | 0;
      $14_1 = $14_1 << 1;
      $25_1 = $14_1;
      $14_1 = $14_1 + $24_1 | 0;
      $3_1 = $25_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$66_1 >> 2] = $14_1;
      HEAP32[$66_1 + 4 >> 2] = $3_1;
      $31_1 = $7_1 + 24 | 0;
      $3_1 = HEAP32[$5_1 + 1448 >> 2];
      $14_1 = HEAP32[$5_1 + 1452 >> 2];
      $24_1 = $3_1;
      $25_1 = $14_1;
      $14_1 = ($0_1 | 0) == ($4_1 | 0) & $22_1 >>> 0 > $23_1 >>> 0 | $0_1 >>> 0 < $4_1 >>> 0;
      $22_1 = ($4_1 | 0) == ($12_1 | 0) & $17_1 >>> 0 > $22_1 >>> 0 | $4_1 >>> 0 < $12_1 >>> 0;
      $3_1 = $36_1 + 8 | 0;
      $23_1 = HEAP32[$3_1 >> 2];
      $36_1 = HEAP32[$3_1 + 4 >> 2];
      $17_1 = ($12_1 | 0) == ($28_1 | 0) & $17_1 >>> 0 < $32_1 >>> 0 | $12_1 >>> 0 < $28_1 >>> 0;
      $3_1 = $43_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $28_1 = $26_1 + 8 | 0;
      $12_1 = $4_1 + HEAP32[$28_1 >> 2] | 0;
      $3_1 = HEAP32[$28_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $12_1;
      $12_1 = $12_1 + $17_1 | 0;
      $3_1 = ($3_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $36_1 | 0;
      $4_1 = $12_1 + $23_1 | 0;
      $3_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $4_1;
      $4_1 = $4_1 + $22_1 | 0;
      $3_1 = $12_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $10_1 >>> 20 | 0;
      $4_1 = $10_1 + $4_1 | 0;
      $3_1 = $10_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $4_1;
      $4_1 = $4_1 + $14_1 | 0;
      $10_1 = $10_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1;
      $4_1 = $10_1 << 12 | $3_1 >>> 20;
      $17_1 = $3_1 << 12 | $0_1 >>> 20;
      $36_1 = HEAP32[$5_1 + 16 >> 2];
      $12_1 = $38_1 & -2;
      $0_1 = $36_1 + $12_1 | 0;
      $28_1 = HEAP32[$5_1 + 20 >> 2];
      $3_1 = $28_1 + ($42_1 & 1048575) | 0;
      $12_1 = $0_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $12_1 + $4_1 | 0;
      $14_1 = $0_1;
      $17_1 = $0_1 + $17_1 | 0;
      $0_1 = $0_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $25_1 + ($0_1 & 1048575) | 0;
      $4_1 = $17_1 + $24_1 | 0;
      $3_1 = $4_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$31_1 >> 2] = $4_1;
      HEAP32[$31_1 + 4 >> 2] = $3_1;
      $22_1 = $4_1 << 1;
      $4_1 = ($3_1 << 1 | $4_1 >>> 31) + $25_1 | 0;
      $3_1 = $22_1 + $24_1 | 0;
      $4_1 = $3_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$67_1 >> 2] = $3_1;
      HEAP32[$67_1 + 4 >> 2] = $4_1;
      $32_1 = $7_1 + 32 | 0;
      $25_1 = $32_1;
      $3_1 = HEAP32[$5_1 + 1456 >> 2];
      $4_1 = HEAP32[$5_1 + 1460 >> 2];
      $22_1 = $3_1;
      $23_1 = $4_1;
      $24_1 = $13_1;
      $18_1 = $18_1 & 65535;
      $17_1 = ($0_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 > $17_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
      $13_1 = ($12_1 | 0) == ($28_1 | 0) & $14_1 >>> 0 < $36_1 >>> 0 | $12_1 >>> 0 < $28_1 >>> 0;
      $3_1 = $46_1 + 8 | 0;
      $4_1 = $13_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $4_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $10_1 >>> 20 | 0;
      $13_1 = $4_1 + $10_1 | 0;
      $4_1 = $10_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $13_1;
      $13_1 = $13_1 + $17_1 | 0;
      $3_1 = ($3_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 12 | $13_1 >>> 20;
      $4_1 = $13_1 << 12 | $0_1 >>> 20;
      $0_1 = $4_1 + $24_1 | 0;
      $3_1 = $3_1 + $18_1 | 0;
      $3_1 = ($0_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $23_1 | 0;
      $4_1 = $0_1;
      $0_1 = $0_1 + $22_1 | 0;
      $3_1 = $4_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$25_1 >> 2] = $0_1;
      HEAP32[$25_1 + 4 >> 2] = $3_1;
      $3_1 = ($3_1 << 1 | $0_1 >>> 31) + $23_1 | 0;
      $0_1 = $0_1 << 1;
      $4_1 = $0_1;
      $0_1 = $0_1 + $22_1 | 0;
      $3_1 = $4_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$61_1 >> 2] = $0_1;
      HEAP32[$61_1 + 4 >> 2] = $3_1;
      $13_1 = $5_1;
      $3_1 = ($8_1 << 1 | $6_1 >>> 31) + $21_1 | 0;
      $0_1 = $6_1 << 1;
      $4_1 = $0_1;
      $0_1 = $0_1 + $16_1 | 0;
      $3_1 = $4_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$5_1 + 1544 >> 2] = $0_1;
      HEAP32[$5_1 + 1548 >> 2] = $3_1;
      $0_1 = $41_1 + 8 | 0;
      $12_1 = HEAP32[$0_1 >> 2];
      $62_1 = HEAP32[$0_1 + 4 >> 2];
      $0_1 = $39_1 + 8 | 0;
      $71 = HEAP32[$0_1 >> 2];
      $72 = HEAP32[$0_1 + 4 >> 2];
      $0_1 = HEAP32[$5_1 + 736 >> 2];
      $3_1 = HEAP32[$5_1 + 740 >> 2];
      $14_1 = HEAP32[$5_1 + 416 >> 2];
      $6_1 = HEAP32[$5_1 + 420 >> 2];
      $4_1 = $37_1 + 8 | 0;
      $73 = HEAP32[$4_1 >> 2];
      $74 = HEAP32[$4_1 + 4 >> 2];
      $4_1 = $57_1 + 8 | 0;
      $17_1 = HEAP32[$4_1 >> 2];
      $60_1 = HEAP32[$4_1 + 4 >> 2];
      $26_1 = HEAP32[$5_1 + 672 >> 2];
      $68_1 = HEAP32[$5_1 + 676 >> 2];
      $41_1 = HEAP32[$5_1 + 384 >> 2];
      $5_1 = HEAP32[$5_1 + 388 >> 2];
      $4_1 = $35_1 + 8 | 0;
      $64_1 = HEAP32[$4_1 >> 2];
      $70_1 = HEAP32[$4_1 + 4 >> 2];
      $4_1 = $40_1 + 8 | 0;
      $51_1 = HEAP32[$4_1 >> 2];
      $75 = HEAP32[$4_1 + 4 >> 2];
      $43_1 = HEAP32[$13_1 + 688 >> 2];
      $76 = HEAP32[$13_1 + 692 >> 2];
      $46_1 = HEAP32[$13_1 + 624 >> 2];
      $57_1 = HEAP32[$13_1 + 628 >> 2];
      $4_1 = $48_1 + 8 | 0;
      $22_1 = HEAP32[$4_1 >> 2];
      $23_1 = HEAP32[$4_1 + 4 >> 2];
      $53_1 = HEAP32[$13_1 + 352 >> 2];
      $77 = HEAP32[$13_1 + 356 >> 2];
      $49_1 = HEAP32[$13_1 + 336 >> 2];
      $48_1 = HEAP32[$13_1 + 340 >> 2];
      $4_1 = $50_1 + 8 | 0;
      $78 = HEAP32[$4_1 >> 2];
      $16_1 = HEAP32[$4_1 + 4 >> 2];
      $40_1 = $7_1 + 104 | 0;
      $18_1 = HEAP32[$40_1 >> 2];
      $21_1 = HEAP32[$40_1 + 4 >> 2];
      $35_1 = $7_1 + 96 | 0;
      $24_1 = HEAP32[$35_1 >> 2];
      $25_1 = HEAP32[$35_1 + 4 >> 2];
      $39_1 = $7_1 + 88 | 0;
      $28_1 = HEAP32[$39_1 >> 2];
      $38_1 = HEAP32[$39_1 + 4 >> 2];
      $37_1 = $7_1 + 112 | 0;
      $42_1 = HEAP32[$37_1 >> 2];
      $8_1 = HEAP32[$37_1 + 4 >> 2];
      $44_1 = HEAP32[$7_1 + 80 >> 2];
      $36_1 = HEAP32[$7_1 + 84 >> 2];
      $34($63_1, $63_1, $13_1 + 1344 | 0);
      $10_1 = HEAP32[$13_1 + 1544 >> 2];
      $50_1 = HEAP32[$13_1 + 1548 >> 2];
      $3_1 = $3_1 + $6_1 | 0;
      $4_1 = $0_1 + $14_1 | 0;
      $0_1 = $4_1 >>> 0 < $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $55_1 = $10_1;
      $3_1 = $4_1;
      $10_1 = $29_1 ? $19_1 : $3_1;
      $19_1 = $55_1 + $10_1 | 0;
      $4_1 = $50_1 + ($29_1 ? $11_1 : $0_1 & 1048575) | 0;
      $63_1 = 8388599 - (($19_1 >>> 0 > 4294959480) + ($10_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0) | 0;
      $50_1 = -7816 - $19_1 | 0;
      $4_1 = $50_1 & 1;
      $55_1 = 0 - $4_1 | 0;
      $10_1 = 0 - $4_1 | 0;
      $6_1 = ($0_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 < $14_1 >>> 0 | $0_1 >>> 0 < $6_1 >>> 0;
      $3_1 = $62_1 + $72 | 0;
      $11_1 = $12_1 + $71 | 0;
      $4_1 = $11_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $6_1 + $11_1 | 0;
      $4_1 = $3_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $4_1 << 12 | $3_1 >>> 20;
      $0_1 = $3_1 << 12 | $0_1 >>> 20;
      $19_1 = $6_1;
      $3_1 = $5_1 + $68_1 | 0;
      $6_1 = $26_1 + $41_1 | 0;
      $11_1 = $6_1 >>> 0 < $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $11_1 + $19_1 | 0;
      $19_1 = $0_1 + $6_1 | 0;
      $0_1 = $19_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $26_1 = $19_1;
      $19_1 = ($11_1 | 0) == ($0_1 | 0) & $19_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 < $11_1 >>> 0;
      $6_1 = ($5_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 < $41_1 >>> 0 | $5_1 >>> 0 > $11_1 >>> 0;
      $3_1 = $60_1 + $74 | 0;
      $11_1 = $17_1 + $73 | 0;
      $3_1 = $11_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $11_1;
      $11_1 = $6_1 + $11_1 | 0;
      $3_1 = $12_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $11_1 = $4_1 + $11_1 | 0;
      $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $11_1 + $19_1 | 0;
      $6_1 = $3_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $11_1 = $6_1 << 12 | $3_1 >>> 20;
      $41_1 = $0_1;
      $0_1 = $3_1 << 12 | $0_1 >>> 20;
      $3_1 = $57_1 + $76 | 0;
      $12_1 = $43_1 + $46_1 | 0;
      $4_1 = $12_1 >>> 0 < $43_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $77 + $4_1 | 0;
      $5_1 = $12_1 + $53_1 | 0;
      $19_1 = $5_1 >>> 0 < $53_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $19_1 + $11_1 | 0;
      $14_1 = $0_1 + $5_1 | 0;
      $11_1 = $14_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $0_1 = $45_1 & -2;
      $17_1 = $0_1 + $49_1 | 0;
      $3_1 = $48_1 + ($54_1 & 1048575) | 0;
      $0_1 = $0_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $45_1 = ($11_1 | 0) == ($19_1 | 0) & $5_1 >>> 0 > $14_1 >>> 0 | $11_1 >>> 0 < $19_1 >>> 0;
      $5_1 = ($4_1 | 0) == ($19_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $4_1 >>> 0 > $19_1 >>> 0;
      $12_1 = ($4_1 | 0) == ($57_1 | 0) & $12_1 >>> 0 < $46_1 >>> 0 | $4_1 >>> 0 < $57_1 >>> 0;
      $4_1 = $70_1 + $75 | 0;
      $19_1 = $51_1 + $64_1 | 0;
      $3_1 = $19_1 >>> 0 < $51_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $12_1 + $19_1 | 0;
      $3_1 = ($4_1 >>> 0 < $19_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $23_1 | 0;
      $12_1 = $4_1;
      $4_1 = $4_1 + $22_1 | 0;
      $3_1 = $12_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $4_1;
      $4_1 = $4_1 + $5_1 | 0;
      $3_1 = $12_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $6_1 >>> 20 | 0;
      $12_1 = $6_1;
      $6_1 = $4_1 + $6_1 | 0;
      $4_1 = $12_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $6_1 + $45_1 | 0;
      $4_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $3_1;
      $3_1 = $0_1 + ($4_1 << 12 | $3_1 >>> 20) | 0;
      $12_1 = $11_1;
      $6_1 = $6_1 << 12 | $11_1 >>> 20;
      $11_1 = $6_1 + $17_1 | 0;
      $19_1 = $11_1;
      $11_1 = $6_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $22_1 = $7_1 + 72 | 0;
      $6_1 = $10_1;
      $3_1 = $6_1 >>> 16 | 0;
      $5_1 = ($6_1 & 65535) << 16 | $55_1 >>> 16;
      $10_1 = $3_1;
      $23_1 = HEAP32[$61_1 >> 2];
      $61_1 = HEAP32[$61_1 + 4 >> 2];
      $45_1 = $33_1 & 65535;
      $54_1 = ($0_1 | 0) == ($11_1 | 0) & $17_1 >>> 0 > $19_1 >>> 0 | $0_1 >>> 0 > $11_1 >>> 0;
      $17_1 = ($0_1 | 0) == ($48_1 | 0) & $17_1 >>> 0 < $49_1 >>> 0 | $0_1 >>> 0 < $48_1 >>> 0;
      $0_1 = $78 + $17_1 | 0;
      $3_1 = $16_1;
      $3_1 = $0_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $0_1 = $0_1 + $4_1 | 0;
      $4_1 = $4_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $0_1;
      $0_1 = $0_1 + $54_1 | 0;
      $4_1 = ($3_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 12 | $0_1 >>> 20;
      $17_1 = $11_1;
      $11_1 = $0_1 << 12 | $11_1 >>> 20;
      $0_1 = $11_1 + $9_1 | 0;
      $3_1 = $4_1 + $45_1 | 0;
      $3_1 = $0_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $29_1 ? $47_1 : $0_1;
      $0_1 = $4_1 + $23_1 | 0;
      $3_1 = $61_1 + ($29_1 ? $56_1 : $3_1) | 0;
      $3_1 = ($10_1 - (($0_1 >>> 0 > $5_1 >>> 0) + ($0_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) | 0) | 0) + 524287 | 0;
      $0_1 = ($5_1 - $0_1 | 0) - 8 | 0;
      $4_1 = $0_1 >>> 0 < 4294967288 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 >>> 1 | 0;
      $5_1 = ($4_1 & 1) << 31 | $0_1 >>> 1;
      HEAP32[$22_1 >> 2] = $5_1;
      $9_1 = $3_1;
      HEAP32[$22_1 + 4 >> 2] = $3_1;
      $23_1 = $7_1 - -64 | 0;
      $10_1 = $23_1;
      $47_1 = $0_1 << 19 & 524288;
      $11_1 = ($6_1 & 4095) << 20 | $55_1 >>> 12;
      $0_1 = $6_1 >>> 12 | 0;
      $6_1 = $29_1 ? $52_1 : $19_1;
      $4_1 = $6_1 + HEAP32[$67_1 >> 2] | 0;
      $3_1 = HEAP32[$67_1 + 4 >> 2] + ($29_1 ? $15_1 : $17_1 & 1048575) | 0;
      $3_1 = ($0_1 - (($4_1 >>> 0 > $11_1 >>> 0) + ($4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) | 0) | 0) + 8388607 | 0;
      $6_1 = ($11_1 - $4_1 | 0) - 8 | 0;
      $15_1 = $6_1 >>> 0 < 4294967288 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = ($15_1 >>> 1 | 0) + $47_1 | 0;
      $19_1 = ($15_1 & 1) << 31 | $6_1 >>> 1;
      $3_1 = $19_1;
      $4_1 = $3_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$10_1 >> 2] = $3_1;
      $47_1 = $4_1;
      HEAP32[$10_1 + 4 >> 2] = $4_1;
      $17_1 = $7_1 + 56 | 0;
      $10_1 = $17_1;
      $16_1 = $6_1 << 19 & 524288;
      $6_1 = $29_1 ? $58_1 : $14_1;
      $4_1 = $6_1 + HEAP32[$66_1 >> 2] | 0;
      $3_1 = HEAP32[$66_1 + 4 >> 2] + ($29_1 ? $20_1 : $12_1 & 1048575) | 0;
      $3_1 = ($0_1 - (($4_1 >>> 0 > $11_1 >>> 0) + ($4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) | 0) | 0) + 8388607 | 0;
      $4_1 = ($11_1 - $4_1 | 0) - 8 | 0;
      $6_1 = $4_1 >>> 0 < 4294967288 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = ($6_1 >>> 1 | 0) + $16_1 | 0;
      $15_1 = ($6_1 & 1) << 31 | $4_1 >>> 1;
      $3_1 = $15_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$10_1 >> 2] = $15_1;
      $20_1 = $3_1;
      HEAP32[$10_1 + 4 >> 2] = $3_1;
      $14_1 = $7_1 + 48 | 0;
      $12_1 = $4_1 << 19 & 524288;
      $6_1 = $11_1;
      $10_1 = $0_1;
      $3_1 = $29_1 ? $59_1 : $26_1;
      $0_1 = $3_1 + HEAP32[$65_1 >> 2] | 0;
      $4_1 = HEAP32[$65_1 + 4 >> 2] + ($29_1 ? $27_1 : $41_1 & 1048575) | 0;
      $3_1 = ($10_1 - (($0_1 >>> 0 > $6_1 >>> 0) + ($0_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0) | 0) + 8388607 | 0;
      $0_1 = ($6_1 - $0_1 | 0) - 8 | 0;
      $11_1 = $0_1 >>> 0 < 4294967288 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = ($11_1 >>> 1 | 0) + $12_1 | 0;
      $27_1 = ($11_1 & 1) << 31 | $0_1 >>> 1;
      $4_1 = $27_1;
      $3_1 = $4_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$14_1 >> 2] = $4_1;
      $12_1 = $3_1;
      HEAP32[$14_1 + 4 >> 2] = $3_1;
      $11_1 = $0_1 << 19 & 524288;
      $3_1 = ($10_1 & 1048574) + $63_1 | 0;
      $0_1 = ($6_1 & -977) + $50_1 | 0;
      $3_1 = $0_1 >>> 0 < $50_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $0_1 = ($3_1 & 1) << 31 | $0_1 >>> 1;
      $3_1 = ($3_1 >>> 1 | 0) + $11_1 | 0;
      $11_1 = $0_1;
      $3_1 = $0_1 >>> 0 < $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$7_1 + 40 >> 2] = $0_1;
      HEAP32[$7_1 + 44 >> 2] = $3_1;
      $1_1 = HEAP32[$1_1 + 120 >> 2];
      $6_1 = $1_1 >> 31;
      $0_1 = $1_1 - 1 | 0;
      $16_1 = $0_1;
      $4_1 = 0 - ((($1_1 | 0) != 0) + $6_1 | 0) | 0;
      $10_1 = $6_1 - !$1_1 | 0;
      $6_1 = $4_1 & HEAP32[$2_1 + 4 >> 2] | $10_1 & HEAP32[$7_1 + 4 >> 2];
      $1_1 = 0 - $1_1 | 0;
      HEAP32[$7_1 >> 2] = $1_1 & HEAP32[$2_1 >> 2] | $0_1 & HEAP32[$7_1 >> 2];
      HEAP32[$7_1 + 4 >> 2] = $6_1;
      $6_1 = HEAP32[$2_1 + 12 >> 2] & $4_1 | HEAP32[$30_1 + 4 >> 2] & $10_1;
      HEAP32[$30_1 >> 2] = HEAP32[$2_1 + 8 >> 2] & $1_1 | HEAP32[$30_1 >> 2] & $0_1;
      HEAP32[$30_1 + 4 >> 2] = $6_1;
      $6_1 = HEAP32[$2_1 + 20 >> 2] & $4_1 | HEAP32[$34_1 + 4 >> 2] & $10_1;
      HEAP32[$34_1 >> 2] = HEAP32[$2_1 + 16 >> 2] & $1_1 | HEAP32[$34_1 >> 2] & $0_1;
      HEAP32[$34_1 + 4 >> 2] = $6_1;
      $6_1 = HEAP32[$2_1 + 28 >> 2] & $4_1 | HEAP32[$31_1 + 4 >> 2] & $10_1;
      HEAP32[$31_1 >> 2] = HEAP32[$2_1 + 24 >> 2] & $1_1 | HEAP32[$31_1 >> 2] & $0_1;
      HEAP32[$31_1 + 4 >> 2] = $6_1;
      $6_1 = HEAP32[$2_1 + 36 >> 2] & $4_1 | HEAP32[$32_1 + 4 >> 2] & $10_1;
      HEAP32[$32_1 >> 2] = HEAP32[$2_1 + 32 >> 2] & $1_1 | HEAP32[$32_1 >> 2] & $0_1;
      HEAP32[$32_1 + 4 >> 2] = $6_1;
      $3_1 = HEAP32[$2_1 + 44 >> 2] & $4_1 | $3_1 & $10_1;
      HEAP32[$7_1 + 40 >> 2] = HEAP32[$2_1 + 40 >> 2] & $1_1 | $0_1 & $11_1;
      HEAP32[$7_1 + 44 >> 2] = $3_1;
      $3_1 = $2_1 + 48 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2] & $4_1 | $10_1 & $12_1;
      HEAP32[$14_1 >> 2] = $1_1 & $11_1 | $0_1 & $27_1;
      HEAP32[$14_1 + 4 >> 2] = $3_1;
      $3_1 = $2_1 + 56 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2] & $4_1 | $10_1 & $20_1;
      HEAP32[$17_1 >> 2] = $1_1 & $11_1 | $0_1 & $15_1;
      HEAP32[$17_1 + 4 >> 2] = $3_1;
      $3_1 = $2_1 - -64 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2] & $4_1 | $10_1 & $47_1;
      HEAP32[$23_1 >> 2] = $1_1 & $11_1 | $0_1 & $19_1;
      HEAP32[$23_1 + 4 >> 2] = $3_1;
      $2_1 = $2_1 + 72 | 0;
      $3_1 = HEAP32[$2_1 >> 2];
      $2_1 = HEAP32[$2_1 + 4 >> 2] & $4_1 | $9_1 & $10_1;
      HEAP32[$22_1 >> 2] = $1_1 & $3_1 | $0_1 & $5_1;
      HEAP32[$22_1 + 4 >> 2] = $2_1;
      $2_1 = $10_1 & HEAP32[$7_1 + 84 >> 2];
      HEAP32[$7_1 + 80 >> 2] = HEAP32[$7_1 + 80 >> 2] & $0_1 | $1_1 & 1;
      HEAP32[$7_1 + 84 >> 2] = $2_1;
      $1_1 = HEAP32[$39_1 + 4 >> 2] & $10_1;
      HEAP32[$39_1 >> 2] = HEAP32[$39_1 >> 2] & $0_1;
      HEAP32[$39_1 + 4 >> 2] = $1_1;
      $1_1 = HEAP32[$35_1 + 4 >> 2] & $10_1;
      HEAP32[$35_1 >> 2] = HEAP32[$35_1 >> 2] & $0_1;
      HEAP32[$35_1 + 4 >> 2] = $1_1;
      $1_1 = HEAP32[$40_1 + 4 >> 2] & $10_1;
      HEAP32[$40_1 >> 2] = HEAP32[$40_1 >> 2] & $0_1;
      HEAP32[$40_1 + 4 >> 2] = $1_1;
      $19_1 = HEAP32[$37_1 >> 2];
      $5_1 = HEAP32[$37_1 + 4 >> 2];
      $20_1 = $7_1;
      $12_1 = $8_1 & 65535;
      $1_1 = __wasm_i64_mul($8_1 >>> 16 | 0, 0, 977, 1);
      $0_1 = $1_1 + $44_1 | 0;
      $3_1 = $36_1 + i64toi32_i32$HIGH_BITS | 0;
      $1_1 = $0_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $2_1 = $1_1 >>> 20 | 0;
      $3_1 = $38_1;
      $4_1 = $2_1;
      $2_1 = $2_1 + $28_1 | 0;
      $11_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $25_1;
      $4_1 = $11_1 >>> 20 | 0;
      $7_1 = $4_1 + $24_1 | 0;
      $6_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $21_1;
      $4_1 = $6_1 >>> 20 | 0;
      $15_1 = $4_1 + $18_1 | 0;
      $9_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $12_1;
      $27_1 = $9_1 >>> 20 | 0;
      $3_1 = $27_1 + $42_1 | 0;
      $4_1 = $27_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      if ($3_1 | ($15_1 | ($0_1 | $2_1 | $7_1)) | ($4_1 | ($1_1 | $11_1 | $6_1 | $9_1) & 1048575)) {
        if (($2_1 & ($0_1 ^ 976) & $7_1 & $15_1 & $3_1) == -1) {
          $0_1 = ($11_1 & ($1_1 ^ 1) & $6_1 & $9_1 & ($4_1 ^ 983040)) == 1048575;
        } else {
          $0_1 = 0;
        }
      } else {
        $0_1 = 1;
      }
      HEAP32[$20_1 + 120 >> 2] = $0_1 & ($69_1 ^ -1);
      HEAP32[$37_1 >> 2] = $16_1 & $19_1;
      HEAP32[$37_1 + 4 >> 2] = $5_1 & $10_1;
      global$0 = $13_1 + 1744 | 0;
    }
    function $54($0_1, $1_1) {
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0;
      $4_1 = global$0 - 336 | 0;
      global$0 = $4_1;
      $2_1 = HEAP32[$1_1 + 4 >> 2];
      $19_1 = $2_1;
      $15_1 = HEAP32[$1_1 >> 2];
      $3_1 = $15_1;
      $2_1 = $2_1 << 1 | $3_1 >>> 31;
      $10_1 = $4_1 - -64 | 0;
      $14_1 = HEAP32[$1_1 + 24 >> 2];
      $13_1 = HEAP32[$1_1 + 28 >> 2];
      $25_1 = $3_1 << 1;
      $29_1 = $2_1;
      $69($10_1, $14_1, $13_1, 0, 0, $25_1, $2_1, 0, 0);
      $2_1 = HEAP32[$1_1 + 12 >> 2];
      $35_1 = $2_1;
      $30_1 = HEAP32[$1_1 + 8 >> 2];
      $3_1 = $30_1;
      $2_1 = $2_1 << 1 | $3_1 >>> 31;
      $8_1 = $4_1 + 272 | 0;
      $18_1 = HEAP32[$1_1 + 16 >> 2];
      $12_1 = HEAP32[$1_1 + 20 >> 2];
      $3_1 = $3_1 << 1;
      $5_1 = $2_1;
      $69($8_1, $18_1, $12_1, 0, 0, $3_1, $2_1, 0, 0);
      $7_1 = $4_1 + 224 | 0;
      $6_1 = HEAP32[$1_1 + 32 >> 2];
      $1_1 = HEAP32[$1_1 + 36 >> 2];
      $69($7_1, $6_1, $1_1, 0, 0, $6_1, $1_1, 0, 0);
      $9_1 = $4_1 + 208 | 0;
      $69($9_1, HEAP32[$4_1 + 224 >> 2], HEAP32[$4_1 + 228 >> 2], 0, 0, 15632, 16, 0, 0);
      $2_1 = $1_1 << 1 | $6_1 >>> 31;
      $31_1 = $4_1 + 176 | 0;
      $21_1 = $6_1 << 1;
      $32_1 = $2_1;
      $69($31_1, $21_1, $2_1, 0, 0, $15_1, $19_1, 0, 0);
      $33_1 = $4_1 + 80 | 0;
      $69($33_1, $14_1, $13_1, 0, 0, $3_1, $5_1, 0, 0);
      $34_1 = $4_1 + 256 | 0;
      $69($34_1, $18_1, $12_1, 0, 0, $18_1, $12_1, 0, 0);
      $11_1 = $4_1 + 192 | 0;
      $1_1 = $7_1 + 8 | 0;
      $69($11_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $37_1 = $4_1 + 320 | 0;
      $69($37_1, $15_1, $19_1, 0, 0, $15_1, $19_1, 0, 0);
      $26_1 = $4_1 + 160 | 0;
      $69($26_1, $21_1, $2_1, 0, 0, $30_1, $35_1, 0, 0);
      $27_1 = $4_1 + 96 | 0;
      $69($27_1, $14_1, $13_1, 0, 0, $18_1 << 1, $12_1 << 1 | $18_1 >>> 31, 0, 0);
      $15_1 = HEAP32[$4_1 + 68 >> 2];
      $2_1 = $15_1 + HEAP32[$4_1 + 276 >> 2] | 0;
      $6_1 = HEAP32[$4_1 + 64 >> 2];
      $1_1 = HEAP32[$4_1 + 272 >> 2];
      $3_1 = $6_1 + $1_1 | 0;
      $5_1 = HEAP32[$4_1 + 208 >> 2];
      $36_1 = $3_1 + $5_1 | 0;
      $1_1 = $1_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $1_1 + HEAP32[$4_1 + 212 >> 2] | 0;
      $5_1 = $5_1 >>> 0 > $36_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $7_1 = ($1_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 > $36_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
      $2_1 = $9_1 + 8 | 0;
      $9_1 = HEAP32[$2_1 >> 2];
      $23_1 = HEAP32[$2_1 + 4 >> 2];
      $6_1 = ($1_1 | 0) == ($15_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
      $2_1 = $8_1 + 8 | 0;
      $3_1 = HEAP32[$2_1 >> 2];
      $1_1 = $10_1 + 8 | 0;
      $8_1 = $3_1 + HEAP32[$1_1 >> 2] | 0;
      $2_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
      $2_1 = $3_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $6_1 + $8_1 | 0;
      $2_1 = ($1_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $23_1 | 0;
      $3_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $3_1 = $1_1;
      $1_1 = $1_1 + $7_1 | 0;
      $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $19_1 = $5_1;
      $23_1 = $1_1 << 12 | $5_1 >>> 20;
      $3_1 = $2_1;
      $6_1 = $2_1 << 12 | $1_1 >>> 20;
      $20_1 = HEAP32[$4_1 + 80 >> 2];
      $1_1 = HEAP32[$4_1 + 256 >> 2];
      $7_1 = $20_1 + $1_1 | 0;
      $28_1 = HEAP32[$4_1 + 84 >> 2];
      $2_1 = $28_1 + HEAP32[$4_1 + 260 >> 2] | 0;
      $2_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = HEAP32[$4_1 + 176 >> 2];
      $9_1 = $1_1 + $7_1 | 0;
      $10_1 = $2_1;
      $2_1 = $2_1 + HEAP32[$4_1 + 180 >> 2] | 0;
      $2_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = HEAP32[$4_1 + 192 >> 2];
      $5_1 = $1_1 + $9_1 | 0;
      $8_1 = $2_1;
      $2_1 = $2_1 + HEAP32[$4_1 + 196 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $1_1 + $6_1 | 0;
      $23_1 = $5_1 + $23_1 | 0;
      $6_1 = $23_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $22_1 = ($1_1 | 0) == ($6_1 | 0) & $5_1 >>> 0 > $23_1 >>> 0 | $1_1 >>> 0 > $6_1 >>> 0;
      $24_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 < $8_1 >>> 0;
      $1_1 = $11_1 + 8 | 0;
      $17_1 = HEAP32[$1_1 >> 2];
      $16_1 = HEAP32[$1_1 + 4 >> 2];
      $15_1 = ($8_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $8_1 >>> 0 < $10_1 >>> 0;
      $1_1 = $31_1 + 8 | 0;
      $11_1 = HEAP32[$1_1 >> 2];
      $8_1 = HEAP32[$1_1 + 4 >> 2];
      $9_1 = ($10_1 | 0) == ($28_1 | 0) & $7_1 >>> 0 < $20_1 >>> 0 | $10_1 >>> 0 < $28_1 >>> 0;
      $2_1 = $34_1 + 8 | 0;
      $5_1 = HEAP32[$2_1 >> 2];
      $1_1 = $33_1 + 8 | 0;
      $7_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $2_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
      $2_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $7_1 + $9_1 | 0;
      $2_1 = ($1_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $8_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $11_1 | 0;
      $2_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $15_1 | 0;
      $2_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $16_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $17_1 | 0;
      $2_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $5_1 = $1_1 + $24_1 | 0;
      $2_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $3_1 = $3_1 >>> 20 | 0;
      $1_1 = $3_1 + $5_1 | 0;
      $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $3_1 = $1_1;
      $1_1 = $1_1 + $22_1 | 0;
      $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $3_1 = $6_1;
      $7_1 = $1_1 << 12 | $3_1 >>> 20;
      $5_1 = $2_1;
      $9_1 = $2_1 << 12 | $1_1 >>> 20;
      $17_1 = HEAP32[$4_1 + 160 >> 2];
      $1_1 = HEAP32[$4_1 + 96 >> 2];
      $6_1 = $17_1 + $1_1 | 0;
      $20_1 = HEAP32[$4_1 + 164 >> 2];
      $2_1 = $20_1 + HEAP32[$4_1 + 100 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $1_1 + $9_1 | 0;
      $11_1 = $6_1;
      $6_1 = $6_1 + $7_1 | 0;
      $7_1 = $6_1 << 4 & -16;
      $8_1 = $6_1 >>> 0 < $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $9_1 = ($8_1 << 4 | $6_1 >>> 28) & 16777215;
      $15_1 = $3_1;
      $69($4_1, $7_1 | $3_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
      $22_1 = HEAP32[$4_1 + 4 >> 2];
      $2_1 = $22_1 + HEAP32[$4_1 + 324 >> 2] | 0;
      $9_1 = $0_1;
      $24_1 = HEAP32[$4_1 >> 2];
      $0_1 = HEAP32[$4_1 + 320 >> 2];
      $10_1 = $24_1 + $0_1 | 0;
      HEAP32[$9_1 >> 2] = $10_1;
      $7_1 = $0_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$9_1 + 4 >> 2] = $7_1 & 1048575;
      $28_1 = $4_1 + 304 | 0;
      $69($28_1, $30_1, $35_1, 0, 0, $25_1, $29_1, 0, 0);
      $31_1 = $4_1 + 144 | 0;
      $69($31_1, $21_1, $32_1, 0, 0, $18_1, $12_1, 0, 0);
      $33_1 = $4_1 + 112 | 0;
      $69($33_1, $14_1, $13_1, 0, 0, $14_1, $13_1, 0, 0);
      $34_1 = $4_1 + 48 | 0;
      $16_1 = $34_1;
      $6_1 = ($1_1 | 0) == ($8_1 | 0) & $6_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
      $3_1 = ($1_1 | 0) == ($20_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $1_1 >>> 0 < $20_1 >>> 0;
      $2_1 = $27_1 + 8 | 0;
      $1_1 = HEAP32[$2_1 >> 2];
      $0_1 = $26_1 + 8 | 0;
      $11_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
      $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
      $2_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $3_1 + $11_1 | 0;
      $2_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $3_1 = $5_1 >>> 20 | 0;
      $0_1 = $1_1 + $3_1 | 0;
      $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $0_1;
      $0_1 = $0_1 + $6_1 | 0;
      $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $8_1 = $0_1 << 12 | $8_1 >>> 20;
      $6_1 = $2_1;
      $5_1 = $2_1 << 12 | $0_1 >>> 20;
      $26_1 = HEAP32[$4_1 + 148 >> 2];
      $2_1 = $26_1 + HEAP32[$4_1 + 116 >> 2] | 0;
      $20_1 = HEAP32[$4_1 + 144 >> 2];
      $1_1 = HEAP32[$4_1 + 112 >> 2];
      $0_1 = $20_1 + $1_1 | 0;
      $17_1 = $0_1;
      $11_1 = $0_1 + $8_1 | 0;
      $3_1 = $0_1 >>> 0 < $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $3_1 + $5_1 | 0;
      $8_1 = $11_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $69($16_1, $11_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $5_1 = ($7_1 | 0) == ($22_1 | 0) & $10_1 >>> 0 < $24_1 >>> 0 | $7_1 >>> 0 < $22_1 >>> 0;
      $2_1 = $37_1 + 8 | 0;
      $1_1 = HEAP32[$2_1 >> 2];
      $0_1 = $4_1 + 8 | 0;
      $10_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
      $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
      $2_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = $5_1 + $10_1 | 0;
      $2_1 = $0_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $10_1 = $0_1 << 12 | $7_1 >>> 20;
      $5_1 = $2_1;
      $7_1 = $2_1 << 12 | $0_1 >>> 20;
      $22_1 = HEAP32[$4_1 + 48 >> 2];
      $0_1 = HEAP32[$4_1 + 304 >> 2];
      $16_1 = $22_1 + $0_1 | 0;
      $27_1 = HEAP32[$4_1 + 52 >> 2];
      $2_1 = $27_1 + HEAP32[$4_1 + 308 >> 2] | 0;
      $1_1 = $0_1 >>> 0 > $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $1_1 + $7_1 | 0;
      $10_1 = $10_1 + $16_1 | 0;
      $2_1 = $10_1 >>> 0 < $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$9_1 + 8 >> 2] = $10_1;
      $7_1 = $2_1;
      HEAP32[$9_1 + 12 >> 2] = $2_1 & 1048575;
      $24_1 = $4_1 + 240 | 0;
      $69($24_1, $18_1, $12_1, 0, 0, $25_1, $29_1, 0, 0);
      $29_1 = $4_1 + 288 | 0;
      $69($29_1, $30_1, $35_1, 0, 0, $30_1, $35_1, 0, 0);
      $25_1 = $4_1 + 128 | 0;
      $69($25_1, $21_1, $32_1, 0, 0, $14_1, $13_1, 0, 0);
      $32_1 = $4_1 + 32 | 0;
      $13_1 = $32_1;
      $12_1 = ($3_1 | 0) == ($8_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
      $11_1 = ($3_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $20_1 >>> 0 | $3_1 >>> 0 < $26_1 >>> 0;
      $2_1 = $33_1 + 8 | 0;
      $3_1 = HEAP32[$2_1 >> 2];
      $0_1 = $31_1 + 8 | 0;
      $14_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
      $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
      $2_1 = $3_1 >>> 0 > $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $3_1 = $11_1 + $14_1 | 0;
      $2_1 = $3_1 >>> 0 < $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $6_1 = $6_1 >>> 20 | 0;
      $0_1 = $3_1 + $6_1 | 0;
      $2_1 = $6_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $3_1 = $0_1;
      $0_1 = $0_1 + $12_1 | 0;
      $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $18_1 = $0_1 << 12 | $8_1 >>> 20;
      $6_1 = HEAP32[$4_1 + 128 >> 2];
      $8_1 = $18_1 + $6_1 | 0;
      $3_1 = $2_1;
      $21_1 = $2_1 << 12 | $0_1 >>> 20;
      $2_1 = $21_1 + HEAP32[$4_1 + 132 >> 2] | 0;
      $11_1 = $6_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $69($13_1, $8_1, $11_1, 0, 0, 15632, 16, 0, 0);
      $6_1 = $9_1;
      $10_1 = ($1_1 | 0) == ($7_1 | 0) & $10_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
      $9_1 = ($1_1 | 0) == ($27_1 | 0) & $16_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
      $2_1 = $28_1 + 8 | 0;
      $1_1 = HEAP32[$2_1 >> 2];
      $0_1 = $34_1 + 8 | 0;
      $12_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
      $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
      $2_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $9_1 + $12_1 | 0;
      $2_1 = $1_1 >>> 0 < $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $5_1 = $5_1 >>> 20 | 0;
      $0_1 = $1_1 + $5_1 | 0;
      $2_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $0_1;
      $0_1 = $0_1 + $10_1 | 0;
      $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $9_1 = $0_1 << 12 | $7_1 >>> 20;
      $1_1 = $2_1;
      $13_1 = $2_1 << 12 | $0_1 >>> 20;
      $16_1 = HEAP32[$4_1 + 240 >> 2];
      $0_1 = HEAP32[$4_1 + 288 >> 2];
      $7_1 = $16_1 + $0_1 | 0;
      $17_1 = HEAP32[$4_1 + 244 >> 2];
      $2_1 = $17_1 + HEAP32[$4_1 + 292 >> 2] | 0;
      $12_1 = $0_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $12_1 + HEAP32[$4_1 + 36 >> 2] | 0;
      $0_1 = HEAP32[$4_1 + 32 >> 2];
      $5_1 = $0_1 + $7_1 | 0;
      $10_1 = $5_1;
      $9_1 = $5_1 + $9_1 | 0;
      $0_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $0_1 + $13_1 | 0;
      HEAP32[$6_1 + 16 >> 2] = $9_1;
      $5_1 = $9_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$6_1 + 20 >> 2] = $5_1 & 1048575;
      $14_1 = $4_1 + 16 | 0;
      $13_1 = ($11_1 | 0) == ($21_1 | 0) & $8_1 >>> 0 < $18_1 >>> 0 | $11_1 >>> 0 < $21_1 >>> 0;
      $2_1 = $25_1 + 8 | 0;
      $11_1 = HEAP32[$2_1 >> 2];
      $2_1 = HEAP32[$2_1 + 4 >> 2];
      $3_1 = $3_1 >>> 20 | 0;
      $8_1 = $3_1;
      $3_1 = $3_1 + $11_1 | 0;
      $2_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $8_1 = $3_1;
      $3_1 = $3_1 + $13_1 | 0;
      $2_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $69($14_1, $3_1, $2_1, 0, 0, 64028672, 65536, 0, 0);
      $3_1 = $6_1;
      $13_1 = ($0_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 > $5_1 >>> 0;
      $11_1 = ($0_1 | 0) == ($12_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
      $0_1 = $32_1 + 8 | 0;
      $10_1 = HEAP32[$0_1 >> 2];
      $8_1 = HEAP32[$0_1 + 4 >> 2];
      $9_1 = ($12_1 | 0) == ($17_1 | 0) & $7_1 >>> 0 < $16_1 >>> 0 | $12_1 >>> 0 < $17_1 >>> 0;
      $2_1 = $29_1 + 8 | 0;
      $6_1 = HEAP32[$2_1 >> 2];
      $0_1 = $24_1 + 8 | 0;
      $7_1 = $6_1 + HEAP32[$0_1 >> 2] | 0;
      $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
      $2_1 = $7_1 >>> 0 < $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = $7_1 + $9_1 | 0;
      $2_1 = ($0_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $8_1 | 0;
      $6_1 = $0_1;
      $0_1 = $0_1 + $10_1 | 0;
      $2_1 = $6_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $6_1 = $0_1 + $11_1 | 0;
      $2_1 = $6_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $1_1 >>> 20 | 0;
      $0_1 = $1_1 + $6_1 | 0;
      $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $0_1;
      $0_1 = $0_1 + $13_1 | 0;
      $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $6_1 = $0_1 << 12 | $5_1 >>> 20;
      $1_1 = $2_1;
      $5_1 = $2_1 << 12 | $0_1 >>> 20;
      $11_1 = HEAP32[$4_1 + 16 >> 2];
      $0_1 = $36_1 & -2;
      $9_1 = $11_1 + $0_1 | 0;
      $2_1 = $19_1 & 1048575;
      $19_1 = HEAP32[$4_1 + 20 >> 2];
      $2_1 = $2_1 + $19_1 | 0;
      $7_1 = $0_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $7_1 + $5_1 | 0;
      $5_1 = $6_1 + $9_1 | 0;
      $2_1 = $5_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$3_1 + 24 >> 2] = $5_1;
      $0_1 = $2_1;
      HEAP32[$3_1 + 28 >> 2] = $2_1 & 1048575;
      $6_1 = $3_1;
      $10_1 = $15_1 & 65535;
      $8_1 = ($2_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 < $9_1 >>> 0 | $2_1 >>> 0 < $7_1 >>> 0;
      $3_1 = ($7_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $11_1 >>> 0 | $7_1 >>> 0 < $19_1 >>> 0;
      $2_1 = $14_1 + 8 | 0;
      $5_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
      $2_1 = HEAP32[$2_1 + 4 >> 2];
      $2_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $1_1 >>> 20 | 0;
      $3_1 = $1_1;
      $1_1 = $1_1 + $5_1 | 0;
      $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $3_1 = $1_1;
      $1_1 = $1_1 + $8_1 | 0;
      $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = $1_1 << 12 | $0_1 >>> 20;
      $3_1 = $0_1 + $23_1 | 0;
      $2_1 = $10_1 + ($2_1 << 12 | $1_1 >>> 20) | 0;
      HEAP32[$6_1 + 32 >> 2] = $3_1;
      HEAP32[$6_1 + 36 >> 2] = $0_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      global$0 = $4_1 + 336 | 0;
    }
    function $55($0_1, $1_1) {
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0, $51_1 = 0, $52_1 = 0, $53_1 = 0, $54_1 = 0, $55_1 = 0, $56_1 = 0, $57_1 = 0, $58_1 = 0, $59_1 = 0, $60_1 = 0;
      $4_1 = global$0 - 464 | 0;
      global$0 = $4_1;
      HEAP32[$0_1 + 120 >> 2] = HEAP32[$1_1 + 120 >> 2];
      $2_1 = $1_1 + 40 | 0;
      $34($0_1 + 80 | 0, $1_1 + 80 | 0, $2_1);
      $54($4_1 + 384 | 0, $2_1);
      $33_1 = $4_1 + 424 | 0;
      $54($33_1, $1_1);
      $15_1 = HEAP32[$4_1 + 388 >> 2];
      $16_1 = HEAP32[$4_1 + 384 >> 2];
      HEAP32[$4_1 + 344 >> 2] = -3908 - $16_1;
      HEAP32[$4_1 + 348 >> 2] = 4194299 - (($16_1 >>> 0 > 4294963388) + $15_1 | 0);
      $13_1 = HEAP32[$4_1 + 396 >> 2];
      $19_1 = HEAP32[$4_1 + 392 >> 2];
      HEAP32[$4_1 + 352 >> 2] = -4 - $19_1;
      HEAP32[$4_1 + 356 >> 2] = 4194303 - (($19_1 >>> 0 > 4294967292) + $13_1 | 0);
      $21_1 = HEAP32[$4_1 + 404 >> 2];
      $18_1 = HEAP32[$4_1 + 400 >> 2];
      HEAP32[$4_1 + 360 >> 2] = -4 - $18_1;
      HEAP32[$4_1 + 364 >> 2] = 4194303 - (($18_1 >>> 0 > 4294967292) + $21_1 | 0);
      $10_1 = HEAP32[$4_1 + 412 >> 2];
      $7_1 = HEAP32[$4_1 + 408 >> 2];
      HEAP32[$4_1 + 368 >> 2] = -4 - $7_1;
      HEAP32[$4_1 + 372 >> 2] = 4194303 - (($7_1 >>> 0 > 4294967292) + $10_1 | 0);
      $6_1 = __wasm_i64_mul(HEAP32[$4_1 + 456 >> 2], HEAP32[$4_1 + 460 >> 2], 3, 0);
      $5_1 = i64toi32_i32$HIGH_BITS;
      $20_1 = __wasm_i64_mul(HEAP32[$4_1 + 424 >> 2], HEAP32[$4_1 + 428 >> 2], 3, 0);
      $9_1 = i64toi32_i32$HIGH_BITS;
      $2_1 = $20_1 & 1;
      $3_1 = 0 - $2_1 | 0;
      $12_1 = $3_1;
      $11_1 = 0 - $2_1 | 0;
      $2_1 = ($11_1 >>> 16 | 0) + $5_1 | 0;
      $3_1 = ($11_1 & 65535) << 16 | $3_1 >>> 16;
      $5_1 = $3_1 + $6_1 | 0;
      $2_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$4_1 + 456 >> 2] = ($2_1 & 1) << 31 | $5_1 >>> 1;
      HEAP32[$4_1 + 460 >> 2] = $2_1 >>> 1;
      $8_1 = $5_1 << 19 & 524288;
      $6_1 = $11_1 >>> 12 | 0;
      $12_1 = ($11_1 & 4095) << 20 | $12_1 >>> 12;
      $3_1 = __wasm_i64_mul(HEAP32[$4_1 + 448 >> 2], HEAP32[$4_1 + 452 >> 2], 3, 0);
      $5_1 = $12_1 + $3_1 | 0;
      $2_1 = $6_1 + i64toi32_i32$HIGH_BITS | 0;
      $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = ($3_1 >>> 1 | 0) + $8_1 | 0;
      $11_1 = ($3_1 & 1) << 31 | $5_1 >>> 1;
      $2_1 = $11_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$4_1 + 448 >> 2] = $11_1;
      HEAP32[$4_1 + 452 >> 2] = $2_1;
      $11_1 = $5_1 << 19 & 524288;
      $5_1 = __wasm_i64_mul(HEAP32[$4_1 + 440 >> 2], HEAP32[$4_1 + 444 >> 2], 3, 0) + $12_1 | 0;
      $3_1 = i64toi32_i32$HIGH_BITS + $6_1 | 0;
      $3_1 = $5_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $2_1 = ($3_1 >>> 1 | 0) + $11_1 | 0;
      $8_1 = ($3_1 & 1) << 31 | $5_1 >>> 1;
      $2_1 = $8_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$4_1 + 440 >> 2] = $8_1;
      HEAP32[$4_1 + 444 >> 2] = $2_1;
      $8_1 = $5_1 << 19 & 524288;
      $3_1 = __wasm_i64_mul(HEAP32[$4_1 + 432 >> 2], HEAP32[$4_1 + 436 >> 2], 3, 0);
      $11_1 = $3_1 + $12_1 | 0;
      $2_1 = $6_1 + i64toi32_i32$HIGH_BITS | 0;
      $5_1 = $3_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = ($5_1 >>> 1 | 0) + $8_1 | 0;
      $22_1 = ($5_1 & 1) << 31 | $11_1 >>> 1;
      $3_1 = $22_1;
      $2_1 = $3_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$4_1 + 432 >> 2] = $3_1;
      HEAP32[$4_1 + 436 >> 2] = $2_1;
      $11_1 = $11_1 << 19 & 524288;
      $2_1 = ($6_1 & 1048574) + $9_1 | 0;
      $5_1 = ($12_1 & -977) + $20_1 | 0;
      $2_1 = $5_1 >>> 0 < $20_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $5_1 = ($2_1 & 1) << 31 | $5_1 >>> 1;
      $2_1 = ($2_1 >>> 1 | 0) + $11_1 | 0;
      $3_1 = $5_1;
      $2_1 = $3_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$4_1 + 424 >> 2] = $3_1;
      HEAP32[$4_1 + 428 >> 2] = $2_1;
      $9_1 = HEAP32[$4_1 + 420 >> 2];
      $8_1 = HEAP32[$4_1 + 416 >> 2];
      HEAP32[$4_1 + 376 >> 2] = -4 - $8_1;
      HEAP32[$4_1 + 380 >> 2] = 262143 - (($8_1 >>> 0 > 4294967292) + $9_1 | 0);
      $34_1 = $4_1 + 344 | 0;
      $34($34_1, $34_1, $1_1);
      $54($0_1, $33_1);
      $1_1 = HEAP32[$4_1 + 376 >> 2];
      $51_1 = $1_1;
      $2_1 = HEAP32[$4_1 + 380 >> 2];
      $52_1 = $2_1;
      $2_1 = HEAP32[$0_1 + 36 >> 2] + ($2_1 << 1 | $1_1 >>> 31) | 0;
      $1_1 = $1_1 << 1;
      $3_1 = $1_1;
      $1_1 = $1_1 + HEAP32[$0_1 + 32 >> 2] | 0;
      $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $38_1 = $1_1;
      HEAP32[$0_1 + 32 >> 2] = $1_1;
      $29_1 = $2_1;
      HEAP32[$0_1 + 36 >> 2] = $2_1;
      $6_1 = $0_1;
      $5_1 = HEAP32[$0_1 + 24 >> 2];
      $0_1 = HEAP32[$4_1 + 368 >> 2];
      $53_1 = $0_1;
      $1_1 = HEAP32[$4_1 + 372 >> 2];
      $54_1 = $1_1;
      $2_1 = HEAP32[$6_1 + 28 >> 2] + ($1_1 << 1 | $0_1 >>> 31) | 0;
      $0_1 = $0_1 << 1;
      $1_1 = $0_1;
      $0_1 = $0_1 + $5_1 | 0;
      $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $39_1 = $0_1;
      HEAP32[$6_1 + 24 >> 2] = $0_1;
      $35_1 = $2_1;
      HEAP32[$6_1 + 28 >> 2] = $2_1;
      $0_1 = HEAP32[$4_1 + 360 >> 2];
      $55_1 = $0_1;
      $1_1 = HEAP32[$4_1 + 364 >> 2];
      $56_1 = $1_1;
      $2_1 = HEAP32[$6_1 + 20 >> 2] + ($1_1 << 1 | $0_1 >>> 31) | 0;
      $0_1 = $0_1 << 1;
      $1_1 = $0_1;
      $0_1 = $0_1 + HEAP32[$6_1 + 16 >> 2] | 0;
      $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $40_1 = $0_1;
      HEAP32[$6_1 + 16 >> 2] = $0_1;
      $36_1 = $2_1;
      HEAP32[$6_1 + 20 >> 2] = $2_1;
      $0_1 = HEAP32[$4_1 + 352 >> 2];
      $57_1 = $0_1;
      $1_1 = HEAP32[$4_1 + 356 >> 2];
      $58_1 = $1_1;
      $3_1 = HEAP32[$6_1 + 12 >> 2] + ($1_1 << 1 | $0_1 >>> 31) | 0;
      $0_1 = $0_1 << 1;
      $1_1 = $0_1;
      $0_1 = $0_1 + HEAP32[$6_1 + 8 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $41_1 = $0_1;
      HEAP32[$6_1 + 8 >> 2] = $0_1;
      $20_1 = $3_1;
      HEAP32[$6_1 + 12 >> 2] = $3_1;
      $0_1 = HEAP32[$4_1 + 344 >> 2];
      $59_1 = $0_1;
      $1_1 = HEAP32[$4_1 + 348 >> 2];
      $60_1 = $1_1;
      $2_1 = HEAP32[$6_1 + 4 >> 2] + ($1_1 << 1 | $0_1 >>> 31) | 0;
      $0_1 = $0_1 << 1;
      $1_1 = $0_1;
      $0_1 = $0_1 + HEAP32[$6_1 >> 2] | 0;
      $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $42_1 = $0_1;
      HEAP32[$6_1 >> 2] = $0_1;
      $22_1 = $2_1;
      HEAP32[$6_1 + 4 >> 2] = $2_1;
      $24_1 = $4_1 + 104 | 0;
      $11_1 = $7_1;
      $5_1 = $10_1;
      $27_1 = $16_1 << 1;
      $25_1 = $15_1 << 1 | $16_1 >>> 31;
      $69($24_1, $7_1, $5_1, 0, 0, $27_1, $25_1, 0, 0);
      $17_1 = $4_1 + 168 | 0;
      $1_1 = $18_1;
      $0_1 = $21_1;
      $12_1 = $19_1 << 1;
      $7_1 = $13_1 << 1 | $19_1 >>> 31;
      $69($17_1, $1_1, $0_1, 0, 0, $12_1, $7_1, 0, 0);
      $18_1 = $4_1 + 328 | 0;
      $69($18_1, $8_1, $9_1, 0, 0, $8_1, $9_1, 0, 0);
      $14_1 = $4_1 + 312 | 0;
      $69($14_1, HEAP32[$4_1 + 328 >> 2], HEAP32[$4_1 + 332 >> 2], 0, 0, 15632, 16, 0, 0);
      $3_1 = $8_1;
      $2_1 = $9_1 << 1 | $3_1 >>> 31;
      $43_1 = $4_1 + 136 | 0;
      $30_1 = $3_1 << 1;
      $21_1 = $2_1;
      $69($43_1, $30_1, $2_1, 0, 0, $16_1, $15_1, 0, 0);
      $44_1 = $4_1 + 152 | 0;
      $69($44_1, $11_1, $5_1, 0, 0, $12_1, $7_1, 0, 0);
      $45_1 = $4_1 + 232 | 0;
      $69($45_1, $1_1, $0_1, 0, 0, $1_1, $0_1, 0, 0);
      $26_1 = $4_1 + 296 | 0;
      $2_1 = $18_1 + 8 | 0;
      $69($26_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $46_1 = $4_1 + 120 | 0;
      $69($46_1, $16_1, $15_1, 0, 0, $16_1, $15_1, 0, 0);
      $47_1 = $4_1 + 200 | 0;
      $69($47_1, $30_1, $21_1, 0, 0, $19_1, $13_1, 0, 0);
      $8_1 = $0_1;
      $18_1 = $1_1;
      $2_1 = $0_1 << 1 | $1_1 >>> 31;
      $48_1 = $4_1 + 248 | 0;
      $10_1 = $11_1;
      $9_1 = $5_1;
      $69($48_1, $10_1, $5_1, 0, 0, $1_1 << 1, $2_1, 0, 0);
      $15_1 = HEAP32[$4_1 + 108 >> 2];
      $2_1 = $15_1 + HEAP32[$4_1 + 172 >> 2] | 0;
      $5_1 = HEAP32[$4_1 + 104 >> 2];
      $0_1 = HEAP32[$4_1 + 168 >> 2];
      $3_1 = $5_1 + $0_1 | 0;
      $1_1 = HEAP32[$4_1 + 312 >> 2];
      $16_1 = $3_1 + $1_1 | 0;
      $0_1 = $0_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $0_1 + HEAP32[$4_1 + 316 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $7_1 = ($0_1 | 0) == ($1_1 | 0) & $3_1 >>> 0 > $16_1 >>> 0 | $0_1 >>> 0 > $1_1 >>> 0;
      $2_1 = $14_1 + 8 | 0;
      $12_1 = HEAP32[$2_1 >> 2];
      $11_1 = HEAP32[$2_1 + 4 >> 2];
      $5_1 = ($0_1 | 0) == ($15_1 | 0) & $3_1 >>> 0 < $5_1 >>> 0 | $0_1 >>> 0 < $15_1 >>> 0;
      $2_1 = $17_1 + 8 | 0;
      $3_1 = HEAP32[$2_1 >> 2];
      $0_1 = $24_1 + 8 | 0;
      $15_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
      $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
      $2_1 = $3_1 >>> 0 > $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = $5_1 + $15_1 | 0;
      $2_1 = ($0_1 >>> 0 < $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $11_1 | 0;
      $3_1 = $0_1;
      $0_1 = $0_1 + $12_1 | 0;
      $3_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $0_1;
      $0_1 = $0_1 + $7_1 | 0;
      $3_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $1_1;
      $11_1 = $0_1 << 12 | $1_1 >>> 20;
      $1_1 = $3_1 << 12 | $0_1 >>> 20;
      $49_1 = HEAP32[$4_1 + 152 >> 2];
      $0_1 = HEAP32[$4_1 + 232 >> 2];
      $7_1 = $49_1 + $0_1 | 0;
      $37_1 = HEAP32[$4_1 + 156 >> 2];
      $2_1 = $37_1 + HEAP32[$4_1 + 236 >> 2] | 0;
      $2_1 = $0_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = HEAP32[$4_1 + 136 >> 2];
      $12_1 = $0_1 + $7_1 | 0;
      $17_1 = $2_1;
      $2_1 = $2_1 + HEAP32[$4_1 + 140 >> 2] | 0;
      $2_1 = $0_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = HEAP32[$4_1 + 296 >> 2];
      $5_1 = $0_1 + $12_1 | 0;
      $14_1 = $2_1;
      $2_1 = $2_1 + HEAP32[$4_1 + 300 >> 2] | 0;
      $0_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $0_1 + $1_1 | 0;
      $50_1 = $4_1 + 40 | 0;
      $11_1 = $5_1 + $11_1 | 0;
      $1_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $28_1 = ($0_1 | 0) == ($1_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $0_1 >>> 0 > $1_1 >>> 0;
      $23_1 = ($0_1 | 0) == ($14_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $0_1 >>> 0 < $14_1 >>> 0;
      $0_1 = $26_1 + 8 | 0;
      $31_1 = HEAP32[$0_1 >> 2];
      $32_1 = HEAP32[$0_1 + 4 >> 2];
      $24_1 = ($14_1 | 0) == ($17_1 | 0) & $7_1 >>> 0 > $12_1 >>> 0 | $14_1 >>> 0 < $17_1 >>> 0;
      $0_1 = $43_1 + 8 | 0;
      $26_1 = HEAP32[$0_1 >> 2];
      $14_1 = HEAP32[$0_1 + 4 >> 2];
      $12_1 = ($17_1 | 0) == ($37_1 | 0) & $7_1 >>> 0 < $49_1 >>> 0 | $17_1 >>> 0 < $37_1 >>> 0;
      $2_1 = $45_1 + 8 | 0;
      $5_1 = HEAP32[$2_1 >> 2];
      $0_1 = $44_1 + 8 | 0;
      $7_1 = $5_1 + HEAP32[$0_1 >> 2] | 0;
      $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
      $2_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = $7_1 + $12_1 | 0;
      $2_1 = ($0_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $14_1 | 0;
      $5_1 = $0_1;
      $0_1 = $0_1 + $26_1 | 0;
      $2_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $5_1 = $0_1;
      $0_1 = $0_1 + $24_1 | 0;
      $2_1 = ($5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $32_1 | 0;
      $5_1 = $0_1;
      $0_1 = $0_1 + $31_1 | 0;
      $2_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $5_1 = $0_1 + $23_1 | 0;
      $2_1 = $5_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $3_1 = $3_1 >>> 20 | 0;
      $0_1 = $3_1 + $5_1 | 0;
      $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $3_1 = $0_1;
      $0_1 = $0_1 + $28_1 | 0;
      $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $7_1 = $0_1 << 12 | $1_1 >>> 20;
      $3_1 = $2_1;
      $12_1 = $2_1 << 12 | $0_1 >>> 20;
      $28_1 = HEAP32[$4_1 + 204 >> 2];
      $2_1 = $28_1 + HEAP32[$4_1 + 252 >> 2] | 0;
      $23_1 = HEAP32[$4_1 + 200 >> 2];
      $0_1 = HEAP32[$4_1 + 248 >> 2];
      $5_1 = $23_1 + $0_1 | 0;
      $14_1 = $5_1;
      $7_1 = $5_1 + $7_1 | 0;
      $0_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $0_1 + $12_1 | 0;
      $5_1 = $7_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $5_1 << 4 | $7_1 >>> 28;
      $17_1 = $7_1 << 4 & -16;
      $12_1 = $1_1;
      $69($50_1, $17_1 | $1_1 >>> 16 & 15, $2_1 & 16777215, 0, 0, 977, 1, 0, 0);
      $31_1 = $4_1 + 24 | 0;
      $69($31_1, $19_1, $13_1, 0, 0, $27_1, $25_1, 0, 0);
      $32_1 = $4_1 + 216 | 0;
      $69($32_1, $30_1, $21_1, 0, 0, $18_1, $8_1, 0, 0);
      $24_1 = $4_1 + 280 | 0;
      $69($24_1, $10_1, $9_1, 0, 0, $10_1, $9_1, 0, 0);
      $26_1 = $4_1 + 88 | 0;
      $17_1 = ($0_1 | 0) == ($5_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $0_1 >>> 0 > $5_1 >>> 0;
      $7_1 = ($0_1 | 0) == ($28_1 | 0) & $14_1 >>> 0 < $23_1 >>> 0 | $0_1 >>> 0 < $28_1 >>> 0;
      $2_1 = $48_1 + 8 | 0;
      $1_1 = HEAP32[$2_1 >> 2];
      $0_1 = $47_1 + 8 | 0;
      $14_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
      $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
      $2_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = $3_1;
      $1_1 = $7_1 + $14_1 | 0;
      $2_1 = $1_1 >>> 0 < $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = $0_1 >>> 20 | 0;
      $3_1 = $0_1;
      $0_1 = $0_1 + $1_1 | 0;
      $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $0_1;
      $0_1 = $0_1 + $17_1 | 0;
      $1_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $3_1 = $1_1 << 12 | $0_1 >>> 20;
      $7_1 = $0_1 << 12 | $5_1 >>> 20;
      $5_1 = $3_1;
      $17_1 = HEAP32[$4_1 + 216 >> 2];
      $0_1 = HEAP32[$4_1 + 280 >> 2];
      $3_1 = $17_1 + $0_1 | 0;
      $23_1 = HEAP32[$4_1 + 220 >> 2];
      $2_1 = $23_1 + HEAP32[$4_1 + 284 >> 2] | 0;
      $0_1 = $0_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $0_1 + $5_1 | 0;
      $5_1 = $7_1;
      $7_1 = $3_1;
      $3_1 = $5_1 + $3_1 | 0;
      $5_1 = $3_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $69($26_1, $3_1, $5_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $14_1 = $4_1 + 8 | 0;
      $69($14_1, $18_1, $8_1, 0, 0, $27_1, $25_1, 0, 0);
      $27_1 = $4_1 + 184 | 0;
      $69($27_1, $19_1, $13_1, 0, 0, $19_1, $13_1, 0, 0);
      $13_1 = $4_1 + 264 | 0;
      $69($13_1, $30_1, $21_1, 0, 0, $10_1, $9_1, 0, 0);
      $21_1 = $4_1 + 72 | 0;
      $9_1 = $21_1;
      $8_1 = ($0_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $7_1 >>> 0 | $0_1 >>> 0 > $5_1 >>> 0;
      $7_1 = ($0_1 | 0) == ($23_1 | 0) & $7_1 >>> 0 < $17_1 >>> 0 | $0_1 >>> 0 < $23_1 >>> 0;
      $3_1 = $24_1 + 8 | 0;
      $2_1 = HEAP32[$3_1 >> 2];
      $0_1 = $32_1 + 8 | 0;
      $10_1 = $2_1 + HEAP32[$0_1 >> 2] | 0;
      $3_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $2_1 = $2_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $7_1 + $10_1 | 0;
      $2_1 = $3_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $1_1 >>> 20 | 0;
      $0_1 = $1_1 + $3_1 | 0;
      $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $0_1;
      $0_1 = $0_1 + $8_1 | 0;
      $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $8_1 = $0_1 << 12 | $5_1 >>> 20;
      $5_1 = HEAP32[$4_1 + 264 >> 2];
      $10_1 = $8_1 + $5_1 | 0;
      $1_1 = $2_1;
      $0_1 = $2_1 << 12 | $0_1 >>> 20;
      $3_1 = $0_1 + HEAP32[$4_1 + 268 >> 2] | 0;
      $3_1 = $5_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($9_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $18_1 = $4_1 + 56 | 0;
      $7_1 = $18_1;
      $5_1 = ($0_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $10_1 >>> 0 | $0_1 >>> 0 > $3_1 >>> 0;
      $0_1 = $13_1 + 8 | 0;
      $3_1 = HEAP32[$0_1 >> 2];
      $2_1 = HEAP32[$0_1 + 4 >> 2];
      $1_1 = $1_1 >>> 20 | 0;
      $0_1 = $1_1 + $3_1 | 0;
      $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $0_1;
      $0_1 = $0_1 + $5_1 | 0;
      $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $69($7_1, $0_1, $2_1, 0, 0, 64028672, 65536, 0, 0);
      $0_1 = $4_1;
      $3_1 = $29_1 + $52_1 | 0;
      $1_1 = $38_1 + $51_1 | 0;
      $3_1 = $1_1 >>> 0 < $38_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$0_1 + 376 >> 2] = $1_1;
      HEAP32[$0_1 + 380 >> 2] = $3_1;
      $2_1 = $35_1 + $54_1 | 0;
      $1_1 = $39_1 + $53_1 | 0;
      $2_1 = $1_1 >>> 0 < $39_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$0_1 + 368 >> 2] = $1_1;
      HEAP32[$0_1 + 372 >> 2] = $2_1;
      $2_1 = $36_1 + $56_1 | 0;
      $1_1 = $40_1 + $55_1 | 0;
      $2_1 = $1_1 >>> 0 < $40_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$0_1 + 360 >> 2] = $1_1;
      HEAP32[$0_1 + 364 >> 2] = $2_1;
      $2_1 = $20_1 + $58_1 | 0;
      $1_1 = $41_1 + $57_1 | 0;
      $2_1 = $1_1 >>> 0 < $41_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$0_1 + 352 >> 2] = $1_1;
      HEAP32[$0_1 + 356 >> 2] = $2_1;
      $8_1 = $0_1;
      $2_1 = $22_1 + $60_1 | 0;
      $0_1 = $42_1 + $59_1 | 0;
      $2_1 = $0_1 >>> 0 < $42_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$4_1 + 344 >> 2] = $0_1;
      HEAP32[$4_1 + 348 >> 2] = $2_1;
      $34($6_1 + 40 | 0, $34_1, $33_1);
      $7_1 = $6_1;
      $6_1 = HEAP32[$6_1 + 40 >> 2];
      $2_1 = HEAP32[$7_1 + 44 >> 2];
      $5_1 = HEAP32[$4_1 + 40 >> 2];
      $1_1 = HEAP32[$4_1 + 120 >> 2];
      $0_1 = $5_1 + $1_1 | 0;
      $9_1 = HEAP32[$4_1 + 44 >> 2];
      $3_1 = $9_1 + HEAP32[$4_1 + 124 >> 2] | 0;
      $1_1 = $0_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $2_1 = $2_1 + ($1_1 & 1048575) | 0;
      $3_1 = $0_1 + $6_1 | 0;
      $2_1 = $3_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$7_1 + 40 >> 2] = -5862 - $3_1;
      HEAP32[$7_1 + 44 >> 2] = 6291449 - (($3_1 >>> 0 > 4294961434) + $2_1 | 0);
      $2_1 = $7_1 + 48 | 0;
      $13_1 = $2_1;
      $10_1 = HEAP32[$2_1 >> 2];
      $4_1 = HEAP32[$2_1 + 4 >> 2];
      $5_1 = ($1_1 | 0) == ($9_1 | 0) & $0_1 >>> 0 < $5_1 >>> 0 | $1_1 >>> 0 < $9_1 >>> 0;
      $2_1 = $46_1 + 8 | 0;
      $3_1 = HEAP32[$2_1 >> 2];
      $0_1 = $50_1 + 8 | 0;
      $6_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
      $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
      $3_1 = $3_1 >>> 0 > $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = $5_1 + $6_1 | 0;
      $3_1 = $0_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $0_1 << 12 | $1_1 >>> 20;
      $5_1 = $3_1 << 12 | $0_1 >>> 20;
      $9_1 = HEAP32[$8_1 + 88 >> 2];
      $0_1 = HEAP32[$8_1 + 24 >> 2];
      $1_1 = $9_1 + $0_1 | 0;
      $20_1 = HEAP32[$8_1 + 92 >> 2];
      $2_1 = $20_1 + HEAP32[$8_1 + 28 >> 2] | 0;
      $2_1 = $0_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = $6_1;
      $6_1 = $1_1;
      $1_1 = $0_1 + $1_1 | 0;
      $0_1 = $2_1;
      $2_1 = $2_1 + $5_1 | 0;
      $5_1 = $1_1 >>> 0 < $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $4_1 + ($5_1 & 1048575) | 0;
      $10_1 = $1_1 + $10_1 | 0;
      $2_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$13_1 >> 2] = -6 - $10_1;
      HEAP32[$13_1 + 4 >> 2] = 6291455 - (($10_1 >>> 0 > 4294967290) + $2_1 | 0);
      $2_1 = $7_1 + 56 | 0;
      $22_1 = $2_1;
      $13_1 = HEAP32[$2_1 >> 2];
      $10_1 = HEAP32[$2_1 + 4 >> 2];
      $4_1 = ($0_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 > $5_1 >>> 0;
      $6_1 = ($0_1 | 0) == ($20_1 | 0) & $6_1 >>> 0 < $9_1 >>> 0 | $0_1 >>> 0 < $20_1 >>> 0;
      $2_1 = $31_1 + 8 | 0;
      $1_1 = HEAP32[$2_1 >> 2];
      $0_1 = $26_1 + 8 | 0;
      $9_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
      $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
      $2_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $6_1 + $9_1 | 0;
      $2_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $3_1 = $3_1 >>> 20 | 0;
      $0_1 = $1_1 + $3_1 | 0;
      $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $0_1;
      $0_1 = $0_1 + $4_1 | 0;
      $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $5_1 = $0_1 << 12 | $5_1 >>> 20;
      $1_1 = $2_1;
      $3_1 = $2_1 << 12 | $0_1 >>> 20;
      $29_1 = HEAP32[$8_1 + 8 >> 2];
      $0_1 = HEAP32[$8_1 + 184 >> 2];
      $4_1 = $29_1 + $0_1 | 0;
      $25_1 = HEAP32[$8_1 + 12 >> 2];
      $2_1 = $25_1 + HEAP32[$8_1 + 188 >> 2] | 0;
      $2_1 = $0_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = HEAP32[$8_1 + 72 >> 2];
      $6_1 = $0_1 + $4_1 | 0;
      $9_1 = $2_1;
      $2_1 = $2_1 + HEAP32[$8_1 + 76 >> 2] | 0;
      $0_1 = $0_1 >>> 0 > $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $0_1 + $3_1 | 0;
      $5_1 = $5_1 + $6_1 | 0;
      $3_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $10_1 + ($3_1 & 1048575) | 0;
      $13_1 = $5_1 + $13_1 | 0;
      $2_1 = $13_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$22_1 >> 2] = -6 - $13_1;
      HEAP32[$22_1 + 4 >> 2] = 6291455 - (($13_1 >>> 0 > 4294967290) + $2_1 | 0);
      $2_1 = $7_1 - -64 | 0;
      $19_1 = $2_1;
      $35_1 = HEAP32[$2_1 >> 2];
      $36_1 = HEAP32[$2_1 + 4 >> 2];
      $20_1 = ($0_1 | 0) == ($3_1 | 0) & $5_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 > $3_1 >>> 0;
      $22_1 = ($0_1 | 0) == ($9_1 | 0) & $4_1 >>> 0 > $6_1 >>> 0 | $0_1 >>> 0 < $9_1 >>> 0;
      $0_1 = $21_1 + 8 | 0;
      $13_1 = HEAP32[$0_1 >> 2];
      $10_1 = HEAP32[$0_1 + 4 >> 2];
      $6_1 = ($9_1 | 0) == ($25_1 | 0) & $4_1 >>> 0 < $29_1 >>> 0 | $9_1 >>> 0 < $25_1 >>> 0;
      $2_1 = $27_1 + 8 | 0;
      $5_1 = HEAP32[$2_1 >> 2];
      $0_1 = $14_1 + 8 | 0;
      $4_1 = $5_1 + HEAP32[$0_1 >> 2] | 0;
      $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
      $2_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = $4_1 + $6_1 | 0;
      $2_1 = ($0_1 >>> 0 < $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $10_1 | 0;
      $5_1 = $0_1;
      $0_1 = $0_1 + $13_1 | 0;
      $2_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $5_1 = $0_1 + $22_1 | 0;
      $2_1 = $5_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $1_1 >>> 20 | 0;
      $0_1 = $1_1 + $5_1 | 0;
      $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $0_1;
      $0_1 = $0_1 + $20_1 | 0;
      $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $5_1 = $0_1 << 12 | $3_1 >>> 20;
      $1_1 = $2_1;
      $4_1 = $2_1 << 12 | $0_1 >>> 20;
      $9_1 = HEAP32[$8_1 + 56 >> 2];
      $3_1 = $16_1 & -2;
      $0_1 = $9_1 + $3_1 | 0;
      $10_1 = HEAP32[$8_1 + 60 >> 2];
      $2_1 = $10_1 + ($15_1 & 1048575) | 0;
      $6_1 = $0_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $6_1 + $4_1 | 0;
      $3_1 = $5_1;
      $5_1 = $0_1;
      $3_1 = $3_1 + $0_1 | 0;
      $0_1 = $3_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $36_1 + ($0_1 & 1048575) | 0;
      $4_1 = $3_1 + $35_1 | 0;
      $2_1 = $4_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$19_1 >> 2] = -6 - $4_1;
      HEAP32[$19_1 + 4 >> 2] = 6291455 - (($4_1 >>> 0 > 4294967290) + $2_1 | 0);
      $2_1 = $7_1 + 72 | 0;
      $16_1 = $2_1;
      $15_1 = HEAP32[$2_1 >> 2];
      $7_1 = HEAP32[$2_1 + 4 >> 2];
      $12_1 = $12_1 & 65535;
      $4_1 = ($0_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 < $5_1 >>> 0 | $0_1 >>> 0 < $6_1 >>> 0;
      $3_1 = ($6_1 | 0) == ($10_1 | 0) & $5_1 >>> 0 < $9_1 >>> 0 | $6_1 >>> 0 < $10_1 >>> 0;
      $2_1 = $18_1 + 8 | 0;
      $5_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
      $2_1 = HEAP32[$2_1 + 4 >> 2];
      $2_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $1_1 = $1_1 >>> 20 | 0;
      $3_1 = $1_1;
      $1_1 = $1_1 + $5_1 | 0;
      $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $3_1 = $1_1;
      $1_1 = $1_1 + $4_1 | 0;
      $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $0_1 = $1_1 << 12 | $0_1 >>> 20;
      $5_1 = $0_1 + $11_1 | 0;
      $3_1 = $12_1 + ($2_1 << 12 | $1_1 >>> 20) | 0;
      $2_1 = ($0_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
      $0_1 = $5_1 + $15_1 | 0;
      $2_1 = $0_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      HEAP32[$16_1 >> 2] = -6 - $0_1;
      HEAP32[$16_1 + 4 >> 2] = 393215 - (($0_1 >>> 0 > 4294967290) + $2_1 | 0);
      global$0 = $8_1 + 464 | 0;
    }
    function $56($0_1, $1_1) {
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0;
      $7_1 = global$0 - 80 | 0;
      global$0 = $7_1;
      label$1: {
        if (HEAP32[$1_1 + 120 >> 2]) {
          HEAP32[$0_1 + 80 >> 2] = 1;
          $68($0_1, 80);
          break label$1;
        }
        $11_1 = $1_1 + 88 | 0;
        $4_1 = HEAP32[$11_1 >> 2];
        $6_1 = HEAP32[$11_1 + 4 >> 2];
        $5_1 = HEAP32[$1_1 + 84 >> 2];
        $3_1 = $1_1 + 112 | 0;
        $14_1 = HEAP32[$3_1 >> 2];
        $8_1 = HEAP32[$3_1 + 4 >> 2];
        $15_1 = $8_1;
        $3_1 = HEAP32[$1_1 + 80 >> 2];
        $2_1 = __wasm_i64_mul($8_1 >>> 16 | 0, 0, 977, 1);
        $10_1 = $3_1 + $2_1 | 0;
        $5_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
        $3_1 = $6_1;
        $9_1 = $2_1 >>> 0 > $10_1 >>> 0 ? $5_1 + 1 | 0 : $5_1;
        $2_1 = $9_1 >>> 20 | 0;
        $6_1 = $2_1;
        $2_1 = $2_1 + $4_1 | 0;
        $6_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $16_1 = $6_1 & 1048575;
        $5_1 = $1_1 + 104 | 0;
        $13_1 = HEAP32[$5_1 >> 2];
        $17_1 = HEAP32[$5_1 + 4 >> 2];
        $5_1 = $1_1 + 96 | 0;
        $8_1 = HEAP32[$5_1 >> 2];
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $5_1 = $6_1 >>> 20 | 0;
        $8_1 = $5_1 + $8_1 | 0;
        $4_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $3_1 = $17_1;
        $12_1 = $4_1;
        $4_1 = $4_1 >>> 20 | 0;
        $5_1 = $4_1 + $13_1 | 0;
        $3_1 = $4_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = $3_1 & 1048575;
        $17_1 = $1_1 + 80 | 0;
        $4_1 = $8_1;
        $12_1 = $12_1 & 1048575;
        $18_1 = ($2_1 & $4_1 & $5_1) == -1 & ($6_1 & $12_1 & $3_1) == 1048575;
        $6_1 = $3_1 >>> 20 | 0;
        $3_1 = $15_1 & 65535;
        $8_1 = $6_1 + $14_1 | 0;
        $6_1 = $8_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $9_1 & 1048575;
        $14_1 = $3_1;
        if ($18_1 & (($8_1 | 0) == -1 & ($6_1 | 0) == 65535) & (($3_1 | 0) == 1048574 & $10_1 >>> 0 > 4294966318 | $3_1 >>> 0 > 1048574) | $6_1 >>> 16) {
          $3_1 = $14_1 + 1 | 0;
          $10_1 = $10_1 + 977 | 0;
          $3_1 = $10_1 >>> 0 < 977 ? $3_1 + 1 | 0 : $3_1;
          $14_1 = $3_1 & 1048575;
          $9_1 = $3_1;
          $3_1 = $16_1;
          $9_1 = $9_1 >>> 20 | 0;
          $2_1 = $2_1 + $9_1 | 0;
          $3_1 = $9_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
          $16_1 = $3_1 & 1048575;
          $9_1 = $4_1;
          $15_1 = $3_1 >>> 20 | 0;
          $4_1 = $12_1;
          $3_1 = $9_1 + $15_1 | 0;
          $4_1 = $3_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $12_1 = $4_1 & 1048575;
          $9_1 = $4_1;
          $4_1 = $3_1;
          $3_1 = $13_1;
          $9_1 = $9_1 >>> 20 | 0;
          $5_1 = $5_1 + $9_1 | 0;
          $3_1 = $9_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
          $13_1 = $3_1 & 1048575;
          $9_1 = $3_1;
          $3_1 = $6_1;
          $6_1 = $8_1;
          $8_1 = ($9_1 >>> 20 | 0) + $8_1 | 0;
          $6_1 = ($6_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) & 65535;
        }
        HEAP32[$7_1 + 72 >> 2] = $6_1 >>> 8;
        HEAP32[$7_1 + 76 >> 2] = 0;
        $3_1 = $6_1 << 22 | $8_1 >>> 10;
        HEAP32[$7_1 + 64 >> 2] = $8_1 << 22 & -4194304 | (($13_1 & 1073741823) << 2 | $5_1 >>> 30);
        HEAP32[$7_1 + 68 >> 2] = $3_1 & 1073741823 | $13_1 >>> 30;
        HEAP32[$7_1 + 56 >> 2] = ($12_1 & 1048575) << 12 | $4_1 >>> 20;
        HEAP32[$7_1 + 60 >> 2] = $5_1 & 1073741823 | $12_1 >>> 20;
        $4_1 = $4_1 << 10 & 1073740800;
        HEAP32[$7_1 + 48 >> 2] = ($16_1 & 1023) << 22 | $2_1 >>> 10;
        HEAP32[$7_1 + 52 >> 2] = $16_1 >>> 10 | $4_1;
        HEAP32[$7_1 + 40 >> 2] = $10_1;
        HEAP32[$7_1 + 44 >> 2] = $14_1 | $2_1 << 20 & 1072693248;
        $10_1 = $7_1 + 40 | 0;
        $40($10_1, 690464);
        $5_1 = HEAP32[$7_1 + 44 >> 2];
        $4_1 = $5_1;
        HEAP32[$1_1 + 80 >> 2] = HEAP32[$7_1 + 40 >> 2];
        HEAP32[$1_1 + 84 >> 2] = $4_1 & 1048575;
        $5_1 = HEAP32[$7_1 + 72 >> 2] << 8;
        $8_1 = HEAP32[$7_1 + 68 >> 2];
        $3_1 = $8_1 >>> 22 | 0;
        $6_1 = HEAP32[$7_1 + 64 >> 2];
        HEAP32[$1_1 + 112 >> 2] = ($8_1 & 4194303) << 10 | $6_1 >>> 22;
        HEAP32[$1_1 + 116 >> 2] = $3_1 | $5_1;
        $2_1 = $6_1;
        $3_1 = $8_1 << 30 | $2_1 >>> 2;
        $6_1 = $2_1 << 30 & -1073741824;
        $2_1 = HEAP32[$7_1 + 56 >> 2];
        $5_1 = HEAP32[$7_1 + 60 >> 2];
        HEAP32[$1_1 + 104 >> 2] = $5_1 | $6_1;
        HEAP32[$1_1 + 108 >> 2] = $3_1 & 1048575;
        $5_1 = $5_1 << 20 | $2_1 >>> 12;
        $6_1 = $2_1 << 20 & -1048576;
        $8_1 = $5_1 & 1048575;
        $2_1 = HEAP32[$7_1 + 48 >> 2];
        $5_1 = HEAP32[$7_1 + 52 >> 2];
        HEAP32[$1_1 + 96 >> 2] = $5_1 >>> 10 | $6_1;
        HEAP32[$1_1 + 100 >> 2] = $8_1;
        $3_1 = $5_1 << 10 | $2_1 >>> 22;
        HEAP32[$1_1 + 88 >> 2] = $2_1 << 10 & -1024 | $4_1 >>> 20;
        HEAP32[$1_1 + 92 >> 2] = $3_1 & 1048575;
        $54($10_1, $17_1);
        $34($7_1, $17_1, $10_1);
        $34($1_1, $1_1, $10_1);
        $2_1 = $1_1 + 40 | 0;
        $34($2_1, $2_1, $7_1);
        HEAP32[$11_1 >> 2] = 0;
        HEAP32[$11_1 + 4 >> 2] = 0;
        $2_1 = $11_1 + 8 | 0;
        HEAP32[$2_1 >> 2] = 0;
        HEAP32[$2_1 + 4 >> 2] = 0;
        $2_1 = $11_1 + 16 | 0;
        HEAP32[$2_1 >> 2] = 0;
        HEAP32[$2_1 + 4 >> 2] = 0;
        $2_1 = $11_1 + 24 | 0;
        HEAP32[$2_1 >> 2] = 0;
        HEAP32[$2_1 + 4 >> 2] = 0;
        HEAP32[$0_1 + 80 >> 2] = 0;
        HEAP32[$1_1 + 80 >> 2] = 1;
        HEAP32[$1_1 + 84 >> 2] = 0;
        $2_1 = HEAP32[$1_1 + 4 >> 2];
        HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
        HEAP32[$0_1 + 4 >> 2] = $2_1;
        $2_1 = $1_1 + 8 | 0;
        $5_1 = HEAP32[$2_1 + 4 >> 2];
        $4_1 = $0_1 + 8 | 0;
        HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
        HEAP32[$4_1 + 4 >> 2] = $5_1;
        $2_1 = $1_1 + 16 | 0;
        $5_1 = HEAP32[$2_1 + 4 >> 2];
        $4_1 = $0_1 + 16 | 0;
        HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
        HEAP32[$4_1 + 4 >> 2] = $5_1;
        $2_1 = $1_1 + 24 | 0;
        $5_1 = HEAP32[$2_1 + 4 >> 2];
        $4_1 = $0_1 + 24 | 0;
        HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
        HEAP32[$4_1 + 4 >> 2] = $5_1;
        $2_1 = $1_1 + 32 | 0;
        $5_1 = HEAP32[$2_1 + 4 >> 2];
        $4_1 = $0_1 + 32 | 0;
        HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
        HEAP32[$4_1 + 4 >> 2] = $5_1;
        $2_1 = $1_1 + 72 | 0;
        $5_1 = HEAP32[$2_1 + 4 >> 2];
        $4_1 = $0_1 + 72 | 0;
        HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
        HEAP32[$4_1 + 4 >> 2] = $5_1;
        $2_1 = $1_1 - -64 | 0;
        $5_1 = HEAP32[$2_1 + 4 >> 2];
        $4_1 = $0_1 - -64 | 0;
        HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
        HEAP32[$4_1 + 4 >> 2] = $5_1;
        $2_1 = $1_1 + 56 | 0;
        $5_1 = HEAP32[$2_1 + 4 >> 2];
        $4_1 = $0_1 + 56 | 0;
        HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
        HEAP32[$4_1 + 4 >> 2] = $5_1;
        $2_1 = $1_1 + 48 | 0;
        $5_1 = HEAP32[$2_1 + 4 >> 2];
        $4_1 = $0_1 + 48 | 0;
        HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
        HEAP32[$4_1 + 4 >> 2] = $5_1;
        $2_1 = HEAP32[$1_1 + 44 >> 2];
        HEAP32[$0_1 + 40 >> 2] = HEAP32[$1_1 + 40 >> 2];
        HEAP32[$0_1 + 44 >> 2] = $2_1;
      }
      global$0 = $7_1 + 80 | 0;
    }
    function $57($0_1, $1_1, $2_1) {
      var $3_1 = 0, $4_1 = 0;
      $4_1 = global$0 - 128 | 0;
      global$0 = $4_1;
      label$1: {
        if (!$1_1) {
          FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689638, HEAP32[$0_1 + 172 >> 2]);
          $0_1 = 0;
          break label$1;
        }
        HEAP8[$1_1 | 0] = 0;
        HEAP8[$1_1 + 1 | 0] = 0;
        HEAP8[$1_1 + 2 | 0] = 0;
        HEAP8[$1_1 + 3 | 0] = 0;
        HEAP8[$1_1 + 4 | 0] = 0;
        HEAP8[$1_1 + 5 | 0] = 0;
        HEAP8[$1_1 + 6 | 0] = 0;
        HEAP8[$1_1 + 7 | 0] = 0;
        $3_1 = $1_1 + 56 | 0;
        HEAP8[$3_1 | 0] = 0;
        HEAP8[$3_1 + 1 | 0] = 0;
        HEAP8[$3_1 + 2 | 0] = 0;
        HEAP8[$3_1 + 3 | 0] = 0;
        HEAP8[$3_1 + 4 | 0] = 0;
        HEAP8[$3_1 + 5 | 0] = 0;
        HEAP8[$3_1 + 6 | 0] = 0;
        HEAP8[$3_1 + 7 | 0] = 0;
        $3_1 = $1_1 + 48 | 0;
        HEAP8[$3_1 | 0] = 0;
        HEAP8[$3_1 + 1 | 0] = 0;
        HEAP8[$3_1 + 2 | 0] = 0;
        HEAP8[$3_1 + 3 | 0] = 0;
        HEAP8[$3_1 + 4 | 0] = 0;
        HEAP8[$3_1 + 5 | 0] = 0;
        HEAP8[$3_1 + 6 | 0] = 0;
        HEAP8[$3_1 + 7 | 0] = 0;
        $3_1 = $1_1 + 40 | 0;
        HEAP8[$3_1 | 0] = 0;
        HEAP8[$3_1 + 1 | 0] = 0;
        HEAP8[$3_1 + 2 | 0] = 0;
        HEAP8[$3_1 + 3 | 0] = 0;
        HEAP8[$3_1 + 4 | 0] = 0;
        HEAP8[$3_1 + 5 | 0] = 0;
        HEAP8[$3_1 + 6 | 0] = 0;
        HEAP8[$3_1 + 7 | 0] = 0;
        $3_1 = $1_1 + 32 | 0;
        HEAP8[$3_1 | 0] = 0;
        HEAP8[$3_1 + 1 | 0] = 0;
        HEAP8[$3_1 + 2 | 0] = 0;
        HEAP8[$3_1 + 3 | 0] = 0;
        HEAP8[$3_1 + 4 | 0] = 0;
        HEAP8[$3_1 + 5 | 0] = 0;
        HEAP8[$3_1 + 6 | 0] = 0;
        HEAP8[$3_1 + 7 | 0] = 0;
        $3_1 = $1_1 + 24 | 0;
        HEAP8[$3_1 | 0] = 0;
        HEAP8[$3_1 + 1 | 0] = 0;
        HEAP8[$3_1 + 2 | 0] = 0;
        HEAP8[$3_1 + 3 | 0] = 0;
        HEAP8[$3_1 + 4 | 0] = 0;
        HEAP8[$3_1 + 5 | 0] = 0;
        HEAP8[$3_1 + 6 | 0] = 0;
        HEAP8[$3_1 + 7 | 0] = 0;
        $3_1 = $1_1 + 16 | 0;
        HEAP8[$3_1 | 0] = 0;
        HEAP8[$3_1 + 1 | 0] = 0;
        HEAP8[$3_1 + 2 | 0] = 0;
        HEAP8[$3_1 + 3 | 0] = 0;
        HEAP8[$3_1 + 4 | 0] = 0;
        HEAP8[$3_1 + 5 | 0] = 0;
        HEAP8[$3_1 + 6 | 0] = 0;
        HEAP8[$3_1 + 7 | 0] = 0;
        $3_1 = $1_1 + 8 | 0;
        HEAP8[$3_1 | 0] = 0;
        HEAP8[$3_1 + 1 | 0] = 0;
        HEAP8[$3_1 + 2 | 0] = 0;
        HEAP8[$3_1 + 3 | 0] = 0;
        HEAP8[$3_1 + 4 | 0] = 0;
        HEAP8[$3_1 + 5 | 0] = 0;
        HEAP8[$3_1 + 6 | 0] = 0;
        HEAP8[$3_1 + 7 | 0] = 0;
        if (!$2_1) {
          FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689936, HEAP32[$0_1 + 172 >> 2]);
          $0_1 = 0;
          break label$1;
        }
        $0_1 = 0;
        if (!$32($4_1, $2_1)) {
          break label$1;
        }
        $0_1 = 0;
        if (!$33($4_1 + 40 | 0, $4_1, 0)) {
          break label$1;
        }
        $35($1_1, $4_1 + 40 | 0);
        $0_1 = 1;
      }
      global$0 = $4_1 + 128 | 0;
      return $0_1;
    }
    function $58($0_1, $1_1) {
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0;
      $3_1 = global$0 - 96 | 0;
      global$0 = $3_1;
      HEAP8[690885] = 0;
      HEAP8[690886] = 0;
      HEAP8[690887] = 0;
      HEAP8[690888] = 0;
      HEAP8[690889] = 0;
      HEAP8[690890] = 0;
      HEAP8[690891] = 0;
      HEAP8[690892] = 0;
      HEAP8[690909] = 0;
      HEAP8[690910] = 0;
      HEAP8[690911] = 0;
      HEAP8[690912] = 0;
      HEAP8[690913] = 0;
      HEAP8[690914] = 0;
      HEAP8[690915] = 0;
      HEAP8[690916] = 0;
      HEAP8[690901] = 0;
      HEAP8[690902] = 0;
      HEAP8[690903] = 0;
      HEAP8[690904] = 0;
      HEAP8[690905] = 0;
      HEAP8[690906] = 0;
      HEAP8[690907] = 0;
      HEAP8[690908] = 0;
      HEAP8[690893] = 0;
      HEAP8[690894] = 0;
      HEAP8[690895] = 0;
      HEAP8[690896] = 0;
      HEAP8[690897] = 0;
      HEAP8[690898] = 0;
      HEAP8[690899] = 0;
      HEAP8[690900] = 0;
      label$1: {
        if (!$1_1) {
          FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689638, HEAP32[$0_1 + 172 >> 2]);
          break label$1;
        }
        $5_1 = HEAPU8[$1_1 + 60 | 0] | HEAPU8[$1_1 + 61 | 0] << 8 | (HEAPU8[$1_1 + 62 | 0] << 16 | HEAPU8[$1_1 + 63 | 0] << 24);
        $8_1 = $5_1 >>> 16 | 0;
        $4_1 = $3_1 + 80 | 0;
        $2_1 = HEAPU8[$1_1 + 56 | 0] | HEAPU8[$1_1 + 57 | 0] << 8 | (HEAPU8[$1_1 + 58 | 0] << 16 | HEAPU8[$1_1 + 59 | 0] << 24);
        HEAP32[$4_1 >> 2] = ($5_1 & 65535) << 16 | $2_1 >>> 16;
        HEAP32[$4_1 + 4 >> 2] = $8_1;
        $7_1 = $2_1 << 4 & 1048560;
        $4_1 = HEAPU8[$1_1 + 52 | 0] | HEAPU8[$1_1 + 53 | 0] << 8 | (HEAPU8[$1_1 + 54 | 0] << 16 | HEAPU8[$1_1 + 55 | 0] << 24);
        $2_1 = $4_1 >>> 28 | 0;
        $6_1 = $3_1 + 72 | 0;
        $5_1 = HEAPU8[$1_1 + 48 | 0] | HEAPU8[$1_1 + 49 | 0] << 8 | (HEAPU8[$1_1 + 50 | 0] << 16 | HEAPU8[$1_1 + 51 | 0] << 24);
        HEAP32[$6_1 >> 2] = ($4_1 & 268435455) << 4 | $5_1 >>> 28;
        HEAP32[$6_1 + 4 >> 2] = $2_1 | $7_1;
        $2_1 = $5_1;
        $8_1 = $4_1 << 24 | $2_1 >>> 8;
        $5_1 = HEAPU8[$1_1 + 40 | 0] | HEAPU8[$1_1 + 41 | 0] << 8 | (HEAPU8[$1_1 + 42 | 0] << 16 | HEAPU8[$1_1 + 43 | 0] << 24);
        $7_1 = $3_1 - -64 | 0;
        $4_1 = HEAPU8[$1_1 + 44 | 0] | HEAPU8[$1_1 + 45 | 0] << 8 | (HEAPU8[$1_1 + 46 | 0] << 16 | HEAPU8[$1_1 + 47 | 0] << 24);
        HEAP32[$7_1 >> 2] = $2_1 << 24 & -16777216 | $4_1 >>> 8;
        HEAP32[$7_1 + 4 >> 2] = $8_1 & 1048575;
        $2_1 = $5_1;
        $4_1 = ($4_1 << 12 | $2_1 >>> 20) & 1048575;
        $7_1 = HEAPU8[$1_1 + 32 | 0] | HEAPU8[$1_1 + 33 | 0] << 8 | (HEAPU8[$1_1 + 34 | 0] << 16 | HEAPU8[$1_1 + 35 | 0] << 24);
        $6_1 = $3_1 + 56 | 0;
        $9_1 = HEAPU8[$1_1 + 36 | 0] | HEAPU8[$1_1 + 37 | 0] << 8 | (HEAPU8[$1_1 + 38 | 0] << 16 | HEAPU8[$1_1 + 39 | 0] << 24);
        HEAP32[$6_1 >> 2] = $2_1 << 12 & -4096 | $9_1 >>> 20;
        HEAP32[$6_1 + 4 >> 2] = $4_1;
        HEAP32[$3_1 + 88 >> 2] = 0;
        HEAP32[$3_1 + 48 >> 2] = $7_1;
        HEAP32[$3_1 + 52 >> 2] = $9_1 & 1048575;
        $5_1 = HEAPU8[$1_1 + 12 | 0] | HEAPU8[$1_1 + 13 | 0] << 8 | (HEAPU8[$1_1 + 14 | 0] << 16 | HEAPU8[$1_1 + 15 | 0] << 24);
        $2_1 = HEAPU8[$1_1 + 8 | 0] | HEAPU8[$1_1 + 9 | 0] << 8 | (HEAPU8[$1_1 + 10 | 0] << 16 | HEAPU8[$1_1 + 11 | 0] << 24);
        $8_1 = $5_1 << 12 | $2_1 >>> 20;
        $4_1 = $2_1 << 12 & -4096;
        $2_1 = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
        $9_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
        $10_1 = $9_1 >>> 20 | $4_1;
        HEAP32[$3_1 + 16 >> 2] = $10_1;
        $11_1 = $8_1 & 1048575;
        HEAP32[$3_1 + 20 >> 2] = $11_1;
        $4_1 = $2_1;
        HEAP32[$3_1 + 8 >> 2] = $2_1;
        $12_1 = $9_1 & 1048575;
        HEAP32[$3_1 + 12 >> 2] = $12_1;
        $6_1 = HEAPU8[$1_1 + 28 | 0] | HEAPU8[$1_1 + 29 | 0] << 8 | (HEAPU8[$1_1 + 30 | 0] << 16 | HEAPU8[$1_1 + 31 | 0] << 24);
        $2_1 = $6_1 >>> 16 | 0;
        $7_1 = HEAPU8[$1_1 + 24 | 0] | HEAPU8[$1_1 + 25 | 0] << 8 | (HEAPU8[$1_1 + 26 | 0] << 16 | HEAPU8[$1_1 + 27 | 0] << 24);
        $9_1 = ($6_1 & 65535) << 16 | $7_1 >>> 16;
        HEAP32[$3_1 + 40 >> 2] = $9_1;
        $6_1 = $2_1;
        HEAP32[$3_1 + 44 >> 2] = $2_1;
        $2_1 = HEAPU8[$1_1 + 16 | 0] | HEAPU8[$1_1 + 17 | 0] << 8 | (HEAPU8[$1_1 + 18 | 0] << 16 | HEAPU8[$1_1 + 19 | 0] << 24);
        $14_1 = $2_1;
        $13_1 = HEAPU8[$1_1 + 20 | 0] | HEAPU8[$1_1 + 21 | 0] << 8 | (HEAPU8[$1_1 + 22 | 0] << 16 | HEAPU8[$1_1 + 23 | 0] << 24);
        $1_1 = $2_1;
        $2_1 = $13_1 << 24 | $1_1 >>> 8;
        $5_1 = $1_1 << 24 & -16777216 | $5_1 >>> 8;
        HEAP32[$3_1 + 24 >> 2] = $5_1;
        $8_1 = $2_1 & 1048575;
        HEAP32[$3_1 + 28 >> 2] = $8_1;
        $1_1 = $13_1;
        $2_1 = $1_1 >>> 28 | 0;
        $1_1 = ($1_1 & 268435455) << 4 | $14_1 >>> 28;
        HEAP32[$3_1 + 32 >> 2] = $1_1;
        $2_1 = $2_1 | $7_1 << 4 & 1048560;
        HEAP32[$3_1 + 36 >> 2] = $2_1;
        if (!($4_1 | $10_1 | $9_1 | $5_1 | $1_1 | ($11_1 | $12_1 | $6_1 | $8_1 | $2_1))) {
          FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](690116, HEAP32[$0_1 + 172 >> 2]);
          break label$1;
        }
        $37(690885, $3_1 + 8 | 0);
        $15_1 = 1;
      }
      global$0 = $3_1 + 96 | 0;
      return $15_1;
    }
    function $59($0_1, $1_1, $2_1, $3_1) {
      var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0;
      $4_1 = global$0 - 96 | 0;
      global$0 = $4_1;
      label$1: {
        if (!$1_1) {
          FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689586, HEAP32[$0_1 + 172 >> 2]);
          $0_1 = 0;
          break label$1;
        }
        if (!$3_1) {
          FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689638, HEAP32[$0_1 + 172 >> 2]);
          $0_1 = 0;
          break label$1;
        }
        $11_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
        $5_1 = $11_1 >>> 16 | 0;
        $6_1 = $4_1 + 80 | 0;
        $7_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
        $11_1 = ($11_1 & 65535) << 16 | $7_1 >>> 16;
        HEAP32[$6_1 >> 2] = $11_1;
        $24_1 = $5_1;
        HEAP32[$6_1 + 4 >> 2] = $5_1;
        $10_1 = $7_1 << 4 & 1048560;
        $8_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
        $5_1 = $8_1 >>> 28 | 0;
        $6_1 = $4_1 + 72 | 0;
        $7_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
        $13_1 = ($8_1 & 268435455) << 4 | $7_1 >>> 28;
        HEAP32[$6_1 >> 2] = $13_1;
        $16_1 = $5_1 | $10_1;
        HEAP32[$6_1 + 4 >> 2] = $16_1;
        $5_1 = $8_1 << 24 | $7_1 >>> 8;
        $10_1 = $7_1 << 24 & -16777216;
        $7_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
        $6_1 = $4_1 - -64 | 0;
        $8_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
        $14_1 = $8_1 >>> 8 | $10_1;
        HEAP32[$6_1 >> 2] = $14_1;
        $17_1 = $5_1 & 1048575;
        HEAP32[$6_1 + 4 >> 2] = $17_1;
        $5_1 = $7_1;
        $10_1 = $8_1 << 12 | $5_1 >>> 20;
        $7_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
        $6_1 = $4_1 + 56 | 0;
        $9_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
        $15_1 = $5_1 << 12 & -4096 | $9_1 >>> 20;
        HEAP32[$6_1 >> 2] = $15_1;
        $18_1 = $10_1 & 1048575;
        HEAP32[$6_1 + 4 >> 2] = $18_1;
        HEAP32[$4_1 + 88 >> 2] = 0;
        HEAP32[$4_1 + 48 >> 2] = $7_1;
        $19_1 = $9_1 & 1048575;
        HEAP32[$4_1 + 52 >> 2] = $19_1;
        $5_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
        $6_1 = $5_1;
        $8_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
        $9_1 = ($5_1 << 12 | $8_1 >>> 20) & 1048575;
        $5_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
        $12_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
        $20_1 = $8_1 << 12 & -4096 | $12_1 >>> 20;
        HEAP32[$4_1 + 16 >> 2] = $20_1;
        $25_1 = $9_1;
        HEAP32[$4_1 + 20 >> 2] = $9_1;
        $8_1 = $5_1;
        HEAP32[$4_1 + 8 >> 2] = $5_1;
        $21_1 = $12_1 & 1048575;
        HEAP32[$4_1 + 12 >> 2] = $21_1;
        $9_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
        $5_1 = $9_1 >>> 16 | 0;
        $10_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
        $12_1 = ($9_1 & 65535) << 16 | $10_1 >>> 16;
        HEAP32[$4_1 + 40 >> 2] = $12_1;
        $9_1 = $5_1;
        HEAP32[$4_1 + 44 >> 2] = $5_1;
        $5_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
        $26_1 = $5_1;
        $22_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
        $3_1 = $5_1;
        $23_1 = ($22_1 << 24 | $3_1 >>> 8) & 1048575;
        $6_1 = $3_1 << 24 & -16777216 | $6_1 >>> 8;
        HEAP32[$4_1 + 24 >> 2] = $6_1;
        HEAP32[$4_1 + 28 >> 2] = $23_1;
        $3_1 = $22_1;
        $5_1 = $3_1 >>> 28 | 0;
        $3_1 = ($3_1 & 268435455) << 4 | $26_1 >>> 28;
        HEAP32[$4_1 + 32 >> 2] = $3_1;
        $5_1 = $5_1 | $10_1 << 4 & 1048560;
        HEAP32[$4_1 + 36 >> 2] = $5_1;
        if (!($8_1 | $20_1 | $12_1 | $6_1 | $3_1 | ($25_1 | $21_1 | $9_1 | $23_1 | $5_1))) {
          FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](690116, HEAP32[$0_1 + 172 >> 2]);
          $0_1 = 0;
          break label$1;
        }
        if ($7_1 & 1) {
          HEAP32[$4_1 + 80 >> 2] = -4 - $11_1;
          HEAP32[$4_1 + 84 >> 2] = 262143 - (($11_1 >>> 0 > 4294967292) + $24_1 | 0);
          HEAP32[$4_1 + 72 >> 2] = -4 - $13_1;
          HEAP32[$4_1 + 76 >> 2] = 4194303 - (($13_1 >>> 0 > 4294967292) + $16_1 | 0);
          HEAP32[$4_1 + 64 >> 2] = -4 - $14_1;
          HEAP32[$4_1 + 68 >> 2] = 4194303 - (($14_1 >>> 0 > 4294967292) + $17_1 | 0);
          HEAP32[$4_1 + 56 >> 2] = -4 - $15_1;
          HEAP32[$4_1 + 60 >> 2] = 4194303 - (($15_1 >>> 0 > 4294967292) + $18_1 | 0);
          HEAP32[$4_1 + 48 >> 2] = -3908 - $7_1;
          HEAP32[$4_1 + 52 >> 2] = 4194299 - (($7_1 >>> 0 > 4294963388) + $19_1 | 0);
          $27_1 = 1;
        }
        if ($2_1) {
          HEAP32[$2_1 >> 2] = $27_1;
        }
        $35($1_1, $4_1 + 8 | 0);
        $0_1 = 1;
      }
      global$0 = $4_1 + 96 | 0;
      return $0_1;
    }
    function $60($0_1, $1_1) {
      var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0;
      $2_1 = global$0 - 256 | 0;
      global$0 = $2_1;
      label$1: {
        if (!$1_1) {
          FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689700, HEAP32[$0_1 + 172 >> 2]);
          break label$1;
        }
        $6_1 = $68($1_1, 96);
        if (!HEAP32[$0_1 >> 2]) {
          FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](690045, HEAP32[$0_1 + 172 >> 2]);
          break label$1;
        }
        $3_1 = $2_1 + 96 | 0;
        $7_1 = $2_1 + 128 | 0;
        $38($3_1, 690788, $7_1);
        $9_1 = HEAP32[$2_1 + 120 >> 2];
        $10_1 = HEAP32[$2_1 + 112 >> 2];
        $4_1 = HEAP32[$2_1 + 104 >> 2];
        $11_1 = HEAP32[$2_1 + 96 >> 2];
        $12_1 = HEAP32[$2_1 + 124 >> 2];
        $13_1 = HEAP32[$2_1 + 116 >> 2];
        $14_1 = HEAP32[$2_1 + 108 >> 2];
        $15_1 = HEAP32[$2_1 + 100 >> 2];
        $8_1 = HEAP32[$2_1 + 128 >> 2] | !($9_1 | ($10_1 | ($4_1 | $11_1)) | ($12_1 | ($13_1 | ($14_1 | $15_1))));
        $1_1 = $8_1 ? 0 : -1;
        HEAP32[$2_1 + 120 >> 2] = $1_1 & $9_1;
        HEAP32[$2_1 + 124 >> 2] = $1_1 & $12_1;
        HEAP32[$2_1 + 112 >> 2] = $1_1 & $10_1;
        HEAP32[$2_1 + 116 >> 2] = $1_1 & $13_1;
        HEAP32[$2_1 + 104 >> 2] = $1_1 & $4_1;
        HEAP32[$2_1 + 108 >> 2] = $1_1 & $14_1;
        $4_1 = ($8_1 | 0) != 0;
        HEAP32[$2_1 + 96 >> 2] = $4_1 | $1_1 & $11_1;
        HEAP32[$2_1 + 100 >> 2] = $1_1 & $15_1;
        $48($0_1, $7_1, $3_1);
        $0_1 = $2_1 + 8 | 0;
        $49($0_1, $7_1);
        $39($6_1, $3_1);
        $35($6_1 + 32 | 0, $0_1);
        HEAP32[$2_1 + 128 >> 2] = $4_1;
        $0_1 = HEAP32[$2_1 + 128 >> 2] - 1 | 0;
        while (1) {
          $1_1 = $5_1 + $6_1 | 0;
          HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] & $0_1;
          $3_1 = $1_1 + 1 | 0;
          HEAP8[$3_1 | 0] = HEAPU8[$3_1 | 0] & $0_1;
          $3_1 = $1_1 + 2 | 0;
          HEAP8[$3_1 | 0] = HEAPU8[$3_1 | 0] & $0_1;
          $3_1 = $1_1 + 3 | 0;
          HEAP8[$3_1 | 0] = HEAPU8[$3_1 | 0] & $0_1;
          $3_1 = $1_1 + 4 | 0;
          HEAP8[$3_1 | 0] = HEAPU8[$3_1 | 0] & $0_1;
          $1_1 = $1_1 + 5 | 0;
          HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] & $0_1;
          $5_1 = $5_1 + 6 | 0;
          if (($5_1 | 0) != 96) {
            continue;
          }
          break;
        }
        ;
        $5_1 = !$8_1;
      }
      global$0 = $2_1 + 256 | 0;
      return $5_1;
    }
    function $61($0_1, $1_1, $2_1, $3_1, $4_1, $5_1, $6_1, $7_1) {
      $0_1 = $0_1 | 0;
      $1_1 = $1_1 | 0;
      $2_1 = $2_1 | 0;
      $3_1 = $3_1 | 0;
      $4_1 = $4_1 | 0;
      $5_1 = $5_1 | 0;
      $6_1 = $6_1 | 0;
      $7_1 = $7_1 | 0;
      var $8_1 = 0, $9_1 = 0;
      $8_1 = global$0 - 176 | 0;
      global$0 = $8_1;
      if ($5_1) {
        label$2: {
          if (!$7_1) {
            HEAP8[$8_1 | 0] = HEAPU8[$3_1 | 0] ^ 84;
            HEAP8[$8_1 + 1 | 0] = HEAPU8[$3_1 + 1 | 0] ^ 241;
            HEAP8[$8_1 + 2 | 0] = HEAPU8[$3_1 + 2 | 0] ^ 105;
            HEAP8[$8_1 + 3 | 0] = HEAPU8[$3_1 + 3 | 0] ^ 207;
            HEAP8[$8_1 + 4 | 0] = HEAPU8[$3_1 + 4 | 0] ^ 201;
            HEAP8[$8_1 + 5 | 0] = HEAPU8[$3_1 + 5 | 0] ^ 226;
            HEAP8[$8_1 + 6 | 0] = HEAPU8[$3_1 + 6 | 0] ^ 229;
            HEAP8[$8_1 + 7 | 0] = HEAPU8[$3_1 + 7 | 0] ^ 114;
            HEAP8[$8_1 + 8 | 0] = HEAPU8[$3_1 + 8 | 0] ^ 116;
            HEAP8[$8_1 + 9 | 0] = HEAPU8[$3_1 + 9 | 0] ^ 128;
            HEAP8[$8_1 + 10 | 0] = HEAPU8[$3_1 + 10 | 0] ^ 68;
            HEAP8[$8_1 + 11 | 0] = HEAPU8[$3_1 + 11 | 0] ^ 31;
            HEAP8[$8_1 + 12 | 0] = HEAPU8[$3_1 + 12 | 0] ^ 144;
            HEAP8[$8_1 + 13 | 0] = HEAPU8[$3_1 + 13 | 0] ^ 186;
            HEAP8[$8_1 + 14 | 0] = HEAPU8[$3_1 + 14 | 0] ^ 37;
            HEAP8[$8_1 + 15 | 0] = HEAPU8[$3_1 + 15 | 0] ^ 196;
            HEAP8[$8_1 + 16 | 0] = HEAPU8[$3_1 + 16 | 0] ^ 136;
            HEAP8[$8_1 + 17 | 0] = HEAPU8[$3_1 + 17 | 0] ^ 244;
            HEAP8[$8_1 + 18 | 0] = HEAPU8[$3_1 + 18 | 0] ^ 97;
            HEAP8[$8_1 + 19 | 0] = HEAPU8[$3_1 + 19 | 0] ^ 199;
            HEAP8[$8_1 + 20 | 0] = HEAPU8[$3_1 + 20 | 0] ^ 11;
            HEAP8[$8_1 + 21 | 0] = HEAPU8[$3_1 + 21 | 0] ^ 94;
            HEAP8[$8_1 + 22 | 0] = HEAPU8[$3_1 + 22 | 0] ^ 165;
            HEAP8[$8_1 + 23 | 0] = HEAPU8[$3_1 + 23 | 0] ^ 220;
            HEAP8[$8_1 + 24 | 0] = HEAPU8[$3_1 + 24 | 0] ^ 170;
            HEAP8[$8_1 + 25 | 0] = HEAPU8[$3_1 + 25 | 0] ^ 247;
            HEAP8[$8_1 + 26 | 0] = HEAPU8[$3_1 + 26 | 0] ^ 175;
            HEAP8[$8_1 + 27 | 0] = HEAPU8[$3_1 + 27 | 0] ^ 105;
            HEAP8[$8_1 + 28 | 0] = HEAPU8[$3_1 + 28 | 0] ^ 39;
            HEAP8[$8_1 + 29 | 0] = HEAPU8[$3_1 + 29 | 0] ^ 10;
            HEAP8[$8_1 + 30 | 0] = HEAPU8[$3_1 + 30 | 0] ^ 165;
            HEAP8[$8_1 + 31 | 0] = HEAPU8[$3_1 + 31 | 0] ^ 20;
            break label$2;
          }
          HEAP32[$8_1 + 136 >> 2] = 64;
          HEAP32[$8_1 + 140 >> 2] = 0;
          HEAP32[$8_1 + 64 >> 2] = 1252796217;
          HEAP32[$8_1 + 68 >> 2] = 614368522;
          HEAP32[$8_1 + 56 >> 2] = 989586609;
          HEAP32[$8_1 + 60 >> 2] = 1279582103;
          HEAP32[$8_1 + 48 >> 2] = -904942663;
          HEAP32[$8_1 + 52 >> 2] = 262346349;
          HEAP32[$8_1 + 40 >> 2] = 618476057;
          HEAP32[$8_1 + 44 >> 2] = 1320844912;
          $9_1 = $8_1 + 40 | 0;
          $29($9_1, $7_1, 32);
          $30($9_1, $8_1);
          HEAP8[$8_1 | 0] = HEAPU8[$8_1 | 0] ^ HEAPU8[$3_1 | 0];
          HEAP8[$8_1 + 1 | 0] = HEAPU8[$8_1 + 1 | 0] ^ HEAPU8[$3_1 + 1 | 0];
          HEAP8[$8_1 + 2 | 0] = HEAPU8[$8_1 + 2 | 0] ^ HEAPU8[$3_1 + 2 | 0];
          HEAP8[$8_1 + 3 | 0] = HEAPU8[$8_1 + 3 | 0] ^ HEAPU8[$3_1 + 3 | 0];
          HEAP8[$8_1 + 4 | 0] = HEAPU8[$8_1 + 4 | 0] ^ HEAPU8[$3_1 + 4 | 0];
          HEAP8[$8_1 + 5 | 0] = HEAPU8[$8_1 + 5 | 0] ^ HEAPU8[$3_1 + 5 | 0];
          HEAP8[$8_1 + 6 | 0] = HEAPU8[$8_1 + 6 | 0] ^ HEAPU8[$3_1 + 6 | 0];
          HEAP8[$8_1 + 7 | 0] = HEAPU8[$8_1 + 7 | 0] ^ HEAPU8[$3_1 + 7 | 0];
          HEAP8[$8_1 + 8 | 0] = HEAPU8[$8_1 + 8 | 0] ^ HEAPU8[$3_1 + 8 | 0];
          HEAP8[$8_1 + 9 | 0] = HEAPU8[$8_1 + 9 | 0] ^ HEAPU8[$3_1 + 9 | 0];
          HEAP8[$8_1 + 10 | 0] = HEAPU8[$8_1 + 10 | 0] ^ HEAPU8[$3_1 + 10 | 0];
          HEAP8[$8_1 + 11 | 0] = HEAPU8[$8_1 + 11 | 0] ^ HEAPU8[$3_1 + 11 | 0];
          HEAP8[$8_1 + 12 | 0] = HEAPU8[$8_1 + 12 | 0] ^ HEAPU8[$3_1 + 12 | 0];
          HEAP8[$8_1 + 13 | 0] = HEAPU8[$8_1 + 13 | 0] ^ HEAPU8[$3_1 + 13 | 0];
          HEAP8[$8_1 + 14 | 0] = HEAPU8[$8_1 + 14 | 0] ^ HEAPU8[$3_1 + 14 | 0];
          HEAP8[$8_1 + 15 | 0] = HEAPU8[$8_1 + 15 | 0] ^ HEAPU8[$3_1 + 15 | 0];
          HEAP8[$8_1 + 16 | 0] = HEAPU8[$8_1 + 16 | 0] ^ HEAPU8[$3_1 + 16 | 0];
          HEAP8[$8_1 + 17 | 0] = HEAPU8[$8_1 + 17 | 0] ^ HEAPU8[$3_1 + 17 | 0];
          HEAP8[$8_1 + 18 | 0] = HEAPU8[$8_1 + 18 | 0] ^ HEAPU8[$3_1 + 18 | 0];
          HEAP8[$8_1 + 19 | 0] = HEAPU8[$8_1 + 19 | 0] ^ HEAPU8[$3_1 + 19 | 0];
          HEAP8[$8_1 + 20 | 0] = HEAPU8[$8_1 + 20 | 0] ^ HEAPU8[$3_1 + 20 | 0];
          HEAP8[$8_1 + 21 | 0] = HEAPU8[$8_1 + 21 | 0] ^ HEAPU8[$3_1 + 21 | 0];
          HEAP8[$8_1 + 22 | 0] = HEAPU8[$8_1 + 22 | 0] ^ HEAPU8[$3_1 + 22 | 0];
          HEAP8[$8_1 + 23 | 0] = HEAPU8[$8_1 + 23 | 0] ^ HEAPU8[$3_1 + 23 | 0];
          HEAP8[$8_1 + 24 | 0] = HEAPU8[$8_1 + 24 | 0] ^ HEAPU8[$3_1 + 24 | 0];
          HEAP8[$8_1 + 25 | 0] = HEAPU8[$8_1 + 25 | 0] ^ HEAPU8[$3_1 + 25 | 0];
          HEAP8[$8_1 + 26 | 0] = HEAPU8[$8_1 + 26 | 0] ^ HEAPU8[$3_1 + 26 | 0];
          HEAP8[$8_1 + 27 | 0] = HEAPU8[$8_1 + 27 | 0] ^ HEAPU8[$3_1 + 27 | 0];
          HEAP8[$8_1 + 28 | 0] = HEAPU8[$8_1 + 28 | 0] ^ HEAPU8[$3_1 + 28 | 0];
          HEAP8[$8_1 + 29 | 0] = HEAPU8[$8_1 + 29 | 0] ^ HEAPU8[$3_1 + 29 | 0];
          HEAP8[$8_1 + 30 | 0] = HEAPU8[$8_1 + 30 | 0] ^ HEAPU8[$3_1 + 30 | 0];
          HEAP8[$8_1 + 31 | 0] = HEAPU8[$8_1 + 31 | 0] ^ HEAPU8[$3_1 + 31 | 0];
        }
        label$4: {
          if (($6_1 | 0) == 13) {
            label$6: {
              if (HEAPU8[$5_1 | 0] != 66) {
                break label$6;
              }
              if (HEAPU8[$5_1 + 1 | 0] != 73) {
                break label$6;
              }
              if (HEAPU8[$5_1 + 2 | 0] != 80) {
                break label$6;
              }
              if (HEAPU8[$5_1 + 3 | 0] != 48) {
                break label$6;
              }
              if (HEAPU8[$5_1 + 4 | 0] != 51) {
                break label$6;
              }
              if (HEAPU8[$5_1 + 5 | 0] != 52) {
                break label$6;
              }
              if (HEAPU8[$5_1 + 6 | 0] != 48) {
                break label$6;
              }
              if (HEAPU8[$5_1 + 7 | 0] != 47) {
                break label$6;
              }
              if (HEAPU8[$5_1 + 8 | 0] != 110) {
                break label$6;
              }
              if (HEAPU8[$5_1 + 9 | 0] != 111) {
                break label$6;
              }
              if (HEAPU8[$5_1 + 10 | 0] != 110) {
                break label$6;
              }
              if (HEAPU8[$5_1 + 11 | 0] != 99) {
                break label$6;
              }
              if (HEAPU8[$5_1 + 12 | 0] != 101) {
                break label$6;
              }
              HEAP32[$8_1 + 136 >> 2] = 64;
              HEAP32[$8_1 + 140 >> 2] = 0;
              HEAP32[$8_1 + 64 >> 2] = 564305492;
              HEAP32[$8_1 + 68 >> 2] = 1756396364;
              HEAP32[$8_1 + 56 >> 2] = 1612804480;
              HEAP32[$8_1 + 60 >> 2] = 1463125601;
              HEAP32[$8_1 + 48 >> 2] = -1618098575;
              HEAP32[$8_1 + 52 >> 2] = -2090698061;
              HEAP32[$8_1 + 40 >> 2] = 1180785461;
              HEAP32[$8_1 + 44 >> 2] = -188760073;
              break label$4;
            }
            HEAP32[$8_1 + 136 >> 2] = 0;
            HEAP32[$8_1 + 140 >> 2] = 0;
            HEAP32[$8_1 + 64 >> 2] = 528734635;
            HEAP32[$8_1 + 68 >> 2] = 1541459225;
            HEAP32[$8_1 + 56 >> 2] = 1359893119;
            HEAP32[$8_1 + 60 >> 2] = -1694144372;
            HEAP32[$8_1 + 48 >> 2] = 1013904242;
            HEAP32[$8_1 + 52 >> 2] = -1521486534;
            HEAP32[$8_1 + 40 >> 2] = 1779033703;
            HEAP32[$8_1 + 44 >> 2] = -1150833019;
            $3_1 = $8_1 + 40 | 0;
            $29($3_1, $5_1, 13);
            $5_1 = $8_1 + 144 | 0;
            $30($3_1, $5_1);
            HEAP32[$8_1 + 136 >> 2] = 0;
            HEAP32[$8_1 + 140 >> 2] = 0;
            HEAP32[$8_1 + 64 >> 2] = 528734635;
            HEAP32[$8_1 + 68 >> 2] = 1541459225;
            HEAP32[$8_1 + 56 >> 2] = 1359893119;
            HEAP32[$8_1 + 60 >> 2] = -1694144372;
            HEAP32[$8_1 + 48 >> 2] = 1013904242;
            HEAP32[$8_1 + 52 >> 2] = -1521486534;
            HEAP32[$8_1 + 40 >> 2] = 1779033703;
            HEAP32[$8_1 + 44 >> 2] = -1150833019;
            $29($3_1, $5_1, 32);
            $29($3_1, $5_1, 32);
            break label$4;
          }
          HEAP32[$8_1 + 136 >> 2] = 0;
          HEAP32[$8_1 + 140 >> 2] = 0;
          HEAP32[$8_1 + 64 >> 2] = 528734635;
          HEAP32[$8_1 + 68 >> 2] = 1541459225;
          HEAP32[$8_1 + 56 >> 2] = 1359893119;
          HEAP32[$8_1 + 60 >> 2] = -1694144372;
          HEAP32[$8_1 + 48 >> 2] = 1013904242;
          HEAP32[$8_1 + 52 >> 2] = -1521486534;
          HEAP32[$8_1 + 40 >> 2] = 1779033703;
          HEAP32[$8_1 + 44 >> 2] = -1150833019;
          $3_1 = $8_1 + 40 | 0;
          $29($3_1, $5_1, $6_1);
          $5_1 = $8_1 + 144 | 0;
          $30($3_1, $5_1);
          HEAP32[$8_1 + 136 >> 2] = 0;
          HEAP32[$8_1 + 140 >> 2] = 0;
          HEAP32[$8_1 + 64 >> 2] = 528734635;
          HEAP32[$8_1 + 68 >> 2] = 1541459225;
          HEAP32[$8_1 + 56 >> 2] = 1359893119;
          HEAP32[$8_1 + 60 >> 2] = -1694144372;
          HEAP32[$8_1 + 48 >> 2] = 1013904242;
          HEAP32[$8_1 + 52 >> 2] = -1521486534;
          HEAP32[$8_1 + 40 >> 2] = 1779033703;
          HEAP32[$8_1 + 44 >> 2] = -1150833019;
          $29($3_1, $5_1, 32);
          $29($3_1, $5_1, 32);
        }
        $3_1 = $8_1 + 40 | 0;
        $29($3_1, $8_1, 32);
        $29($3_1, $4_1, 32);
        $29($3_1, $1_1, $2_1);
        $30($3_1, $0_1);
        $0_1 = 1;
      } else {
        $0_1 = 0;
      }
      global$0 = $8_1 + 176 | 0;
      return $0_1 | 0;
    }
    function $62($0_1, $1_1, $2_1) {
      var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0;
      $7_1 = global$0 - 32 | 0;
      global$0 = $7_1;
      $13_1 = $68($0_1, 516);
      $0_1 = $1_1 + 24 | 0;
      $10_1 = HEAP32[$0_1 >> 2];
      $0_1 = HEAP32[$0_1 + 4 >> 2];
      $4_1 = $7_1 + 24 | 0;
      HEAP32[$4_1 >> 2] = $10_1;
      HEAP32[$4_1 + 4 >> 2] = $0_1;
      $4_1 = $1_1 + 16 | 0;
      $3_1 = HEAP32[$4_1 + 4 >> 2];
      $5_1 = $7_1 + 16 | 0;
      HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
      HEAP32[$5_1 + 4 >> 2] = $3_1;
      $4_1 = $1_1 + 8 | 0;
      $3_1 = HEAP32[$4_1 + 4 >> 2];
      $5_1 = $7_1 + 8 | 0;
      HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
      HEAP32[$5_1 + 4 >> 2] = $3_1;
      $4_1 = HEAP32[$1_1 + 4 >> 2];
      HEAP32[$7_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$7_1 + 4 >> 2] = $4_1;
      $8_1 = 1;
      $4_1 = $0_1;
      if (($0_1 | 0) < 0) {
        $3_1 = HEAP32[$7_1 >> 2] ^ -1;
        $5_1 = $3_1 - 801750718 | 0;
        $6_1 = HEAP32[$7_1 + 4 >> 2] ^ -1;
        $1_1 = $6_1 - (($3_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
        HEAP32[$7_1 >> 2] = $5_1;
        HEAP32[$7_1 + 4 >> 2] = $1_1;
        $1_1 = ($1_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 > $5_1 >>> 0 | $1_1 >>> 0 < $6_1 >>> 0;
        $0_1 = $7_1;
        $5_1 = HEAP32[$0_1 + 8 >> 2] ^ -1;
        $1_1 = $1_1 + $5_1 | 0;
        $6_1 = HEAP32[$0_1 + 12 >> 2] ^ -1;
        $3_1 = $6_1;
        $9_1 = $1_1 - 1354194885 | 0;
        HEAP32[$0_1 + 8 >> 2] = $9_1;
        $3_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $3_1 - (($1_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
        HEAP32[$0_1 + 12 >> 2] = $8_1;
        $6_1 = ($3_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 < $5_1 >>> 0 | $3_1 >>> 0 < $6_1 >>> 0;
        $5_1 = ($3_1 | 0) == ($8_1 | 0) & $1_1 >>> 0 > $9_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
        $1_1 = $6_1 + $5_1 | 0;
        $6_1 = HEAP32[$0_1 + 20 >> 2] ^ -1;
        $3_1 = $6_1 + ($1_1 >>> 0 < $5_1 >>> 0) | 0;
        $5_1 = HEAP32[$0_1 + 16 >> 2] ^ -1;
        $1_1 = $5_1 + $1_1 | 0;
        $9_1 = $1_1 - 2 | 0;
        HEAP32[$0_1 + 16 >> 2] = $9_1;
        $3_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $3_1 - ($1_1 >>> 0 < 2) | 0;
        HEAP32[$0_1 + 20 >> 2] = $8_1;
        $0_1 = ($3_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 < $5_1 >>> 0 | $3_1 >>> 0 < $6_1 >>> 0;
        $3_1 = ($3_1 | 0) == ($8_1 | 0) & $1_1 >>> 0 > $9_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
        $0_1 = $0_1 + $3_1 | 0;
        $1_1 = $0_1 >>> 0 < $3_1 >>> 0;
        $3_1 = $0_1 - $10_1 | 0;
        HEAP32[$7_1 + 24 >> 2] = $3_1 - 2;
        HEAP32[$7_1 + 28 >> 2] = ($1_1 - (($0_1 >>> 0 < $10_1 >>> 0) + $4_1 | 0) | 0) - ($3_1 >>> 0 < 2);
        $8_1 = -1;
      }
      $14_1 = $2_1 - 1 | 0;
      $10_1 = -1;
      $1_1 = 0;
      while (1) {
        $3_1 = $1_1 >>> 6 | 0;
        $12_1 = $3_1 << 3;
        $4_1 = $12_1 + $7_1 | 0;
        $0_1 = HEAP32[$4_1 >> 2];
        $5_1 = HEAP32[$4_1 + 4 >> 2];
        $6_1 = $1_1 & 63;
        $4_1 = $6_1 & 31;
        if ($6_1 >>> 0 >= 32) {
          $4_1 = $5_1 >>> $4_1 | 0;
        } else {
          $4_1 = ((1 << $4_1) - 1 & $5_1) << 32 - $4_1 | $0_1 >>> $4_1;
        }
        label$3: {
          if (($11_1 | 0) == ($4_1 & 1)) {
            $0_1 = $1_1 + 1 | 0;
            break label$3;
          }
          $0_1 = 129 - $1_1 | 0;
          $9_1 = ($0_1 | 0) < ($2_1 | 0) ? $0_1 : $2_1;
          $0_1 = $9_1 + $1_1 | 0;
          if (($3_1 | 0) != ($0_1 - 1 >>> 6 | 0)) {
            $3_1 = ($7_1 + $12_1 | 0) + 8 | 0;
            $10_1 = HEAP32[$3_1 >> 2];
            $3_1 = 64 - $6_1 | 0;
            $6_1 = $3_1 & 31;
            $4_1 = (($3_1 & 63) >>> 0 < 32 ? $10_1 << $6_1 : 0) | $4_1;
          }
          $3_1 = $9_1 & 31;
          $4_1 = $11_1 + ($4_1 & ((($9_1 & 63) >>> 0 < 32 ? -1 << $3_1 : 0) ^ -1)) | 0;
          $11_1 = $4_1 >>> $14_1 & 1;
          HEAP32[$13_1 + ($1_1 << 2) >> 2] = Math_imul($4_1 - ($11_1 << $2_1) | 0, $8_1);
          $10_1 = $1_1;
        }
        $1_1 = $0_1;
        if (($1_1 | 0) < 129) {
          continue;
        }
        break;
      }
      ;
      global$0 = $7_1 + 32 | 0;
      return $10_1 + 1 | 0;
    }
    function $63($0_1, $1_1, $2_1) {
      var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0;
      label$1: {
        if (($2_1 | 0) > 0) {
          $3_1 = $1_1 + (($2_1 << 5) - 32 & -64) | 0;
          $1_1 = HEAP32[$3_1 >> 2];
          $2_1 = HEAP32[$3_1 + 4 >> 2] & 1048575;
          HEAP32[$0_1 >> 2] = $1_1;
          HEAP32[$0_1 + 4 >> 2] = $2_1;
          $1_1 = HEAP32[$3_1 + 8 >> 2];
          $2_1 = HEAP32[$3_1 + 12 >> 2] << 12 | $1_1 >>> 20;
          HEAP32[$0_1 + 8 >> 2] = $1_1 << 12 & -4096 | HEAP32[$3_1 + 4 >> 2] >>> 20;
          HEAP32[$0_1 + 12 >> 2] = $2_1 & 1048575;
          $1_1 = HEAP32[$3_1 + 16 >> 2];
          $2_1 = HEAP32[$3_1 + 20 >> 2] << 24 | $1_1 >>> 8;
          HEAP32[$0_1 + 16 >> 2] = $1_1 << 24 & -16777216 | HEAP32[$3_1 + 12 >> 2] >>> 8;
          HEAP32[$0_1 + 20 >> 2] = $2_1 & 1048575;
          $4_1 = HEAP32[$3_1 + 24 >> 2] << 4 & 1048560;
          $2_1 = HEAP32[$3_1 + 20 >> 2];
          $1_1 = $2_1 >>> 28 | 0;
          HEAP32[$0_1 + 24 >> 2] = ($2_1 & 268435455) << 4 | HEAP32[$3_1 + 16 >> 2] >>> 28;
          HEAP32[$0_1 + 28 >> 2] = $1_1 | $4_1;
          $1_1 = HEAP32[$3_1 + 28 >> 2];
          $2_1 = $1_1 >>> 16 | 0;
          HEAP32[$0_1 + 32 >> 2] = ($1_1 & 65535) << 16 | HEAP32[$3_1 + 24 >> 2] >>> 16;
          HEAP32[$0_1 + 36 >> 2] = $2_1;
          $1_1 = HEAP32[$3_1 + 36 >> 2] & 1048575;
          HEAP32[$0_1 + 40 >> 2] = HEAP32[$3_1 + 32 >> 2];
          HEAP32[$0_1 + 44 >> 2] = $1_1;
          $4_1 = $3_1 + 40 | 0;
          $1_1 = HEAP32[$4_1 >> 2];
          $2_1 = HEAP32[$4_1 + 4 >> 2] << 12 | $1_1 >>> 20;
          $5_1 = $0_1 + 48 | 0;
          HEAP32[$5_1 >> 2] = $1_1 << 12 & -4096 | HEAP32[$3_1 + 36 >> 2] >>> 20;
          HEAP32[$5_1 + 4 >> 2] = $2_1 & 1048575;
          $5_1 = $3_1 + 48 | 0;
          $1_1 = HEAP32[$5_1 >> 2];
          $2_1 = HEAP32[$5_1 + 4 >> 2] << 24 | $1_1 >>> 8;
          $6_1 = $0_1 + 56 | 0;
          HEAP32[$6_1 >> 2] = $1_1 << 24 & -16777216 | HEAP32[$4_1 + 4 >> 2] >>> 8;
          HEAP32[$6_1 + 4 >> 2] = $2_1 & 1048575;
          $3_1 = $3_1 + 56 | 0;
          $1_1 = HEAP32[$3_1 >> 2];
          $6_1 = $1_1 << 4 & 1048560;
          $2_1 = HEAP32[$5_1 + 4 >> 2];
          $1_1 = $2_1 >>> 28 | 0;
          $4_1 = $0_1 - -64 | 0;
          HEAP32[$4_1 >> 2] = ($2_1 & 268435455) << 4 | HEAP32[$5_1 >> 2] >>> 28;
          HEAP32[$4_1 + 4 >> 2] = $1_1 | $6_1;
          $1_1 = $0_1 + 72 | 0;
          $4_1 = HEAP32[$3_1 + 4 >> 2];
          HEAP32[$1_1 >> 2] = ($4_1 & 65535) << 16 | HEAP32[$3_1 >> 2] >>> 16;
          HEAP32[$1_1 + 4 >> 2] = $4_1 >>> 16;
          break label$1;
        }
        $3_1 = $1_1 + (($2_1 ^ -1) / 2 << 6) | 0;
        $1_1 = HEAP32[$3_1 >> 2];
        $2_1 = HEAP32[$3_1 + 4 >> 2] & 1048575;
        HEAP32[$0_1 >> 2] = $1_1;
        HEAP32[$0_1 + 4 >> 2] = $2_1;
        $1_1 = HEAP32[$3_1 + 8 >> 2];
        $2_1 = HEAP32[$3_1 + 12 >> 2] << 12 | $1_1 >>> 20;
        HEAP32[$0_1 + 8 >> 2] = $1_1 << 12 & -4096 | HEAP32[$3_1 + 4 >> 2] >>> 20;
        HEAP32[$0_1 + 12 >> 2] = $2_1 & 1048575;
        $1_1 = HEAP32[$3_1 + 16 >> 2];
        $2_1 = HEAP32[$3_1 + 20 >> 2] << 24 | $1_1 >>> 8;
        HEAP32[$0_1 + 16 >> 2] = $1_1 << 24 & -16777216 | HEAP32[$3_1 + 12 >> 2] >>> 8;
        HEAP32[$0_1 + 20 >> 2] = $2_1 & 1048575;
        $4_1 = HEAP32[$3_1 + 24 >> 2] << 4 & 1048560;
        $2_1 = HEAP32[$3_1 + 20 >> 2];
        $1_1 = $2_1 >>> 28 | 0;
        HEAP32[$0_1 + 24 >> 2] = ($2_1 & 268435455) << 4 | HEAP32[$3_1 + 16 >> 2] >>> 28;
        HEAP32[$0_1 + 28 >> 2] = $1_1 | $4_1;
        $1_1 = HEAP32[$3_1 + 28 >> 2];
        $2_1 = $1_1 >>> 16 | 0;
        HEAP32[$0_1 + 32 >> 2] = ($1_1 & 65535) << 16 | HEAP32[$3_1 + 24 >> 2] >>> 16;
        HEAP32[$0_1 + 36 >> 2] = $2_1;
        $6_1 = HEAP32[$3_1 + 36 >> 2] & 1048575;
        $9_1 = HEAP32[$3_1 + 32 >> 2];
        HEAP32[$0_1 + 40 >> 2] = $9_1;
        HEAP32[$0_1 + 44 >> 2] = $6_1;
        $4_1 = $3_1 + 40 | 0;
        $1_1 = HEAP32[$4_1 >> 2];
        $2_1 = HEAP32[$4_1 + 4 >> 2] << 12 | $1_1 >>> 20;
        $10_1 = $0_1 + 48 | 0;
        $5_1 = $10_1;
        $11_1 = $1_1 << 12 & -4096 | HEAP32[$3_1 + 36 >> 2] >>> 20;
        HEAP32[$5_1 >> 2] = $11_1;
        $13_1 = $2_1 & 1048575;
        HEAP32[$5_1 + 4 >> 2] = $13_1;
        $5_1 = $3_1 + 48 | 0;
        $1_1 = HEAP32[$5_1 >> 2];
        $2_1 = HEAP32[$5_1 + 4 >> 2] << 24 | $1_1 >>> 8;
        $7_1 = $0_1 + 56 | 0;
        $4_1 = $1_1 << 24 & -16777216 | HEAP32[$4_1 + 4 >> 2] >>> 8;
        HEAP32[$7_1 >> 2] = $4_1;
        $14_1 = $2_1 & 1048575;
        HEAP32[$7_1 + 4 >> 2] = $14_1;
        $3_1 = $3_1 + 56 | 0;
        $1_1 = HEAP32[$3_1 >> 2];
        $12_1 = $1_1 << 4 & 1048560;
        $2_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $2_1 >>> 28 | 0;
        $8_1 = $0_1 - -64 | 0;
        $2_1 = ($2_1 & 268435455) << 4 | HEAP32[$5_1 >> 2] >>> 28;
        HEAP32[$8_1 >> 2] = $2_1;
        $5_1 = $1_1 | $12_1;
        HEAP32[$8_1 + 4 >> 2] = $5_1;
        $12_1 = HEAP32[$3_1 >> 2];
        $1_1 = HEAP32[$3_1 + 4 >> 2];
        HEAP32[$8_1 >> 2] = -4 - $2_1;
        HEAP32[$8_1 + 4 >> 2] = 4194303 - (($2_1 >>> 0 > 4294967292) + $5_1 | 0);
        HEAP32[$7_1 >> 2] = -4 - $4_1;
        HEAP32[$7_1 + 4 >> 2] = 4194303 - (($4_1 >>> 0 > 4294967292) + $14_1 | 0);
        HEAP32[$10_1 >> 2] = -4 - $11_1;
        HEAP32[$10_1 + 4 >> 2] = 4194303 - (($11_1 >>> 0 > 4294967292) + $13_1 | 0);
        HEAP32[$0_1 + 40 >> 2] = -3908 - $9_1;
        HEAP32[$0_1 + 44 >> 2] = 4194299 - (($9_1 >>> 0 > 4294963388) + $6_1 | 0);
        $3_1 = $1_1 >>> 16 | 0;
        $2_1 = $0_1 + 72 | 0;
        $1_1 = ($1_1 & 65535) << 16 | $12_1 >>> 16;
        HEAP32[$2_1 >> 2] = -4 - $1_1;
        HEAP32[$2_1 + 4 >> 2] = 262143 - (($1_1 >>> 0 > 4294967292) + $3_1 | 0);
      }
      HEAP32[$0_1 + 80 >> 2] = 0;
    }
    function $64($0_1, $1_1, $2_1, $3_1) {
      var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0;
      $6_1 = global$0 - 1120 | 0;
      global$0 = $6_1;
      label$1: {
        if (HEAP32[$1_1 + 120 >> 2]) {
          HEAP32[$0_1 + 120 >> 2] = HEAP32[$2_1 + 80 >> 2];
          $4_1 = $6_1 + 1080 | 0;
          $54($4_1, $3_1);
          $1_1 = $6_1 + 1040 | 0;
          $34($1_1, $4_1, $3_1);
          $34($0_1, $2_1, $4_1);
          $34($0_1 + 40 | 0, $2_1 + 40 | 0, $1_1);
          $1_1 = $0_1 + 88 | 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          HEAP32[$0_1 + 80 >> 2] = 1;
          HEAP32[$0_1 + 84 >> 2] = 0;
          $1_1 = $0_1 + 96 | 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          $1_1 = $0_1 + 104 | 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          $0_1 = $0_1 + 112 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          break label$1;
        }
        if (HEAP32[$2_1 + 80 >> 2]) {
          $70($0_1, $1_1, 128);
          break label$1;
        }
        $44_1 = $6_1 + 1080 | 0;
        $45_1 = $1_1 + 80 | 0;
        $34($44_1, $45_1, $3_1);
        $3_1 = HEAP32[$6_1 + 1084 >> 2];
        $15_1 = $3_1;
        $12_1 = HEAP32[$6_1 + 1080 >> 2];
        $4_1 = $12_1;
        $3_1 = $3_1 << 1 | $4_1 >>> 31;
        $13_1 = $6_1 + 408 | 0;
        $21_1 = HEAP32[$6_1 + 1104 >> 2];
        $19_1 = HEAP32[$6_1 + 1108 >> 2];
        $22_1 = $4_1 << 1;
        $27_1 = $3_1;
        $69($13_1, $21_1, $19_1, 0, 0, $22_1, $3_1, 0, 0);
        $3_1 = HEAP32[$6_1 + 1092 >> 2];
        $42_1 = $3_1;
        $41_1 = HEAP32[$6_1 + 1088 >> 2];
        $5_1 = $41_1;
        $3_1 = $3_1 << 1 | $5_1 >>> 31;
        $9_1 = $6_1 + 616 | 0;
        $18_1 = HEAP32[$6_1 + 1096 >> 2];
        $17_1 = HEAP32[$6_1 + 1100 >> 2];
        $5_1 = $5_1 << 1;
        $8_1 = $3_1;
        $69($9_1, $18_1, $17_1, 0, 0, $5_1, $3_1, 0, 0);
        $14_1 = $6_1 + 568 | 0;
        $4_1 = HEAP32[$6_1 + 1112 >> 2];
        $3_1 = HEAP32[$6_1 + 1116 >> 2];
        $69($14_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
        $10_1 = $6_1 + 552 | 0;
        $69($10_1, HEAP32[$6_1 + 568 >> 2], HEAP32[$6_1 + 572 >> 2], 0, 0, 15632, 16, 0, 0);
        $3_1 = $3_1 << 1 | $4_1 >>> 31;
        $37_1 = $6_1 + 520 | 0;
        $28_1 = $4_1 << 1;
        $20_1 = $3_1;
        $69($37_1, $28_1, $3_1, 0, 0, $12_1, $15_1, 0, 0);
        $32_1 = $6_1 + 424 | 0;
        $69($32_1, $21_1, $19_1, 0, 0, $5_1, $8_1, 0, 0);
        $30_1 = $6_1 + 600 | 0;
        $69($30_1, $18_1, $17_1, 0, 0, $18_1, $17_1, 0, 0);
        $11_1 = $6_1 + 536 | 0;
        $3_1 = $14_1 + 8 | 0;
        $69($11_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
        $39_1 = $6_1 + 664 | 0;
        $69($39_1, $12_1, $15_1, 0, 0, $12_1, $15_1, 0, 0);
        $38_1 = $6_1 + 504 | 0;
        $69($38_1, $28_1, $20_1, 0, 0, $41_1, $42_1, 0, 0);
        $35_1 = $6_1 + 440 | 0;
        $69($35_1, $21_1, $19_1, 0, 0, $18_1 << 1, $17_1 << 1 | $18_1 >>> 31, 0, 0);
        $15_1 = HEAP32[$6_1 + 412 >> 2];
        $3_1 = $15_1 + HEAP32[$6_1 + 620 >> 2] | 0;
        $7_1 = HEAP32[$6_1 + 408 >> 2];
        $5_1 = HEAP32[$6_1 + 616 >> 2];
        $4_1 = $7_1 + $5_1 | 0;
        $8_1 = HEAP32[$6_1 + 552 >> 2];
        $25_1 = $4_1 + $8_1 | 0;
        $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $5_1 + HEAP32[$6_1 + 556 >> 2] | 0;
        $8_1 = $8_1 >>> 0 > $25_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $12_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $25_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
        $3_1 = $10_1 + 8 | 0;
        $14_1 = HEAP32[$3_1 >> 2];
        $10_1 = HEAP32[$3_1 + 4 >> 2];
        $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
        $5_1 = $9_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $13_1 + 8 | 0;
        $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $7_1 + $9_1 | 0;
        $3_1 = ($4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
        $5_1 = $4_1;
        $4_1 = $4_1 + $14_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $12_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $33_1 = $8_1;
        $14_1 = $4_1 << 12 | $8_1 >>> 20;
        $5_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $29_1 = HEAP32[$6_1 + 424 >> 2];
        $4_1 = HEAP32[$6_1 + 600 >> 2];
        $12_1 = $29_1 + $4_1 | 0;
        $36_1 = HEAP32[$6_1 + 428 >> 2];
        $3_1 = $36_1 + HEAP32[$6_1 + 604 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 520 >> 2];
        $10_1 = $4_1 + $12_1 | 0;
        $13_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 524 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = HEAP32[$6_1 + 536 >> 2];
        $8_1 = $4_1 + $10_1 | 0;
        $9_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 540 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $7_1 | 0;
        $34_1 = $6_1 + 344 | 0;
        $31_1 = $34_1;
        $14_1 = $8_1 + $14_1 | 0;
        $7_1 = $14_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $26_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $23_1 = ($4_1 | 0) == ($9_1 | 0) & $8_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $9_1 >>> 0;
        $3_1 = $11_1 + 8 | 0;
        $24_1 = HEAP32[$3_1 >> 2];
        $16_1 = HEAP32[$3_1 + 4 >> 2];
        $15_1 = ($9_1 | 0) == ($13_1 | 0) & $12_1 >>> 0 > $10_1 >>> 0 | $9_1 >>> 0 < $13_1 >>> 0;
        $3_1 = $37_1 + 8 | 0;
        $11_1 = HEAP32[$3_1 >> 2];
        $9_1 = HEAP32[$3_1 + 4 >> 2];
        $10_1 = ($13_1 | 0) == ($36_1 | 0) & $12_1 >>> 0 < $29_1 >>> 0 | $13_1 >>> 0 < $36_1 >>> 0;
        $8_1 = $30_1 + 8 | 0;
        $4_1 = HEAP32[$8_1 >> 2];
        $3_1 = $32_1 + 8 | 0;
        $12_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $12_1 + $10_1 | 0;
        $3_1 = ($4_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $9_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + $11_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1;
        $4_1 = $4_1 + $15_1 | 0;
        $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + $24_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1 + $23_1 | 0;
        $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $8_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $26_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $7_1;
        $10_1 = $4_1 << 12 | $5_1 >>> 20;
        $8_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $15_1 = HEAP32[$6_1 + 504 >> 2];
        $4_1 = HEAP32[$6_1 + 440 >> 2];
        $13_1 = $15_1 + $4_1 | 0;
        $23_1 = HEAP32[$6_1 + 508 >> 2];
        $3_1 = $23_1 + HEAP32[$6_1 + 444 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $7_1 | 0;
        $10_1 = $10_1 + $13_1 | 0;
        $3_1 = $10_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $9_1 = $10_1 << 4 & -16;
        $7_1 = $3_1;
        $12_1 = ($3_1 << 4 | $10_1 >>> 28) & 16777215;
        $16_1 = $5_1;
        $69($31_1, $9_1 | $5_1 >>> 16 & 15, $12_1, 0, 0, 977, 1, 0, 0);
        $5_1 = $1_1 + 8 | 0;
        $3_1 = HEAP32[$5_1 + 4 >> 2];
        $12_1 = $6_1 + 1e3 | 0;
        $30_1 = $12_1 + 8 | 0;
        HEAP32[$30_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$30_1 + 4 >> 2] = $3_1;
        $5_1 = $1_1 + 16 | 0;
        $3_1 = HEAP32[$5_1 + 4 >> 2];
        $29_1 = $12_1 + 16 | 0;
        HEAP32[$29_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$29_1 + 4 >> 2] = $3_1;
        $5_1 = $1_1 + 24 | 0;
        $3_1 = HEAP32[$5_1 + 4 >> 2];
        $31_1 = $12_1 + 24 | 0;
        HEAP32[$31_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$31_1 + 4 >> 2] = $3_1;
        $5_1 = $1_1 + 32 | 0;
        $3_1 = HEAP32[$5_1 + 4 >> 2];
        $26_1 = $12_1 + 32 | 0;
        HEAP32[$26_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$26_1 + 4 >> 2] = $3_1;
        $3_1 = HEAP32[$1_1 + 4 >> 2];
        HEAP32[$6_1 + 1e3 >> 2] = HEAP32[$1_1 >> 2];
        HEAP32[$6_1 + 1004 >> 2] = $3_1;
        $43_1 = HEAP32[$6_1 + 348 >> 2];
        $3_1 = $43_1 + HEAP32[$6_1 + 668 >> 2] | 0;
        $32_1 = HEAP32[$6_1 + 344 >> 2];
        $5_1 = HEAP32[$6_1 + 664 >> 2];
        $9_1 = $32_1 + $5_1 | 0;
        HEAP32[$6_1 + 1040 >> 2] = $9_1;
        $5_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$6_1 + 1044 >> 2] = $5_1 & 1048575;
        $46_1 = $6_1 + 648 | 0;
        $69($46_1, $41_1, $42_1, 0, 0, $22_1, $27_1, 0, 0);
        $40_1 = $6_1 + 488 | 0;
        $69($40_1, $28_1, $20_1, 0, 0, $18_1, $17_1, 0, 0);
        $36_1 = $6_1 + 456 | 0;
        $69($36_1, $21_1, $19_1, 0, 0, $21_1, $19_1, 0, 0);
        $37_1 = $6_1 + 392 | 0;
        $24_1 = $37_1;
        $11_1 = ($4_1 | 0) == ($7_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $13_1 = ($4_1 | 0) == ($23_1 | 0) & $13_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $23_1 >>> 0;
        $10_1 = $35_1 + 8 | 0;
        $4_1 = HEAP32[$10_1 >> 2];
        $3_1 = $38_1 + 8 | 0;
        $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $13_1 + $15_1 | 0;
        $3_1 = $10_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $8_1 >>> 20 | 0;
        $4_1 = $8_1 + $10_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1;
        $4_1 = $4_1 + $11_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = $4_1 << 12 | $7_1 >>> 20;
        $10_1 = $3_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $12_1 = HEAP32[$6_1 + 492 >> 2];
        $3_1 = $12_1 + HEAP32[$6_1 + 460 >> 2] | 0;
        $38_1 = HEAP32[$6_1 + 488 >> 2];
        $8_1 = HEAP32[$6_1 + 456 >> 2];
        $4_1 = $38_1 + $8_1 | 0;
        $23_1 = $4_1;
        $15_1 = $4_1 + $13_1 | 0;
        $8_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $8_1 + $7_1 | 0;
        $13_1 = $15_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($24_1, $15_1, $13_1 & 1048575, 0, 0, 15632, 16, 0, 0);
        $9_1 = ($5_1 | 0) == ($43_1 | 0) & $9_1 >>> 0 < $32_1 >>> 0 | $5_1 >>> 0 < $43_1 >>> 0;
        $7_1 = $39_1 + 8 | 0;
        $4_1 = HEAP32[$7_1 >> 2];
        $3_1 = $34_1 + 8 | 0;
        $11_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $9_1 + $11_1 | 0;
        $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $11_1 = $4_1 << 12 | $5_1 >>> 20;
        $7_1 = $3_1;
        $9_1 = $3_1 << 12 | $4_1 >>> 20;
        $39_1 = HEAP32[$6_1 + 396 >> 2];
        $3_1 = $39_1 + HEAP32[$6_1 + 652 >> 2] | 0;
        $35_1 = HEAP32[$6_1 + 392 >> 2];
        $5_1 = HEAP32[$6_1 + 648 >> 2];
        $4_1 = $35_1 + $5_1 | 0;
        $24_1 = $4_1;
        $11_1 = $4_1 + $11_1 | 0;
        $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $5_1 + $9_1 | 0;
        HEAP32[$6_1 + 1048 >> 2] = $11_1;
        $9_1 = $11_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$6_1 + 1052 >> 2] = $9_1 & 1048575;
        $34_1 = $6_1 + 584 | 0;
        $69($34_1, $18_1, $17_1, 0, 0, $22_1, $27_1, 0, 0);
        $32_1 = $6_1 + 632 | 0;
        $69($32_1, $41_1, $42_1, 0, 0, $41_1, $42_1, 0, 0);
        $27_1 = $6_1 + 472 | 0;
        $69($27_1, $28_1, $20_1, 0, 0, $21_1, $19_1, 0, 0);
        $22_1 = $6_1 + 376 | 0;
        $19_1 = $22_1;
        $17_1 = ($8_1 | 0) == ($13_1 | 0) & $15_1 >>> 0 < $23_1 >>> 0 | $8_1 >>> 0 > $13_1 >>> 0;
        $15_1 = ($8_1 | 0) == ($12_1 | 0) & $23_1 >>> 0 < $38_1 >>> 0 | $8_1 >>> 0 < $12_1 >>> 0;
        $8_1 = $36_1 + 8 | 0;
        $4_1 = HEAP32[$8_1 >> 2];
        $3_1 = $40_1 + 8 | 0;
        $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $15_1 + $21_1 | 0;
        $3_1 = $8_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $10_1 >>> 20 | 0;
        $4_1 = $8_1 + $10_1 | 0;
        $3_1 = $10_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $4_1;
        $4_1 = $4_1 + $17_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $20_1 = $4_1 << 12 | $13_1 >>> 20;
        $10_1 = HEAP32[$6_1 + 472 >> 2];
        $13_1 = $20_1 + $10_1 | 0;
        $8_1 = $3_1;
        $23_1 = $3_1 << 12 | $4_1 >>> 20;
        $3_1 = $23_1 + HEAP32[$6_1 + 476 >> 2] | 0;
        $15_1 = $10_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($19_1, $13_1, $15_1, 0, 0, 15632, 16, 0, 0);
        $11_1 = ($5_1 | 0) == ($9_1 | 0) & $11_1 >>> 0 < $24_1 >>> 0 | $5_1 >>> 0 > $9_1 >>> 0;
        $12_1 = ($5_1 | 0) == ($39_1 | 0) & $24_1 >>> 0 < $35_1 >>> 0 | $5_1 >>> 0 < $39_1 >>> 0;
        $5_1 = $46_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 >> 2];
        $3_1 = $37_1 + 8 | 0;
        $17_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $12_1 + $17_1 | 0;
        $3_1 = $5_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $7_1 >>> 20 | 0;
        $4_1 = $5_1 + $7_1 | 0;
        $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $11_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $12_1 = $4_1 << 12 | $9_1 >>> 20;
        $5_1 = $3_1;
        $19_1 = $3_1 << 12 | $4_1 >>> 20;
        $18_1 = HEAP32[$6_1 + 584 >> 2];
        $4_1 = HEAP32[$6_1 + 632 >> 2];
        $9_1 = $18_1 + $4_1 | 0;
        $24_1 = HEAP32[$6_1 + 588 >> 2];
        $3_1 = $24_1 + HEAP32[$6_1 + 636 >> 2] | 0;
        $17_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $17_1 + HEAP32[$6_1 + 380 >> 2] | 0;
        $4_1 = HEAP32[$6_1 + 376 >> 2];
        $7_1 = $4_1 + $9_1 | 0;
        $11_1 = $7_1;
        $12_1 = $7_1 + $12_1 | 0;
        $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $4_1 + $19_1 | 0;
        HEAP32[$6_1 + 1056 >> 2] = $12_1;
        $7_1 = $12_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$6_1 + 1060 >> 2] = $7_1 & 1048575;
        $21_1 = $6_1 + 360 | 0;
        $19_1 = ($15_1 | 0) == ($23_1 | 0) & $13_1 >>> 0 < $20_1 >>> 0 | $15_1 >>> 0 < $23_1 >>> 0;
        $3_1 = $27_1 + 8 | 0;
        $15_1 = HEAP32[$3_1 >> 2];
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $8_1 = $8_1 >>> 20 | 0;
        $10_1 = $8_1;
        $8_1 = $8_1 + $15_1 | 0;
        $3_1 = $10_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $8_1;
        $8_1 = $8_1 + $19_1 | 0;
        $3_1 = $10_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($21_1, $8_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
        $19_1 = ($4_1 | 0) == ($7_1 | 0) & $12_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
        $15_1 = ($4_1 | 0) == ($17_1 | 0) & $9_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 < $17_1 >>> 0;
        $3_1 = $22_1 + 8 | 0;
        $11_1 = HEAP32[$3_1 >> 2];
        $13_1 = HEAP32[$3_1 + 4 >> 2];
        $12_1 = ($17_1 | 0) == ($24_1 | 0) & $9_1 >>> 0 < $18_1 >>> 0 | $17_1 >>> 0 < $24_1 >>> 0;
        $10_1 = $32_1 + 8 | 0;
        $4_1 = HEAP32[$10_1 >> 2];
        $3_1 = $34_1 + 8 | 0;
        $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $9_1 + $12_1 | 0;
        $3_1 = ($4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $13_1 | 0;
        $8_1 = $4_1;
        $4_1 = $4_1 + $11_1 | 0;
        $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $4_1 + $15_1 | 0;
        $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $4_1 = $5_1 + $10_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $19_1 | 0;
        $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $4_1 << 12 | $7_1 >>> 20;
        $5_1 = $3_1;
        $9_1 = $3_1 << 12 | $4_1 >>> 20;
        $11_1 = HEAP32[$6_1 + 360 >> 2];
        $7_1 = $25_1 & -2;
        $4_1 = $11_1 + $7_1 | 0;
        $15_1 = HEAP32[$6_1 + 364 >> 2];
        $3_1 = $15_1 + ($33_1 & 1048575) | 0;
        $12_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $12_1 + $9_1 | 0;
        $8_1 = $10_1;
        $10_1 = $4_1;
        $7_1 = $8_1 + $4_1 | 0;
        HEAP32[$6_1 + 1064 >> 2] = $7_1;
        $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$6_1 + 1068 >> 2] = $4_1 & 1048575;
        $13_1 = $16_1 & 65535;
        $9_1 = ($4_1 | 0) == ($12_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $12_1 >>> 0;
        $7_1 = ($12_1 | 0) == ($15_1 | 0) & $10_1 >>> 0 < $11_1 >>> 0 | $12_1 >>> 0 < $15_1 >>> 0;
        $3_1 = $21_1 + 8 | 0;
        $10_1 = $7_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $3_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $5_1 >>> 20 | 0;
        $8_1 = $5_1;
        $5_1 = $5_1 + $10_1 | 0;
        $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $5_1;
        $5_1 = $5_1 + $9_1 | 0;
        $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $5_1 << 12 | $4_1 >>> 20;
        $7_1 = $4_1 + $14_1 | 0;
        $3_1 = $13_1 + ($3_1 << 12 | $5_1 >>> 20) | 0;
        HEAP32[$6_1 + 1072 >> 2] = $7_1;
        HEAP32[$6_1 + 1076 >> 2] = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = $30_1;
        $9_1 = HEAP32[$14_1 >> 2];
        $12_1 = HEAP32[$14_1 + 4 >> 2];
        $10_1 = HEAP32[$6_1 + 1004 >> 2];
        $7_1 = HEAP32[$26_1 >> 2];
        $4_1 = HEAP32[$26_1 + 4 >> 2];
        $11_1 = $4_1;
        $3_1 = HEAP32[$6_1 + 1e3 >> 2];
        $5_1 = __wasm_i64_mul($4_1 >>> 16 | 0, 0, 977, 1);
        $4_1 = $3_1 + $5_1 | 0;
        $3_1 = $10_1 + i64toi32_i32$HIGH_BITS | 0;
        $10_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $12_1;
        $5_1 = $10_1 >>> 20 | 0;
        $8_1 = $5_1;
        $5_1 = $5_1 + $9_1 | 0;
        $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $15_1 = $5_1;
        HEAP32[$14_1 >> 2] = $5_1;
        $30_1 = $3_1 & 1048575;
        HEAP32[$14_1 + 4 >> 2] = $30_1;
        $14_1 = $29_1;
        $9_1 = HEAP32[$14_1 >> 2];
        $5_1 = $3_1;
        $3_1 = HEAP32[$14_1 + 4 >> 2];
        $5_1 = $5_1 >>> 20 | 0;
        $8_1 = $5_1;
        $5_1 = $5_1 + $9_1 | 0;
        $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = $5_1;
        HEAP32[$14_1 >> 2] = $5_1;
        $29_1 = $3_1 & 1048575;
        HEAP32[$14_1 + 4 >> 2] = $29_1;
        $14_1 = $31_1;
        $9_1 = HEAP32[$14_1 >> 2];
        $5_1 = $3_1;
        $3_1 = HEAP32[$14_1 + 4 >> 2];
        $5_1 = $5_1 >>> 20 | 0;
        $8_1 = $5_1;
        $5_1 = $5_1 + $9_1 | 0;
        $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $9_1 = $5_1;
        HEAP32[$14_1 >> 2] = $5_1;
        $31_1 = $3_1 & 1048575;
        HEAP32[$14_1 + 4 >> 2] = $31_1;
        $14_1 = $26_1;
        $5_1 = $3_1;
        $3_1 = $11_1 & 65535;
        $5_1 = $5_1 >>> 20 | 0;
        $8_1 = $5_1;
        $5_1 = $5_1 + $7_1 | 0;
        $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $21_1 = $5_1;
        HEAP32[$14_1 >> 2] = $5_1;
        $33_1 = $3_1;
        HEAP32[$14_1 + 4 >> 2] = $3_1;
        $14_1 = $4_1;
        HEAP32[$6_1 + 1e3 >> 2] = $4_1;
        $26_1 = $10_1 & 1048575;
        HEAP32[$6_1 + 1004 >> 2] = $26_1;
        $28_1 = $6_1 + 1040 | 0;
        $34($6_1 + 960 | 0, $2_1, $28_1);
        $17_1 = $6_1 + 920 | 0;
        $25_1 = $17_1 + 8 | 0;
        $3_1 = $1_1 + 48 | 0;
        $11_1 = HEAP32[$3_1 >> 2];
        $12_1 = HEAP32[$3_1 + 4 >> 2];
        $10_1 = HEAP32[$1_1 + 44 >> 2];
        $3_1 = $1_1 + 72 | 0;
        $7_1 = HEAP32[$3_1 >> 2];
        $4_1 = HEAP32[$3_1 + 4 >> 2];
        $16_1 = $4_1;
        $3_1 = HEAP32[$1_1 + 40 >> 2];
        $5_1 = __wasm_i64_mul($4_1 >>> 16 | 0, 0, 977, 1);
        $4_1 = $3_1 + $5_1 | 0;
        $3_1 = $10_1 + i64toi32_i32$HIGH_BITS | 0;
        $10_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $12_1;
        $5_1 = $10_1 >>> 20 | 0;
        $8_1 = $5_1;
        $5_1 = $5_1 + $11_1 | 0;
        $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $20_1 = $5_1;
        HEAP32[$25_1 >> 2] = $5_1;
        $23_1 = $3_1 & 1048575;
        HEAP32[$25_1 + 4 >> 2] = $23_1;
        $25_1 = $17_1 + 16 | 0;
        $5_1 = $1_1 + 56 | 0;
        $11_1 = HEAP32[$5_1 >> 2];
        $12_1 = HEAP32[$5_1 + 4 >> 2];
        $5_1 = $3_1;
        $3_1 = $12_1;
        $5_1 = $5_1 >>> 20 | 0;
        $8_1 = $5_1;
        $5_1 = $5_1 + $11_1 | 0;
        $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $18_1 = $5_1;
        HEAP32[$25_1 >> 2] = $5_1;
        $24_1 = $3_1 & 1048575;
        HEAP32[$25_1 + 4 >> 2] = $24_1;
        $25_1 = $17_1 + 24 | 0;
        $5_1 = $1_1 - -64 | 0;
        $11_1 = HEAP32[$5_1 >> 2];
        $12_1 = HEAP32[$5_1 + 4 >> 2];
        $5_1 = $3_1;
        $3_1 = $12_1;
        $5_1 = $5_1 >>> 20 | 0;
        $8_1 = $5_1;
        $5_1 = $5_1 + $11_1 | 0;
        $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $19_1 = $5_1;
        HEAP32[$25_1 >> 2] = $5_1;
        $27_1 = $3_1 & 1048575;
        HEAP32[$25_1 + 4 >> 2] = $27_1;
        $11_1 = $17_1 + 32 | 0;
        $5_1 = $3_1;
        $3_1 = $16_1 & 65535;
        $5_1 = $5_1 >>> 20 | 0;
        $7_1 = $5_1 + $7_1 | 0;
        $3_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $17_1 = $7_1;
        HEAP32[$11_1 >> 2] = $7_1;
        $5_1 = $3_1;
        HEAP32[$11_1 + 4 >> 2] = $3_1;
        $25_1 = $4_1;
        HEAP32[$6_1 + 920 >> 2] = $4_1;
        $22_1 = $10_1 & 1048575;
        HEAP32[$6_1 + 924 >> 2] = $22_1;
        $3_1 = $6_1 + 880 | 0;
        $34($3_1, $2_1 + 40 | 0, $28_1);
        $34($3_1, $3_1, $44_1);
        $4_1 = $6_1;
        $2_1 = HEAP32[$4_1 + 960 >> 2];
        $12_1 = ($2_1 - $14_1 | 0) - 3908 | 0;
        $3_1 = (HEAP32[$4_1 + 964 >> 2] - (($2_1 >>> 0 < $14_1 >>> 0) + $26_1 | 0) | 0) + 4194299 | 0;
        HEAP32[$4_1 + 840 >> 2] = $12_1;
        $10_1 = $12_1 >>> 0 < 4294963388 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$4_1 + 844 >> 2] = $10_1;
        $2_1 = HEAP32[$4_1 + 968 >> 2];
        $11_1 = ($2_1 - $15_1 | 0) - 4 | 0;
        $3_1 = (HEAP32[$4_1 + 972 >> 2] - (($2_1 >>> 0 < $15_1 >>> 0) + $30_1 | 0) | 0) + 4194303 | 0;
        HEAP32[$4_1 + 848 >> 2] = $11_1;
        $14_1 = $11_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$4_1 + 852 >> 2] = $14_1;
        $2_1 = HEAP32[$4_1 + 976 >> 2];
        $16_1 = ($2_1 - $13_1 | 0) - 4 | 0;
        $3_1 = (HEAP32[$4_1 + 980 >> 2] - (($2_1 >>> 0 < $13_1 >>> 0) + $29_1 | 0) | 0) + 4194303 | 0;
        HEAP32[$4_1 + 856 >> 2] = $16_1;
        $13_1 = $16_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$4_1 + 860 >> 2] = $13_1;
        $2_1 = HEAP32[$4_1 + 984 >> 2];
        $15_1 = ($2_1 - $9_1 | 0) - 4 | 0;
        $3_1 = (HEAP32[$4_1 + 988 >> 2] - (($2_1 >>> 0 < $9_1 >>> 0) + $31_1 | 0) | 0) + 4194303 | 0;
        HEAP32[$4_1 + 864 >> 2] = $15_1;
        $9_1 = $15_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$4_1 + 868 >> 2] = $9_1;
        $3_1 = HEAP32[$4_1 + 992 >> 2];
        $2_1 = ($3_1 - $21_1 | 0) - 4 | 0;
        $3_1 = (HEAP32[$4_1 + 996 >> 2] - (($3_1 >>> 0 < $21_1 >>> 0) + $33_1 | 0) | 0) + 262143 | 0;
        HEAP32[$4_1 + 872 >> 2] = $2_1;
        $7_1 = $2_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$4_1 + 876 >> 2] = $7_1;
        $3_1 = HEAP32[$4_1 + 912 >> 2];
        $33_1 = ($17_1 - $3_1 | 0) - 4 | 0;
        $3_1 = ($5_1 - (HEAP32[$4_1 + 916 >> 2] + ($3_1 >>> 0 > $17_1 >>> 0) | 0) | 0) + 262143 | 0;
        $5_1 = $33_1;
        HEAP32[$4_1 + 832 >> 2] = $5_1;
        $8_1 = $5_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$4_1 + 836 >> 2] = $8_1;
        $3_1 = HEAP32[$4_1 + 904 >> 2];
        $29_1 = ($19_1 - $3_1 | 0) - 4 | 0;
        $3_1 = ($27_1 - (HEAP32[$4_1 + 908 >> 2] + ($3_1 >>> 0 > $19_1 >>> 0) | 0) | 0) + 4194303 | 0;
        HEAP32[$4_1 + 824 >> 2] = $29_1;
        $21_1 = $29_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$4_1 + 828 >> 2] = $21_1;
        $3_1 = HEAP32[$4_1 + 896 >> 2];
        $31_1 = ($18_1 - $3_1 | 0) - 4 | 0;
        $3_1 = ($24_1 - (HEAP32[$4_1 + 900 >> 2] + ($3_1 >>> 0 > $18_1 >>> 0) | 0) | 0) + 4194303 | 0;
        HEAP32[$4_1 + 816 >> 2] = $31_1;
        $19_1 = $31_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$4_1 + 820 >> 2] = $19_1;
        $3_1 = HEAP32[$4_1 + 888 >> 2];
        $26_1 = ($20_1 - $3_1 | 0) - 4 | 0;
        $3_1 = ($23_1 - (HEAP32[$4_1 + 892 >> 2] + ($3_1 >>> 0 > $20_1 >>> 0) | 0) | 0) + 4194303 | 0;
        HEAP32[$4_1 + 808 >> 2] = $26_1;
        $17_1 = $26_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$4_1 + 812 >> 2] = $17_1;
        $3_1 = HEAP32[$4_1 + 880 >> 2];
        $28_1 = ($25_1 - $3_1 | 0) - 3908 | 0;
        $3_1 = ($22_1 - (HEAP32[$4_1 + 884 >> 2] + ($3_1 >>> 0 > $25_1 >>> 0) | 0) | 0) + 4194299 | 0;
        HEAP32[$4_1 + 800 >> 2] = $28_1;
        $25_1 = $28_1 >>> 0 < 4294963388 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$4_1 + 804 >> 2] = $25_1;
        $4_1 = __wasm_i64_mul($7_1 >>> 16 | 0, 0, 977, 1) + $12_1 | 0;
        $3_1 = i64toi32_i32$HIGH_BITS + $10_1 | 0;
        $3_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $18_1 = $3_1 & 1048575;
        $35_1 = $18_1;
        label$4: {
          $33_1 = $4_1;
          $34_1 = $4_1 ^ 976;
          $32_1 = $18_1 ^ 1;
          if ((($34_1 | 0) != -1 | ($32_1 | 0) != 1048575) & ($4_1 | $18_1) != 0) {
            break label$4;
          }
          $30_1 = $7_1 & 65535;
          $4_1 = $3_1;
          $3_1 = $14_1;
          $4_1 = ($4_1 >>> 20 | 0) + $11_1 | 0;
          $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
          $23_1 = $4_1;
          $24_1 = $3_1;
          $3_1 = $13_1;
          $4_1 = ($24_1 >>> 20 | 0) + $16_1 | 0;
          $3_1 = $4_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
          $27_1 = $4_1;
          $22_1 = $3_1;
          $3_1 = $9_1;
          $4_1 = ($22_1 >>> 20 | 0) + $15_1 | 0;
          $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
          $20_1 = $4_1;
          $18_1 = $3_1;
          $3_1 = $30_1;
          $4_1 = $18_1 >>> 20 | 0;
          $30_1 = $4_1;
          $4_1 = $2_1 + $4_1 | 0;
          $3_1 = $30_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
          if ($4_1 | ($20_1 | ($27_1 | ($23_1 | $33_1))) | ($3_1 | ($18_1 & 1048575 | ($22_1 & 1048575 | ($24_1 & 1048575 | $35_1))))) {
            if (($23_1 & $34_1 & $27_1 & $20_1 & $4_1) != -1) {
              $3_1 = 1;
            } else {
              $3_1 = ($24_1 & $32_1 & $22_1 & $18_1 & ($3_1 ^ 983040)) != 1048575;
            }
            if ($3_1) {
              break label$4;
            }
          }
          $2_1 = __wasm_i64_mul($8_1 >>> 16 | 0, 0, 977, 1) + $28_1 | 0;
          $3_1 = i64toi32_i32$HIGH_BITS + $25_1 | 0;
          $3_1 = $2_1 >>> 0 < $28_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
          $7_1 = $3_1 & 1048575;
          $16_1 = $7_1;
          label$6: {
            $4_1 = $2_1;
            $15_1 = $4_1 ^ 976;
            $11_1 = $7_1 ^ 1;
            if ((($15_1 | 0) != -1 | ($11_1 | 0) != 1048575) & ($4_1 | $7_1) != 0) {
              break label$6;
            }
            $13_1 = $8_1 & 65535;
            $2_1 = $3_1;
            $3_1 = $17_1;
            $2_1 = ($2_1 >>> 20 | 0) + $26_1 | 0;
            $3_1 = $2_1 >>> 0 < $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
            $9_1 = $2_1;
            $12_1 = $3_1;
            $3_1 = $19_1;
            $2_1 = ($12_1 >>> 20 | 0) + $31_1 | 0;
            $3_1 = $2_1 >>> 0 < $31_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
            $14_1 = $2_1;
            $10_1 = $3_1;
            $3_1 = $21_1;
            $2_1 = ($10_1 >>> 20 | 0) + $29_1 | 0;
            $3_1 = $2_1 >>> 0 < $29_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
            $7_1 = $2_1;
            $8_1 = $3_1;
            $3_1 = $13_1;
            $2_1 = $8_1 >>> 20 | 0;
            $13_1 = $2_1;
            $2_1 = $2_1 + $5_1 | 0;
            $3_1 = $13_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
            if ($2_1 | ($7_1 | ($14_1 | ($4_1 | $9_1))) | ($3_1 | ($8_1 & 1048575 | ($10_1 & 1048575 | ($12_1 & 1048575 | $16_1))))) {
              if (($9_1 & $15_1 & $14_1 & $7_1 & $2_1) != -1) {
                $2_1 = 1;
              } else {
                $2_1 = ($12_1 & $11_1 & $10_1 & $8_1 & ($3_1 ^ 983040)) != 1048575;
              }
              if ($2_1) {
                break label$6;
              }
            }
            if (HEAP32[$1_1 + 120 >> 2]) {
              HEAP32[$0_1 + 120 >> 2] = 1;
              $68($0_1, 120);
              break label$1;
            }
            $55($0_1, $1_1);
            break label$1;
          }
          HEAP32[$0_1 + 120 >> 2] = 1;
          $68($0_1, 120);
          break label$1;
        }
        HEAP32[$0_1 + 120 >> 2] = 0;
        $36_1 = $6_1 + 840 | 0;
        $34($0_1 + 80 | 0, $45_1, $36_1);
        $27_1 = $6_1 + 312 | 0;
        $8_1 = $15_1;
        $5_1 = $9_1;
        $19_1 = $12_1 << 1;
        $9_1 = $10_1;
        $21_1 = $9_1 << 1 | $12_1 >>> 31;
        $69($27_1, $8_1, $5_1, 0, 0, $19_1, $21_1, 0, 0);
        $20_1 = $6_1 + 232 | 0;
        $4_1 = $16_1;
        $1_1 = $13_1;
        $10_1 = $11_1 << 1;
        $15_1 = $14_1;
        $17_1 = $11_1;
        $14_1 = $14_1 << 1 | $11_1 >>> 31;
        $69($20_1, $4_1, $1_1, 0, 0, $10_1, $14_1, 0, 0);
        $11_1 = $6_1 + 168 | 0;
        $69($11_1, $2_1, $7_1, 0, 0, $2_1, $7_1, 0, 0);
        $16_1 = $6_1 + 152 | 0;
        $69($16_1, HEAP32[$6_1 + 168 >> 2], HEAP32[$6_1 + 172 >> 2], 0, 0, 15632, 16, 0, 0);
        $3_1 = $7_1 << 1 | $2_1 >>> 31;
        $37_1 = $6_1 + 120 | 0;
        $18_1 = $2_1 << 1;
        $25_1 = $3_1;
        $69($37_1, $18_1, $3_1, 0, 0, $12_1, $9_1, 0, 0);
        $38_1 = $6_1 + 280 | 0;
        $69($38_1, $8_1, $5_1, 0, 0, $10_1, $14_1, 0, 0);
        $35_1 = $6_1 + 216 | 0;
        $69($35_1, $4_1, $1_1, 0, 0, $4_1, $1_1, 0, 0);
        $22_1 = $6_1 + 136 | 0;
        $2_1 = $11_1 + 8 | 0;
        $69($22_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
        $34_1 = $6_1 + 328 | 0;
        $69($34_1, $12_1, $9_1, 0, 0, $12_1, $9_1, 0, 0);
        $32_1 = $6_1 + 104 | 0;
        $69($32_1, $18_1, $3_1, 0, 0, $17_1, $15_1, 0, 0);
        $9_1 = $1_1;
        $33_1 = $4_1;
        $3_1 = $1_1 << 1 | $4_1 >>> 31;
        $30_1 = $6_1 + 184 | 0;
        $11_1 = $8_1;
        $13_1 = $5_1;
        $69($30_1, $8_1, $5_1, 0, 0, $4_1 << 1, $3_1, 0, 0);
        $14_1 = HEAP32[$6_1 + 316 >> 2];
        $3_1 = $14_1 + HEAP32[$6_1 + 236 >> 2] | 0;
        $5_1 = HEAP32[$6_1 + 312 >> 2];
        $2_1 = HEAP32[$6_1 + 232 >> 2];
        $1_1 = $5_1 + $2_1 | 0;
        $4_1 = HEAP32[$6_1 + 152 >> 2];
        $12_1 = $1_1 + $4_1 | 0;
        $2_1 = $1_1 >>> 0 < $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $2_1 + HEAP32[$6_1 + 156 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = ($2_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $12_1 >>> 0 | $2_1 >>> 0 > $4_1 >>> 0;
        $3_1 = $16_1 + 8 | 0;
        $7_1 = HEAP32[$3_1 >> 2];
        $8_1 = HEAP32[$3_1 + 4 >> 2];
        $5_1 = ($2_1 | 0) == ($14_1 | 0) & $1_1 >>> 0 < $5_1 >>> 0 | $2_1 >>> 0 < $14_1 >>> 0;
        $3_1 = $20_1 + 8 | 0;
        $2_1 = HEAP32[$3_1 >> 2];
        $1_1 = $27_1 + 8 | 0;
        $14_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
        $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
        $3_1 = $2_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $1_1 = $5_1 + $14_1 | 0;
        $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $8_1 | 0;
        $2_1 = $1_1;
        $1_1 = $1_1 + $7_1 | 0;
        $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $2_1 = $1_1;
        $1_1 = $1_1 + $10_1 | 0;
        $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $10_1 = $4_1;
        $8_1 = $1_1 << 12 | $4_1 >>> 20;
        $2_1 = $3_1;
        $5_1 = $3_1 << 12 | $1_1 >>> 20;
        $29_1 = HEAP32[$6_1 + 280 >> 2];
        $1_1 = HEAP32[$6_1 + 216 >> 2];
        $14_1 = $29_1 + $1_1 | 0;
        $40_1 = HEAP32[$6_1 + 284 >> 2];
        $3_1 = $40_1 + HEAP32[$6_1 + 220 >> 2] | 0;
        $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $1_1 = HEAP32[$6_1 + 120 >> 2];
        $7_1 = $1_1 + $14_1 | 0;
        $20_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 124 >> 2] | 0;
        $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $1_1 = HEAP32[$6_1 + 136 >> 2];
        $4_1 = $1_1 + $7_1 | 0;
        $16_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 140 >> 2] | 0;
        $1_1 = $1_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $1_1 + $5_1 | 0;
        $31_1 = $6_1 + 88 | 0;
        $5_1 = $4_1 + $8_1 | 0;
        $8_1 = $5_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $26_1 = ($1_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $5_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
        $28_1 = ($1_1 | 0) == ($16_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
        $1_1 = $22_1 + 8 | 0;
        $23_1 = HEAP32[$1_1 >> 2];
        $24_1 = HEAP32[$1_1 + 4 >> 2];
        $27_1 = ($16_1 | 0) == ($20_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $16_1 >>> 0 < $20_1 >>> 0;
        $1_1 = $37_1 + 8 | 0;
        $22_1 = HEAP32[$1_1 >> 2];
        $16_1 = HEAP32[$1_1 + 4 >> 2];
        $7_1 = ($20_1 | 0) == ($40_1 | 0) & $14_1 >>> 0 < $29_1 >>> 0 | $20_1 >>> 0 < $40_1 >>> 0;
        $3_1 = $35_1 + 8 | 0;
        $4_1 = HEAP32[$3_1 >> 2];
        $1_1 = $38_1 + 8 | 0;
        $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
        $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $1_1 = $7_1 + $14_1 | 0;
        $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
        $4_1 = $1_1;
        $1_1 = $1_1 + $22_1 | 0;
        $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $1_1;
        $1_1 = $1_1 + $27_1 | 0;
        $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $24_1 | 0;
        $4_1 = $1_1;
        $1_1 = $1_1 + $23_1 | 0;
        $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $1_1 + $28_1 | 0;
        $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $2_1 = $2_1 >>> 20 | 0;
        $1_1 = $2_1 + $4_1 | 0;
        $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $2_1 = $1_1;
        $1_1 = $1_1 + $26_1 | 0;
        $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $2_1 = $8_1;
        $7_1 = $1_1 << 12 | $2_1 >>> 20;
        $4_1 = $3_1;
        $8_1 = $3_1 << 12 | $1_1 >>> 20;
        $22_1 = HEAP32[$6_1 + 104 >> 2];
        $1_1 = HEAP32[$6_1 + 184 >> 2];
        $16_1 = $22_1 + $1_1 | 0;
        $26_1 = HEAP32[$6_1 + 108 >> 2];
        $3_1 = $26_1 + HEAP32[$6_1 + 188 >> 2] | 0;
        $1_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $1_1 + $8_1 | 0;
        $7_1 = $7_1 + $16_1 | 0;
        $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $20_1 = $7_1 << 4 & -16;
        $14_1 = $2_1;
        $8_1 = $3_1;
        $69($31_1, $20_1 | $2_1 >>> 16 & 15, ($3_1 << 4 | $7_1 >>> 28) & 16777215, 0, 0, 977, 1, 0, 0);
        $28_1 = $6_1 + 264 | 0;
        $69($28_1, $17_1, $15_1, 0, 0, $19_1, $21_1, 0, 0);
        $23_1 = $6_1 + 72 | 0;
        $69($23_1, $18_1, $25_1, 0, 0, $33_1, $9_1, 0, 0);
        $24_1 = $6_1 + 296 | 0;
        $69($24_1, $11_1, $13_1, 0, 0, $11_1, $13_1, 0, 0);
        $27_1 = $6_1 + 56 | 0;
        $20_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
        $7_1 = ($1_1 | 0) == ($26_1 | 0) & $16_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $26_1 >>> 0;
        $3_1 = $30_1 + 8 | 0;
        $2_1 = HEAP32[$3_1 >> 2];
        $1_1 = $32_1 + 8 | 0;
        $16_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
        $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
        $3_1 = $2_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $2_1 = $7_1 + $16_1 | 0;
        $3_1 = $2_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $4_1 >>> 20 | 0;
        $1_1 = $2_1 + $4_1 | 0;
        $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $2_1 = $1_1;
        $1_1 = $1_1 + $20_1 | 0;
        $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $1_1 << 12 | $8_1 >>> 20;
        $2_1 = $3_1;
        $4_1 = $3_1 << 12 | $1_1 >>> 20;
        $22_1 = HEAP32[$6_1 + 72 >> 2];
        $1_1 = HEAP32[$6_1 + 296 >> 2];
        $7_1 = $22_1 + $1_1 | 0;
        $26_1 = HEAP32[$6_1 + 76 >> 2];
        $3_1 = $26_1 + HEAP32[$6_1 + 300 >> 2] | 0;
        $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $1_1 + $4_1 | 0;
        $8_1 = $8_1 + $7_1 | 0;
        $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $3_1;
        $69($27_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
        $20_1 = $6_1 + 200 | 0;
        $69($20_1, $33_1, $9_1, 0, 0, $19_1, $21_1, 0, 0);
        $21_1 = $6_1 + 248 | 0;
        $69($21_1, $17_1, $15_1, 0, 0, $17_1, $15_1, 0, 0);
        $16_1 = $6_1 + 40 | 0;
        $69($16_1, $18_1, $25_1, 0, 0, $11_1, $13_1, 0, 0);
        $15_1 = $6_1 + 24 | 0;
        $13_1 = $15_1;
        $9_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
        $7_1 = ($1_1 | 0) == ($26_1 | 0) & $7_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $26_1 >>> 0;
        $3_1 = $24_1 + 8 | 0;
        $8_1 = HEAP32[$3_1 >> 2];
        $1_1 = $23_1 + 8 | 0;
        $11_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
        $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
        $3_1 = $8_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $7_1 + $11_1 | 0;
        $3_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $2_1 = $2_1 >>> 20 | 0;
        $1_1 = $2_1 + $8_1 | 0;
        $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $2_1 = $1_1;
        $1_1 = $1_1 + $9_1 | 0;
        $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $8_1 = $1_1 << 12 | $4_1 >>> 20;
        $4_1 = HEAP32[$6_1 + 40 >> 2];
        $9_1 = $8_1 + $4_1 | 0;
        $2_1 = $3_1;
        $1_1 = $3_1 << 12 | $1_1 >>> 20;
        $3_1 = $1_1 + HEAP32[$6_1 + 44 >> 2] | 0;
        $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($13_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
        $19_1 = $6_1 + 8 | 0;
        $7_1 = $19_1;
        $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
        $1_1 = $16_1 + 8 | 0;
        $4_1 = HEAP32[$1_1 >> 2];
        $3_1 = HEAP32[$1_1 + 4 >> 2];
        $2_1 = $2_1 >>> 20 | 0;
        $1_1 = $2_1 + $4_1 | 0;
        $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $2_1 = $1_1;
        $1_1 = $1_1 + $8_1 | 0;
        $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
        $9_1 = HEAP32[$6_1 + 92 >> 2];
        $3_1 = $9_1 + HEAP32[$6_1 + 332 >> 2] | 0;
        $7_1 = HEAP32[$6_1 + 88 >> 2];
        $2_1 = HEAP32[$6_1 + 328 >> 2];
        $1_1 = $7_1 + $2_1 | 0;
        HEAP32[$6_1 + 760 >> 2] = -3908 - $1_1;
        $4_1 = $1_1 >>> 0 < $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$6_1 + 764 >> 2] = 4194299 - (($4_1 & 1048575) + ($1_1 >>> 0 > 4294963388) | 0);
        $7_1 = ($4_1 | 0) == ($9_1 | 0) & $1_1 >>> 0 < $7_1 >>> 0 | $4_1 >>> 0 < $9_1 >>> 0;
        $3_1 = $34_1 + 8 | 0;
        $2_1 = HEAP32[$3_1 >> 2];
        $1_1 = $31_1 + 8 | 0;
        $9_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
        $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
        $3_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $1_1 = $7_1 + $9_1 | 0;
        $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $1_1 << 12 | $4_1 >>> 20;
        $2_1 = $3_1;
        $13_1 = $3_1 << 12 | $1_1 >>> 20;
        $16_1 = HEAP32[$6_1 + 60 >> 2];
        $3_1 = $16_1 + HEAP32[$6_1 + 268 >> 2] | 0;
        $11_1 = HEAP32[$6_1 + 56 >> 2];
        $1_1 = HEAP32[$6_1 + 264 >> 2];
        $4_1 = $11_1 + $1_1 | 0;
        $9_1 = $4_1;
        $7_1 = $4_1 + $7_1 | 0;
        $1_1 = $1_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $1_1 + $13_1 | 0;
        $4_1 = $7_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $7_1;
        HEAP32[$6_1 + 768 >> 2] = -4 - $3_1;
        HEAP32[$6_1 + 772 >> 2] = 4194303 - (($4_1 & 1048575) + ($3_1 >>> 0 > 4294967292) | 0);
        $13_1 = ($1_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $4_1 >>> 0;
        $9_1 = ($1_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
        $3_1 = $28_1 + 8 | 0;
        $7_1 = HEAP32[$3_1 >> 2];
        $1_1 = $27_1 + 8 | 0;
        $11_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
        $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
        $3_1 = $7_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $9_1 + $11_1 | 0;
        $3_1 = $7_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $2_1 = $2_1 >>> 20 | 0;
        $1_1 = $2_1 + $7_1 | 0;
        $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $2_1 = $1_1;
        $1_1 = $1_1 + $13_1 | 0;
        $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $1_1 << 12 | $4_1 >>> 20;
        $2_1 = $3_1;
        $4_1 = $3_1 << 12 | $1_1 >>> 20;
        $17_1 = HEAP32[$6_1 + 200 >> 2];
        $1_1 = HEAP32[$6_1 + 248 >> 2];
        $13_1 = $17_1 + $1_1 | 0;
        $18_1 = HEAP32[$6_1 + 204 >> 2];
        $3_1 = $18_1 + HEAP32[$6_1 + 252 >> 2] | 0;
        $3_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $1_1 = HEAP32[$6_1 + 24 >> 2];
        $9_1 = $1_1 + $13_1 | 0;
        $11_1 = $3_1;
        $3_1 = $3_1 + HEAP32[$6_1 + 28 >> 2] | 0;
        $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $1_1 + $4_1 | 0;
        $7_1 = $7_1 + $9_1 | 0;
        $3_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$6_1 + 776 >> 2] = -4 - $7_1;
        $4_1 = $3_1;
        HEAP32[$6_1 + 780 >> 2] = 4194303 - (($3_1 & 1048575) + ($7_1 >>> 0 > 4294967292) | 0);
        $25_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
        $33_1 = ($1_1 | 0) == ($11_1 | 0) & $9_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $11_1 >>> 0;
        $1_1 = $15_1 + 8 | 0;
        $16_1 = HEAP32[$1_1 >> 2];
        $15_1 = HEAP32[$1_1 + 4 >> 2];
        $9_1 = ($11_1 | 0) == ($18_1 | 0) & $13_1 >>> 0 < $17_1 >>> 0 | $11_1 >>> 0 < $18_1 >>> 0;
        $3_1 = $21_1 + 8 | 0;
        $7_1 = HEAP32[$3_1 >> 2];
        $1_1 = $20_1 + 8 | 0;
        $13_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
        $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
        $3_1 = $7_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $1_1 = $9_1 + $13_1 | 0;
        $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $15_1 | 0;
        $8_1 = $1_1;
        $1_1 = $1_1 + $16_1 | 0;
        $3_1 = $8_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $1_1 + $33_1 | 0;
        $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $2_1 = $2_1 >>> 20 | 0;
        $1_1 = $2_1 + $7_1 | 0;
        $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $2_1 = $1_1;
        $1_1 = $1_1 + $25_1 | 0;
        $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $1_1 << 12 | $4_1 >>> 20;
        $2_1 = $3_1;
        $11_1 = $3_1 << 12 | $1_1 >>> 20;
        $15_1 = HEAP32[$6_1 + 12 >> 2];
        $3_1 = $15_1 + ($10_1 & 1048575) | 0;
        $13_1 = HEAP32[$6_1 + 8 >> 2];
        $4_1 = $12_1 & -2;
        $1_1 = $13_1 + $4_1 | 0;
        $12_1 = $1_1;
        $7_1 = $1_1 + $7_1 | 0;
        $9_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $9_1 + $11_1 | 0;
        HEAP32[$6_1 + 784 >> 2] = -4 - $7_1;
        $1_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$6_1 + 788 >> 2] = 4194303 - (($1_1 & 1048575) + ($7_1 >>> 0 > 4294967292) | 0);
        $4_1 = $6_1;
        $10_1 = $5_1;
        $14_1 = $14_1 & 65535;
        $7_1 = ($1_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $9_1 >>> 0;
        $5_1 = ($9_1 | 0) == ($15_1 | 0) & $12_1 >>> 0 < $13_1 >>> 0 | $9_1 >>> 0 < $15_1 >>> 0;
        $3_1 = $19_1 + 8 | 0;
        $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2];
        $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $2_1 = $2_1 >>> 20 | 0;
        $5_1 = $2_1;
        $2_1 = $2_1 + $8_1 | 0;
        $3_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $2_1;
        $2_1 = $2_1 + $7_1 | 0;
        $3_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $1_1 = $2_1 << 12 | $1_1 >>> 20;
        $5_1 = $1_1 + $10_1 | 0;
        $3_1 = $14_1 + ($3_1 << 12 | $2_1 >>> 20) | 0;
        HEAP32[$4_1 + 792 >> 2] = -4 - $5_1;
        HEAP32[$4_1 + 796 >> 2] = 262143 - (($5_1 >>> 0 > 4294967292) + ($1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) | 0);
        $23_1 = $4_1 + 720 | 0;
        $1_1 = $4_1 + 760 | 0;
        $34($23_1, $1_1, $36_1);
        $27_1 = $4_1 + 680 | 0;
        $34($27_1, $4_1 + 1e3 | 0, $1_1);
        $22_1 = $4_1 + 800 | 0;
        $54($0_1, $22_1);
        $1_1 = HEAP32[$4_1 + 752 >> 2];
        $5_1 = $1_1 + HEAP32[$0_1 + 32 >> 2] | 0;
        $3_1 = HEAP32[$0_1 + 36 >> 2] + HEAP32[$4_1 + 756 >> 2] | 0;
        $2_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $1_1 = HEAP32[$4_1 + 712 >> 2];
        $20_1 = $1_1;
        $3_1 = HEAP32[$4_1 + 716 >> 2];
        $18_1 = $3_1;
        $3_1 = ($3_1 << 1 | $1_1 >>> 31) + $2_1 | 0;
        $1_1 = $1_1 << 1;
        $2_1 = $1_1;
        $1_1 = $1_1 + $5_1 | 0;
        $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $11_1 = $1_1;
        HEAP32[$0_1 + 32 >> 2] = $1_1;
        $12_1 = $3_1;
        HEAP32[$0_1 + 36 >> 2] = $3_1;
        $1_1 = $0_1;
        $0_1 = HEAP32[$4_1 + 744 >> 2];
        $5_1 = $0_1 + HEAP32[$1_1 + 24 >> 2] | 0;
        $3_1 = HEAP32[$1_1 + 28 >> 2] + HEAP32[$4_1 + 748 >> 2] | 0;
        $2_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $0_1 = HEAP32[$4_1 + 704 >> 2];
        $21_1 = $0_1;
        $3_1 = HEAP32[$4_1 + 708 >> 2];
        $19_1 = $3_1;
        $3_1 = ($3_1 << 1 | $0_1 >>> 31) + $2_1 | 0;
        $0_1 = $0_1 << 1;
        $2_1 = $0_1;
        $0_1 = $0_1 + $5_1 | 0;
        $3_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = $0_1;
        HEAP32[$1_1 + 24 >> 2] = $0_1;
        $14_1 = $3_1;
        HEAP32[$1_1 + 28 >> 2] = $3_1;
        $0_1 = HEAP32[$4_1 + 736 >> 2];
        $5_1 = $0_1 + HEAP32[$1_1 + 16 >> 2] | 0;
        $3_1 = HEAP32[$1_1 + 20 >> 2] + HEAP32[$4_1 + 740 >> 2] | 0;
        $2_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $0_1 = HEAP32[$4_1 + 696 >> 2];
        $17_1 = $0_1;
        $3_1 = HEAP32[$4_1 + 700 >> 2];
        $25_1 = $3_1;
        $3_1 = ($3_1 << 1 | $0_1 >>> 31) + $2_1 | 0;
        $0_1 = $0_1 << 1;
        $2_1 = $0_1;
        $0_1 = $0_1 + $5_1 | 0;
        $3_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $9_1 = $0_1;
        HEAP32[$1_1 + 16 >> 2] = $0_1;
        $10_1 = $3_1;
        HEAP32[$1_1 + 20 >> 2] = $3_1;
        $0_1 = HEAP32[$4_1 + 728 >> 2];
        $2_1 = $0_1 + HEAP32[$1_1 + 8 >> 2] | 0;
        $3_1 = HEAP32[$1_1 + 12 >> 2] + HEAP32[$4_1 + 732 >> 2] | 0;
        $0_1 = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = HEAP32[$4_1 + 692 >> 2];
        $33_1 = $3_1;
        $24_1 = HEAP32[$4_1 + 688 >> 2];
        $5_1 = $24_1;
        $3_1 = ($3_1 << 1 | $5_1 >>> 31) + $0_1 | 0;
        $5_1 = $5_1 << 1;
        $7_1 = $2_1 + $5_1 | 0;
        $3_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$1_1 + 8 >> 2] = $7_1;
        $8_1 = $3_1;
        HEAP32[$1_1 + 12 >> 2] = $3_1;
        $0_1 = HEAP32[$4_1 + 720 >> 2];
        $5_1 = $0_1 + HEAP32[$1_1 >> 2] | 0;
        $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 724 >> 2] | 0;
        $2_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $0_1 = HEAP32[$4_1 + 680 >> 2];
        $16_1 = $0_1;
        $3_1 = HEAP32[$4_1 + 684 >> 2];
        $15_1 = $3_1;
        $3_1 = ($3_1 << 1 | $0_1 >>> 31) + $2_1 | 0;
        $0_1 = $0_1 << 1;
        $2_1 = $0_1;
        $0_1 = $0_1 + $5_1 | 0;
        $3_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $5_1 = $0_1;
        HEAP32[$1_1 >> 2] = $5_1;
        $2_1 = $3_1;
        HEAP32[$1_1 + 4 >> 2] = $3_1;
        $3_1 = $12_1 + $18_1 | 0;
        $4_1 = $11_1 + $20_1 | 0;
        $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$6_1 + 712 >> 2] = $4_1;
        HEAP32[$6_1 + 716 >> 2] = $3_1;
        $3_1 = $14_1 + $19_1 | 0;
        $4_1 = $13_1 + $21_1 | 0;
        $3_1 = $4_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$6_1 + 704 >> 2] = $4_1;
        HEAP32[$6_1 + 708 >> 2] = $3_1;
        $3_1 = $10_1 + $25_1 | 0;
        $4_1 = $9_1 + $17_1 | 0;
        $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$6_1 + 696 >> 2] = $4_1;
        HEAP32[$6_1 + 700 >> 2] = $3_1;
        $3_1 = $8_1 + $33_1 | 0;
        $4_1 = $7_1 + $24_1 | 0;
        $3_1 = $4_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$6_1 + 688 >> 2] = $4_1;
        HEAP32[$6_1 + 692 >> 2] = $3_1;
        $3_1 = $2_1 + $15_1 | 0;
        $0_1 = $5_1 + $16_1 | 0;
        $3_1 = $0_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        HEAP32[$6_1 + 680 >> 2] = $0_1;
        HEAP32[$6_1 + 684 >> 2] = $3_1;
        $34($1_1 + 40 | 0, $27_1, $22_1);
        $34($23_1, $23_1, $6_1 + 920 | 0);
        $3_1 = HEAP32[$1_1 + 44 >> 2] + HEAP32[$6_1 + 724 >> 2] | 0;
        $0_1 = HEAP32[$6_1 + 720 >> 2];
        $2_1 = $0_1 + HEAP32[$1_1 + 40 >> 2] | 0;
        HEAP32[$1_1 + 40 >> 2] = $2_1;
        HEAP32[$1_1 + 44 >> 2] = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $1_1 + 48 | 0;
        $4_1 = $3_1;
        $0_1 = HEAP32[$6_1 + 728 >> 2];
        $2_1 = $0_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$6_1 + 732 >> 2] | 0;
        HEAP32[$4_1 >> 2] = $2_1;
        HEAP32[$4_1 + 4 >> 2] = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $1_1 + 56 | 0;
        $4_1 = $3_1;
        $0_1 = HEAP32[$6_1 + 736 >> 2];
        $2_1 = $0_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$6_1 + 740 >> 2] | 0;
        HEAP32[$4_1 >> 2] = $2_1;
        HEAP32[$4_1 + 4 >> 2] = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $3_1 = $1_1 - -64 | 0;
        $4_1 = $3_1;
        $0_1 = HEAP32[$6_1 + 744 >> 2];
        $2_1 = $0_1 + HEAP32[$3_1 >> 2] | 0;
        $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$6_1 + 748 >> 2] | 0;
        HEAP32[$4_1 >> 2] = $2_1;
        HEAP32[$4_1 + 4 >> 2] = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $0_1 = HEAP32[$6_1 + 752 >> 2];
        $2_1 = $1_1 + 72 | 0;
        $1_1 = $0_1 + HEAP32[$2_1 >> 2] | 0;
        $3_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$6_1 + 756 >> 2] | 0;
        HEAP32[$2_1 >> 2] = $1_1;
        HEAP32[$2_1 + 4 >> 2] = $0_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      }
      global$0 = $6_1 + 1120 | 0;
    }
    function $65($0_1, $1_1, $2_1, $3_1) {
      var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0;
      $8_1 = global$0 - 736 | 0;
      global$0 = $8_1;
      $4_1 = HEAP32[$2_1 + 80 >> 2];
      label$1: {
        if (HEAP32[$1_1 + 120 >> 2]) {
          HEAP32[$0_1 + 120 >> 2] = $4_1;
          $1_1 = HEAP32[$2_1 + 4 >> 2];
          HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$0_1 + 4 >> 2] = $1_1;
          $1_1 = $2_1 + 8 | 0;
          $3_1 = HEAP32[$1_1 + 4 >> 2];
          $4_1 = $0_1 + 8 | 0;
          HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
          HEAP32[$4_1 + 4 >> 2] = $3_1;
          $1_1 = $2_1 + 16 | 0;
          $3_1 = HEAP32[$1_1 + 4 >> 2];
          $4_1 = $0_1 + 16 | 0;
          HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
          HEAP32[$4_1 + 4 >> 2] = $3_1;
          $1_1 = $2_1 + 24 | 0;
          $3_1 = HEAP32[$1_1 + 4 >> 2];
          $4_1 = $0_1 + 24 | 0;
          HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
          HEAP32[$4_1 + 4 >> 2] = $3_1;
          $1_1 = $2_1 + 32 | 0;
          $3_1 = HEAP32[$1_1 + 4 >> 2];
          $4_1 = $0_1 + 32 | 0;
          HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
          HEAP32[$4_1 + 4 >> 2] = $3_1;
          $1_1 = HEAP32[$2_1 + 44 >> 2];
          HEAP32[$0_1 + 40 >> 2] = HEAP32[$2_1 + 40 >> 2];
          HEAP32[$0_1 + 44 >> 2] = $1_1;
          $1_1 = $2_1 + 48 | 0;
          $3_1 = HEAP32[$1_1 + 4 >> 2];
          $4_1 = $0_1 + 48 | 0;
          HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
          HEAP32[$4_1 + 4 >> 2] = $3_1;
          $1_1 = $2_1 + 56 | 0;
          $3_1 = HEAP32[$1_1 + 4 >> 2];
          $4_1 = $0_1 + 56 | 0;
          HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
          HEAP32[$4_1 + 4 >> 2] = $3_1;
          $1_1 = $2_1 - -64 | 0;
          $3_1 = HEAP32[$1_1 + 4 >> 2];
          $4_1 = $0_1 - -64 | 0;
          HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
          HEAP32[$4_1 + 4 >> 2] = $3_1;
          $1_1 = $2_1 + 72 | 0;
          $2_1 = HEAP32[$1_1 + 4 >> 2];
          $3_1 = $0_1 + 72 | 0;
          HEAP32[$3_1 >> 2] = HEAP32[$1_1 >> 2];
          HEAP32[$3_1 + 4 >> 2] = $2_1;
          $1_1 = $0_1 + 88 | 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          HEAP32[$0_1 + 80 >> 2] = 1;
          HEAP32[$0_1 + 84 >> 2] = 0;
          $1_1 = $0_1 + 96 | 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          $1_1 = $0_1 + 104 | 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          $0_1 = $0_1 + 112 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          break label$1;
        }
        if ($4_1) {
          if ($3_1) {
            HEAP32[$3_1 + 8 >> 2] = 0;
            HEAP32[$3_1 + 12 >> 2] = 0;
            HEAP32[$3_1 >> 2] = 1;
            HEAP32[$3_1 + 4 >> 2] = 0;
            $2_1 = $3_1 + 16 | 0;
            HEAP32[$2_1 >> 2] = 0;
            HEAP32[$2_1 + 4 >> 2] = 0;
            $2_1 = $3_1 + 24 | 0;
            HEAP32[$2_1 >> 2] = 0;
            HEAP32[$2_1 + 4 >> 2] = 0;
            $2_1 = $3_1 + 32 | 0;
            HEAP32[$2_1 >> 2] = 0;
            HEAP32[$2_1 + 4 >> 2] = 0;
          }
          $70($0_1, $1_1, 128);
          break label$1;
        }
        $18_1 = $8_1 + 696 | 0;
        $30_1 = $1_1 + 80 | 0;
        $54($18_1, $30_1);
        $14_1 = $8_1 + 656 | 0;
        $10_1 = $14_1 + 8 | 0;
        $4_1 = $1_1 + 8 | 0;
        $7_1 = HEAP32[$4_1 >> 2];
        $12_1 = HEAP32[$4_1 + 4 >> 2];
        $6_1 = HEAP32[$1_1 + 4 >> 2];
        $4_1 = $1_1 + 32 | 0;
        $11_1 = HEAP32[$4_1 >> 2];
        $9_1 = HEAP32[$4_1 + 4 >> 2];
        $17_1 = $9_1;
        $4_1 = HEAP32[$1_1 >> 2];
        $9_1 = __wasm_i64_mul($9_1 >>> 16 | 0, 0, 977, 1);
        $5_1 = $4_1 + $9_1 | 0;
        $4_1 = $6_1 + i64toi32_i32$HIGH_BITS | 0;
        $9_1 = $5_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $12_1;
        $6_1 = $9_1 >>> 20 | 0;
        $12_1 = $6_1;
        $6_1 = $6_1 + $7_1 | 0;
        $4_1 = $12_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$10_1 >> 2] = $6_1;
        $19_1 = $4_1 & 1048575;
        HEAP32[$10_1 + 4 >> 2] = $19_1;
        $7_1 = $14_1 + 16 | 0;
        $10_1 = $1_1 + 16 | 0;
        $12_1 = HEAP32[$10_1 >> 2];
        $15_1 = HEAP32[$10_1 + 4 >> 2];
        $10_1 = $4_1;
        $4_1 = $15_1;
        $10_1 = $10_1 >>> 20 | 0;
        $13_1 = $10_1;
        $10_1 = $10_1 + $12_1 | 0;
        $4_1 = $13_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$7_1 >> 2] = $10_1;
        $28_1 = $4_1 & 1048575;
        HEAP32[$7_1 + 4 >> 2] = $28_1;
        $12_1 = $14_1 + 24 | 0;
        $7_1 = $1_1 + 24 | 0;
        $15_1 = HEAP32[$7_1 >> 2];
        $13_1 = HEAP32[$7_1 + 4 >> 2];
        $7_1 = $4_1;
        $4_1 = $13_1;
        $7_1 = $7_1 >>> 20 | 0;
        $13_1 = $7_1;
        $7_1 = $7_1 + $15_1 | 0;
        $4_1 = $13_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$12_1 >> 2] = $7_1;
        $24_1 = $4_1 & 1048575;
        HEAP32[$12_1 + 4 >> 2] = $24_1;
        $12_1 = $14_1 + 32 | 0;
        $14_1 = $4_1;
        $4_1 = $17_1 & 65535;
        $14_1 = $14_1 >>> 20 | 0;
        $17_1 = $11_1 + $14_1 | 0;
        $4_1 = $14_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$12_1 >> 2] = $17_1;
        $21_1 = $4_1;
        HEAP32[$12_1 + 4 >> 2] = $4_1;
        $11_1 = $5_1;
        HEAP32[$8_1 + 656 >> 2] = $5_1;
        $20_1 = $9_1 & 1048575;
        HEAP32[$8_1 + 660 >> 2] = $20_1;
        $34($8_1 + 616 | 0, $2_1, $18_1);
        $15_1 = $8_1 + 576 | 0;
        $12_1 = $15_1 + 8 | 0;
        $4_1 = $1_1 + 48 | 0;
        $16_1 = HEAP32[$4_1 >> 2];
        $22_1 = HEAP32[$4_1 + 4 >> 2];
        $14_1 = HEAP32[$1_1 + 44 >> 2];
        $4_1 = $1_1 + 72 | 0;
        $9_1 = HEAP32[$4_1 >> 2];
        $13_1 = HEAP32[$4_1 + 4 >> 2];
        $23_1 = $13_1;
        $4_1 = HEAP32[$1_1 + 40 >> 2];
        $13_1 = __wasm_i64_mul($13_1 >>> 16 | 0, 0, 977, 1);
        $5_1 = $4_1 + $13_1 | 0;
        $4_1 = $14_1 + i64toi32_i32$HIGH_BITS | 0;
        $14_1 = $5_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $22_1;
        $13_1 = $14_1 >>> 20 | 0;
        $22_1 = $13_1 + $16_1 | 0;
        $4_1 = $13_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$12_1 >> 2] = $22_1;
        $31_1 = $4_1 & 1048575;
        HEAP32[$12_1 + 4 >> 2] = $31_1;
        $13_1 = $15_1 + 16 | 0;
        $12_1 = $1_1 + 56 | 0;
        $16_1 = HEAP32[$12_1 >> 2];
        $25_1 = HEAP32[$12_1 + 4 >> 2];
        $12_1 = $4_1;
        $4_1 = $25_1;
        $12_1 = $12_1 >>> 20 | 0;
        $25_1 = $12_1 + $16_1 | 0;
        $4_1 = $12_1 >>> 0 > $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$13_1 >> 2] = $25_1;
        $27_1 = $4_1 & 1048575;
        HEAP32[$13_1 + 4 >> 2] = $27_1;
        $13_1 = $15_1 + 24 | 0;
        $12_1 = $1_1 - -64 | 0;
        $16_1 = HEAP32[$12_1 >> 2];
        $26_1 = HEAP32[$12_1 + 4 >> 2];
        $12_1 = $4_1;
        $4_1 = $26_1;
        $12_1 = $12_1 >>> 20 | 0;
        $26_1 = $12_1 + $16_1 | 0;
        $4_1 = $12_1 >>> 0 > $26_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$13_1 >> 2] = $26_1;
        $29_1 = $4_1 & 1048575;
        HEAP32[$13_1 + 4 >> 2] = $29_1;
        $15_1 = $15_1 + 32 | 0;
        $12_1 = $4_1;
        $4_1 = $23_1 & 65535;
        $12_1 = $12_1 >>> 20 | 0;
        $13_1 = $9_1 + $12_1 | 0;
        $4_1 = $12_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$15_1 >> 2] = $13_1;
        $16_1 = $4_1;
        HEAP32[$15_1 + 4 >> 2] = $4_1;
        $23_1 = $5_1;
        HEAP32[$8_1 + 576 >> 2] = $5_1;
        $32_1 = $14_1 & 1048575;
        HEAP32[$8_1 + 580 >> 2] = $32_1;
        $4_1 = $8_1 + 536 | 0;
        $34($4_1, $2_1 + 40 | 0, $18_1);
        $34($4_1, $4_1, $30_1);
        $2_1 = HEAP32[$8_1 + 616 >> 2];
        $9_1 = ($2_1 - $11_1 | 0) - 3908 | 0;
        $4_1 = (HEAP32[$8_1 + 620 >> 2] - (($2_1 >>> 0 < $11_1 >>> 0) + $20_1 | 0) | 0) + 4194299 | 0;
        HEAP32[$8_1 + 496 >> 2] = $9_1;
        $12_1 = $9_1 >>> 0 < 4294963388 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$8_1 + 500 >> 2] = $12_1;
        $2_1 = $8_1;
        $4_1 = HEAP32[$2_1 + 624 >> 2];
        $11_1 = ($4_1 - $6_1 | 0) - 4 | 0;
        $4_1 = (HEAP32[$2_1 + 628 >> 2] - (($4_1 >>> 0 < $6_1 >>> 0) + $19_1 | 0) | 0) + 4194303 | 0;
        HEAP32[$2_1 + 504 >> 2] = $11_1;
        $14_1 = $11_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$2_1 + 508 >> 2] = $14_1;
        $4_1 = HEAP32[$2_1 + 632 >> 2];
        $5_1 = ($4_1 - $10_1 | 0) - 4 | 0;
        $4_1 = (HEAP32[$2_1 + 636 >> 2] - (($4_1 >>> 0 < $10_1 >>> 0) + $28_1 | 0) | 0) + 4194303 | 0;
        HEAP32[$2_1 + 512 >> 2] = $5_1;
        $10_1 = $5_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$2_1 + 516 >> 2] = $10_1;
        $4_1 = HEAP32[$2_1 + 640 >> 2];
        $6_1 = ($4_1 - $7_1 | 0) - 4 | 0;
        $4_1 = (HEAP32[$2_1 + 644 >> 2] - (($4_1 >>> 0 < $7_1 >>> 0) + $24_1 | 0) | 0) + 4194303 | 0;
        HEAP32[$2_1 + 520 >> 2] = $6_1;
        $7_1 = $6_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$2_1 + 524 >> 2] = $7_1;
        $4_1 = HEAP32[$2_1 + 648 >> 2];
        $2_1 = ($4_1 - $17_1 | 0) - 4 | 0;
        $4_1 = (HEAP32[$8_1 + 652 >> 2] - (($4_1 >>> 0 < $17_1 >>> 0) + $21_1 | 0) | 0) + 262143 | 0;
        HEAP32[$8_1 + 528 >> 2] = $2_1;
        $17_1 = $2_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$8_1 + 532 >> 2] = $17_1;
        $4_1 = HEAP32[$8_1 + 568 >> 2];
        $21_1 = ($13_1 - $4_1 | 0) - 4 | 0;
        $4_1 = ($16_1 - (HEAP32[$8_1 + 572 >> 2] + ($4_1 >>> 0 > $13_1 >>> 0) | 0) | 0) + 262143 | 0;
        HEAP32[$8_1 + 488 >> 2] = $21_1;
        $13_1 = $21_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$8_1 + 492 >> 2] = $13_1;
        $4_1 = HEAP32[$8_1 + 560 >> 2];
        $16_1 = ($26_1 - $4_1 | 0) - 4 | 0;
        $4_1 = ($29_1 - (HEAP32[$8_1 + 564 >> 2] + ($4_1 >>> 0 > $26_1 >>> 0) | 0) | 0) + 4194303 | 0;
        $26_1 = $16_1;
        HEAP32[$8_1 + 480 >> 2] = $16_1;
        $29_1 = $16_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$8_1 + 484 >> 2] = $29_1;
        $4_1 = HEAP32[$8_1 + 552 >> 2];
        $16_1 = ($25_1 - $4_1 | 0) - 4 | 0;
        $4_1 = ($27_1 - (HEAP32[$8_1 + 556 >> 2] + ($4_1 >>> 0 > $25_1 >>> 0) | 0) | 0) + 4194303 | 0;
        $25_1 = $16_1;
        HEAP32[$8_1 + 472 >> 2] = $16_1;
        $27_1 = $16_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$8_1 + 476 >> 2] = $27_1;
        $4_1 = HEAP32[$8_1 + 544 >> 2];
        $16_1 = ($22_1 - $4_1 | 0) - 4 | 0;
        $4_1 = ($31_1 - (HEAP32[$8_1 + 548 >> 2] + ($4_1 >>> 0 > $22_1 >>> 0) | 0) | 0) + 4194303 | 0;
        HEAP32[$8_1 + 464 >> 2] = $16_1;
        $31_1 = $16_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$8_1 + 468 >> 2] = $31_1;
        $4_1 = HEAP32[$8_1 + 536 >> 2];
        $15_1 = ($23_1 - $4_1 | 0) - 3908 | 0;
        $4_1 = ($32_1 - (HEAP32[$8_1 + 540 >> 2] + ($4_1 >>> 0 > $23_1 >>> 0) | 0) | 0) + 4194299 | 0;
        $22_1 = $15_1;
        HEAP32[$8_1 + 456 >> 2] = $15_1;
        $32_1 = $15_1 >>> 0 < 4294963388 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$8_1 + 460 >> 2] = $32_1;
        $15_1 = __wasm_i64_mul($17_1 >>> 16 | 0, 0, 977, 1) + $9_1 | 0;
        $4_1 = i64toi32_i32$HIGH_BITS + $12_1 | 0;
        $4_1 = $9_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $23_1 = $4_1 & 1048575;
        $33_1 = $23_1;
        label$5: {
          $34_1 = $15_1;
          $35_1 = $15_1 ^ 976;
          $36_1 = $23_1 ^ 1;
          if ((($35_1 | 0) != -1 | ($36_1 | 0) != 1048575) & ($15_1 | $23_1) != 0) {
            break label$5;
          }
          $20_1 = $17_1 & 65535;
          $15_1 = $4_1;
          $4_1 = $14_1;
          $15_1 = ($15_1 >>> 20 | 0) + $11_1 | 0;
          $23_1 = $15_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $10_1;
          $18_1 = ($23_1 >>> 20 | 0) + $5_1 | 0;
          $19_1 = $18_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $7_1;
          $28_1 = ($19_1 >>> 20 | 0) + $6_1 | 0;
          $24_1 = $28_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $20_1;
          $20_1 = $24_1 >>> 20 | 0;
          $37_1 = $20_1;
          $20_1 = $2_1 + $20_1 | 0;
          $4_1 = $37_1 >>> 0 > $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          if ($20_1 | ($28_1 | ($18_1 | ($15_1 | $34_1))) | ($4_1 | ($24_1 & 1048575 | ($19_1 & 1048575 | ($23_1 & 1048575 | $33_1))))) {
            if (($15_1 & $35_1 & $18_1 & $28_1 & $20_1) != -1) {
              $4_1 = 1;
            } else {
              $4_1 = ($23_1 & $36_1 & $19_1 & $24_1 & ($4_1 ^ 983040)) != 1048575;
            }
            if ($4_1) {
              break label$5;
            }
          }
          $2_1 = __wasm_i64_mul($13_1 >>> 16 | 0, 0, 977, 1) + $22_1 | 0;
          $4_1 = i64toi32_i32$HIGH_BITS + $32_1 | 0;
          $4_1 = $2_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $5_1 = $4_1 & 1048575;
          $12_1 = $5_1;
          label$7: {
            $14_1 = $2_1;
            $17_1 = $2_1 ^ 976;
            $15_1 = $5_1 ^ 1;
            if ((($17_1 | 0) != -1 | ($15_1 | 0) != 1048575) & ($2_1 | $5_1) != 0) {
              break label$7;
            }
            $13_1 = $13_1 & 65535;
            $2_1 = $4_1;
            $4_1 = $31_1;
            $2_1 = ($2_1 >>> 20 | 0) + $16_1 | 0;
            $5_1 = $2_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $4_1 = $27_1;
            $6_1 = ($5_1 >>> 20 | 0) + $25_1 | 0;
            $11_1 = $6_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $4_1 = $29_1;
            $10_1 = ($11_1 >>> 20 | 0) + $26_1 | 0;
            $7_1 = $10_1 >>> 0 < $26_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            $4_1 = $13_1;
            $9_1 = $7_1 >>> 20 | 0;
            $13_1 = $9_1;
            $9_1 = $9_1 + $21_1 | 0;
            $4_1 = $13_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            if ($9_1 | ($10_1 | ($6_1 | ($2_1 | $14_1))) | ($4_1 | ($7_1 & 1048575 | ($11_1 & 1048575 | ($5_1 & 1048575 | $12_1))))) {
              if (($2_1 & $17_1 & $6_1 & $10_1 & $9_1) != -1) {
                $2_1 = 1;
              } else {
                $2_1 = ($5_1 & $15_1 & $11_1 & $7_1 & ($4_1 ^ 983040)) != 1048575;
              }
              if ($2_1) {
                break label$7;
              }
            }
            if (HEAP32[$1_1 + 120 >> 2]) {
              HEAP32[$0_1 + 120 >> 2] = 1;
              $68($0_1, 120);
              if (!$3_1) {
                break label$1;
              }
              HEAP32[$3_1 + 8 >> 2] = 0;
              HEAP32[$3_1 + 12 >> 2] = 0;
              HEAP32[$3_1 >> 2] = 1;
              HEAP32[$3_1 + 4 >> 2] = 0;
              $0_1 = $3_1 + 16 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              $0_1 = $3_1 + 24 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              $0_1 = $3_1 + 32 | 0;
              HEAP32[$0_1 >> 2] = 0;
              HEAP32[$0_1 + 4 >> 2] = 0;
              break label$1;
            }
            if ($3_1) {
              $2_1 = $1_1 + 40 | 0;
              $4_1 = HEAP32[$2_1 >> 2];
              $5_1 = HEAP32[$2_1 + 4 >> 2];
              HEAP32[$3_1 >> 2] = $4_1;
              HEAP32[$3_1 + 4 >> 2] = $5_1;
              $6_1 = $2_1 + 8 | 0;
              $11_1 = HEAP32[$6_1 >> 2];
              $14_1 = $11_1;
              $10_1 = HEAP32[$6_1 + 4 >> 2];
              $12_1 = $10_1;
              $6_1 = $3_1 + 8 | 0;
              HEAP32[$6_1 >> 2] = $11_1;
              HEAP32[$6_1 + 4 >> 2] = $10_1;
              $11_1 = $2_1 + 16 | 0;
              $10_1 = HEAP32[$11_1 >> 2];
              $17_1 = $10_1;
              $7_1 = HEAP32[$11_1 + 4 >> 2];
              $15_1 = $7_1;
              $11_1 = $3_1 + 16 | 0;
              HEAP32[$11_1 >> 2] = $10_1;
              HEAP32[$11_1 + 4 >> 2] = $7_1;
              $10_1 = $2_1 + 24 | 0;
              $7_1 = HEAP32[$10_1 >> 2];
              $13_1 = $7_1;
              $9_1 = HEAP32[$10_1 + 4 >> 2];
              $21_1 = $9_1;
              $10_1 = $3_1 + 24 | 0;
              HEAP32[$10_1 >> 2] = $7_1;
              HEAP32[$10_1 + 4 >> 2] = $9_1;
              $2_1 = $2_1 + 32 | 0;
              $7_1 = HEAP32[$2_1 >> 2];
              $2_1 = HEAP32[$2_1 + 4 >> 2];
              $9_1 = $3_1 + 32 | 0;
              HEAP32[$9_1 >> 2] = $7_1;
              HEAP32[$9_1 + 4 >> 2] = $2_1;
              $22_1 = __wasm_i64_mul($2_1 >>> 16 | 0, 0, 977, 1);
              $16_1 = $22_1 + $4_1 | 0;
              $4_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
              HEAP32[$3_1 >> 2] = $16_1;
              $4_1 = $16_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
              HEAP32[$3_1 + 4 >> 2] = $4_1 & 1048575;
              $3_1 = $4_1;
              $4_1 = $12_1;
              $3_1 = $3_1 >>> 20 | 0;
              $5_1 = $3_1;
              $3_1 = $3_1 + $14_1 | 0;
              $4_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
              HEAP32[$6_1 >> 2] = $3_1;
              HEAP32[$6_1 + 4 >> 2] = $4_1 & 1048575;
              $3_1 = $4_1;
              $4_1 = $15_1;
              $3_1 = $3_1 >>> 20 | 0;
              $5_1 = $3_1;
              $3_1 = $3_1 + $17_1 | 0;
              $4_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
              HEAP32[$11_1 >> 2] = $3_1;
              HEAP32[$11_1 + 4 >> 2] = $4_1 & 1048575;
              $3_1 = $4_1;
              $4_1 = $21_1;
              $3_1 = $3_1 >>> 20 | 0;
              $5_1 = $3_1;
              $3_1 = $3_1 + $13_1 | 0;
              $4_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
              HEAP32[$10_1 >> 2] = $3_1;
              HEAP32[$10_1 + 4 >> 2] = $4_1 & 1048575;
              $3_1 = $2_1 & 65535;
              $2_1 = $4_1;
              $4_1 = $3_1;
              $2_1 = $2_1 >>> 20 | 0;
              $3_1 = $2_1;
              $2_1 = $2_1 + $7_1 | 0;
              $4_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
              HEAP32[$9_1 >> 2] = $2_1;
              HEAP32[$9_1 + 4 >> 2] = $4_1;
            }
            $55($0_1, $1_1);
            break label$1;
          }
          if ($3_1) {
            HEAP32[$3_1 >> 2] = 0;
            HEAP32[$3_1 + 4 >> 2] = 0;
            $1_1 = $3_1 + 32 | 0;
            HEAP32[$1_1 >> 2] = 0;
            HEAP32[$1_1 + 4 >> 2] = 0;
            $1_1 = $3_1 + 24 | 0;
            HEAP32[$1_1 >> 2] = 0;
            HEAP32[$1_1 + 4 >> 2] = 0;
            $1_1 = $3_1 + 16 | 0;
            HEAP32[$1_1 >> 2] = 0;
            HEAP32[$1_1 + 4 >> 2] = 0;
            $1_1 = $3_1 + 8 | 0;
            HEAP32[$1_1 >> 2] = 0;
            HEAP32[$1_1 + 4 >> 2] = 0;
          }
          HEAP32[$0_1 + 120 >> 2] = 1;
          $68($0_1, 120);
          break label$1;
        }
        HEAP32[$0_1 + 120 >> 2] = 0;
        if ($3_1) {
          $1_1 = HEAP32[$8_1 + 500 >> 2];
          HEAP32[$3_1 >> 2] = HEAP32[$8_1 + 496 >> 2];
          HEAP32[$3_1 + 4 >> 2] = $1_1;
          $1_1 = $8_1 + 496 | 0;
          $4_1 = $1_1 + 32 | 0;
          $15_1 = HEAP32[$4_1 + 4 >> 2];
          $13_1 = $3_1 + 32 | 0;
          HEAP32[$13_1 >> 2] = HEAP32[$4_1 >> 2];
          HEAP32[$13_1 + 4 >> 2] = $15_1;
          $4_1 = $1_1 + 24 | 0;
          $15_1 = HEAP32[$4_1 + 4 >> 2];
          $13_1 = $3_1 + 24 | 0;
          HEAP32[$13_1 >> 2] = HEAP32[$4_1 >> 2];
          HEAP32[$13_1 + 4 >> 2] = $15_1;
          $4_1 = $1_1 + 16 | 0;
          $15_1 = HEAP32[$4_1 + 4 >> 2];
          $13_1 = $3_1 + 16 | 0;
          HEAP32[$13_1 >> 2] = HEAP32[$4_1 >> 2];
          HEAP32[$13_1 + 4 >> 2] = $15_1;
          $1_1 = $1_1 + 8 | 0;
          $4_1 = HEAP32[$1_1 + 4 >> 2];
          $3_1 = $3_1 + 8 | 0;
          HEAP32[$3_1 >> 2] = HEAP32[$1_1 >> 2];
          HEAP32[$3_1 + 4 >> 2] = $4_1;
        }
        $28_1 = $8_1 + 496 | 0;
        $34($0_1 + 80 | 0, $30_1, $28_1);
        $23_1 = $8_1 + 304 | 0;
        $15_1 = $9_1 << 1;
        $1_1 = $12_1;
        $12_1 = $1_1 << 1 | $9_1 >>> 31;
        $69($23_1, $6_1, $7_1, 0, 0, $15_1, $12_1, 0, 0);
        $18_1 = $8_1 + 224 | 0;
        $3_1 = $11_1 << 1;
        $21_1 = $14_1;
        $14_1 = $11_1;
        $13_1 = $21_1 << 1 | $11_1 >>> 31;
        $69($18_1, $5_1, $10_1, 0, 0, $3_1, $13_1, 0, 0);
        $16_1 = $8_1 + 160 | 0;
        $69($16_1, $2_1, $17_1, 0, 0, $2_1, $17_1, 0, 0);
        $19_1 = $8_1 + 144 | 0;
        $69($19_1, HEAP32[$8_1 + 160 >> 2], HEAP32[$8_1 + 164 >> 2], 0, 0, 15632, 16, 0, 0);
        $24_1 = $8_1 + 112 | 0;
        $11_1 = $2_1 << 1;
        $17_1 = $17_1 << 1 | $2_1 >>> 31;
        $69($24_1, $11_1, $17_1, 0, 0, $9_1, $1_1, 0, 0);
        $20_1 = $8_1 + 272 | 0;
        $69($20_1, $6_1, $7_1, 0, 0, $3_1, $13_1, 0, 0);
        $29_1 = $8_1 + 208 | 0;
        $69($29_1, $5_1, $10_1, 0, 0, $5_1, $10_1, 0, 0);
        $27_1 = $8_1 + 128 | 0;
        $2_1 = $16_1 + 8 | 0;
        $69($27_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
        $31_1 = $8_1 + 320 | 0;
        $69($31_1, $9_1, $1_1, 0, 0, $9_1, $1_1, 0, 0);
        $32_1 = $8_1 + 96 | 0;
        $69($32_1, $11_1, $17_1, 0, 0, $14_1, $21_1, 0, 0);
        $34_1 = $8_1 + 176 | 0;
        $16_1 = $6_1;
        $22_1 = $7_1;
        $25_1 = $10_1;
        $10_1 = $5_1;
        $69($34_1, $6_1, $7_1, 0, 0, $5_1 << 1, $25_1 << 1 | $5_1 >>> 31, 0, 0);
        $6_1 = HEAP32[$8_1 + 304 >> 2];
        $2_1 = HEAP32[$8_1 + 224 >> 2];
        $1_1 = $6_1 + $2_1 | 0;
        $5_1 = HEAP32[$8_1 + 308 >> 2];
        $4_1 = $5_1 + HEAP32[$8_1 + 228 >> 2] | 0;
        $2_1 = $1_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $2_1 + HEAP32[$8_1 + 148 >> 2] | 0;
        $3_1 = $1_1;
        $7_1 = HEAP32[$8_1 + 144 >> 2];
        $1_1 = $1_1 + $7_1 | 0;
        $26_1 = $1_1;
        $1_1 = $1_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = ($2_1 | 0) == ($1_1 | 0) & $3_1 >>> 0 > $26_1 >>> 0 | $1_1 >>> 0 < $2_1 >>> 0;
        $4_1 = $19_1 + 8 | 0;
        $9_1 = HEAP32[$4_1 >> 2];
        $13_1 = HEAP32[$4_1 + 4 >> 2];
        $3_1 = ($2_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $2_1 >>> 0 < $5_1 >>> 0;
        $4_1 = $18_1 + 8 | 0;
        $5_1 = HEAP32[$4_1 >> 2];
        $6_1 = $23_1 + 8 | 0;
        $2_1 = $5_1 + HEAP32[$6_1 >> 2] | 0;
        $4_1 = HEAP32[$6_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $2_1;
        $2_1 = $2_1 + $3_1 | 0;
        $4_1 = ($5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $13_1 | 0;
        $3_1 = $2_1;
        $2_1 = $2_1 + $9_1 | 0;
        $4_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $3_1 = $2_1 + $7_1 | 0;
        $2_1 = $3_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $2_1 << 12 | $3_1 >>> 20;
        $23_1 = $1_1;
        $18_1 = $3_1 << 12 | $1_1 >>> 20;
        $30_1 = $5_1;
        $33_1 = HEAP32[$8_1 + 272 >> 2];
        $3_1 = HEAP32[$8_1 + 208 >> 2];
        $1_1 = $33_1 + $3_1 | 0;
        $19_1 = HEAP32[$8_1 + 276 >> 2];
        $4_1 = $19_1 + HEAP32[$8_1 + 212 >> 2] | 0;
        $4_1 = $1_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $1_1;
        $3_1 = HEAP32[$8_1 + 112 >> 2];
        $1_1 = $1_1 + $3_1 | 0;
        $5_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$8_1 + 116 >> 2] | 0;
        $4_1 = $1_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $9_1 = $1_1;
        $3_1 = HEAP32[$8_1 + 128 >> 2];
        $1_1 = $1_1 + $3_1 | 0;
        $6_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$8_1 + 132 >> 2] | 0;
        $3_1 = $1_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $3_1 + $30_1 | 0;
        $30_1 = $8_1 + 80 | 0;
        $13_1 = $1_1;
        $18_1 = $1_1 + $18_1 | 0;
        $1_1 = $1_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $3_1;
        $3_1 = $18_1;
        $18_1 = ($1_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $4_1 >>> 0;
        $13_1 = ($4_1 | 0) == ($6_1 | 0) & $9_1 >>> 0 > $13_1 >>> 0 | $4_1 >>> 0 < $6_1 >>> 0;
        $4_1 = $27_1 + 8 | 0;
        $27_1 = HEAP32[$4_1 >> 2];
        $35_1 = HEAP32[$4_1 + 4 >> 2];
        $6_1 = ($5_1 | 0) == ($6_1 | 0) & $9_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 > $6_1 >>> 0;
        $4_1 = $24_1 + 8 | 0;
        $9_1 = HEAP32[$4_1 >> 2];
        $24_1 = HEAP32[$4_1 + 4 >> 2];
        $7_1 = ($5_1 | 0) == ($19_1 | 0) & $7_1 >>> 0 < $33_1 >>> 0 | $5_1 >>> 0 < $19_1 >>> 0;
        $4_1 = $29_1 + 8 | 0;
        $19_1 = HEAP32[$4_1 >> 2];
        $20_1 = $20_1 + 8 | 0;
        $5_1 = $19_1 + HEAP32[$20_1 >> 2] | 0;
        $4_1 = HEAP32[$20_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $5_1 >>> 0 < $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $20_1 = $5_1;
        $5_1 = $5_1 + $7_1 | 0;
        $4_1 = ($20_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $24_1 | 0;
        $7_1 = $5_1;
        $5_1 = $5_1 + $9_1 | 0;
        $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $5_1;
        $5_1 = $5_1 + $6_1 | 0;
        $4_1 = ($7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $35_1 | 0;
        $7_1 = $5_1;
        $5_1 = $5_1 + $27_1 | 0;
        $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $5_1;
        $5_1 = $5_1 + $13_1 | 0;
        $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $2_1 = $2_1 >>> 20 | 0;
        $7_1 = $2_1;
        $2_1 = $2_1 + $5_1 | 0;
        $4_1 = $7_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $2_1 + $18_1 | 0;
        $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $2_1 << 12 | $5_1 >>> 20;
        $7_1 = $5_1 << 12;
        $5_1 = $1_1;
        $9_1 = $7_1 | $1_1 >>> 20;
        $13_1 = $4_1;
        $19_1 = HEAP32[$8_1 + 96 >> 2];
        $6_1 = HEAP32[$8_1 + 176 >> 2];
        $1_1 = $19_1 + $6_1 | 0;
        $18_1 = HEAP32[$8_1 + 100 >> 2];
        $4_1 = $18_1 + HEAP32[$8_1 + 180 >> 2] | 0;
        $6_1 = $1_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $6_1 + $13_1 | 0;
        $7_1 = $1_1;
        $9_1 = $1_1 + $9_1 | 0;
        $4_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $24_1 = $9_1 << 4 & -16;
        $13_1 = $5_1;
        $1_1 = $4_1;
        $69($30_1, $24_1 | $5_1 >>> 16 & 15, ($4_1 << 4 | $9_1 >>> 28) & 16777215, 0, 0, 977, 1, 0, 0);
        $24_1 = $8_1 + 256 | 0;
        $69($24_1, $14_1, $21_1, 0, 0, $15_1, $12_1, 0, 0);
        $20_1 = $8_1 - -64 | 0;
        $69($20_1, $11_1, $17_1, 0, 0, $10_1, $25_1, 0, 0);
        $29_1 = $8_1 + 288 | 0;
        $69($29_1, $16_1, $22_1, 0, 0, $16_1, $22_1, 0, 0);
        $27_1 = $8_1 + 48 | 0;
        $9_1 = ($4_1 | 0) == ($6_1 | 0) & $9_1 >>> 0 < $7_1 >>> 0 | $4_1 >>> 0 < $6_1 >>> 0;
        $6_1 = ($6_1 | 0) == ($18_1 | 0) & $7_1 >>> 0 < $19_1 >>> 0 | $6_1 >>> 0 < $18_1 >>> 0;
        $4_1 = $34_1 + 8 | 0;
        $7_1 = HEAP32[$4_1 >> 2];
        $18_1 = $32_1 + 8 | 0;
        $5_1 = $7_1 + HEAP32[$18_1 >> 2] | 0;
        $4_1 = HEAP32[$18_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $5_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $5_1;
        $5_1 = $5_1 + $6_1 | 0;
        $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $2_1 = $2_1 >>> 20 | 0;
        $7_1 = $2_1;
        $2_1 = $2_1 + $5_1 | 0;
        $4_1 = $7_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $2_1 + $9_1 | 0;
        $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $2_1 << 12 | $5_1 >>> 20;
        $5_1 = $5_1 << 12 | $1_1 >>> 20;
        $7_1 = $6_1;
        $18_1 = HEAP32[$8_1 + 64 >> 2];
        $6_1 = HEAP32[$8_1 + 288 >> 2];
        $1_1 = $18_1 + $6_1 | 0;
        $9_1 = HEAP32[$8_1 + 68 >> 2];
        $4_1 = $9_1 + HEAP32[$8_1 + 292 >> 2] | 0;
        $4_1 = $1_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $1_1;
        $1_1 = $4_1;
        $4_1 = $4_1 + $7_1 | 0;
        $5_1 = $5_1 + $6_1 | 0;
        $4_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $5_1;
        $5_1 = $4_1;
        $69($27_1, $7_1, $4_1 & 1048575, 0, 0, 15632, 16, 0, 0);
        $19_1 = $8_1 + 192 | 0;
        $69($19_1, $10_1, $25_1, 0, 0, $15_1, $12_1, 0, 0);
        $12_1 = $8_1 + 240 | 0;
        $69($12_1, $14_1, $21_1, 0, 0, $14_1, $21_1, 0, 0);
        $10_1 = $8_1 + 32 | 0;
        $69($10_1, $11_1, $17_1, 0, 0, $16_1, $22_1, 0, 0);
        $17_1 = $8_1 + 16 | 0;
        $11_1 = $17_1;
        $7_1 = ($1_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 > $7_1 >>> 0 | $1_1 >>> 0 > $4_1 >>> 0;
        $6_1 = ($1_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 < $18_1 >>> 0 | $1_1 >>> 0 < $9_1 >>> 0;
        $4_1 = $29_1 + 8 | 0;
        $9_1 = HEAP32[$4_1 >> 2];
        $14_1 = $20_1 + 8 | 0;
        $1_1 = $9_1 + HEAP32[$14_1 >> 2] | 0;
        $4_1 = HEAP32[$14_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $14_1 = $1_1;
        $1_1 = $1_1 + $6_1 | 0;
        $4_1 = $14_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $2_1 = $2_1 >>> 20 | 0;
        $1_1 = $1_1 + $2_1 | 0;
        $4_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $2_1 = $1_1 + $7_1 | 0;
        $1_1 = $2_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $1_1 << 12 | $2_1 >>> 20;
        $7_1 = $2_1 << 12 | $5_1 >>> 20;
        $9_1 = HEAP32[$8_1 + 32 >> 2];
        $2_1 = $7_1 + $9_1 | 0;
        $5_1 = $6_1;
        $4_1 = $5_1 + HEAP32[$8_1 + 36 >> 2] | 0;
        $4_1 = $2_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $69($11_1, $2_1, $4_1, 0, 0, 15632, 16, 0, 0);
        $2_1 = ($4_1 | 0) == ($5_1 | 0) & $2_1 >>> 0 < $7_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
        $4_1 = $10_1 + 8 | 0;
        $5_1 = HEAP32[$4_1 >> 2];
        $4_1 = HEAP32[$4_1 + 4 >> 2];
        $1_1 = $1_1 >>> 20 | 0;
        $7_1 = $1_1;
        $1_1 = $1_1 + $5_1 | 0;
        $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $1_1;
        $1_1 = $1_1 + $2_1 | 0;
        $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $69($8_1, $1_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
        $1_1 = $8_1;
        $11_1 = HEAP32[$1_1 + 80 >> 2];
        $2_1 = HEAP32[$1_1 + 320 >> 2];
        $5_1 = $11_1 + $2_1 | 0;
        $6_1 = HEAP32[$1_1 + 84 >> 2];
        $4_1 = $6_1 + HEAP32[$1_1 + 324 >> 2] | 0;
        HEAP32[$1_1 + 416 >> 2] = -3908 - $5_1;
        $2_1 = $2_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$1_1 + 420 >> 2] = 4194299 - (($2_1 & 1048575) + ($5_1 >>> 0 > 4294963388) | 0);
        $6_1 = ($2_1 | 0) == ($6_1 | 0) & $5_1 >>> 0 < $11_1 >>> 0 | $2_1 >>> 0 < $6_1 >>> 0;
        $4_1 = $31_1 + 8 | 0;
        $11_1 = HEAP32[$4_1 >> 2];
        $10_1 = $30_1 + 8 | 0;
        $5_1 = $11_1 + HEAP32[$10_1 >> 2] | 0;
        $4_1 = HEAP32[$10_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $5_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $5_1 + $6_1 | 0;
        $5_1 = $6_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $11_1 = $5_1 << 12 | $6_1 >>> 20;
        $6_1 = $6_1 << 12 | $2_1 >>> 20;
        $10_1 = $11_1;
        $9_1 = HEAP32[$1_1 + 48 >> 2];
        $11_1 = HEAP32[$1_1 + 256 >> 2];
        $2_1 = $9_1 + $11_1 | 0;
        $7_1 = HEAP32[$1_1 + 52 >> 2];
        $4_1 = $7_1 + HEAP32[$1_1 + 260 >> 2] | 0;
        $4_1 = $2_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $11_1 = $2_1;
        $2_1 = $4_1;
        $4_1 = $4_1 + $10_1 | 0;
        $6_1 = $6_1 + $11_1 | 0;
        $4_1 = $6_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $10_1 = $6_1;
        HEAP32[$1_1 + 424 >> 2] = -4 - $6_1;
        $6_1 = $4_1;
        HEAP32[$1_1 + 428 >> 2] = 4194303 - (($4_1 & 1048575) + ($10_1 >>> 0 > 4294967292) | 0);
        $10_1 = ($2_1 | 0) == ($4_1 | 0) & $10_1 >>> 0 < $11_1 >>> 0 | $2_1 >>> 0 > $4_1 >>> 0;
        $11_1 = ($2_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 > $11_1 >>> 0 | $2_1 >>> 0 < $7_1 >>> 0;
        $4_1 = $24_1 + 8 | 0;
        $7_1 = HEAP32[$4_1 >> 2];
        $9_1 = $27_1 + 8 | 0;
        $2_1 = $7_1 + HEAP32[$9_1 >> 2] | 0;
        $4_1 = HEAP32[$9_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $2_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $2_1;
        $2_1 = $2_1 + $11_1 | 0;
        $4_1 = $7_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $5_1 >>> 20 | 0;
        $2_1 = $2_1 + $5_1 | 0;
        $4_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $2_1 + $10_1 | 0;
        $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $11_1 = $2_1 << 12 | $5_1 >>> 20;
        $9_1 = $5_1 << 12 | $6_1 >>> 20;
        $21_1 = HEAP32[$1_1 + 192 >> 2];
        $5_1 = HEAP32[$1_1 + 240 >> 2];
        $6_1 = $21_1 + $5_1 | 0;
        $14_1 = HEAP32[$1_1 + 196 >> 2];
        $4_1 = $14_1 + HEAP32[$1_1 + 244 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $6_1;
        $6_1 = HEAP32[$1_1 + 16 >> 2];
        $10_1 = $7_1 + $6_1 | 0;
        $5_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$1_1 + 20 >> 2] | 0;
        $6_1 = $6_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $6_1 + $11_1 | 0;
        $11_1 = $9_1 + $10_1 | 0;
        $4_1 = $11_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $9_1 = $11_1;
        HEAP32[$1_1 + 432 >> 2] = -4 - $9_1;
        $11_1 = $4_1;
        HEAP32[$1_1 + 436 >> 2] = 4194303 - (($4_1 & 1048575) + ($9_1 >>> 0 > 4294967292) | 0);
        $9_1 = ($4_1 | 0) == ($6_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $6_1 >>> 0;
        $6_1 = ($5_1 | 0) == ($6_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $5_1 >>> 0 > $6_1 >>> 0;
        $4_1 = $17_1 + 8 | 0;
        $10_1 = HEAP32[$4_1 >> 2];
        $17_1 = HEAP32[$4_1 + 4 >> 2];
        $7_1 = ($5_1 | 0) == ($14_1 | 0) & $7_1 >>> 0 < $21_1 >>> 0 | $5_1 >>> 0 < $14_1 >>> 0;
        $4_1 = $12_1 + 8 | 0;
        $14_1 = HEAP32[$4_1 >> 2];
        $12_1 = $19_1 + 8 | 0;
        $5_1 = $14_1 + HEAP32[$12_1 >> 2] | 0;
        $4_1 = HEAP32[$12_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $12_1 = $5_1;
        $5_1 = $5_1 + $7_1 | 0;
        $4_1 = ($12_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $17_1 | 0;
        $7_1 = $5_1;
        $5_1 = $5_1 + $10_1 | 0;
        $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $5_1;
        $5_1 = $5_1 + $6_1 | 0;
        $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $2_1 = $2_1 >>> 20 | 0;
        $7_1 = $2_1;
        $2_1 = $2_1 + $5_1 | 0;
        $4_1 = $7_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $2_1 + $9_1 | 0;
        $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $2_1 << 12 | $5_1 >>> 20;
        $10_1 = $5_1 << 12 | $11_1 >>> 20;
        $14_1 = HEAP32[$1_1 >> 2];
        $5_1 = $26_1 & -2;
        $11_1 = $14_1 + $5_1 | 0;
        $9_1 = HEAP32[$1_1 + 4 >> 2];
        $4_1 = $9_1 + ($23_1 & 1048575) | 0;
        $5_1 = $5_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $5_1 + $6_1 | 0;
        $10_1 = $10_1 + $11_1 | 0;
        $4_1 = $10_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$1_1 + 440 >> 2] = -4 - $10_1;
        $6_1 = $4_1;
        HEAP32[$1_1 + 444 >> 2] = 4194303 - (($4_1 & 1048575) + ($10_1 >>> 0 > 4294967292) | 0);
        $7_1 = $3_1;
        $12_1 = $13_1 & 65535;
        $10_1 = ($4_1 | 0) == ($5_1 | 0) & $10_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
        $5_1 = ($5_1 | 0) == ($9_1 | 0) & $11_1 >>> 0 < $14_1 >>> 0 | $5_1 >>> 0 < $9_1 >>> 0;
        $4_1 = $1_1 + 8 | 0;
        $3_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2];
        $4_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $2_1 = $2_1 >>> 20 | 0;
        $5_1 = $2_1;
        $2_1 = $2_1 + $3_1 | 0;
        $4_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $3_1 = $2_1;
        $2_1 = $2_1 + $10_1 | 0;
        $4_1 = $12_1 + (($3_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 12 | $2_1 >>> 20) | 0;
        $5_1 = $2_1 << 12 | $6_1 >>> 20;
        $2_1 = $5_1 + $7_1 | 0;
        HEAP32[$1_1 + 448 >> 2] = -4 - $2_1;
        HEAP32[$1_1 + 452 >> 2] = 262143 - (($2_1 >>> 0 > 4294967292) + ($2_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0);
        $15_1 = $1_1 + 376 | 0;
        $2_1 = $1_1 + 416 | 0;
        $34($15_1, $2_1, $28_1);
        $16_1 = $1_1 + 336 | 0;
        $34($16_1, $1_1 + 656 | 0, $2_1);
        $22_1 = $1_1 + 456 | 0;
        $54($0_1, $22_1);
        $3_1 = HEAP32[$1_1 + 408 >> 2];
        $2_1 = $3_1 + HEAP32[$0_1 + 32 >> 2] | 0;
        $4_1 = HEAP32[$0_1 + 36 >> 2] + HEAP32[$1_1 + 412 >> 2] | 0;
        $3_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = HEAP32[$1_1 + 372 >> 2];
        $25_1 = $4_1;
        $13_1 = HEAP32[$1_1 + 368 >> 2];
        $5_1 = $13_1;
        $4_1 = ($4_1 << 1 | $5_1 >>> 31) + $3_1 | 0;
        $5_1 = $5_1 << 1;
        $2_1 = $2_1 + $5_1 | 0;
        $4_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $2_1;
        HEAP32[$0_1 + 32 >> 2] = $2_1;
        $11_1 = $4_1;
        HEAP32[$0_1 + 36 >> 2] = $4_1;
        $3_1 = HEAP32[$1_1 + 400 >> 2];
        $2_1 = $3_1 + HEAP32[$0_1 + 24 >> 2] | 0;
        $4_1 = HEAP32[$0_1 + 28 >> 2] + HEAP32[$1_1 + 404 >> 2] | 0;
        $4_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $3_1 = $2_1;
        $5_1 = $4_1;
        $2_1 = HEAP32[$1_1 + 360 >> 2];
        $26_1 = $2_1;
        $4_1 = HEAP32[$1_1 + 364 >> 2];
        $23_1 = $4_1;
        $4_1 = ($4_1 << 1 | $2_1 >>> 31) + $5_1 | 0;
        $2_1 = $2_1 << 1;
        $5_1 = $2_1;
        $2_1 = $2_1 + $3_1 | 0;
        $4_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$0_1 + 24 >> 2] = $2_1;
        $10_1 = $4_1;
        HEAP32[$0_1 + 28 >> 2] = $4_1;
        $5_1 = HEAP32[$1_1 + 392 >> 2];
        $3_1 = $5_1 + HEAP32[$0_1 + 16 >> 2] | 0;
        $4_1 = HEAP32[$0_1 + 20 >> 2] + HEAP32[$1_1 + 396 >> 2] | 0;
        $4_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $3_1;
        $7_1 = $4_1;
        $3_1 = HEAP32[$1_1 + 352 >> 2];
        $18_1 = $3_1;
        $4_1 = HEAP32[$1_1 + 356 >> 2];
        $19_1 = $4_1;
        $4_1 = ($4_1 << 1 | $3_1 >>> 31) + $7_1 | 0;
        $3_1 = $3_1 << 1;
        $7_1 = $3_1;
        $3_1 = $3_1 + $5_1 | 0;
        $4_1 = $7_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$0_1 + 16 >> 2] = $3_1;
        $7_1 = $4_1;
        HEAP32[$0_1 + 20 >> 2] = $4_1;
        $9_1 = HEAP32[$1_1 + 384 >> 2];
        $5_1 = $9_1 + HEAP32[$0_1 + 8 >> 2] | 0;
        $4_1 = HEAP32[$0_1 + 12 >> 2] + HEAP32[$1_1 + 388 >> 2] | 0;
        $9_1 = $5_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = HEAP32[$1_1 + 348 >> 2];
        $28_1 = $4_1;
        $21_1 = HEAP32[$1_1 + 344 >> 2];
        $14_1 = $21_1;
        $4_1 = ($4_1 << 1 | $14_1 >>> 31) + $9_1 | 0;
        $14_1 = $14_1 << 1;
        $5_1 = $5_1 + $14_1 | 0;
        $4_1 = $14_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $9_1 = $5_1;
        HEAP32[$0_1 + 8 >> 2] = $5_1;
        $14_1 = $4_1;
        HEAP32[$0_1 + 12 >> 2] = $4_1;
        $12_1 = HEAP32[$1_1 + 376 >> 2];
        $5_1 = $12_1 + HEAP32[$0_1 >> 2] | 0;
        $4_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$1_1 + 380 >> 2] | 0;
        $4_1 = $5_1 >>> 0 < $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $12_1 = $5_1;
        $17_1 = $4_1;
        $5_1 = HEAP32[$1_1 + 336 >> 2];
        $24_1 = $5_1;
        $4_1 = HEAP32[$1_1 + 340 >> 2];
        $20_1 = $4_1;
        $4_1 = ($4_1 << 1 | $5_1 >>> 31) + $17_1 | 0;
        $5_1 = $5_1 << 1;
        $17_1 = $5_1;
        $5_1 = $5_1 + $12_1 | 0;
        $4_1 = $17_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$0_1 >> 2] = $5_1;
        $12_1 = $4_1;
        HEAP32[$0_1 + 4 >> 2] = $4_1;
        $4_1 = $11_1 + $25_1 | 0;
        $6_1 = $6_1 + $13_1 | 0;
        $4_1 = $6_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$1_1 + 368 >> 2] = $6_1;
        HEAP32[$1_1 + 372 >> 2] = $4_1;
        $4_1 = $10_1 + $23_1 | 0;
        $6_1 = $2_1;
        $2_1 = $2_1 + $26_1 | 0;
        $4_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$1_1 + 360 >> 2] = $2_1;
        HEAP32[$1_1 + 364 >> 2] = $4_1;
        $4_1 = $7_1 + $19_1 | 0;
        $2_1 = $3_1 + $18_1 | 0;
        $4_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$1_1 + 352 >> 2] = $2_1;
        HEAP32[$1_1 + 356 >> 2] = $4_1;
        $4_1 = $14_1 + $28_1 | 0;
        $2_1 = $9_1 + $21_1 | 0;
        $4_1 = $2_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$1_1 + 344 >> 2] = $2_1;
        HEAP32[$1_1 + 348 >> 2] = $4_1;
        $4_1 = $12_1 + $20_1 | 0;
        $1_1 = $5_1 + $24_1 | 0;
        $4_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$8_1 + 336 >> 2] = $1_1;
        HEAP32[$8_1 + 340 >> 2] = $4_1;
        $34($0_1 + 40 | 0, $16_1, $22_1);
        $34($15_1, $15_1, $8_1 + 576 | 0);
        $4_1 = HEAP32[$0_1 + 44 >> 2] + HEAP32[$8_1 + 380 >> 2] | 0;
        $2_1 = HEAP32[$8_1 + 376 >> 2];
        $1_1 = $2_1 + HEAP32[$0_1 + 40 >> 2] | 0;
        HEAP32[$0_1 + 40 >> 2] = $1_1;
        HEAP32[$0_1 + 44 >> 2] = $1_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $3_1 = HEAP32[$8_1 + 384 >> 2];
        $1_1 = $0_1 + 48 | 0;
        $2_1 = $3_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$8_1 + 388 >> 2] | 0;
        HEAP32[$1_1 >> 2] = $2_1;
        HEAP32[$1_1 + 4 >> 2] = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $3_1 = HEAP32[$8_1 + 392 >> 2];
        $1_1 = $0_1 + 56 | 0;
        $2_1 = $3_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$8_1 + 396 >> 2] | 0;
        HEAP32[$1_1 >> 2] = $2_1;
        HEAP32[$1_1 + 4 >> 2] = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $3_1 = HEAP32[$8_1 + 400 >> 2];
        $1_1 = $0_1 - -64 | 0;
        $2_1 = $3_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$8_1 + 404 >> 2] | 0;
        HEAP32[$1_1 >> 2] = $2_1;
        HEAP32[$1_1 + 4 >> 2] = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $2_1 = HEAP32[$8_1 + 408 >> 2];
        $0_1 = $0_1 + 72 | 0;
        $1_1 = $2_1 + HEAP32[$0_1 >> 2] | 0;
        $4_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$8_1 + 412 >> 2] | 0;
        HEAP32[$0_1 >> 2] = $1_1;
        HEAP32[$0_1 + 4 >> 2] = $1_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      }
      global$0 = $8_1 + 736 | 0;
    }
    function $66($0_1, $1_1, $2_1) {
      var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0;
      $6_1 = global$0 - 256 | 0;
      global$0 = $6_1;
      $8_1 = $6_1 + 240 | 0;
      $69($8_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0);
      $3_1 = HEAP32[$6_1 + 244 >> 2];
      HEAP32[$0_1 >> 2] = HEAP32[$6_1 + 240 >> 2];
      HEAP32[$0_1 + 4 >> 2] = $3_1;
      $10_1 = $6_1 + 208 | 0;
      $69($10_1, HEAP32[$2_1 + 8 >> 2], HEAP32[$2_1 + 12 >> 2], 0, 0, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0);
      $7_1 = $6_1 + 224 | 0;
      $69($7_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, HEAP32[$1_1 + 8 >> 2], HEAP32[$1_1 + 12 >> 2], 0, 0);
      $14_1 = $0_1;
      $4_1 = HEAP32[$6_1 + 208 >> 2];
      $0_1 = $8_1 + 8 | 0;
      $3_1 = HEAP32[$0_1 >> 2];
      $13_1 = $4_1 + $3_1 | 0;
      $11_1 = HEAP32[$6_1 + 212 >> 2];
      $0_1 = $11_1 + HEAP32[$0_1 + 4 >> 2] | 0;
      $9_1 = $3_1 >>> 0 > $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $9_1 + HEAP32[$6_1 + 228 >> 2] | 0;
      $3_1 = HEAP32[$6_1 + 224 >> 2];
      $8_1 = $3_1 + $13_1 | 0;
      HEAP32[$14_1 + 8 >> 2] = $8_1;
      $5_1 = $3_1 >>> 0 > $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      HEAP32[$14_1 + 12 >> 2] = $5_1;
      $17_1 = $6_1 + 160 | 0;
      $69($17_1, HEAP32[$2_1 + 16 >> 2], HEAP32[$2_1 + 20 >> 2], 0, 0, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0);
      $20_1 = $6_1 + 176 | 0;
      $69($20_1, HEAP32[$2_1 + 8 >> 2], HEAP32[$2_1 + 12 >> 2], 0, 0, HEAP32[$1_1 + 8 >> 2], HEAP32[$1_1 + 12 >> 2], 0, 0);
      $18_1 = $6_1 + 192 | 0;
      $69($18_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, HEAP32[$1_1 + 16 >> 2], HEAP32[$1_1 + 20 >> 2], 0, 0);
      $4_1 = ($9_1 | 0) == ($11_1 | 0) & $4_1 >>> 0 > $13_1 >>> 0 | $9_1 >>> 0 < $11_1 >>> 0;
      $0_1 = $10_1 + 8 | 0;
      $3_1 = $4_1 + HEAP32[$0_1 >> 2] | 0;
      $0_1 = HEAP32[$0_1 + 4 >> 2];
      $4_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $8_1 = ($5_1 | 0) == ($9_1 | 0) & $8_1 >>> 0 < $13_1 >>> 0 | $5_1 >>> 0 < $9_1 >>> 0;
      $0_1 = $7_1 + 8 | 0;
      $5_1 = $8_1 + HEAP32[$0_1 >> 2] | 0;
      $0_1 = HEAP32[$0_1 + 4 >> 2];
      $0_1 = ($5_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $4_1 | 0;
      $8_1 = $3_1 + $5_1 | 0;
      $0_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $11_1 = $8_1;
      $8_1 = HEAP32[$6_1 + 160 >> 2];
      $5_1 = $11_1 + $8_1 | 0;
      $15_1 = $0_1;
      $0_1 = $0_1 + HEAP32[$6_1 + 164 >> 2] | 0;
      $0_1 = $5_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $8_1 = HEAP32[$6_1 + 176 >> 2];
      $10_1 = $8_1 + $5_1 | 0;
      $16_1 = $0_1;
      $0_1 = $0_1 + HEAP32[$6_1 + 180 >> 2] | 0;
      $12_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $12_1 + HEAP32[$6_1 + 196 >> 2] | 0;
      $8_1 = HEAP32[$6_1 + 192 >> 2];
      $9_1 = $8_1 + $10_1 | 0;
      HEAP32[$14_1 + 16 >> 2] = $9_1;
      $7_1 = $9_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      HEAP32[$14_1 + 20 >> 2] = $7_1;
      $25_1 = $6_1 + 96 | 0;
      $69($25_1, HEAP32[$2_1 + 24 >> 2], HEAP32[$2_1 + 28 >> 2], 0, 0, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0);
      $23_1 = $6_1 + 112 | 0;
      $69($23_1, HEAP32[$2_1 + 16 >> 2], HEAP32[$2_1 + 20 >> 2], 0, 0, HEAP32[$1_1 + 8 >> 2], HEAP32[$1_1 + 12 >> 2], 0, 0);
      $24_1 = $6_1 + 128 | 0;
      $69($24_1, HEAP32[$2_1 + 8 >> 2], HEAP32[$2_1 + 12 >> 2], 0, 0, HEAP32[$1_1 + 16 >> 2], HEAP32[$1_1 + 20 >> 2], 0, 0);
      $22_1 = $6_1 + 144 | 0;
      $69($22_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, HEAP32[$1_1 + 24 >> 2], HEAP32[$1_1 + 28 >> 2], 0, 0);
      $8_1 = ($15_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 < $11_1 >>> 0 | $15_1 >>> 0 > $16_1 >>> 0;
      $0_1 = $17_1 + 8 | 0;
      $13_1 = $8_1 + HEAP32[$0_1 >> 2] | 0;
      $0_1 = HEAP32[$0_1 + 4 >> 2];
      $3_1 = ($4_1 | 0) == ($15_1 | 0) & $3_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 > $15_1 >>> 0;
      $17_1 = $13_1 + $3_1 | 0;
      $0_1 = $8_1 >>> 0 > $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $8_1 = $0_1;
      $4_1 = $3_1 >>> 0 > $17_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $11_1 = $17_1;
      $3_1 = ($12_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 > $10_1 >>> 0 | $12_1 >>> 0 < $16_1 >>> 0;
      $0_1 = $20_1 + 8 | 0;
      $5_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
      $0_1 = HEAP32[$0_1 + 4 >> 2];
      $0_1 = ($3_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $4_1 | 0;
      $21_1 = $5_1;
      $5_1 = $5_1 + $11_1 | 0;
      $3_1 = $21_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $20_1 = $5_1;
      $11_1 = $5_1;
      $5_1 = ($7_1 | 0) == ($12_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $7_1 >>> 0 < $12_1 >>> 0;
      $0_1 = $18_1 + 8 | 0;
      $9_1 = $5_1 + HEAP32[$0_1 >> 2] | 0;
      $0_1 = HEAP32[$0_1 + 4 >> 2];
      $0_1 = ($5_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $3_1 | 0;
      $5_1 = $9_1 + $11_1 | 0;
      $0_1 = $5_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $15_1 = $5_1;
      $5_1 = HEAP32[$6_1 + 96 >> 2];
      $16_1 = $15_1 + $5_1 | 0;
      $18_1 = $0_1;
      $0_1 = $0_1 + HEAP32[$6_1 + 100 >> 2] | 0;
      $0_1 = $5_1 >>> 0 > $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $5_1 = HEAP32[$6_1 + 112 >> 2];
      $12_1 = $5_1 + $16_1 | 0;
      $19_1 = $0_1;
      $0_1 = $0_1 + HEAP32[$6_1 + 116 >> 2] | 0;
      $0_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $5_1 = HEAP32[$6_1 + 128 >> 2];
      $7_1 = $5_1 + $12_1 | 0;
      $21_1 = $0_1;
      $0_1 = $0_1 + HEAP32[$6_1 + 132 >> 2] | 0;
      $10_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $10_1 + HEAP32[$6_1 + 148 >> 2] | 0;
      $5_1 = HEAP32[$6_1 + 144 >> 2];
      $9_1 = $5_1 + $7_1 | 0;
      HEAP32[$14_1 + 24 >> 2] = $9_1;
      $0_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      HEAP32[$14_1 + 28 >> 2] = $0_1;
      $26_1 = $6_1 + 48 | 0;
      $69($26_1, HEAP32[$2_1 + 24 >> 2], HEAP32[$2_1 + 28 >> 2], 0, 0, HEAP32[$1_1 + 8 >> 2], HEAP32[$1_1 + 12 >> 2], 0, 0);
      $27_1 = $6_1 - -64 | 0;
      $69($27_1, HEAP32[$2_1 + 16 >> 2], HEAP32[$2_1 + 20 >> 2], 0, 0, HEAP32[$1_1 + 16 >> 2], HEAP32[$1_1 + 20 >> 2], 0, 0);
      $28_1 = $6_1 + 80 | 0;
      $69($28_1, HEAP32[$2_1 + 8 >> 2], HEAP32[$2_1 + 12 >> 2], 0, 0, HEAP32[$1_1 + 24 >> 2], HEAP32[$1_1 + 28 >> 2], 0, 0);
      $9_1 = ($0_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $0_1 >>> 0 < $10_1 >>> 0;
      $0_1 = $22_1 + 8 | 0;
      $5_1 = $9_1 + HEAP32[$0_1 >> 2] | 0;
      $0_1 = HEAP32[$0_1 + 4 >> 2];
      $9_1 = $5_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $7_1 = ($10_1 | 0) == ($21_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $10_1 >>> 0 < $21_1 >>> 0;
      $0_1 = $24_1 + 8 | 0;
      $11_1 = $7_1 + HEAP32[$0_1 >> 2] | 0;
      $0_1 = HEAP32[$0_1 + 4 >> 2];
      $10_1 = $7_1 >>> 0 > $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $7_1 = ($3_1 | 0) == ($18_1 | 0) & $15_1 >>> 0 < $20_1 >>> 0 | $3_1 >>> 0 > $18_1 >>> 0;
      $0_1 = ($3_1 | 0) == ($4_1 | 0) & $17_1 >>> 0 > $20_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $3_1 = ($4_1 | 0) == ($8_1 | 0) & $13_1 >>> 0 > $17_1 >>> 0 | $4_1 >>> 0 < $8_1 >>> 0;
      $4_1 = $0_1 + $3_1 | 0;
      $0_1 = $3_1 >>> 0 > $4_1 >>> 0;
      $8_1 = $4_1 + $7_1 | 0;
      $13_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $3_1 = ($18_1 | 0) == ($19_1 | 0) & $15_1 >>> 0 > $16_1 >>> 0 | $18_1 >>> 0 > $19_1 >>> 0;
      $0_1 = $25_1 + 8 | 0;
      $4_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
      $0_1 = HEAP32[$0_1 + 4 >> 2];
      $0_1 = ($3_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $13_1 | 0;
      $7_1 = $4_1;
      $4_1 = $4_1 + $8_1 | 0;
      $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $18_1 = $4_1;
      $7_1 = $4_1;
      $4_1 = ($19_1 | 0) == ($21_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $19_1 >>> 0 > $21_1 >>> 0;
      $0_1 = $23_1 + 8 | 0;
      $12_1 = $4_1 + HEAP32[$0_1 >> 2] | 0;
      $0_1 = HEAP32[$0_1 + 4 >> 2];
      $0_1 = ($4_1 >>> 0 > $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $3_1 | 0;
      $7_1 = $7_1 + $12_1 | 0;
      $4_1 = $7_1 >>> 0 < $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $4_1 + $10_1 | 0;
      $21_1 = $7_1;
      $16_1 = $7_1 + $11_1 | 0;
      $17_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $17_1 + $9_1 | 0;
      $7_1 = $5_1 + $16_1 | 0;
      $0_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $20_1 = $7_1;
      $7_1 = HEAP32[$6_1 + 48 >> 2];
      $15_1 = $20_1 + $7_1 | 0;
      $22_1 = $0_1;
      $0_1 = $0_1 + HEAP32[$6_1 + 52 >> 2] | 0;
      $19_1 = $7_1 >>> 0 > $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $19_1 + HEAP32[$6_1 + 68 >> 2] | 0;
      $10_1 = HEAP32[$6_1 + 64 >> 2];
      $7_1 = $10_1 + $15_1 | 0;
      $11_1 = HEAP32[$6_1 + 80 >> 2];
      $12_1 = $7_1 + $11_1 | 0;
      $10_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $10_1 + HEAP32[$6_1 + 84 >> 2] | 0;
      HEAP32[$14_1 + 32 >> 2] = $12_1;
      $0_1 = $12_1 >>> 0 < $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      HEAP32[$14_1 + 36 >> 2] = $0_1;
      $23_1 = $6_1 + 16 | 0;
      $69($23_1, HEAP32[$2_1 + 24 >> 2], HEAP32[$2_1 + 28 >> 2], 0, 0, HEAP32[$1_1 + 16 >> 2], HEAP32[$1_1 + 20 >> 2], 0, 0);
      $24_1 = $6_1 + 32 | 0;
      $69($24_1, HEAP32[$2_1 + 16 >> 2], HEAP32[$2_1 + 20 >> 2], 0, 0, HEAP32[$1_1 + 24 >> 2], HEAP32[$1_1 + 28 >> 2], 0, 0);
      $11_1 = ($0_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 > $12_1 >>> 0 | $0_1 >>> 0 < $10_1 >>> 0;
      $0_1 = $28_1 + 8 | 0;
      $12_1 = $11_1 + HEAP32[$0_1 >> 2] | 0;
      $0_1 = HEAP32[$0_1 + 4 >> 2];
      $11_1 = $12_1 >>> 0 < $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $7_1 = ($10_1 | 0) == ($19_1 | 0) & $7_1 >>> 0 < $15_1 >>> 0 | $10_1 >>> 0 < $19_1 >>> 0;
      $0_1 = $27_1 + 8 | 0;
      $10_1 = $7_1 + HEAP32[$0_1 >> 2] | 0;
      $0_1 = HEAP32[$0_1 + 4 >> 2];
      $7_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $9_1 = ($9_1 | 0) == ($22_1 | 0) & $5_1 >>> 0 > $20_1 >>> 0 | $9_1 >>> 0 > $22_1 >>> 0;
      $5_1 = ($4_1 | 0) == ($17_1 | 0) & $16_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 > $17_1 >>> 0;
      $0_1 = ($3_1 | 0) == ($4_1 | 0) & $18_1 >>> 0 > $21_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
      $3_1 = ($3_1 | 0) == ($13_1 | 0) & $8_1 >>> 0 > $18_1 >>> 0 | $3_1 >>> 0 < $13_1 >>> 0;
      $4_1 = $0_1 + $3_1 | 0;
      $0_1 = $3_1 >>> 0 > $4_1 >>> 0;
      $3_1 = $4_1 + $5_1 | 0;
      $0_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $8_1 = $3_1 + $9_1 | 0;
      $5_1 = $8_1 >>> 0 < $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $3_1 = ($19_1 | 0) == ($22_1 | 0) & $15_1 >>> 0 < $20_1 >>> 0 | $19_1 >>> 0 < $22_1 >>> 0;
      $0_1 = $26_1 + 8 | 0;
      $4_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
      $0_1 = HEAP32[$0_1 + 4 >> 2];
      $0_1 = ($3_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $5_1 | 0;
      $3_1 = $4_1 + $8_1 | 0;
      $4_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $4_1 + $7_1 | 0;
      $7_1 = $12_1;
      $16_1 = $3_1;
      $13_1 = $3_1 + $10_1 | 0;
      $12_1 = $13_1;
      $9_1 = $7_1 + $12_1 | 0;
      $3_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $3_1 + $11_1 | 0;
      $13_1 = HEAP32[$6_1 + 16 >> 2];
      $10_1 = $13_1 + $9_1 | 0;
      $15_1 = $9_1 >>> 0 < $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $15_1 + HEAP32[$6_1 + 20 >> 2] | 0;
      $11_1 = $10_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $11_1 + HEAP32[$6_1 + 36 >> 2] | 0;
      $7_1 = HEAP32[$6_1 + 32 >> 2];
      $13_1 = $7_1 + $10_1 | 0;
      HEAP32[$14_1 + 40 >> 2] = $13_1;
      $7_1 = $7_1 >>> 0 > $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      HEAP32[$14_1 + 44 >> 2] = $7_1;
      $69($6_1, HEAP32[$2_1 + 24 >> 2], HEAP32[$2_1 + 28 >> 2], 0, 0, HEAP32[$1_1 + 24 >> 2], HEAP32[$1_1 + 28 >> 2], 0, 0);
      $2_1 = $14_1;
      $1_1 = ($11_1 | 0) == ($15_1 | 0) & $9_1 >>> 0 > $10_1 >>> 0 | $11_1 >>> 0 < $15_1 >>> 0;
      $0_1 = $23_1 + 8 | 0;
      $14_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
      $0_1 = HEAP32[$0_1 + 4 >> 2];
      $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $9_1 = ($3_1 | 0) == ($15_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 > $15_1 >>> 0;
      $0_1 = ($3_1 | 0) == ($4_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $3_1 = ($4_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 > $16_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
      $4_1 = $0_1 + $3_1 | 0;
      $0_1 = $3_1 >>> 0 > $4_1 >>> 0;
      $8_1 = $4_1 + $9_1 | 0;
      $9_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $9_1 + $1_1 | 0;
      $1_1 = $8_1 + $14_1 | 0;
      $3_1 = $1_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $5_1 = $1_1;
      $4_1 = $1_1;
      $1_1 = ($7_1 | 0) == ($11_1 | 0) & $10_1 >>> 0 > $13_1 >>> 0 | $7_1 >>> 0 < $11_1 >>> 0;
      $0_1 = $24_1 + 8 | 0;
      $14_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
      $0_1 = HEAP32[$0_1 + 4 >> 2];
      $0_1 = ($1_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $3_1 | 0;
      $4_1 = $4_1 + $14_1 | 0;
      $1_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $1_1 + HEAP32[$6_1 + 4 >> 2] | 0;
      $14_1 = HEAP32[$6_1 >> 2];
      $13_1 = $14_1 + $4_1 | 0;
      HEAP32[$2_1 + 48 >> 2] = $13_1;
      $0_1 = $14_1 >>> 0 > $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      HEAP32[$2_1 + 52 >> 2] = $0_1;
      $14_1 = ($0_1 | 0) == ($1_1 | 0) & $4_1 >>> 0 > $13_1 >>> 0 | $0_1 >>> 0 < $1_1 >>> 0;
      $4_1 = ($1_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 < $5_1 >>> 0 | $1_1 >>> 0 < $3_1 >>> 0;
      $1_1 = ($3_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $3_1 >>> 0 < $9_1 >>> 0;
      $0_1 = $6_1 + 8 | 0;
      $3_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
      $0_1 = HEAP32[$0_1 + 4 >> 2];
      $0_1 = $1_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $1_1 = $3_1 + $4_1 | 0;
      $0_1 = $1_1 >>> 0 < $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $14_1 | 0;
      $0_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      HEAP32[$2_1 + 56 >> 2] = $1_1;
      HEAP32[$2_1 + 60 >> 2] = $0_1;
      global$0 = $6_1 + 256 | 0;
    }
    function $67($0_1, $1_1, $2_1, $3_1) {
      var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0;
      $7_1 = global$0 - 480 | 0;
      global$0 = $7_1;
      $4_1 = HEAP32[$2_1 + 4 >> 2];
      $30_1 = $4_1;
      $10_1 = $4_1 >> 31;
      $4_1 = HEAP32[$0_1 + 4 >> 2];
      $12_1 = $4_1;
      $4_1 = $4_1 >> 31;
      $35_1 = $7_1 + 352 | 0;
      $28_1 = HEAP32[$2_1 >> 2];
      $6_1 = HEAP32[$0_1 >> 2];
      $5_1 = $4_1;
      $69($35_1, $28_1, $30_1, $10_1, $10_1, $6_1, $12_1, $4_1, $4_1);
      $4_1 = HEAP32[$2_1 + 12 >> 2];
      $31_1 = $4_1;
      $13_1 = $4_1 >> 31;
      $4_1 = HEAP32[$1_1 + 4 >> 2];
      $11_1 = $4_1;
      $4_1 = $4_1 >> 31;
      $38_1 = $7_1 + 384 | 0;
      $16_1 = HEAP32[$2_1 + 8 >> 2];
      $15_1 = HEAP32[$1_1 >> 2];
      $9_1 = $4_1;
      $69($38_1, $16_1, $31_1, $13_1, $13_1, $15_1, $11_1, $4_1, $4_1);
      $4_1 = HEAP32[$2_1 + 20 >> 2];
      $17_1 = $4_1;
      $4_1 = $4_1 >> 31;
      $36_1 = $7_1 + 368 | 0;
      $32_1 = HEAP32[$2_1 + 16 >> 2];
      $23_1 = $4_1;
      $69($36_1, $32_1, $17_1, $4_1, $4_1, $6_1, $12_1, $5_1, $5_1);
      $37_1 = HEAP32[$2_1 + 24 >> 2];
      $2_1 = HEAP32[$2_1 + 28 >> 2];
      $18_1 = $2_1;
      $2_1 = $2_1 >> 31;
      $33_1 = $7_1 + 400 | 0;
      $27_1 = $2_1;
      $69($33_1, $37_1, $18_1, $2_1, $2_1, $15_1, $11_1, $9_1, $9_1);
      $43_1 = HEAP32[$1_1 + 32 >> 2];
      $2_1 = HEAP32[$1_1 + 36 >> 2];
      $50_1 = $2_1;
      $2_1 = $2_1 >> 31;
      $9_1 = $2_1;
      $5_1 = $2_1 & $16_1;
      $44_1 = HEAP32[$0_1 + 32 >> 2];
      $2_1 = HEAP32[$0_1 + 36 >> 2];
      $45_1 = $2_1;
      $2_1 = $2_1 >> 31;
      $4_1 = $5_1;
      $12_1 = $2_1;
      $5_1 = $2_1 & $28_1;
      $2_1 = $4_1 + $5_1 | 0;
      $4_1 = ($12_1 & $30_1) + ($9_1 & $31_1) | 0;
      $5_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = HEAP32[$3_1 + 40 >> 2];
      $8_1 = $4_1;
      $21_1 = HEAP32[$7_1 + 388 >> 2];
      $4_1 = $21_1 + HEAP32[$7_1 + 356 >> 2] | 0;
      $24_1 = HEAP32[$3_1 + 44 >> 2];
      $22_1 = HEAP32[$7_1 + 384 >> 2];
      $6_1 = HEAP32[$7_1 + 352 >> 2];
      $11_1 = $22_1 + $6_1 | 0;
      $6_1 = $6_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $25_1 = __wasm_i64_mul($8_1, $24_1, $11_1, $6_1);
      $15_1 = $25_1 + $2_1 | 0;
      $4_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
      $29_1 = $2_1 - $15_1 | 0;
      $2_1 = $5_1 - ((($15_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) & 1073741823) + ($2_1 >>> 0 < $15_1 >>> 0) | 0) | 0;
      $25_1 = $2_1;
      $14_1 = $2_1 >> 31;
      $2_1 = HEAP32[$3_1 + 4 >> 2];
      $19_1 = $2_1;
      $2_1 = $2_1 >> 31;
      $39_1 = $7_1 + 320 | 0;
      $20_1 = HEAP32[$3_1 >> 2];
      $15_1 = $2_1;
      $69($39_1, $29_1, $25_1, $14_1, $14_1, $20_1, $19_1, $2_1, $2_1);
      $5_1 = $12_1 & $32_1;
      $2_1 = $5_1 + ($9_1 & $37_1) | 0;
      $4_1 = ($9_1 & $18_1) + ($12_1 & $17_1) | 0;
      $5_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $26_1 = HEAP32[$7_1 + 404 >> 2];
      $4_1 = $26_1 + HEAP32[$7_1 + 372 >> 2] | 0;
      $40_1 = HEAP32[$7_1 + 400 >> 2];
      $9_1 = HEAP32[$7_1 + 368 >> 2];
      $12_1 = $40_1 + $9_1 | 0;
      $9_1 = $9_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $24_1 = __wasm_i64_mul($12_1, $9_1, $8_1, $24_1);
      $8_1 = $24_1 + $2_1 | 0;
      $4_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
      $34_1 = $2_1 - $8_1 | 0;
      $2_1 = $5_1 - ((($8_1 >>> 0 < $24_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) & 1073741823) + ($2_1 >>> 0 < $8_1 >>> 0) | 0) | 0;
      $24_1 = $2_1;
      $2_1 = $2_1 >> 31;
      $41_1 = $7_1 + 336 | 0;
      $42_1 = $2_1;
      $69($41_1, $34_1, $24_1, $2_1, $2_1, $20_1, $19_1, $15_1, $15_1);
      $2_1 = HEAP32[$0_1 + 12 >> 2];
      $8_1 = $2_1;
      $2_1 = $2_1 >> 31;
      $46_1 = $7_1 + 416 | 0;
      $15_1 = HEAP32[$0_1 + 8 >> 2];
      $5_1 = $2_1;
      $69($46_1, $28_1, $30_1, $10_1, $10_1, $15_1, $8_1, $2_1, $2_1);
      $2_1 = HEAP32[$1_1 + 12 >> 2];
      $19_1 = $2_1;
      $2_1 = $2_1 >> 31;
      $4_1 = $2_1;
      $47_1 = $7_1 + 448 | 0;
      $20_1 = HEAP32[$1_1 + 8 >> 2];
      $69($47_1, $16_1, $31_1, $13_1, $13_1, $20_1, $19_1, $4_1, $4_1);
      $48_1 = $7_1 + 432 | 0;
      $69($48_1, $32_1, $17_1, $23_1, $23_1, $15_1, $8_1, $5_1, $5_1);
      $49_1 = $7_1 + 464 | 0;
      $69($49_1, $37_1, $18_1, $27_1, $27_1, $20_1, $19_1, $4_1, $4_1);
      $2_1 = HEAP32[$7_1 + 336 >> 2];
      $8_1 = $2_1;
      $15_1 = HEAP32[$7_1 + 340 >> 2];
      $4_1 = $15_1 + $9_1 | 0;
      $2_1 = $2_1 + $12_1 | 0;
      $4_1 = $2_1 >>> 0 < $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $2_1;
      $2_1 = $4_1;
      $15_1 = ($15_1 | 0) == ($4_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $15_1 >>> 0;
      $4_1 = $41_1 + 8 | 0;
      $8_1 = HEAP32[$4_1 >> 2];
      $20_1 = HEAP32[$4_1 + 4 >> 2];
      $9_1 = ($9_1 | 0) == ($26_1 | 0) & $12_1 >>> 0 < $40_1 >>> 0 | $9_1 >>> 0 < $26_1 >>> 0;
      $4_1 = $36_1 + 8 | 0;
      $12_1 = HEAP32[$4_1 >> 2];
      $19_1 = $33_1 + 8 | 0;
      $5_1 = $12_1 + HEAP32[$19_1 >> 2] | 0;
      $4_1 = HEAP32[$19_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $5_1 >>> 0 < $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $12_1 = $5_1;
      $5_1 = $5_1 + $9_1 | 0;
      $4_1 = ($12_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $20_1 | 0;
      $9_1 = $5_1;
      $5_1 = $5_1 + $8_1 | 0;
      $4_1 = $9_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $9_1 = $5_1 + $15_1 | 0;
      $5_1 = $9_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $12_1 = $5_1 << 2 | $9_1 >>> 30;
      $15_1 = $9_1 << 2 | $2_1 >>> 30;
      $19_1 = HEAP32[$7_1 + 464 >> 2];
      $2_1 = HEAP32[$7_1 + 432 >> 2];
      $9_1 = $19_1 + $2_1 | 0;
      $8_1 = HEAP32[$7_1 + 468 >> 2];
      $4_1 = $8_1 + HEAP32[$7_1 + 436 >> 2] | 0;
      $2_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $2_1 + $12_1 | 0;
      $12_1 = $9_1 + $15_1 | 0;
      $15_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $20_1 = ($2_1 | 0) == ($15_1 | 0) & $9_1 >>> 0 > $12_1 >>> 0 | $2_1 >>> 0 > $15_1 >>> 0;
      $9_1 = ($2_1 | 0) == ($8_1 | 0) & $9_1 >>> 0 < $19_1 >>> 0 | $2_1 >>> 0 < $8_1 >>> 0;
      $4_1 = $48_1 + 8 | 0;
      $8_1 = HEAP32[$4_1 >> 2];
      $19_1 = $49_1 + 8 | 0;
      $2_1 = $8_1 + HEAP32[$19_1 >> 2] | 0;
      $4_1 = HEAP32[$19_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $2_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $8_1 = $2_1;
      $2_1 = $2_1 + $9_1 | 0;
      $4_1 = ($5_1 >> 31) + ($8_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
      $5_1 = $5_1 >> 30;
      $2_1 = $2_1 + $5_1 | 0;
      $4_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $9_1 = $2_1 + $20_1 | 0;
      $2_1 = $9_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = HEAP32[$7_1 + 320 >> 2];
      $19_1 = $5_1;
      $20_1 = HEAP32[$7_1 + 324 >> 2];
      $4_1 = $20_1 + $6_1 | 0;
      $5_1 = $5_1 + $11_1 | 0;
      $4_1 = $5_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $8_1 = $5_1;
      $5_1 = $4_1;
      $8_1 = ($20_1 | 0) == ($4_1 | 0) & $8_1 >>> 0 < $19_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0;
      $4_1 = $39_1 + 8 | 0;
      $20_1 = HEAP32[$4_1 >> 2];
      $19_1 = HEAP32[$4_1 + 4 >> 2];
      $11_1 = ($6_1 | 0) == ($21_1 | 0) & $11_1 >>> 0 < $22_1 >>> 0 | $6_1 >>> 0 < $21_1 >>> 0;
      $4_1 = $35_1 + 8 | 0;
      $21_1 = HEAP32[$4_1 >> 2];
      $26_1 = $38_1 + 8 | 0;
      $6_1 = $21_1 + HEAP32[$26_1 >> 2] | 0;
      $4_1 = HEAP32[$26_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $6_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $22_1 = $6_1;
      $6_1 = $6_1 + $11_1 | 0;
      $4_1 = ($22_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $19_1 | 0;
      $11_1 = $6_1;
      $6_1 = $6_1 + $20_1 | 0;
      $4_1 = $11_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $11_1 = $6_1 + $8_1 | 0;
      $6_1 = $11_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $8_1 = $6_1 << 2 | $11_1 >>> 30;
      $11_1 = $11_1 << 2 | $5_1 >>> 30;
      $19_1 = HEAP32[$7_1 + 448 >> 2];
      $21_1 = HEAP32[$7_1 + 416 >> 2];
      $5_1 = $19_1 + $21_1 | 0;
      $20_1 = HEAP32[$7_1 + 452 >> 2];
      $4_1 = $20_1 + HEAP32[$7_1 + 420 >> 2] | 0;
      $4_1 = $5_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $21_1 = $5_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $8_1 | 0;
      $8_1 = $11_1 + $21_1 | 0;
      $11_1 = $8_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $26_1 = ($5_1 | 0) == ($11_1 | 0) & $8_1 >>> 0 < $21_1 >>> 0 | $5_1 >>> 0 > $11_1 >>> 0;
      $21_1 = ($5_1 | 0) == ($20_1 | 0) & $19_1 >>> 0 > $21_1 >>> 0 | $5_1 >>> 0 < $20_1 >>> 0;
      $4_1 = $46_1 + 8 | 0;
      $20_1 = HEAP32[$4_1 >> 2];
      $19_1 = $47_1 + 8 | 0;
      $5_1 = $20_1 + HEAP32[$19_1 >> 2] | 0;
      $4_1 = HEAP32[$19_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $5_1 >>> 0 < $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $19_1 = $5_1;
      $5_1 = $5_1 + $21_1 | 0;
      $4_1 = ($6_1 >> 31) + ($19_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
      $6_1 = $6_1 >> 30;
      $5_1 = $5_1 + $6_1 | 0;
      $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $5_1 + $26_1 | 0;
      $5_1 = $6_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $21_1 = HEAP32[$1_1 + 24 >> 2];
      $20_1 = HEAP32[$1_1 + 28 >> 2];
      $19_1 = HEAP32[$1_1 + 16 >> 2];
      $26_1 = HEAP32[$1_1 + 20 >> 2];
      $35_1 = HEAP32[$0_1 + 24 >> 2];
      $38_1 = HEAP32[$0_1 + 28 >> 2];
      $36_1 = HEAP32[$0_1 + 16 >> 2];
      $33_1 = HEAP32[$0_1 + 20 >> 2];
      $4_1 = HEAP32[$3_1 + 8 >> 2];
      $22_1 = HEAP32[$3_1 + 12 >> 2];
      if ($4_1 | $22_1) {
        $41_1 = $7_1 + 304 | 0;
        $40_1 = $4_1;
        $4_1 = $22_1 >> 31;
        $69($41_1, $29_1, $25_1, $14_1, $14_1, $40_1, $22_1, $4_1, $4_1);
        $39_1 = $7_1 + 288 | 0;
        $69($39_1, $34_1, $24_1, $42_1, $42_1, $40_1, $22_1, $4_1, $4_1);
        $14_1 = $15_1;
        $22_1 = $12_1;
        $15_1 = HEAP32[$7_1 + 288 >> 2];
        $12_1 = $12_1 + $15_1 | 0;
        $4_1 = $14_1 + HEAP32[$7_1 + 292 >> 2] | 0;
        $15_1 = $12_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $14_1 = ($14_1 | 0) == ($15_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $14_1 >>> 0 > $15_1 >>> 0;
        $4_1 = $39_1 + 8 | 0;
        $22_1 = HEAP32[$4_1 >> 2];
        $9_1 = $22_1 + $9_1 | 0;
        $4_1 = $2_1 + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $9_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $2_1 = $9_1;
        $9_1 = $9_1 + $14_1 | 0;
        $2_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $14_1 = $11_1;
        $22_1 = $8_1;
        $11_1 = HEAP32[$7_1 + 304 >> 2];
        $8_1 = $8_1 + $11_1 | 0;
        $4_1 = $14_1 + HEAP32[$7_1 + 308 >> 2] | 0;
        $11_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $14_1 = ($14_1 | 0) == ($11_1 | 0) & $8_1 >>> 0 < $22_1 >>> 0 | $11_1 >>> 0 < $14_1 >>> 0;
        $4_1 = $41_1 + 8 | 0;
        $22_1 = HEAP32[$4_1 >> 2];
        $6_1 = $22_1 + $6_1 | 0;
        $4_1 = $5_1 + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $6_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $6_1;
        $6_1 = $6_1 + $14_1 | 0;
        $5_1 = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      }
      HEAP32[$0_1 >> 2] = $8_1;
      HEAP32[$0_1 + 4 >> 2] = $11_1 & 1073741823;
      HEAP32[$1_1 >> 2] = $12_1;
      HEAP32[$1_1 + 4 >> 2] = $15_1 & 1073741823;
      $4_1 = $33_1 >> 31;
      $8_1 = $4_1;
      $22_1 = $7_1 + 272 | 0;
      $14_1 = $28_1;
      $69($22_1, $14_1, $30_1, $10_1, $10_1, $36_1, $33_1, $4_1, $4_1);
      $42_1 = $7_1 + 240 | 0;
      $28_1 = $16_1;
      $10_1 = $13_1;
      $16_1 = $26_1;
      $4_1 = $16_1 >> 31;
      $69($42_1, $28_1, $31_1, $10_1, $10_1, $19_1, $16_1, $4_1, $4_1);
      $13_1 = $7_1 + 256 | 0;
      $69($13_1, $32_1, $17_1, $23_1, $23_1, $36_1, $33_1, $8_1, $8_1);
      $16_1 = $7_1 + 224 | 0;
      $69($16_1, $37_1, $18_1, $27_1, $27_1, $19_1, $26_1, $4_1, $4_1);
      $23_1 = HEAP32[$7_1 + 224 >> 2];
      $8_1 = HEAP32[$7_1 + 256 >> 2];
      $12_1 = $23_1 + $8_1 | 0;
      $10_1 = HEAP32[$7_1 + 228 >> 2];
      $4_1 = $10_1 + HEAP32[$7_1 + 260 >> 2] | 0;
      $8_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $23_1 = ($10_1 | 0) == ($8_1 | 0) & $12_1 >>> 0 < $23_1 >>> 0 | $8_1 >>> 0 < $10_1 >>> 0;
      $4_1 = $13_1 + 8 | 0;
      $13_1 = HEAP32[$4_1 >> 2];
      $16_1 = $16_1 + 8 | 0;
      $10_1 = $13_1 + HEAP32[$16_1 >> 2] | 0;
      $4_1 = HEAP32[$16_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $10_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $13_1 = $10_1;
      $10_1 = $10_1 + $23_1 | 0;
      $4_1 = ($2_1 >> 31) + ($13_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
      $16_1 = $2_1 >> 30;
      $10_1 = $10_1 + $16_1 | 0;
      $4_1 = $16_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $13_1 = $10_1;
      $10_1 = $4_1;
      $4_1 = $2_1 << 2 | $9_1 >>> 30;
      $2_1 = $9_1 << 2 | $15_1 >>> 30;
      $9_1 = $2_1 + $12_1 | 0;
      $4_1 = $4_1 + $8_1 | 0;
      $2_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $15_1 = ($8_1 | 0) == ($2_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $2_1 >>> 0 < $8_1 >>> 0;
      $12_1 = $15_1 + $13_1 | 0;
      $4_1 = $10_1;
      $15_1 = $12_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $16_1 = HEAP32[$7_1 + 240 >> 2];
      $10_1 = HEAP32[$7_1 + 272 >> 2];
      $8_1 = $16_1 + $10_1 | 0;
      $13_1 = HEAP32[$7_1 + 244 >> 2];
      $4_1 = $13_1 + HEAP32[$7_1 + 276 >> 2] | 0;
      $10_1 = $8_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $16_1 = ($13_1 | 0) == ($10_1 | 0) & $8_1 >>> 0 < $16_1 >>> 0 | $10_1 >>> 0 < $13_1 >>> 0;
      $4_1 = $22_1 + 8 | 0;
      $23_1 = HEAP32[$4_1 >> 2];
      $27_1 = $42_1 + 8 | 0;
      $13_1 = $23_1 + HEAP32[$27_1 >> 2] | 0;
      $4_1 = HEAP32[$27_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $13_1 >>> 0 < $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $19_1 = $13_1;
      $13_1 = $13_1 + $16_1 | 0;
      $4_1 = ($5_1 >> 31) + ($19_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
      $23_1 = $5_1 >> 30;
      $13_1 = $13_1 + $23_1 | 0;
      $4_1 = $23_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $16_1 = $13_1;
      $13_1 = $4_1;
      $4_1 = $5_1 << 2 | $6_1 >>> 30;
      $5_1 = $6_1 << 2 | $11_1 >>> 30;
      $6_1 = $5_1 + $8_1 | 0;
      $4_1 = $4_1 + $10_1 | 0;
      $5_1 = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $8_1 = ($10_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $10_1 >>> 0;
      $11_1 = $8_1 + $16_1 | 0;
      $4_1 = $13_1;
      $8_1 = $8_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $13_1 = HEAP32[$3_1 + 16 >> 2];
      $16_1 = HEAP32[$3_1 + 20 >> 2];
      if ($13_1 | $16_1) {
        $4_1 = $16_1 >> 31;
        $23_1 = $7_1 + 208 | 0;
        $10_1 = $4_1;
        $4_1 = $25_1 >> 31;
        $69($23_1, $13_1, $16_1, $10_1, $10_1, $29_1, $25_1, $4_1, $4_1);
        $27_1 = $7_1 + 192 | 0;
        $4_1 = $24_1 >> 31;
        $69($27_1, $13_1, $16_1, $10_1, $10_1, $34_1, $24_1, $4_1, $4_1);
        $10_1 = HEAP32[$7_1 + 196 >> 2];
        $4_1 = $10_1 + $2_1 | 0;
        $2_1 = $9_1;
        $13_1 = HEAP32[$7_1 + 192 >> 2];
        $9_1 = $13_1 + $9_1 | 0;
        $2_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $13_1 = ($10_1 | 0) == ($2_1 | 0) & $9_1 >>> 0 < $13_1 >>> 0 | $2_1 >>> 0 < $10_1 >>> 0;
        $4_1 = $27_1 + 8 | 0;
        $10_1 = HEAP32[$4_1 >> 2] + $12_1 | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2] + $15_1 | 0;
        $4_1 = $12_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $12_1 = $10_1 + $13_1 | 0;
        $15_1 = $12_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $10_1 = HEAP32[$7_1 + 212 >> 2];
        $4_1 = $10_1 + $5_1 | 0;
        $5_1 = $6_1;
        $13_1 = HEAP32[$7_1 + 208 >> 2];
        $6_1 = $13_1 + $6_1 | 0;
        $5_1 = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $13_1 = ($10_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $13_1 >>> 0 | $5_1 >>> 0 < $10_1 >>> 0;
        $4_1 = $23_1 + 8 | 0;
        $10_1 = HEAP32[$4_1 >> 2] + $11_1 | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2] + $8_1 | 0;
        $4_1 = $11_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $11_1 = $10_1 + $13_1 | 0;
        $8_1 = $11_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      }
      HEAP32[$0_1 + 8 >> 2] = $6_1;
      HEAP32[$0_1 + 12 >> 2] = $5_1 & 1073741823;
      HEAP32[$1_1 + 8 >> 2] = $9_1;
      HEAP32[$1_1 + 12 >> 2] = $2_1 & 1073741823;
      $4_1 = $30_1 >> 31;
      $10_1 = $4_1;
      $4_1 = $38_1 >> 31;
      $36_1 = $7_1 + 176 | 0;
      $16_1 = $14_1;
      $9_1 = $4_1;
      $69($36_1, $14_1, $30_1, $10_1, $10_1, $35_1, $38_1, $4_1, $4_1);
      $4_1 = $31_1 >> 31;
      $13_1 = $4_1;
      $4_1 = $20_1 >> 31;
      $33_1 = $7_1 + 144 | 0;
      $6_1 = $4_1;
      $69($33_1, $28_1, $31_1, $13_1, $13_1, $21_1, $20_1, $4_1, $4_1);
      $4_1 = $17_1;
      $23_1 = $4_1;
      $4_1 = $4_1 >> 31;
      $22_1 = $7_1 + 160 | 0;
      $27_1 = $4_1;
      $69($22_1, $32_1, $17_1, $4_1, $4_1, $35_1, $38_1, $9_1, $9_1);
      $4_1 = $18_1;
      $19_1 = $4_1;
      $4_1 = $4_1 >> 31;
      $35_1 = $7_1 + 128 | 0;
      $26_1 = $4_1;
      $69($35_1, $37_1, $18_1, $4_1, $4_1, $21_1, $20_1, $6_1, $6_1);
      $18_1 = HEAP32[$7_1 + 128 >> 2];
      $9_1 = HEAP32[$7_1 + 160 >> 2];
      $6_1 = $18_1 + $9_1 | 0;
      $17_1 = HEAP32[$7_1 + 132 >> 2];
      $4_1 = $17_1 + HEAP32[$7_1 + 164 >> 2] | 0;
      $9_1 = $6_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $14_1 = $15_1 << 2 | $12_1 >>> 30;
      $2_1 = $12_1 << 2 | $2_1 >>> 30;
      $12_1 = $2_1 + $6_1 | 0;
      $4_1 = $9_1 + $14_1 | 0;
      $2_1 = $2_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $9_1;
      $9_1 = $12_1;
      $14_1 = ($2_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 > $9_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
      $12_1 = ($4_1 | 0) == ($17_1 | 0) & $6_1 >>> 0 < $18_1 >>> 0 | $4_1 >>> 0 < $17_1 >>> 0;
      $4_1 = $22_1 + 8 | 0;
      $17_1 = HEAP32[$4_1 >> 2];
      $18_1 = $35_1 + 8 | 0;
      $6_1 = $17_1 + HEAP32[$18_1 >> 2] | 0;
      $4_1 = HEAP32[$18_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $6_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $18_1 = $6_1;
      $6_1 = $6_1 + $12_1 | 0;
      $4_1 = ($15_1 >> 31) + ($18_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
      $15_1 = $15_1 >> 30;
      $6_1 = $6_1 + $15_1 | 0;
      $4_1 = $15_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $12_1 = $6_1 + $14_1 | 0;
      $15_1 = $12_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $21_1 = HEAP32[$7_1 + 144 >> 2];
      $6_1 = HEAP32[$7_1 + 176 >> 2];
      $14_1 = $21_1 + $6_1 | 0;
      $18_1 = HEAP32[$7_1 + 148 >> 2];
      $4_1 = $18_1 + HEAP32[$7_1 + 180 >> 2] | 0;
      $6_1 = $6_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $17_1 = $8_1 << 2 | $11_1 >>> 30;
      $5_1 = $11_1 << 2 | $5_1 >>> 30;
      $11_1 = $5_1 + $14_1 | 0;
      $4_1 = $6_1 + $17_1 | 0;
      $5_1 = $5_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $6_1;
      $6_1 = $11_1;
      $17_1 = ($5_1 | 0) == ($4_1 | 0) & $14_1 >>> 0 > $6_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
      $14_1 = ($4_1 | 0) == ($18_1 | 0) & $14_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
      $4_1 = $36_1 + 8 | 0;
      $18_1 = HEAP32[$4_1 >> 2];
      $21_1 = $33_1 + 8 | 0;
      $11_1 = $18_1 + HEAP32[$21_1 >> 2] | 0;
      $4_1 = HEAP32[$21_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $11_1 >>> 0 < $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $18_1 = $11_1;
      $11_1 = $11_1 + $14_1 | 0;
      $4_1 = ($8_1 >> 31) + ($18_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
      $8_1 = $8_1 >> 30;
      $11_1 = $8_1 + $11_1 | 0;
      $4_1 = $8_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $8_1 = $11_1;
      $11_1 = $11_1 + $17_1 | 0;
      $8_1 = $8_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $17_1 = HEAP32[$3_1 + 24 >> 2];
      $18_1 = HEAP32[$3_1 + 28 >> 2];
      if ($17_1 | $18_1) {
        $4_1 = $18_1 >> 31;
        $21_1 = $7_1 + 112 | 0;
        $14_1 = $4_1;
        $4_1 = $25_1 >> 31;
        $69($21_1, $17_1, $18_1, $14_1, $14_1, $29_1, $25_1, $4_1, $4_1);
        $20_1 = $7_1 + 96 | 0;
        $4_1 = $24_1 >> 31;
        $69($20_1, $17_1, $18_1, $14_1, $14_1, $34_1, $24_1, $4_1, $4_1);
        $14_1 = HEAP32[$7_1 + 100 >> 2];
        $4_1 = $14_1 + $2_1 | 0;
        $2_1 = $9_1;
        $17_1 = HEAP32[$7_1 + 96 >> 2];
        $9_1 = $17_1 + $9_1 | 0;
        $2_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $17_1 = ($14_1 | 0) == ($2_1 | 0) & $9_1 >>> 0 < $17_1 >>> 0 | $2_1 >>> 0 < $14_1 >>> 0;
        $4_1 = $20_1 + 8 | 0;
        $14_1 = HEAP32[$4_1 >> 2] + $12_1 | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2] + $15_1 | 0;
        $4_1 = $12_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $12_1 = $14_1 + $17_1 | 0;
        $15_1 = $12_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $14_1 = HEAP32[$7_1 + 116 >> 2];
        $4_1 = $14_1 + $5_1 | 0;
        $5_1 = $6_1;
        $17_1 = HEAP32[$7_1 + 112 >> 2];
        $6_1 = $17_1 + $6_1 | 0;
        $5_1 = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $17_1 = ($14_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $17_1 >>> 0 | $5_1 >>> 0 < $14_1 >>> 0;
        $4_1 = $21_1 + 8 | 0;
        $14_1 = HEAP32[$4_1 >> 2] + $11_1 | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2] + $8_1 | 0;
        $4_1 = $11_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $11_1 = $14_1 + $17_1 | 0;
        $8_1 = $11_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      }
      HEAP32[$0_1 + 16 >> 2] = $6_1;
      HEAP32[$0_1 + 20 >> 2] = $5_1 & 1073741823;
      HEAP32[$1_1 + 16 >> 2] = $9_1;
      HEAP32[$1_1 + 20 >> 2] = $2_1 & 1073741823;
      $4_1 = $45_1 >> 31;
      $6_1 = $4_1;
      $17_1 = $7_1 + 80 | 0;
      $18_1 = $45_1;
      $69($17_1, $16_1, $30_1, $10_1, $10_1, $44_1, $18_1, $4_1, $4_1);
      $30_1 = $7_1 + 48 | 0;
      $10_1 = $13_1;
      $16_1 = $50_1;
      $4_1 = $16_1 >> 31;
      $69($30_1, $28_1, $31_1, $10_1, $10_1, $43_1, $16_1, $4_1, $4_1);
      $28_1 = $7_1 - -64 | 0;
      $69($28_1, $32_1, $23_1, $27_1, $27_1, $44_1, $18_1, $6_1, $6_1);
      $31_1 = $7_1 + 32 | 0;
      $69($31_1, $37_1, $19_1, $26_1, $26_1, $43_1, $16_1, $4_1, $4_1);
      $9_1 = HEAP32[$3_1 + 32 >> 2];
      $3_1 = HEAP32[$3_1 + 36 >> 2];
      $6_1 = $3_1;
      $3_1 = $6_1 >> 31;
      $4_1 = $25_1 >> 31;
      $69($7_1, $9_1, $6_1, $3_1, $3_1, $29_1, $25_1, $4_1, $4_1);
      $16_1 = $7_1 + 16 | 0;
      $4_1 = $24_1 >> 31;
      $69($16_1, $9_1, $6_1, $3_1, $3_1, $34_1, $24_1, $4_1, $4_1);
      $9_1 = $0_1;
      $18_1 = HEAP32[$7_1 + 48 >> 2];
      $0_1 = HEAP32[$7_1 + 80 >> 2];
      $3_1 = $18_1 + $0_1 | 0;
      $13_1 = HEAP32[$7_1 + 52 >> 2];
      $4_1 = $13_1 + HEAP32[$7_1 + 84 >> 2] | 0;
      $0_1 = $0_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $25_1 = $3_1;
      $5_1 = $11_1 << 2 | $5_1 >>> 30;
      $3_1 = $3_1 + $5_1 | 0;
      $4_1 = $0_1 + ($8_1 << 2 | $11_1 >>> 30) | 0;
      $6_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $6_1 + HEAP32[$7_1 + 4 >> 2] | 0;
      $29_1 = $3_1;
      $3_1 = HEAP32[$7_1 >> 2];
      $5_1 = $29_1 + $3_1 | 0;
      $10_1 = $5_1;
      HEAP32[$9_1 + 24 >> 2] = $5_1;
      $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$9_1 + 28 >> 2] = $3_1 & 1073741823;
      $5_1 = $1_1;
      $1_1 = $12_1 << 2 | $2_1 >>> 30;
      $12_1 = $15_1 << 2 | $12_1 >>> 30;
      $32_1 = HEAP32[$7_1 + 32 >> 2];
      $2_1 = HEAP32[$7_1 + 64 >> 2];
      $11_1 = $32_1 + $2_1 | 0;
      $14_1 = HEAP32[$7_1 + 36 >> 2];
      $4_1 = $14_1 + HEAP32[$7_1 + 68 >> 2] | 0;
      $2_1 = $2_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $2_1 + $12_1 | 0;
      $1_1 = $1_1 + $11_1 | 0;
      $12_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $12_1 + HEAP32[$7_1 + 20 >> 2] | 0;
      $24_1 = $1_1;
      $1_1 = HEAP32[$7_1 + 16 >> 2];
      $34_1 = $24_1 + $1_1 | 0;
      HEAP32[$5_1 + 24 >> 2] = $34_1;
      $1_1 = $1_1 >>> 0 > $34_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$5_1 + 28 >> 2] = $1_1 & 1073741823;
      $10_1 = ($3_1 | 0) == ($6_1 | 0) & $10_1 >>> 0 < $29_1 >>> 0 | $3_1 >>> 0 < $6_1 >>> 0;
      $4_1 = $7_1 + 8 | 0;
      $37_1 = HEAP32[$4_1 >> 2];
      $23_1 = HEAP32[$4_1 + 4 >> 2];
      $29_1 = ($0_1 | 0) == ($6_1 | 0) & $25_1 >>> 0 > $29_1 >>> 0 | $0_1 >>> 0 > $6_1 >>> 0;
      $6_1 = ($0_1 | 0) == ($13_1 | 0) & $18_1 >>> 0 > $25_1 >>> 0 | $0_1 >>> 0 < $13_1 >>> 0;
      $4_1 = $17_1 + 8 | 0;
      $25_1 = HEAP32[$4_1 >> 2];
      $13_1 = $30_1 + 8 | 0;
      $0_1 = $25_1 + HEAP32[$13_1 >> 2] | 0;
      $4_1 = HEAP32[$13_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $0_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $13_1 = $0_1;
      $0_1 = $0_1 + $6_1 | 0;
      $4_1 = ($8_1 >> 31) + ($13_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
      $8_1 = $8_1 >> 30;
      $0_1 = $0_1 + $8_1 | 0;
      $4_1 = $8_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $0_1;
      $0_1 = $0_1 + $29_1 | 0;
      $4_1 = ($6_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $23_1 | 0;
      $6_1 = $0_1;
      $0_1 = $0_1 + $37_1 | 0;
      $4_1 = $6_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $0_1;
      $0_1 = $0_1 + $10_1 | 0;
      $6_1 = ($6_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 2 | $0_1 >>> 30;
      HEAP32[$9_1 + 32 >> 2] = $0_1 << 2 | $3_1 >>> 30;
      HEAP32[$9_1 + 36 >> 2] = $6_1;
      $9_1 = ($1_1 | 0) == ($12_1 | 0) & $24_1 >>> 0 > $34_1 >>> 0 | $1_1 >>> 0 < $12_1 >>> 0;
      $0_1 = $16_1 + 8 | 0;
      $6_1 = HEAP32[$0_1 >> 2];
      $8_1 = HEAP32[$0_1 + 4 >> 2];
      $12_1 = ($2_1 | 0) == ($12_1 | 0) & $11_1 >>> 0 > $24_1 >>> 0 | $2_1 >>> 0 > $12_1 >>> 0;
      $2_1 = ($2_1 | 0) == ($14_1 | 0) & $11_1 >>> 0 < $32_1 >>> 0 | $2_1 >>> 0 < $14_1 >>> 0;
      $3_1 = $28_1 + 8 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $4_1 = $31_1 + 8 | 0;
      $0_1 = $11_1 + HEAP32[$4_1 >> 2] | 0;
      $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $4_1 = $0_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $3_1 = $0_1;
      $0_1 = $0_1 + $2_1 | 0;
      $4_1 = ($15_1 >> 31) + ($3_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
      $3_1 = $15_1 >> 30;
      $0_1 = $0_1 + $3_1 | 0;
      $4_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $2_1 = $0_1;
      $0_1 = $0_1 + $12_1 | 0;
      $4_1 = ($2_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $8_1 | 0;
      $2_1 = $0_1;
      $0_1 = $0_1 + $6_1 | 0;
      $4_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $2_1 = $0_1;
      $0_1 = $0_1 + $9_1 | 0;
      $2_1 = ($2_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 2 | $0_1 >>> 30;
      HEAP32[$5_1 + 32 >> 2] = $0_1 << 2 | $1_1 >>> 30;
      HEAP32[$5_1 + 36 >> 2] = $2_1;
      global$0 = $7_1 + 480 | 0;
    }
    function $68($0_1, $1_1) {
      var $2_1 = 0, $3_1 = 0, $4_1 = 0;
      $2_1 = $1_1;
      label$1: {
        if ($1_1 >>> 0 <= 15) {
          $1_1 = $0_1;
          break label$1;
        }
        $3_1 = 0 - $0_1 & 3;
        $4_1 = $3_1 + $0_1 | 0;
        if ($3_1) {
          $1_1 = $0_1;
          while (1) {
            HEAP8[$1_1 | 0] = 0;
            $1_1 = $1_1 + 1 | 0;
            if ($4_1 >>> 0 > $1_1 >>> 0) {
              continue;
            }
            break;
          }
          ;
        }
        $2_1 = $2_1 - $3_1 | 0;
        $3_1 = $2_1 & -4;
        $1_1 = $3_1 + $4_1 | 0;
        if (($3_1 | 0) > 0) {
          while (1) {
            HEAP32[$4_1 >> 2] = 0;
            $4_1 = $4_1 + 4 | 0;
            if ($4_1 >>> 0 < $1_1 >>> 0) {
              continue;
            }
            break;
          }
        }
        $2_1 = $2_1 & 3;
      }
      if ($2_1) {
        $2_1 = $1_1 + $2_1 | 0;
        while (1) {
          HEAP8[$1_1 | 0] = 0;
          $1_1 = $1_1 + 1 | 0;
          if ($2_1 >>> 0 > $1_1 >>> 0) {
            continue;
          }
          break;
        }
        ;
      }
      return $0_1;
    }
    function $69($0_1, $1_1, $2_1, $3_1, $4_1, $5_1, $6_1, $7_1, $8_1) {
      var $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0;
      $9_1 = __wasm_i64_mul($5_1, 0, $1_1, 0);
      $12_1 = $0_1;
      $10_1 = i64toi32_i32$HIGH_BITS;
      $15_1 = $1_1;
      $1_1 = __wasm_i64_mul($1_1, 0, $6_1, 0);
      $11_1 = i64toi32_i32$HIGH_BITS;
      $13_1 = __wasm_i64_mul($5_1, 0, $2_1, 0);
      $14_1 = i64toi32_i32$HIGH_BITS;
      $0_1 = $11_1 + $14_1 | 0;
      $11_1 = $1_1 + $13_1 | 0;
      $1_1 = $11_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $10_1 + $11_1 | 0;
      $0_1 = 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      HEAP32[$12_1 >> 2] = $9_1;
      HEAP32[$12_1 + 4 >> 2] = $0_1;
      $10_1 = ($0_1 | 0) == ($10_1 | 0) & $9_1 >>> 0 < $9_1 >>> 0 | $0_1 >>> 0 < $10_1 >>> 0;
      $0_1 = ($1_1 | 0) == ($14_1 | 0) & $11_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
      $9_1 = $1_1;
      $1_1 = $1_1 + __wasm_i64_mul($2_1, 0, $6_1, 0) | 0;
      $0_1 = i64toi32_i32$HIGH_BITS + $0_1 | 0;
      $0_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $9_1 = $1_1;
      $1_1 = $1_1 + $10_1 | 0;
      $9_1 = $9_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = __wasm_i64_mul($15_1, $2_1, $7_1, $8_1);
      $7_1 = i64toi32_i32$HIGH_BITS;
      $3_1 = __wasm_i64_mul($3_1, $4_1, $5_1, $6_1);
      $2_1 = $3_1 + $0_1 | 0;
      $0_1 = $7_1 + i64toi32_i32$HIGH_BITS | 0;
      $0_1 = ($2_1 >>> 0 < $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $9_1 | 0;
      $1_1 = $1_1 + $2_1 | 0;
      $0_1 = $1_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      HEAP32[$12_1 + 8 >> 2] = $1_1;
      HEAP32[$12_1 + 12 >> 2] = $0_1;
    }
    function $70($0_1, $1_1, $2_1) {
      var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0;
      $6_1 = $2_1;
      label$1: {
        if ($2_1 >>> 0 <= 15) {
          $2_1 = $0_1;
          break label$1;
        }
        $5_1 = 0 - $0_1 & 3;
        $4_1 = $5_1 + $0_1 | 0;
        if ($5_1) {
          $2_1 = $0_1;
          $3_1 = $1_1;
          while (1) {
            HEAP8[$2_1 | 0] = HEAPU8[$3_1 | 0];
            $3_1 = $3_1 + 1 | 0;
            $2_1 = $2_1 + 1 | 0;
            if ($4_1 >>> 0 > $2_1 >>> 0) {
              continue;
            }
            break;
          }
          ;
        }
        $6_1 = $6_1 - $5_1 | 0;
        $7_1 = $6_1 & -4;
        $2_1 = $7_1 + $4_1 | 0;
        $5_1 = $1_1 + $5_1 | 0;
        $3_1 = $5_1 & 3;
        label$5: {
          if ($3_1) {
            if (($7_1 | 0) <= 0) {
              break label$5;
            }
            $8_1 = $5_1 & -4;
            $1_1 = $8_1 + 4 | 0;
            $9_1 = $3_1 << 3;
            $10_1 = 0 - $9_1 & 24;
            $3_1 = HEAP32[$8_1 >> 2];
            while (1) {
              $8_1 = $3_1 >>> $9_1 | 0;
              $3_1 = HEAP32[$1_1 >> 2];
              HEAP32[$4_1 >> 2] = $8_1 | $3_1 << $10_1;
              $1_1 = $1_1 + 4 | 0;
              $4_1 = $4_1 + 4 | 0;
              if ($4_1 >>> 0 < $2_1 >>> 0) {
                continue;
              }
              break;
            }
            ;
            break label$5;
          }
          if (($7_1 | 0) <= 0) {
            break label$5;
          }
          $1_1 = $5_1;
          while (1) {
            HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
            $1_1 = $1_1 + 4 | 0;
            $4_1 = $4_1 + 4 | 0;
            if ($4_1 >>> 0 < $2_1 >>> 0) {
              continue;
            }
            break;
          }
          ;
        }
        $6_1 = $6_1 & 3;
        $1_1 = $5_1 + $7_1 | 0;
      }
      if ($6_1) {
        $3_1 = $2_1 + $6_1 | 0;
        while (1) {
          HEAP8[$2_1 | 0] = HEAPU8[$1_1 | 0];
          $1_1 = $1_1 + 1 | 0;
          $2_1 = $2_1 + 1 | 0;
          if ($3_1 >>> 0 > $2_1 >>> 0) {
            continue;
          }
          break;
        }
        ;
      }
      return $0_1;
    }
    function __wasm_ctz_i64($0_1, $1_1) {
      var $2_1 = 0, $3_1 = 0;
      if ($0_1 | $1_1) {
        $2_1 = $1_1 - 1 | 0;
        $3_1 = $0_1 - 1 | 0;
        $2_1 = ($3_1 | 0) != -1 ? $2_1 + 1 | 0 : $2_1;
        $3_1 = $0_1 ^ $3_1;
        $0_1 = Math_clz32($1_1 ^ $2_1);
        if (($0_1 | 0) == 32) {
          $0_1 = Math_clz32($3_1) + 32 | 0;
        }
        i64toi32_i32$HIGH_BITS = 0 - ($0_1 >>> 0 > 63) | 0;
        return 63 - $0_1 | 0;
      }
      i64toi32_i32$HIGH_BITS = 0;
      return 64;
    }
    function __wasm_i64_mul($0_1, $1_1, $2_1, $3_1) {
      var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0;
      $4_1 = $2_1 & 65535;
      $5_1 = $0_1 & 65535;
      $6_1 = Math_imul($4_1, $5_1);
      $7_1 = $2_1 >>> 16 | 0;
      $9_1 = Math_imul($5_1, $7_1);
      $8_1 = $0_1 >>> 16 | 0;
      $5_1 = Math_imul($4_1, $8_1) + ($6_1 >>> 16 | 0) | 0;
      $4_1 = $9_1 + ($5_1 & 65535) | 0;
      i64toi32_i32$HIGH_BITS = (Math_imul($1_1, $2_1) + Math_imul($7_1, $8_1) | 0) + Math_imul($0_1, $3_1) + ($5_1 >>> 16) + ($4_1 >>> 16) | 0;
      return $6_1 & 65535 | $4_1 << 16;
    }
    function __wasm_rotl_i32($0_1, $1_1) {
      var $2_1 = 0, $3_1 = 0;
      $2_1 = $1_1 & 31;
      $3_1 = (-1 >>> $2_1 & $0_1) << $2_1;
      $2_1 = $0_1;
      $0_1 = 0 - $1_1 & 31;
      return $3_1 | ($2_1 & -1 << $0_1) >>> $0_1;
    }
    bufferView = HEAPU8;
    initActiveSegments(imports);
    var FUNCTION_TABLE = [null, $4, $0, $3, $44, $61, $28];
    function __wasm_memory_size() {
      return buffer.byteLength / 65536 | 0;
    }
    function __wasm_memory_grow(pagesToAdd) {
      pagesToAdd = pagesToAdd | 0;
      var oldPages = __wasm_memory_size() | 0;
      var newPages = oldPages + pagesToAdd | 0;
      if (oldPages < newPages && newPages < 65536) {
        var newBuffer = new ArrayBuffer(Math_imul(newPages, 65536));
        var newHEAP8 = new Int8Array(newBuffer);
        newHEAP8.set(HEAP8);
        HEAP8 = new Int8Array(newBuffer);
        HEAP16 = new Int16Array(newBuffer);
        HEAP32 = new Int32Array(newBuffer);
        HEAPU8 = new Uint8Array(newBuffer);
        HEAPU16 = new Uint16Array(newBuffer);
        HEAPU32 = new Uint32Array(newBuffer);
        HEAPF32 = new Float32Array(newBuffer);
        HEAPF64 = new Float64Array(newBuffer);
        buffer = newBuffer;
        bufferView = HEAPU8;
      }
      return oldPages;
    }
    return {
      "memory": Object.create(Object.prototype, {
        "grow": {
          "value": __wasm_memory_grow
        },
        "buffer": {
          "get": function() {
            return buffer;
          }
        }
      }),
      "initializeContext": $7,
      "isPoint": $8,
      "PUBLIC_KEY_INPUT": {
        get value() {
          return global$1;
        },
        set value(_global$13) {
          global$1 = _global$13;
        }
      },
      "pointAdd": $9,
      "PUBLIC_KEY_INPUT2": {
        get value() {
          return global$2;
        },
        set value(_global$23) {
          global$2 = _global$23;
        }
      },
      "pointAddScalar": $10,
      "TWEAK_INPUT": {
        get value() {
          return global$3;
        },
        set value(_global$3) {
          global$3 = _global$3;
        }
      },
      "xOnlyPointAddTweak": $11,
      "X_ONLY_PUBLIC_KEY_INPUT": {
        get value() {
          return global$4;
        },
        set value(_global$4) {
          global$4 = _global$4;
        }
      },
      "xOnlyPointAddTweakCheck": $12,
      "X_ONLY_PUBLIC_KEY_INPUT2": {
        get value() {
          return global$5;
        },
        set value(_global$5) {
          global$5 = _global$5;
        }
      },
      "pointCompress": $13,
      "pointFromScalar": $14,
      "PRIVATE_INPUT": {
        get value() {
          return global$6;
        },
        set value(_global$6) {
          global$6 = _global$6;
        }
      },
      "xOnlyPointFromScalar": $15,
      "xOnlyPointFromPoint": $16,
      "pointMultiply": $17,
      "privateAdd": $18,
      "privateSub": $19,
      "privateNegate": $20,
      "sign": $21,
      "HASH_INPUT": {
        get value() {
          return global$7;
        },
        set value(_global$7) {
          global$7 = _global$7;
        }
      },
      "EXTRA_DATA_INPUT": {
        get value() {
          return global$8;
        },
        set value(_global$8) {
          global$8 = _global$8;
        }
      },
      "SIGNATURE_INPUT": {
        get value() {
          return global$9;
        },
        set value(_global$9) {
          global$9 = _global$9;
        }
      },
      "signRecoverable": $22,
      "signSchnorr": $23,
      "verify": $24,
      "recover": $25,
      "verifySchnorr": $26,
      "rustsecp256k1_v0_8_1_default_error_callback_fn": $28,
      "rustsecp256k1_v0_8_1_default_illegal_callback_fn": $28,
      "__data_end": {
        get value() {
          return global$10;
        },
        set value(_global$10) {
          global$10 = _global$10;
        }
      },
      "__heap_base": {
        get value() {
          return global$11;
        },
        set value(_global$11) {
          global$11 = _global$11;
        }
      }
    };
  }
  var bufferView, base64ReverseLookup, i, retasmFunc, memory, initializeContext, isPoint2, PUBLIC_KEY_INPUT, pointAdd, PUBLIC_KEY_INPUT2, pointAddScalar, TWEAK_INPUT, xOnlyPointAddTweak, X_ONLY_PUBLIC_KEY_INPUT, xOnlyPointAddTweakCheck, X_ONLY_PUBLIC_KEY_INPUT2, pointCompress, pointFromScalar, PRIVATE_INPUT, xOnlyPointFromScalar, xOnlyPointFromPoint, pointMultiply, privateAdd, privateSub, privateNegate, sign, HASH_INPUT, EXTRA_DATA_INPUT, SIGNATURE_INPUT, signRecoverable, signSchnorr, verify, recover, verifySchnorr, rustsecp256k1_v0_8_1_default_error_callback_fn, rustsecp256k1_v0_8_1_default_illegal_callback_fn, __data_end, __heap_base;
  var init_secp256k1_asm = __esm({
    "node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/secp256k1.asm.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_rand_browser();
      init_validate_error();
      base64ReverseLookup = new Uint8Array(
        123
        /*'z'+1*/
      );
      for (i = 25; i >= 0; --i) {
        base64ReverseLookup[48 + i] = 52 + i;
        base64ReverseLookup[65 + i] = i;
        base64ReverseLookup[97 + i] = 26 + i;
      }
      base64ReverseLookup[43] = 62;
      base64ReverseLookup[47] = 63;
      retasmFunc = asmFunc({
        "./rand.js": rand_browser_exports,
        "./validate_error.js": validate_error_exports
      });
      memory = retasmFunc.memory;
      initializeContext = retasmFunc.initializeContext;
      isPoint2 = retasmFunc.isPoint;
      PUBLIC_KEY_INPUT = retasmFunc.PUBLIC_KEY_INPUT;
      pointAdd = retasmFunc.pointAdd;
      PUBLIC_KEY_INPUT2 = retasmFunc.PUBLIC_KEY_INPUT2;
      pointAddScalar = retasmFunc.pointAddScalar;
      TWEAK_INPUT = retasmFunc.TWEAK_INPUT;
      xOnlyPointAddTweak = retasmFunc.xOnlyPointAddTweak;
      X_ONLY_PUBLIC_KEY_INPUT = retasmFunc.X_ONLY_PUBLIC_KEY_INPUT;
      xOnlyPointAddTweakCheck = retasmFunc.xOnlyPointAddTweakCheck;
      X_ONLY_PUBLIC_KEY_INPUT2 = retasmFunc.X_ONLY_PUBLIC_KEY_INPUT2;
      pointCompress = retasmFunc.pointCompress;
      pointFromScalar = retasmFunc.pointFromScalar;
      PRIVATE_INPUT = retasmFunc.PRIVATE_INPUT;
      xOnlyPointFromScalar = retasmFunc.xOnlyPointFromScalar;
      xOnlyPointFromPoint = retasmFunc.xOnlyPointFromPoint;
      pointMultiply = retasmFunc.pointMultiply;
      privateAdd = retasmFunc.privateAdd;
      privateSub = retasmFunc.privateSub;
      privateNegate = retasmFunc.privateNegate;
      sign = retasmFunc.sign;
      HASH_INPUT = retasmFunc.HASH_INPUT;
      EXTRA_DATA_INPUT = retasmFunc.EXTRA_DATA_INPUT;
      SIGNATURE_INPUT = retasmFunc.SIGNATURE_INPUT;
      signRecoverable = retasmFunc.signRecoverable;
      signSchnorr = retasmFunc.signSchnorr;
      verify = retasmFunc.verify;
      recover = retasmFunc.recover;
      verifySchnorr = retasmFunc.verifySchnorr;
      rustsecp256k1_v0_8_1_default_error_callback_fn = retasmFunc.rustsecp256k1_v0_8_1_default_error_callback_fn;
      rustsecp256k1_v0_8_1_default_illegal_callback_fn = retasmFunc.rustsecp256k1_v0_8_1_default_illegal_callback_fn;
      __data_end = retasmFunc.__data_end;
      __heap_base = retasmFunc.__heap_base;
    }
  });

  // node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/wasm_loader.js
  var wasm_loader_default;
  var init_wasm_loader = __esm({
    "node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/wasm_loader.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_secp256k1_asm();
      wasm_loader_default = secp256k1_asm_exports;
    }
  });

  // node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/index.js
  var lib_exports = {};
  __export(lib_exports, {
    __initializeContext: () => __initializeContext,
    isPoint: () => isPoint3,
    isPointCompressed: () => isPointCompressed2,
    isPrivate: () => isPrivate2,
    isXOnlyPoint: () => isXOnlyPoint2,
    pointAdd: () => pointAdd2,
    pointAddScalar: () => pointAddScalar2,
    pointCompress: () => pointCompress2,
    pointFromScalar: () => pointFromScalar2,
    pointMultiply: () => pointMultiply2,
    privateAdd: () => privateAdd2,
    privateNegate: () => privateNegate2,
    privateSub: () => privateSub2,
    recover: () => recover2,
    sign: () => sign2,
    signRecoverable: () => signRecoverable2,
    signSchnorr: () => signSchnorr2,
    verify: () => verify2,
    verifySchnorr: () => verifySchnorr2,
    xOnlyPointAddTweak: () => xOnlyPointAddTweak2,
    xOnlyPointAddTweakCheck: () => xOnlyPointAddTweakCheck2,
    xOnlyPointFromPoint: () => xOnlyPointFromPoint2,
    xOnlyPointFromScalar: () => xOnlyPointFromScalar2
  });
  function assumeCompression(compressed, p) {
    if (compressed === void 0) {
      return p !== void 0 ? p.length : PUBLIC_KEY_COMPRESSED_SIZE;
    }
    return compressed ? PUBLIC_KEY_COMPRESSED_SIZE : PUBLIC_KEY_UNCOMPRESSED_SIZE;
  }
  function _isPoint(p) {
    try {
      PUBLIC_KEY_INPUT3.set(p);
      return wasm_loader_default.isPoint(p.length) === 1;
    } finally {
      PUBLIC_KEY_INPUT3.fill(0);
    }
  }
  function __initializeContext() {
    wasm_loader_default.initializeContext();
  }
  function isPoint3(p) {
    return isDERPoint(p) && _isPoint(p);
  }
  function isPointCompressed2(p) {
    return isPointCompressed(p) && _isPoint(p);
  }
  function isXOnlyPoint2(p) {
    return isXOnlyPoint(p) && _isPoint(p);
  }
  function isPrivate2(d) {
    return isPrivate(d);
  }
  function pointAdd2(pA, pB, compressed) {
    validatePoint(pA);
    validatePoint(pB);
    const outputlen = assumeCompression(compressed, pA);
    try {
      PUBLIC_KEY_INPUT3.set(pA);
      PUBLIC_KEY_INPUT22.set(pB);
      return wasm_loader_default.pointAdd(pA.length, pB.length, outputlen) === 1 ? PUBLIC_KEY_INPUT3.slice(0, outputlen) : null;
    } finally {
      PUBLIC_KEY_INPUT3.fill(0);
      PUBLIC_KEY_INPUT22.fill(0);
    }
  }
  function pointAddScalar2(p, tweak, compressed) {
    validatePoint(p);
    validateTweak(tweak);
    const outputlen = assumeCompression(compressed, p);
    try {
      PUBLIC_KEY_INPUT3.set(p);
      TWEAK_INPUT2.set(tweak);
      return wasm_loader_default.pointAddScalar(p.length, outputlen) === 1 ? PUBLIC_KEY_INPUT3.slice(0, outputlen) : null;
    } finally {
      PUBLIC_KEY_INPUT3.fill(0);
      TWEAK_INPUT2.fill(0);
    }
  }
  function pointCompress2(p, compressed) {
    validatePoint(p);
    const outputlen = assumeCompression(compressed, p);
    try {
      PUBLIC_KEY_INPUT3.set(p);
      wasm_loader_default.pointCompress(p.length, outputlen);
      return PUBLIC_KEY_INPUT3.slice(0, outputlen);
    } finally {
      PUBLIC_KEY_INPUT3.fill(0);
    }
  }
  function pointFromScalar2(d, compressed) {
    validatePrivate(d);
    const outputlen = assumeCompression(compressed);
    try {
      PRIVATE_KEY_INPUT.set(d);
      return wasm_loader_default.pointFromScalar(outputlen) === 1 ? PUBLIC_KEY_INPUT3.slice(0, outputlen) : null;
    } finally {
      PRIVATE_KEY_INPUT.fill(0);
      PUBLIC_KEY_INPUT3.fill(0);
    }
  }
  function xOnlyPointFromScalar2(d) {
    validatePrivate(d);
    try {
      PRIVATE_KEY_INPUT.set(d);
      wasm_loader_default.xOnlyPointFromScalar();
      return X_ONLY_PUBLIC_KEY_INPUT3.slice(0, X_ONLY_PUBLIC_KEY_SIZE);
    } finally {
      PRIVATE_KEY_INPUT.fill(0);
      X_ONLY_PUBLIC_KEY_INPUT3.fill(0);
    }
  }
  function xOnlyPointFromPoint2(p) {
    validatePoint(p);
    try {
      PUBLIC_KEY_INPUT3.set(p);
      wasm_loader_default.xOnlyPointFromPoint(p.length);
      return X_ONLY_PUBLIC_KEY_INPUT3.slice(0, X_ONLY_PUBLIC_KEY_SIZE);
    } finally {
      PUBLIC_KEY_INPUT3.fill(0);
      X_ONLY_PUBLIC_KEY_INPUT3.fill(0);
    }
  }
  function pointMultiply2(p, tweak, compressed) {
    validatePoint(p);
    validateTweak(tweak);
    const outputlen = assumeCompression(compressed, p);
    try {
      PUBLIC_KEY_INPUT3.set(p);
      TWEAK_INPUT2.set(tweak);
      return wasm_loader_default.pointMultiply(p.length, outputlen) === 1 ? PUBLIC_KEY_INPUT3.slice(0, outputlen) : null;
    } finally {
      PUBLIC_KEY_INPUT3.fill(0);
      TWEAK_INPUT2.fill(0);
    }
  }
  function privateAdd2(d, tweak) {
    validatePrivate(d);
    validateTweak(tweak);
    try {
      PRIVATE_KEY_INPUT.set(d);
      TWEAK_INPUT2.set(tweak);
      return wasm_loader_default.privateAdd() === 1 ? PRIVATE_KEY_INPUT.slice(0, PRIVATE_KEY_SIZE) : null;
    } finally {
      PRIVATE_KEY_INPUT.fill(0);
      TWEAK_INPUT2.fill(0);
    }
  }
  function privateSub2(d, tweak) {
    validatePrivate(d);
    validateTweak(tweak);
    if (isZero(tweak)) {
      return new Uint8Array(d);
    }
    try {
      PRIVATE_KEY_INPUT.set(d);
      TWEAK_INPUT2.set(tweak);
      return wasm_loader_default.privateSub() === 1 ? PRIVATE_KEY_INPUT.slice(0, PRIVATE_KEY_SIZE) : null;
    } finally {
      PRIVATE_KEY_INPUT.fill(0);
      TWEAK_INPUT2.fill(0);
    }
  }
  function privateNegate2(d) {
    validatePrivate(d);
    try {
      PRIVATE_KEY_INPUT.set(d);
      wasm_loader_default.privateNegate();
      return PRIVATE_KEY_INPUT.slice(0, PRIVATE_KEY_SIZE);
    } finally {
      PRIVATE_KEY_INPUT.fill(0);
    }
  }
  function xOnlyPointAddTweak2(p, tweak) {
    validateXOnlyPoint(p);
    validateTweak(tweak);
    try {
      X_ONLY_PUBLIC_KEY_INPUT3.set(p);
      TWEAK_INPUT2.set(tweak);
      const parity = wasm_loader_default.xOnlyPointAddTweak();
      return parity !== -1 ? {
        parity,
        xOnlyPubkey: X_ONLY_PUBLIC_KEY_INPUT3.slice(0, X_ONLY_PUBLIC_KEY_SIZE)
      } : null;
    } finally {
      X_ONLY_PUBLIC_KEY_INPUT3.fill(0);
      TWEAK_INPUT2.fill(0);
    }
  }
  function xOnlyPointAddTweakCheck2(point, tweak, resultToCheck, tweakParity) {
    validateXOnlyPoint(point);
    validateXOnlyPoint(resultToCheck);
    validateTweak(tweak);
    const hasParity = tweakParity !== void 0;
    if (hasParity)
      validateParity(tweakParity);
    try {
      X_ONLY_PUBLIC_KEY_INPUT3.set(point);
      X_ONLY_PUBLIC_KEY_INPUT22.set(resultToCheck);
      TWEAK_INPUT2.set(tweak);
      if (hasParity) {
        return wasm_loader_default.xOnlyPointAddTweakCheck(tweakParity) === 1;
      } else {
        wasm_loader_default.xOnlyPointAddTweak();
        const newKey = X_ONLY_PUBLIC_KEY_INPUT3.slice(0, X_ONLY_PUBLIC_KEY_SIZE);
        return compare2(newKey, resultToCheck) === 0;
      }
    } finally {
      X_ONLY_PUBLIC_KEY_INPUT3.fill(0);
      X_ONLY_PUBLIC_KEY_INPUT22.fill(0);
      TWEAK_INPUT2.fill(0);
    }
  }
  function sign2(h, d, e) {
    validateHash(h);
    validatePrivate(d);
    validateExtraData(e);
    try {
      HASH_INPUT2.set(h);
      PRIVATE_KEY_INPUT.set(d);
      if (e !== void 0)
        EXTRA_DATA_INPUT2.set(e);
      wasm_loader_default.sign(e === void 0 ? 0 : 1);
      return SIGNATURE_INPUT2.slice(0, SIGNATURE_SIZE);
    } finally {
      HASH_INPUT2.fill(0);
      PRIVATE_KEY_INPUT.fill(0);
      if (e !== void 0)
        EXTRA_DATA_INPUT2.fill(0);
      SIGNATURE_INPUT2.fill(0);
    }
  }
  function signRecoverable2(h, d, e) {
    validateHash(h);
    validatePrivate(d);
    validateExtraData(e);
    try {
      HASH_INPUT2.set(h);
      PRIVATE_KEY_INPUT.set(d);
      if (e !== void 0)
        EXTRA_DATA_INPUT2.set(e);
      const recoveryId = wasm_loader_default.signRecoverable(e === void 0 ? 0 : 1);
      const signature = SIGNATURE_INPUT2.slice(0, SIGNATURE_SIZE);
      return {
        signature,
        recoveryId
      };
    } finally {
      HASH_INPUT2.fill(0);
      PRIVATE_KEY_INPUT.fill(0);
      if (e !== void 0)
        EXTRA_DATA_INPUT2.fill(0);
      SIGNATURE_INPUT2.fill(0);
    }
  }
  function signSchnorr2(h, d, e) {
    validateHash(h);
    validatePrivate(d);
    validateExtraData(e);
    try {
      HASH_INPUT2.set(h);
      PRIVATE_KEY_INPUT.set(d);
      if (e !== void 0)
        EXTRA_DATA_INPUT2.set(e);
      wasm_loader_default.signSchnorr(e === void 0 ? 0 : 1);
      return SIGNATURE_INPUT2.slice(0, SIGNATURE_SIZE);
    } finally {
      HASH_INPUT2.fill(0);
      PRIVATE_KEY_INPUT.fill(0);
      if (e !== void 0)
        EXTRA_DATA_INPUT2.fill(0);
      SIGNATURE_INPUT2.fill(0);
    }
  }
  function verify2(h, Q, signature, strict = false) {
    validateHash(h);
    validatePoint(Q);
    validateSignature(signature);
    try {
      HASH_INPUT2.set(h);
      PUBLIC_KEY_INPUT3.set(Q);
      SIGNATURE_INPUT2.set(signature);
      return wasm_loader_default.verify(Q.length, strict === true ? 1 : 0) === 1 ? true : false;
    } finally {
      HASH_INPUT2.fill(0);
      PUBLIC_KEY_INPUT3.fill(0);
      SIGNATURE_INPUT2.fill(0);
    }
  }
  function recover2(h, signature, recoveryId, compressed = false) {
    validateHash(h);
    validateSignature(signature);
    validateSignatureNonzeroRS(signature);
    if (recoveryId & 2) {
      validateSigrPMinusN(signature);
    }
    validateSignatureCustom(() => isXOnlyPoint2(signature.subarray(0, 32)));
    const outputlen = assumeCompression(compressed);
    try {
      HASH_INPUT2.set(h);
      SIGNATURE_INPUT2.set(signature);
      return wasm_loader_default.recover(outputlen, recoveryId) === 1 ? PUBLIC_KEY_INPUT3.slice(0, outputlen) : null;
    } finally {
      HASH_INPUT2.fill(0);
      SIGNATURE_INPUT2.fill(0);
      PUBLIC_KEY_INPUT3.fill(0);
    }
  }
  function verifySchnorr2(h, Q, signature) {
    validateHash(h);
    validateXOnlyPoint(Q);
    validateSignature(signature);
    try {
      HASH_INPUT2.set(h);
      X_ONLY_PUBLIC_KEY_INPUT3.set(Q);
      SIGNATURE_INPUT2.set(signature);
      return wasm_loader_default.verifySchnorr() === 1 ? true : false;
    } finally {
      HASH_INPUT2.fill(0);
      X_ONLY_PUBLIC_KEY_INPUT3.fill(0);
      SIGNATURE_INPUT2.fill(0);
    }
  }
  var WASM_BUFFER, WASM_PRIVATE_KEY_PTR, WASM_PUBLIC_KEY_INPUT_PTR, WASM_PUBLIC_KEY_INPUT_PTR2, WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR, WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR, WASM_TWEAK_INPUT_PTR, WASM_HASH_INPUT_PTR, WASM_EXTRA_DATA_INPUT_PTR, WASM_SIGNATURE_INPUT_PTR, PRIVATE_KEY_INPUT, PUBLIC_KEY_INPUT3, PUBLIC_KEY_INPUT22, X_ONLY_PUBLIC_KEY_INPUT3, X_ONLY_PUBLIC_KEY_INPUT22, TWEAK_INPUT2, HASH_INPUT2, EXTRA_DATA_INPUT2, SIGNATURE_INPUT2;
  var init_lib = __esm({
    "node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/index.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_browser2();
      init_validate();
      init_wasm_loader();
      WASM_BUFFER = new Uint8Array(wasm_loader_default.memory.buffer);
      WASM_PRIVATE_KEY_PTR = wasm_loader_default.PRIVATE_INPUT.value;
      WASM_PUBLIC_KEY_INPUT_PTR = wasm_loader_default.PUBLIC_KEY_INPUT.value;
      WASM_PUBLIC_KEY_INPUT_PTR2 = wasm_loader_default.PUBLIC_KEY_INPUT2.value;
      WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR = wasm_loader_default.X_ONLY_PUBLIC_KEY_INPUT.value;
      WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR = wasm_loader_default.X_ONLY_PUBLIC_KEY_INPUT2.value;
      WASM_TWEAK_INPUT_PTR = wasm_loader_default.TWEAK_INPUT.value;
      WASM_HASH_INPUT_PTR = wasm_loader_default.HASH_INPUT.value;
      WASM_EXTRA_DATA_INPUT_PTR = wasm_loader_default.EXTRA_DATA_INPUT.value;
      WASM_SIGNATURE_INPUT_PTR = wasm_loader_default.SIGNATURE_INPUT.value;
      PRIVATE_KEY_INPUT = WASM_BUFFER.subarray(WASM_PRIVATE_KEY_PTR, WASM_PRIVATE_KEY_PTR + PRIVATE_KEY_SIZE);
      PUBLIC_KEY_INPUT3 = WASM_BUFFER.subarray(WASM_PUBLIC_KEY_INPUT_PTR, WASM_PUBLIC_KEY_INPUT_PTR + PUBLIC_KEY_UNCOMPRESSED_SIZE);
      PUBLIC_KEY_INPUT22 = WASM_BUFFER.subarray(WASM_PUBLIC_KEY_INPUT_PTR2, WASM_PUBLIC_KEY_INPUT_PTR2 + PUBLIC_KEY_UNCOMPRESSED_SIZE);
      X_ONLY_PUBLIC_KEY_INPUT3 = WASM_BUFFER.subarray(WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR, WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR + X_ONLY_PUBLIC_KEY_SIZE);
      X_ONLY_PUBLIC_KEY_INPUT22 = WASM_BUFFER.subarray(WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR, WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR + X_ONLY_PUBLIC_KEY_SIZE);
      TWEAK_INPUT2 = WASM_BUFFER.subarray(WASM_TWEAK_INPUT_PTR, WASM_TWEAK_INPUT_PTR + TWEAK_SIZE);
      HASH_INPUT2 = WASM_BUFFER.subarray(WASM_HASH_INPUT_PTR, WASM_HASH_INPUT_PTR + HASH_SIZE);
      EXTRA_DATA_INPUT2 = WASM_BUFFER.subarray(WASM_EXTRA_DATA_INPUT_PTR, WASM_EXTRA_DATA_INPUT_PTR + EXTRA_DATA_SIZE);
      SIGNATURE_INPUT2 = WASM_BUFFER.subarray(WASM_SIGNATURE_INPUT_PTR, WASM_SIGNATURE_INPUT_PTR + SIGNATURE_SIZE);
    }
  });

  // node_modules/mnemonic/wordlist.json
  var require_wordlist = __commonJS({
    "node_modules/mnemonic/wordlist.json"(exports9, module) {
      module.exports = [
        "like",
        "just",
        "love",
        "know",
        "never",
        "want",
        "time",
        "out",
        "there",
        "make",
        "look",
        "eye",
        "down",
        "only",
        "think",
        "heart",
        "back",
        "then",
        "into",
        "about",
        "more",
        "away",
        "still",
        "them",
        "take",
        "thing",
        "even",
        "through",
        "long",
        "always",
        "world",
        "too",
        "friend",
        "tell",
        "try",
        "hand",
        "thought",
        "over",
        "here",
        "other",
        "need",
        "smile",
        "again",
        "much",
        "cry",
        "been",
        "night",
        "ever",
        "little",
        "said",
        "end",
        "some",
        "those",
        "around",
        "mind",
        "people",
        "girl",
        "leave",
        "dream",
        "left",
        "turn",
        "myself",
        "give",
        "nothing",
        "really",
        "off",
        "before",
        "something",
        "find",
        "walk",
        "wish",
        "good",
        "once",
        "place",
        "ask",
        "stop",
        "keep",
        "watch",
        "seem",
        "everything",
        "wait",
        "got",
        "yet",
        "made",
        "remember",
        "start",
        "alone",
        "run",
        "hope",
        "maybe",
        "believe",
        "body",
        "hate",
        "after",
        "close",
        "talk",
        "stand",
        "own",
        "each",
        "hurt",
        "help",
        "home",
        "god",
        "soul",
        "new",
        "many",
        "two",
        "inside",
        "should",
        "true",
        "first",
        "fear",
        "mean",
        "better",
        "play",
        "another",
        "gone",
        "change",
        "use",
        "wonder",
        "someone",
        "hair",
        "cold",
        "open",
        "best",
        "any",
        "behind",
        "happen",
        "water",
        "dark",
        "laugh",
        "stay",
        "forever",
        "name",
        "work",
        "show",
        "sky",
        "break",
        "came",
        "deep",
        "door",
        "put",
        "black",
        "together",
        "upon",
        "happy",
        "such",
        "great",
        "white",
        "matter",
        "fill",
        "past",
        "please",
        "burn",
        "cause",
        "enough",
        "touch",
        "moment",
        "soon",
        "voice",
        "scream",
        "anything",
        "stare",
        "sound",
        "red",
        "everyone",
        "hide",
        "kiss",
        "truth",
        "death",
        "beautiful",
        "mine",
        "blood",
        "broken",
        "very",
        "pass",
        "next",
        "forget",
        "tree",
        "wrong",
        "air",
        "mother",
        "understand",
        "lip",
        "hit",
        "wall",
        "memory",
        "sleep",
        "free",
        "high",
        "realize",
        "school",
        "might",
        "skin",
        "sweet",
        "perfect",
        "blue",
        "kill",
        "breath",
        "dance",
        "against",
        "fly",
        "between",
        "grow",
        "strong",
        "under",
        "listen",
        "bring",
        "sometimes",
        "speak",
        "pull",
        "person",
        "become",
        "family",
        "begin",
        "ground",
        "real",
        "small",
        "father",
        "sure",
        "feet",
        "rest",
        "young",
        "finally",
        "land",
        "across",
        "today",
        "different",
        "guy",
        "line",
        "fire",
        "reason",
        "reach",
        "second",
        "slowly",
        "write",
        "eat",
        "smell",
        "mouth",
        "step",
        "learn",
        "three",
        "floor",
        "promise",
        "breathe",
        "darkness",
        "push",
        "earth",
        "guess",
        "save",
        "song",
        "above",
        "along",
        "both",
        "color",
        "house",
        "almost",
        "sorry",
        "anymore",
        "brother",
        "okay",
        "dear",
        "game",
        "fade",
        "already",
        "apart",
        "warm",
        "beauty",
        "heard",
        "notice",
        "question",
        "shine",
        "began",
        "piece",
        "whole",
        "shadow",
        "secret",
        "street",
        "within",
        "finger",
        "point",
        "morning",
        "whisper",
        "child",
        "moon",
        "green",
        "story",
        "glass",
        "kid",
        "silence",
        "since",
        "soft",
        "yourself",
        "empty",
        "shall",
        "angel",
        "answer",
        "baby",
        "bright",
        "dad",
        "path",
        "worry",
        "hour",
        "drop",
        "follow",
        "power",
        "war",
        "half",
        "flow",
        "heaven",
        "act",
        "chance",
        "fact",
        "least",
        "tired",
        "children",
        "near",
        "quite",
        "afraid",
        "rise",
        "sea",
        "taste",
        "window",
        "cover",
        "nice",
        "trust",
        "lot",
        "sad",
        "cool",
        "force",
        "peace",
        "return",
        "blind",
        "easy",
        "ready",
        "roll",
        "rose",
        "drive",
        "held",
        "music",
        "beneath",
        "hang",
        "mom",
        "paint",
        "emotion",
        "quiet",
        "clear",
        "cloud",
        "few",
        "pretty",
        "bird",
        "outside",
        "paper",
        "picture",
        "front",
        "rock",
        "simple",
        "anyone",
        "meant",
        "reality",
        "road",
        "sense",
        "waste",
        "bit",
        "leaf",
        "thank",
        "happiness",
        "meet",
        "men",
        "smoke",
        "truly",
        "decide",
        "self",
        "age",
        "book",
        "form",
        "alive",
        "carry",
        "escape",
        "damn",
        "instead",
        "able",
        "ice",
        "minute",
        "throw",
        "catch",
        "leg",
        "ring",
        "course",
        "goodbye",
        "lead",
        "poem",
        "sick",
        "corner",
        "desire",
        "known",
        "problem",
        "remind",
        "shoulder",
        "suppose",
        "toward",
        "wave",
        "drink",
        "jump",
        "woman",
        "pretend",
        "sister",
        "week",
        "human",
        "joy",
        "crack",
        "grey",
        "pray",
        "surprise",
        "dry",
        "knee",
        "less",
        "search",
        "bleed",
        "caught",
        "clean",
        "embrace",
        "future",
        "king",
        "son",
        "sorrow",
        "chest",
        "hug",
        "remain",
        "sat",
        "worth",
        "blow",
        "daddy",
        "final",
        "parent",
        "tight",
        "also",
        "create",
        "lonely",
        "safe",
        "cross",
        "dress",
        "evil",
        "silent",
        "bone",
        "fate",
        "perhaps",
        "anger",
        "class",
        "scar",
        "snow",
        "tiny",
        "tonight",
        "continue",
        "control",
        "dog",
        "edge",
        "mirror",
        "month",
        "suddenly",
        "comfort",
        "given",
        "loud",
        "quickly",
        "gaze",
        "plan",
        "rush",
        "stone",
        "town",
        "battle",
        "ignore",
        "spirit",
        "stood",
        "stupid",
        "yours",
        "brown",
        "build",
        "dust",
        "hey",
        "kept",
        "pay",
        "phone",
        "twist",
        "although",
        "ball",
        "beyond",
        "hidden",
        "nose",
        "taken",
        "fail",
        "float",
        "pure",
        "somehow",
        "wash",
        "wrap",
        "angry",
        "cheek",
        "creature",
        "forgotten",
        "heat",
        "rip",
        "single",
        "space",
        "special",
        "weak",
        "whatever",
        "yell",
        "anyway",
        "blame",
        "job",
        "choose",
        "country",
        "curse",
        "drift",
        "echo",
        "figure",
        "grew",
        "laughter",
        "neck",
        "suffer",
        "worse",
        "yeah",
        "disappear",
        "foot",
        "forward",
        "knife",
        "mess",
        "somewhere",
        "stomach",
        "storm",
        "beg",
        "idea",
        "lift",
        "offer",
        "breeze",
        "field",
        "five",
        "often",
        "simply",
        "stuck",
        "win",
        "allow",
        "confuse",
        "enjoy",
        "except",
        "flower",
        "seek",
        "strength",
        "calm",
        "grin",
        "gun",
        "heavy",
        "hill",
        "large",
        "ocean",
        "shoe",
        "sigh",
        "straight",
        "summer",
        "tongue",
        "accept",
        "crazy",
        "everyday",
        "exist",
        "grass",
        "mistake",
        "sent",
        "shut",
        "surround",
        "table",
        "ache",
        "brain",
        "destroy",
        "heal",
        "nature",
        "shout",
        "sign",
        "stain",
        "choice",
        "doubt",
        "glance",
        "glow",
        "mountain",
        "queen",
        "stranger",
        "throat",
        "tomorrow",
        "city",
        "either",
        "fish",
        "flame",
        "rather",
        "shape",
        "spin",
        "spread",
        "ash",
        "distance",
        "finish",
        "image",
        "imagine",
        "important",
        "nobody",
        "shatter",
        "warmth",
        "became",
        "feed",
        "flesh",
        "funny",
        "lust",
        "shirt",
        "trouble",
        "yellow",
        "attention",
        "bare",
        "bite",
        "money",
        "protect",
        "amaze",
        "appear",
        "born",
        "choke",
        "completely",
        "daughter",
        "fresh",
        "friendship",
        "gentle",
        "probably",
        "six",
        "deserve",
        "expect",
        "grab",
        "middle",
        "nightmare",
        "river",
        "thousand",
        "weight",
        "worst",
        "wound",
        "barely",
        "bottle",
        "cream",
        "regret",
        "relationship",
        "stick",
        "test",
        "crush",
        "endless",
        "fault",
        "itself",
        "rule",
        "spill",
        "art",
        "circle",
        "join",
        "kick",
        "mask",
        "master",
        "passion",
        "quick",
        "raise",
        "smooth",
        "unless",
        "wander",
        "actually",
        "broke",
        "chair",
        "deal",
        "favorite",
        "gift",
        "note",
        "number",
        "sweat",
        "box",
        "chill",
        "clothes",
        "lady",
        "mark",
        "park",
        "poor",
        "sadness",
        "tie",
        "animal",
        "belong",
        "brush",
        "consume",
        "dawn",
        "forest",
        "innocent",
        "pen",
        "pride",
        "stream",
        "thick",
        "clay",
        "complete",
        "count",
        "draw",
        "faith",
        "press",
        "silver",
        "struggle",
        "surface",
        "taught",
        "teach",
        "wet",
        "bless",
        "chase",
        "climb",
        "enter",
        "letter",
        "melt",
        "metal",
        "movie",
        "stretch",
        "swing",
        "vision",
        "wife",
        "beside",
        "crash",
        "forgot",
        "guide",
        "haunt",
        "joke",
        "knock",
        "plant",
        "pour",
        "prove",
        "reveal",
        "steal",
        "stuff",
        "trip",
        "wood",
        "wrist",
        "bother",
        "bottom",
        "crawl",
        "crowd",
        "fix",
        "forgive",
        "frown",
        "grace",
        "loose",
        "lucky",
        "party",
        "release",
        "surely",
        "survive",
        "teacher",
        "gently",
        "grip",
        "speed",
        "suicide",
        "travel",
        "treat",
        "vein",
        "written",
        "cage",
        "chain",
        "conversation",
        "date",
        "enemy",
        "however",
        "interest",
        "million",
        "page",
        "pink",
        "proud",
        "sway",
        "themselves",
        "winter",
        "church",
        "cruel",
        "cup",
        "demon",
        "experience",
        "freedom",
        "pair",
        "pop",
        "purpose",
        "respect",
        "shoot",
        "softly",
        "state",
        "strange",
        "bar",
        "birth",
        "curl",
        "dirt",
        "excuse",
        "lord",
        "lovely",
        "monster",
        "order",
        "pack",
        "pants",
        "pool",
        "scene",
        "seven",
        "shame",
        "slide",
        "ugly",
        "among",
        "blade",
        "blonde",
        "closet",
        "creek",
        "deny",
        "drug",
        "eternity",
        "gain",
        "grade",
        "handle",
        "key",
        "linger",
        "pale",
        "prepare",
        "swallow",
        "swim",
        "tremble",
        "wheel",
        "won",
        "cast",
        "cigarette",
        "claim",
        "college",
        "direction",
        "dirty",
        "gather",
        "ghost",
        "hundred",
        "loss",
        "lung",
        "orange",
        "present",
        "swear",
        "swirl",
        "twice",
        "wild",
        "bitter",
        "blanket",
        "doctor",
        "everywhere",
        "flash",
        "grown",
        "knowledge",
        "numb",
        "pressure",
        "radio",
        "repeat",
        "ruin",
        "spend",
        "unknown",
        "buy",
        "clock",
        "devil",
        "early",
        "false",
        "fantasy",
        "pound",
        "precious",
        "refuse",
        "sheet",
        "teeth",
        "welcome",
        "add",
        "ahead",
        "block",
        "bury",
        "caress",
        "content",
        "depth",
        "despite",
        "distant",
        "marry",
        "purple",
        "threw",
        "whenever",
        "bomb",
        "dull",
        "easily",
        "grasp",
        "hospital",
        "innocence",
        "normal",
        "receive",
        "reply",
        "rhyme",
        "shade",
        "someday",
        "sword",
        "toe",
        "visit",
        "asleep",
        "bought",
        "center",
        "consider",
        "flat",
        "hero",
        "history",
        "ink",
        "insane",
        "muscle",
        "mystery",
        "pocket",
        "reflection",
        "shove",
        "silently",
        "smart",
        "soldier",
        "spot",
        "stress",
        "train",
        "type",
        "view",
        "whether",
        "bus",
        "energy",
        "explain",
        "holy",
        "hunger",
        "inch",
        "magic",
        "mix",
        "noise",
        "nowhere",
        "prayer",
        "presence",
        "shock",
        "snap",
        "spider",
        "study",
        "thunder",
        "trail",
        "admit",
        "agree",
        "bag",
        "bang",
        "bound",
        "butterfly",
        "cute",
        "exactly",
        "explode",
        "familiar",
        "fold",
        "further",
        "pierce",
        "reflect",
        "scent",
        "selfish",
        "sharp",
        "sink",
        "spring",
        "stumble",
        "universe",
        "weep",
        "women",
        "wonderful",
        "action",
        "ancient",
        "attempt",
        "avoid",
        "birthday",
        "branch",
        "chocolate",
        "core",
        "depress",
        "drunk",
        "especially",
        "focus",
        "fruit",
        "honest",
        "match",
        "palm",
        "perfectly",
        "pillow",
        "pity",
        "poison",
        "roar",
        "shift",
        "slightly",
        "thump",
        "truck",
        "tune",
        "twenty",
        "unable",
        "wipe",
        "wrote",
        "coat",
        "constant",
        "dinner",
        "drove",
        "egg",
        "eternal",
        "flight",
        "flood",
        "frame",
        "freak",
        "gasp",
        "glad",
        "hollow",
        "motion",
        "peer",
        "plastic",
        "root",
        "screen",
        "season",
        "sting",
        "strike",
        "team",
        "unlike",
        "victim",
        "volume",
        "warn",
        "weird",
        "attack",
        "await",
        "awake",
        "built",
        "charm",
        "crave",
        "despair",
        "fought",
        "grant",
        "grief",
        "horse",
        "limit",
        "message",
        "ripple",
        "sanity",
        "scatter",
        "serve",
        "split",
        "string",
        "trick",
        "annoy",
        "blur",
        "boat",
        "brave",
        "clearly",
        "cling",
        "connect",
        "fist",
        "forth",
        "imagination",
        "iron",
        "jock",
        "judge",
        "lesson",
        "milk",
        "misery",
        "nail",
        "naked",
        "ourselves",
        "poet",
        "possible",
        "princess",
        "sail",
        "size",
        "snake",
        "society",
        "stroke",
        "torture",
        "toss",
        "trace",
        "wise",
        "bloom",
        "bullet",
        "cell",
        "check",
        "cost",
        "darling",
        "during",
        "footstep",
        "fragile",
        "hallway",
        "hardly",
        "horizon",
        "invisible",
        "journey",
        "midnight",
        "mud",
        "nod",
        "pause",
        "relax",
        "shiver",
        "sudden",
        "value",
        "youth",
        "abuse",
        "admire",
        "blink",
        "breast",
        "bruise",
        "constantly",
        "couple",
        "creep",
        "curve",
        "difference",
        "dumb",
        "emptiness",
        "gotta",
        "honor",
        "plain",
        "planet",
        "recall",
        "rub",
        "ship",
        "slam",
        "soar",
        "somebody",
        "tightly",
        "weather",
        "adore",
        "approach",
        "bond",
        "bread",
        "burst",
        "candle",
        "coffee",
        "cousin",
        "crime",
        "desert",
        "flutter",
        "frozen",
        "grand",
        "heel",
        "hello",
        "language",
        "level",
        "movement",
        "pleasure",
        "powerful",
        "random",
        "rhythm",
        "settle",
        "silly",
        "slap",
        "sort",
        "spoken",
        "steel",
        "threaten",
        "tumble",
        "upset",
        "aside",
        "awkward",
        "bee",
        "blank",
        "board",
        "button",
        "card",
        "carefully",
        "complain",
        "crap",
        "deeply",
        "discover",
        "drag",
        "dread",
        "effort",
        "entire",
        "fairy",
        "giant",
        "gotten",
        "greet",
        "illusion",
        "jeans",
        "leap",
        "liquid",
        "march",
        "mend",
        "nervous",
        "nine",
        "replace",
        "rope",
        "spine",
        "stole",
        "terror",
        "accident",
        "apple",
        "balance",
        "boom",
        "childhood",
        "collect",
        "demand",
        "depression",
        "eventually",
        "faint",
        "glare",
        "goal",
        "group",
        "honey",
        "kitchen",
        "laid",
        "limb",
        "machine",
        "mere",
        "mold",
        "murder",
        "nerve",
        "painful",
        "poetry",
        "prince",
        "rabbit",
        "shelter",
        "shore",
        "shower",
        "soothe",
        "stair",
        "steady",
        "sunlight",
        "tangle",
        "tease",
        "treasure",
        "uncle",
        "begun",
        "bliss",
        "canvas",
        "cheer",
        "claw",
        "clutch",
        "commit",
        "crimson",
        "crystal",
        "delight",
        "doll",
        "existence",
        "express",
        "fog",
        "football",
        "gay",
        "goose",
        "guard",
        "hatred",
        "illuminate",
        "mass",
        "math",
        "mourn",
        "rich",
        "rough",
        "skip",
        "stir",
        "student",
        "style",
        "support",
        "thorn",
        "tough",
        "yard",
        "yearn",
        "yesterday",
        "advice",
        "appreciate",
        "autumn",
        "bank",
        "beam",
        "bowl",
        "capture",
        "carve",
        "collapse",
        "confusion",
        "creation",
        "dove",
        "feather",
        "girlfriend",
        "glory",
        "government",
        "harsh",
        "hop",
        "inner",
        "loser",
        "moonlight",
        "neighbor",
        "neither",
        "peach",
        "pig",
        "praise",
        "screw",
        "shield",
        "shimmer",
        "sneak",
        "stab",
        "subject",
        "throughout",
        "thrown",
        "tower",
        "twirl",
        "wow",
        "army",
        "arrive",
        "bathroom",
        "bump",
        "cease",
        "cookie",
        "couch",
        "courage",
        "dim",
        "guilt",
        "howl",
        "hum",
        "husband",
        "insult",
        "led",
        "lunch",
        "mock",
        "mostly",
        "natural",
        "nearly",
        "needle",
        "nerd",
        "peaceful",
        "perfection",
        "pile",
        "price",
        "remove",
        "roam",
        "sanctuary",
        "serious",
        "shiny",
        "shook",
        "sob",
        "stolen",
        "tap",
        "vain",
        "void",
        "warrior",
        "wrinkle",
        "affection",
        "apologize",
        "blossom",
        "bounce",
        "bridge",
        "cheap",
        "crumble",
        "decision",
        "descend",
        "desperately",
        "dig",
        "dot",
        "flip",
        "frighten",
        "heartbeat",
        "huge",
        "lazy",
        "lick",
        "odd",
        "opinion",
        "process",
        "puzzle",
        "quietly",
        "retreat",
        "score",
        "sentence",
        "separate",
        "situation",
        "skill",
        "soak",
        "square",
        "stray",
        "taint",
        "task",
        "tide",
        "underneath",
        "veil",
        "whistle",
        "anywhere",
        "bedroom",
        "bid",
        "bloody",
        "burden",
        "careful",
        "compare",
        "concern",
        "curtain",
        "decay",
        "defeat",
        "describe",
        "double",
        "dreamer",
        "driver",
        "dwell",
        "evening",
        "flare",
        "flicker",
        "grandma",
        "guitar",
        "harm",
        "horrible",
        "hungry",
        "indeed",
        "lace",
        "melody",
        "monkey",
        "nation",
        "object",
        "obviously",
        "rainbow",
        "salt",
        "scratch",
        "shown",
        "shy",
        "stage",
        "stun",
        "third",
        "tickle",
        "useless",
        "weakness",
        "worship",
        "worthless",
        "afternoon",
        "beard",
        "boyfriend",
        "bubble",
        "busy",
        "certain",
        "chin",
        "concrete",
        "desk",
        "diamond",
        "doom",
        "drawn",
        "due",
        "felicity",
        "freeze",
        "frost",
        "garden",
        "glide",
        "harmony",
        "hopefully",
        "hunt",
        "jealous",
        "lightning",
        "mama",
        "mercy",
        "peel",
        "physical",
        "position",
        "pulse",
        "punch",
        "quit",
        "rant",
        "respond",
        "salty",
        "sane",
        "satisfy",
        "savior",
        "sheep",
        "slept",
        "social",
        "sport",
        "tuck",
        "utter",
        "valley",
        "wolf",
        "aim",
        "alas",
        "alter",
        "arrow",
        "awaken",
        "beaten",
        "belief",
        "brand",
        "ceiling",
        "cheese",
        "clue",
        "confidence",
        "connection",
        "daily",
        "disguise",
        "eager",
        "erase",
        "essence",
        "everytime",
        "expression",
        "fan",
        "flag",
        "flirt",
        "foul",
        "fur",
        "giggle",
        "glorious",
        "ignorance",
        "law",
        "lifeless",
        "measure",
        "mighty",
        "muse",
        "north",
        "opposite",
        "paradise",
        "patience",
        "patient",
        "pencil",
        "petal",
        "plate",
        "ponder",
        "possibly",
        "practice",
        "slice",
        "spell",
        "stock",
        "strife",
        "strip",
        "suffocate",
        "suit",
        "tender",
        "tool",
        "trade",
        "velvet",
        "verse",
        "waist",
        "witch",
        "aunt",
        "bench",
        "bold",
        "cap",
        "certainly",
        "click",
        "companion",
        "creator",
        "dart",
        "delicate",
        "determine",
        "dish",
        "dragon",
        "drama",
        "drum",
        "dude",
        "everybody",
        "feast",
        "forehead",
        "former",
        "fright",
        "fully",
        "gas",
        "hook",
        "hurl",
        "invite",
        "juice",
        "manage",
        "moral",
        "possess",
        "raw",
        "rebel",
        "royal",
        "scale",
        "scary",
        "several",
        "slight",
        "stubborn",
        "swell",
        "talent",
        "tea",
        "terrible",
        "thread",
        "torment",
        "trickle",
        "usually",
        "vast",
        "violence",
        "weave",
        "acid",
        "agony",
        "ashamed",
        "awe",
        "belly",
        "blend",
        "blush",
        "character",
        "cheat",
        "common",
        "company",
        "coward",
        "creak",
        "danger",
        "deadly",
        "defense",
        "define",
        "depend",
        "desperate",
        "destination",
        "dew",
        "duck",
        "dusty",
        "embarrass",
        "engine",
        "example",
        "explore",
        "foe",
        "freely",
        "frustrate",
        "generation",
        "glove",
        "guilty",
        "health",
        "hurry",
        "idiot",
        "impossible",
        "inhale",
        "jaw",
        "kingdom",
        "mention",
        "mist",
        "moan",
        "mumble",
        "mutter",
        "observe",
        "ode",
        "pathetic",
        "pattern",
        "pie",
        "prefer",
        "puff",
        "rape",
        "rare",
        "revenge",
        "rude",
        "scrape",
        "spiral",
        "squeeze",
        "strain",
        "sunset",
        "suspend",
        "sympathy",
        "thigh",
        "throne",
        "total",
        "unseen",
        "weapon",
        "weary"
      ];
    }
  });

  // node_modules/mnemonic/index.js
  var require_mnemonic = __commonJS({
    "node_modules/mnemonic/index.js"(exports9, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var words = require_wordlist();
      var n = words.length;
      function decode(wlist) {
        var result = "";
        for (var i = 0; i < div(wlist.length, 3); i++) {
          var word1 = wlist[3 * i];
          var word2 = wlist[3 * i + 1];
          var word3 = wlist[3 * i + 2];
          var w1 = words.indexOf(word1);
          var w2 = mod(words.indexOf(word2), n);
          var w3 = mod(words.indexOf(word3), n);
          var number = w1 + mod(w2 - w1, n) * n + mod(w3 - w2, n) * n * n;
          var hex = number.toString(16);
          while (hex.length < 8) {
            hex = "0" + hex;
          }
          result += hex;
        }
        return result;
      }
      function encode(message) {
        var result = [];
        for (var i = 0; i < div(message.length, 8); i++) {
          var word = message.substr(8 * i, 8);
          var hex = parseInt(word, 16);
          var w1 = mod(hex, n);
          var w2 = mod(div(hex, n) + w1, n);
          var w3 = mod(div(div(hex, n), n) + w2, n);
          result.push(words[w1], words[w2], words[w3]);
        }
        return result;
      }
      function mod(a, b) {
        return (a % b + b) % b;
      }
      function div(a, b) {
        return Math.floor(a / b);
      }
      module.exports = {
        words,
        decode,
        encode
      };
    }
  });

  // src/index.cjs
  var require_index = __commonJS({
    "src/index.cjs"(exports9, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      module.exports.bitcoinjs = require_src2();
      module.exports.bitcoinjsMessage = require_bitcoinjs_message();
      module.exports.bech32 = require_dist();
      module.exports.bip32 = require_cjs5();
      module.exports.bip39 = require_src4();
      module.exports.crypto = (init_empty(), __toCommonJS(empty_exports));
      module.exports.ecpair = require_cjs6();
      module.exports.tinysecp256k1 = (init_lib(), __toCommonJS(lib_exports));
      window.Mnemonic = require_mnemonic();
      window.buffer = (init_buffer(), __toCommonJS(buffer_exports)).default;
    }
  });
  return require_index();
})();
/*! Bundled license information:

@jspm/core/nodelibs/browser/chunk-DtuTasat.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@jspm/core/nodelibs/browser/chunk-CcCWfKp1.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@scure/base/lib/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
